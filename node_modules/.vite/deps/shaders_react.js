import { __toESM, require_react } from "./react-DKvWvDh_.js";
import { require_jsx_runtime } from "./jsx-runtime-Bjn4RU3W.js";

//#region node_modules/three/build/three.core.js
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
/**
* @license
* Copyright 2010-2025 Three.js Authors
* SPDX-License-Identifier: MIT
*/
var REVISION = "181";
/**
* Disables face culling.
*
* @type {number}
* @constant
*/
var CullFaceNone = 0;
/**
* Culls back faces.
*
* @type {number}
* @constant
*/
var CullFaceBack = 1;
/**
* Culls front faces.
*
* @type {number}
* @constant
*/
var CullFaceFront = 2;
/**
* Gives unfiltered shadow maps - fastest, but lowest quality.
*
* @type {number}
* @constant
*/
var BasicShadowMap = 0;
/**
* Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm.
*
* @type {number}
* @constant
*/
var PCFShadowMap = 1;
/**
* Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm with
* better soft shadows especially when using low-resolution shadow maps.
*
* @type {number}
* @constant
*/
var PCFSoftShadowMap = 2;
/**
* Filters shadow maps using the Variance Shadow Map (VSM) algorithm.
* When using VSMShadowMap all shadow receivers will also cast shadows.
*
* @type {number}
* @constant
*/
var VSMShadowMap = 3;
/**
* Only front faces are rendered.
*
* @type {number}
* @constant
*/
var FrontSide = 0;
/**
* Only back faces are rendered.
*
* @type {number}
* @constant
*/
var BackSide = 1;
/**
* Both front and back faces are rendered.
*
* @type {number}
* @constant
*/
var DoubleSide = 2;
/**
* No blending is performed which effectively disables
* alpha transparency.
*
* @type {number}
* @constant
*/
var NoBlending = 0;
/**
* The default blending.
*
* @type {number}
* @constant
*/
var NormalBlending = 1;
/**
* Represents additive blending.
*
* @type {number}
* @constant
*/
var AdditiveBlending = 2;
/**
* Represents subtractive blending.
*
* @type {number}
* @constant
*/
var SubtractiveBlending = 3;
/**
* Represents multiply blending.
*
* @type {number}
* @constant
*/
var MultiplyBlending = 4;
/**
* Represents custom blending.
*
* @type {number}
* @constant
*/
var CustomBlending = 5;
/**
* A `source + destination` blending equation.
*
* @type {number}
* @constant
*/
var AddEquation = 100;
/**
* A `source - destination` blending equation.
*
* @type {number}
* @constant
*/
var SubtractEquation = 101;
/**
* A `destination - source` blending equation.
*
* @type {number}
* @constant
*/
var ReverseSubtractEquation = 102;
/**
* A blend equation that uses the minimum of source and destination.
*
* @type {number}
* @constant
*/
var MinEquation = 103;
/**
* A blend equation that uses the maximum of source and destination.
*
* @type {number}
* @constant
*/
var MaxEquation = 104;
/**
* Multiplies all colors by `0`.
*
* @type {number}
* @constant
*/
var ZeroFactor = 200;
/**
* Multiplies all colors by `1`.
*
* @type {number}
* @constant
*/
var OneFactor = 201;
/**
* Multiplies all colors by the source colors.
*
* @type {number}
* @constant
*/
var SrcColorFactor = 202;
/**
* Multiplies all colors by `1` minus each source color.
*
* @type {number}
* @constant
*/
var OneMinusSrcColorFactor = 203;
/**
* Multiplies all colors by the source alpha value.
*
* @type {number}
* @constant
*/
var SrcAlphaFactor = 204;
/**
* Multiplies all colors by 1 minus the source alpha value.
*
* @type {number}
* @constant
*/
var OneMinusSrcAlphaFactor = 205;
/**
* Multiplies all colors by the destination alpha value.
*
* @type {number}
* @constant
*/
var DstAlphaFactor = 206;
/**
* Multiplies all colors by `1` minus the destination alpha value.
*
* @type {number}
* @constant
*/
var OneMinusDstAlphaFactor = 207;
/**
* Multiplies all colors by the destination color.
*
* @type {number}
* @constant
*/
var DstColorFactor = 208;
/**
* Multiplies all colors by `1` minus each destination color.
*
* @type {number}
* @constant
*/
var OneMinusDstColorFactor = 209;
/**
* Multiplies the RGB colors by the smaller of either the source alpha
* value or the value of `1` minus the destination alpha value. The alpha
* value is multiplied by `1`.
*
* @type {number}
* @constant
*/
var SrcAlphaSaturateFactor = 210;
/**
* Multiplies all colors by a constant color.
*
* @type {number}
* @constant
*/
var ConstantColorFactor = 211;
/**
* Multiplies all colors by `1` minus a constant color.
*
* @type {number}
* @constant
*/
var OneMinusConstantColorFactor = 212;
/**
* Multiplies all colors by a constant alpha value.
*
* @type {number}
* @constant
*/
var ConstantAlphaFactor = 213;
/**
* Multiplies all colors by 1 minus a constant alpha value.
*
* @type {number}
* @constant
*/
var OneMinusConstantAlphaFactor = 214;
/**
* Never pass.
*
* @type {number}
* @constant
*/
var NeverDepth = 0;
/**
* Always pass.
*
* @type {number}
* @constant
*/
var AlwaysDepth = 1;
/**
* Pass if the incoming value is less than the depth buffer value.
*
* @type {number}
* @constant
*/
var LessDepth = 2;
/**
* Pass if the incoming value is less than or equal to the depth buffer value.
*
* @type {number}
* @constant
*/
var LessEqualDepth = 3;
/**
* Pass if the incoming value equals the depth buffer value.
*
* @type {number}
* @constant
*/
var EqualDepth = 4;
/**
* Pass if the incoming value is greater than or equal to the depth buffer value.
*
* @type {number}
* @constant
*/
var GreaterEqualDepth = 5;
/**
* Pass if the incoming value is greater than the depth buffer value.
*
* @type {number}
* @constant
*/
var GreaterDepth = 6;
/**
* Pass if the incoming value is not equal to the depth buffer value.
*
* @type {number}
* @constant
*/
var NotEqualDepth = 7;
/**
* Multiplies the environment map color with the surface color.
*
* @type {number}
* @constant
*/
var MultiplyOperation = 0;
/**
* Uses reflectivity to blend between the two colors.
*
* @type {number}
* @constant
*/
var MixOperation = 1;
/**
* Adds the two colors.
*
* @type {number}
* @constant
*/
var AddOperation = 2;
/**
* No tone mapping is applied.
*
* @type {number}
* @constant
*/
var NoToneMapping = 0;
/**
* Linear tone mapping.
*
* @type {number}
* @constant
*/
var LinearToneMapping = 1;
/**
* Reinhard tone mapping.
*
* @type {number}
* @constant
*/
var ReinhardToneMapping = 2;
/**
* Cineon tone mapping.
*
* @type {number}
* @constant
*/
var CineonToneMapping = 3;
/**
* ACES Filmic tone mapping.
*
* @type {number}
* @constant
*/
var ACESFilmicToneMapping = 4;
/**
* Custom tone mapping.
*
* Expects a custom implementation by modifying shader code of the material's fragment shader.
*
* @type {number}
* @constant
*/
var CustomToneMapping = 5;
/**
* AgX tone mapping.
*
* @type {number}
* @constant
*/
var AgXToneMapping = 6;
/**
* Neutral tone mapping.
*
* Implementation based on the Khronos 3D Commerce Group standard tone mapping.
*
* @type {number}
* @constant
*/
var NeutralToneMapping = 7;
/**
* Maps textures using the geometry's UV coordinates.
*
* @type {number}
* @constant
*/
var UVMapping = 300;
/**
* Reflection mapping for cube textures.
*
* @type {number}
* @constant
*/
var CubeReflectionMapping = 301;
/**
* Refraction mapping for cube textures.
*
* @type {number}
* @constant
*/
var CubeRefractionMapping = 302;
/**
* Reflection mapping for equirectangular textures.
*
* @type {number}
* @constant
*/
var EquirectangularReflectionMapping = 303;
/**
* Refraction mapping for equirectangular textures.
*
* @type {number}
* @constant
*/
var EquirectangularRefractionMapping = 304;
/**
* Reflection mapping for PMREM textures.
*
* @type {number}
* @constant
*/
var CubeUVReflectionMapping = 306;
/**
* The texture will simply repeat to infinity.
*
* @type {number}
* @constant
*/
var RepeatWrapping = 1e3;
/**
* The last pixel of the texture stretches to the edge of the mesh.
*
* @type {number}
* @constant
*/
var ClampToEdgeWrapping = 1001;
/**
* The texture will repeats to infinity, mirroring on each repeat.
*
* @type {number}
* @constant
*/
var MirroredRepeatWrapping = 1002;
/**
* Returns the value of the texture element that is nearest (in Manhattan distance)
* to the specified texture coordinates.
*
* @type {number}
* @constant
*/
var NearestFilter = 1003;
/**
* Chooses the mipmap that most closely matches the size of the pixel being textured
* and uses the `NearestFilter` criterion (the texel nearest to the center of the pixel)
* to produce a texture value.
*
* @type {number}
* @constant
*/
var NearestMipmapNearestFilter = 1004;
/**
* Chooses the two mipmaps that most closely match the size of the pixel being textured and
* uses the `NearestFilter` criterion to produce a texture value from each mipmap.
* The final texture value is a weighted average of those two values.
*
* @type {number}
* @constant
*/
var NearestMipmapLinearFilter = 1005;
/**
* Returns the weighted average of the four texture elements that are closest to the specified
* texture coordinates, and can include items wrapped or repeated from other parts of a texture,
* depending on the values of `wrapS` and `wrapT`, and on the exact mapping.
*
* @type {number}
* @constant
*/
var LinearFilter = 1006;
/**
* Chooses the mipmap that most closely matches the size of the pixel being textured and uses
* the `LinearFilter` criterion (a weighted average of the four texels that are closest to the
* center of the pixel) to produce a texture value.
*
* @type {number}
* @constant
*/
var LinearMipmapNearestFilter = 1007;
/**
* Chooses the two mipmaps that most closely match the size of the pixel being textured and uses
* the `LinearFilter` criterion to produce a texture value from each mipmap. The final texture value
* is a weighted average of those two values.
*
* @type {number}
* @constant
*/
var LinearMipmapLinearFilter = 1008;
var LinearMipMapLinearFilter = 1008;
/**
* An unsigned byte data type for textures.
*
* @type {number}
* @constant
*/
var UnsignedByteType = 1009;
/**
* A byte data type for textures.
*
* @type {number}
* @constant
*/
var ByteType = 1010;
/**
* A short data type for textures.
*
* @type {number}
* @constant
*/
var ShortType = 1011;
/**
* An unsigned short data type for textures.
*
* @type {number}
* @constant
*/
var UnsignedShortType = 1012;
/**
* An int data type for textures.
*
* @type {number}
* @constant
*/
var IntType = 1013;
/**
* An unsigned int data type for textures.
*
* @type {number}
* @constant
*/
var UnsignedIntType = 1014;
/**
* A float data type for textures.
*
* @type {number}
* @constant
*/
var FloatType = 1015;
/**
* A half float data type for textures.
*
* @type {number}
* @constant
*/
var HalfFloatType = 1016;
/**
* An unsigned short 4_4_4_4 (packed) data type for textures.
*
* @type {number}
* @constant
*/
var UnsignedShort4444Type = 1017;
/**
* An unsigned short 5_5_5_1 (packed) data type for textures.
*
* @type {number}
* @constant
*/
var UnsignedShort5551Type = 1018;
/**
* An unsigned int 24_8 data type for textures.
*
* @type {number}
* @constant
*/
var UnsignedInt248Type = 1020;
/**
* An unsigned int 5_9_9_9 (packed) data type for textures.
*
* @type {number}
* @constant
*/
var UnsignedInt5999Type = 35902;
/**
* An unsigned int 10_11_11 (packed) data type for textures.
*
* @type {number}
* @constant
*/
var UnsignedInt101111Type = 35899;
/**
* Discards the red, green and blue components and reads just the alpha component.
*
* @type {number}
* @constant
*/
var AlphaFormat = 1021;
/**
* Discards the alpha component and reads the red, green and blue component.
*
* @type {number}
* @constant
*/
var RGBFormat = 1022;
/**
* Reads the red, green, blue and alpha components.
*
* @type {number}
* @constant
*/
var RGBAFormat = 1023;
/**
* Reads each element as a single depth value, converts it to floating point, and clamps to the range `[0,1]`.
*
* @type {number}
* @constant
*/
var DepthFormat = 1026;
/**
* Reads each element is a pair of depth and stencil values. The depth component of the pair is interpreted as
* in `DepthFormat`. The stencil component is interpreted based on the depth + stencil internal format.
*
* @type {number}
* @constant
*/
var DepthStencilFormat = 1027;
/**
* Discards the green, blue and alpha components and reads just the red component.
*
* @type {number}
* @constant
*/
var RedFormat = 1028;
/**
* Discards the green, blue and alpha components and reads just the red component. The texels are read as integers instead of floating point.
*
* @type {number}
* @constant
*/
var RedIntegerFormat = 1029;
/**
* Discards the alpha, and blue components and reads the red, and green components.
*
* @type {number}
* @constant
*/
var RGFormat = 1030;
/**
* Discards the alpha, and blue components and reads the red, and green components. The texels are read as integers instead of floating point.
*
* @type {number}
* @constant
*/
var RGIntegerFormat = 1031;
/**
* Discards the alpha component and reads the red, green and blue component. The texels are read as integers instead of floating point.
*
* @type {number}
* @constant
*/
var RGBIntegerFormat = 1032;
/**
* Reads the red, green, blue and alpha components. The texels are read as integers instead of floating point.
*
* @type {number}
* @constant
*/
var RGBAIntegerFormat = 1033;
/**
* A DXT1-compressed image in an RGB image format.
*
* @type {number}
* @constant
*/
var RGB_S3TC_DXT1_Format = 33776;
/**
* A DXT1-compressed image in an RGB image format with a simple on/off alpha value.
*
* @type {number}
* @constant
*/
var RGBA_S3TC_DXT1_Format = 33777;
/**
* A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.
*
* @type {number}
* @constant
*/
var RGBA_S3TC_DXT3_Format = 33778;
/**
* A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3
* compression in how the alpha compression is done.
*
* @type {number}
* @constant
*/
var RGBA_S3TC_DXT5_Format = 33779;
/**
* PVRTC RGB compression in 4-bit mode. One block for each 4×4 pixels.
*
* @type {number}
* @constant
*/
var RGB_PVRTC_4BPPV1_Format = 35840;
/**
* PVRTC RGB compression in 2-bit mode. One block for each 8×4 pixels.
*
* @type {number}
* @constant
*/
var RGB_PVRTC_2BPPV1_Format = 35841;
/**
* PVRTC RGBA compression in 4-bit mode. One block for each 4×4 pixels.
*
* @type {number}
* @constant
*/
var RGBA_PVRTC_4BPPV1_Format = 35842;
/**
* PVRTC RGBA compression in 2-bit mode. One block for each 8×4 pixels.
*
* @type {number}
* @constant
*/
var RGBA_PVRTC_2BPPV1_Format = 35843;
/**
* ETC1 RGB format.
*
* @type {number}
* @constant
*/
var RGB_ETC1_Format = 36196;
/**
* ETC2 RGB format.
*
* @type {number}
* @constant
*/
var RGB_ETC2_Format = 37492;
/**
* ETC2 RGBA format.
*
* @type {number}
* @constant
*/
var RGBA_ETC2_EAC_Format = 37496;
/**
* ASTC RGBA 4x4 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_4x4_Format = 37808;
/**
* ASTC RGBA 5x4 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_5x4_Format = 37809;
/**
* ASTC RGBA 5x5 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_5x5_Format = 37810;
/**
* ASTC RGBA 6x5 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_6x5_Format = 37811;
/**
* ASTC RGBA 6x6 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_6x6_Format = 37812;
/**
* ASTC RGBA 8x5 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_8x5_Format = 37813;
/**
* ASTC RGBA 8x6 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_8x6_Format = 37814;
/**
* ASTC RGBA 8x8 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_8x8_Format = 37815;
/**
* ASTC RGBA 10x5 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_10x5_Format = 37816;
/**
* ASTC RGBA 10x6 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_10x6_Format = 37817;
/**
* ASTC RGBA 10x8 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_10x8_Format = 37818;
/**
* ASTC RGBA 10x10 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_10x10_Format = 37819;
/**
* ASTC RGBA 12x10 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_12x10_Format = 37820;
/**
* ASTC RGBA 12x12 format.
*
* @type {number}
* @constant
*/
var RGBA_ASTC_12x12_Format = 37821;
/**
* BPTC RGBA format.
*
* @type {number}
* @constant
*/
var RGBA_BPTC_Format = 36492;
/**
* BPTC Signed RGB format.
*
* @type {number}
* @constant
*/
var RGB_BPTC_SIGNED_Format = 36494;
/**
* BPTC Unsigned RGB format.
*
* @type {number}
* @constant
*/
var RGB_BPTC_UNSIGNED_Format = 36495;
/**
* RGTC1 Red format.
*
* @type {number}
* @constant
*/
var RED_RGTC1_Format = 36283;
/**
* RGTC1 Signed Red format.
*
* @type {number}
* @constant
*/
var SIGNED_RED_RGTC1_Format = 36284;
/**
* RGTC2 Red Green format.
*
* @type {number}
* @constant
*/
var RED_GREEN_RGTC2_Format = 36285;
/**
* RGTC2 Signed Red Green format.
*
* @type {number}
* @constant
*/
var SIGNED_RED_GREEN_RGTC2_Format = 36286;
/**
* Discrete interpolation mode for keyframe tracks.
*
* @type {number}
* @constant
*/
var InterpolateDiscrete = 2300;
/**
* Linear interpolation mode for keyframe tracks.
*
* @type {number}
* @constant
*/
var InterpolateLinear = 2301;
/**
* Smooth interpolation mode for keyframe tracks.
*
* @type {number}
* @constant
*/
var InterpolateSmooth = 2302;
/**
* Zero curvature ending for animations.
*
* @type {number}
* @constant
*/
var ZeroCurvatureEnding = 2400;
/**
* Zero slope ending for animations.
*
* @type {number}
* @constant
*/
var ZeroSlopeEnding = 2401;
/**
* Wrap around ending for animations.
*
* @type {number}
* @constant
*/
var WrapAroundEnding = 2402;
/**
* Basic depth packing.
*
* @type {number}
* @constant
*/
var BasicDepthPacking = 3200;
/**
* A depth value is packed into 32 bit RGBA.
*
* @type {number}
* @constant
*/
var RGBADepthPacking = 3201;
/**
* Normal information is relative to the underlying surface.
*
* @type {number}
* @constant
*/
var TangentSpaceNormalMap = 0;
/**
* Normal information is relative to the object orientation.
*
* @type {number}
* @constant
*/
var ObjectSpaceNormalMap = 1;
/**
* No color space.
*
* @type {string}
* @constant
*/
var NoColorSpace = "";
/**
* sRGB color space.
*
* @type {string}
* @constant
*/
var SRGBColorSpace = "srgb";
/**
* sRGB-linear color space.
*
* @type {string}
* @constant
*/
var LinearSRGBColorSpace = "srgb-linear";
/**
* Linear transfer function.
*
* @type {string}
* @constant
*/
var LinearTransfer = "linear";
/**
* sRGB transfer function.
*
* @type {string}
* @constant
*/
var SRGBTransfer = "srgb";
/**
* Sets the stencil buffer value to `0`.
*
* @type {number}
* @constant
*/
var ZeroStencilOp = 0;
/**
* Keeps the current value.
*
* @type {number}
* @constant
*/
var KeepStencilOp = 7680;
/**
* Sets the stencil buffer value to the specified reference value.
*
* @type {number}
* @constant
*/
var ReplaceStencilOp = 7681;
/**
* Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.
*
* @type {number}
* @constant
*/
var IncrementStencilOp = 7682;
/**
* Decrements the current stencil buffer value. Clamps to `0`.
*
* @type {number}
* @constant
*/
var DecrementStencilOp = 7683;
/**
* Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing
* the maximum representable unsigned value.
*
* @type {number}
* @constant
*/
var IncrementWrapStencilOp = 34055;
/**
* Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable
* unsigned value when decrementing a stencil buffer value of `0`.
*
* @type {number}
* @constant
*/
var DecrementWrapStencilOp = 34056;
/**
* Inverts the current stencil buffer value bitwise.
*
* @type {number}
* @constant
*/
var InvertStencilOp = 5386;
/**
* Will never return true.
*
* @type {number}
* @constant
*/
var NeverStencilFunc = 512;
/**
* Will return true if the stencil reference value is less than the current stencil value.
*
* @type {number}
* @constant
*/
var LessStencilFunc = 513;
/**
* Will return true if the stencil reference value is equal to the current stencil value.
*
* @type {number}
* @constant
*/
var EqualStencilFunc = 514;
/**
* Will return true if the stencil reference value is less than or equal to the current stencil value.
*
* @type {number}
* @constant
*/
var LessEqualStencilFunc = 515;
/**
* Will return true if the stencil reference value is greater than the current stencil value.
*
* @type {number}
* @constant
*/
var GreaterStencilFunc = 516;
/**
* Will return true if the stencil reference value is not equal to the current stencil value.
*
* @type {number}
* @constant
*/
var NotEqualStencilFunc = 517;
/**
* Will return true if the stencil reference value is greater than or equal to the current stencil value.
*
* @type {number}
* @constant
*/
var GreaterEqualStencilFunc = 518;
/**
* Will always return true.
*
* @type {number}
* @constant
*/
var AlwaysStencilFunc = 519;
/**
* Never pass.
*
* @type {number}
* @constant
*/
var NeverCompare = 512;
/**
* Pass if the incoming value is less than the texture value.
*
* @type {number}
* @constant
*/
var LessCompare = 513;
/**
* Pass if the incoming value equals the texture value.
*
* @type {number}
* @constant
*/
var EqualCompare = 514;
/**
* Pass if the incoming value is less than or equal to the texture value.
*
* @type {number}
* @constant
*/
var LessEqualCompare = 515;
/**
* Pass if the incoming value is greater than the texture value.
*
* @type {number}
* @constant
*/
var GreaterCompare = 516;
/**
* Pass if the incoming value is not equal to the texture value.
*
* @type {number}
* @constant
*/
var NotEqualCompare = 517;
/**
* Pass if the incoming value is greater than or equal to the texture value.
*
* @type {number}
* @constant
*/
var GreaterEqualCompare = 518;
/**
* Always pass.
*
* @type {number}
* @constant
*/
var AlwaysCompare = 519;
/**
* The contents are intended to be specified once by the application, and used many
* times as the source for drawing and image specification commands.
*
* @type {number}
* @constant
*/
var StaticDrawUsage = 35044;
/**
* The contents are intended to be respecified repeatedly by the application, and
* used many times as the source for drawing and image specification commands.
*
* @type {number}
* @constant
*/
var DynamicDrawUsage = 35048;
/**
* GLSL 3 shader code.
*
* @type {string}
* @constant
*/
var GLSL3 = "300 es";
/**
* WebGL coordinate system.
*
* @type {number}
* @constant
*/
var WebGLCoordinateSystem = 2e3;
/**
* WebGPU coordinate system.
*
* @type {number}
* @constant
*/
var WebGPUCoordinateSystem = 2001;
/**
* Represents the different timestamp query types.
*
* @type {ConstantsTimestampQuery}
* @constant
*/
var TimestampQuery = {
	COMPUTE: "compute",
	RENDER: "render"
};
/**
* This type represents mouse buttons and interaction types in context of controls.
*
* @typedef {Object} ConstantsMouse
* @property {number} MIDDLE - The left mouse button.
* @property {number} LEFT - The middle mouse button.
* @property {number} RIGHT - The right mouse button.
* @property {number} ROTATE - A rotate interaction.
* @property {number} DOLLY - A dolly interaction.
* @property {number} PAN - A pan interaction.
**/
/**
* This type represents touch interaction types in context of controls.
*
* @typedef {Object} ConstantsTouch
* @property {number} ROTATE - A rotate interaction.
* @property {number} PAN - A pan interaction.
* @property {number} DOLLY_PAN - The dolly-pan interaction.
* @property {number} DOLLY_ROTATE - A dolly-rotate interaction.
**/
/**
* This type represents the different timestamp query types.
*
* @typedef {Object} ConstantsTimestampQuery
* @property {string} COMPUTE - A `compute` timestamp query.
* @property {string} RENDER - A `render` timestamp query.
**/
/**
* Represents the different interpolation sampling types.
*
* @typedef {Object} ConstantsInterpolationSamplingType
* @property {string} PERSPECTIVE - Perspective-correct interpolation.
* @property {string} LINEAR - Linear interpolation.
* @property {string} FLAT - Flat interpolation.
*/
/**
* Represents the different interpolation sampling modes.
*
* @typedef {Object} ConstantsInterpolationSamplingMode
* @property {string} NORMAL - Normal sampling mode.
* @property {string} CENTROID - Centroid sampling mode.
* @property {string} SAMPLE - Sample-specific sampling mode.
* @property {string} FIRST - Flat interpolation using the first vertex.
* @property {string} EITHER - Flat interpolation using either vertex.
*/
function arrayNeedsUint32(array$2) {
	for (let i = array$2.length - 1; i >= 0; --i) if (array$2[i] >= 65535) return true;
	return false;
}
function createElementNS(name) {
	return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function createCanvasElement() {
	const canvas = createElementNS("canvas");
	canvas.style.display = "block";
	return canvas;
}
var _cache$2 = {};
var _setConsoleFunction = null;
function log(...params) {
	const message = "THREE." + params.shift();
	if (_setConsoleFunction) _setConsoleFunction("log", message, ...params);
	else console.log(message, ...params);
}
function warn(...params) {
	const message = "THREE." + params.shift();
	if (_setConsoleFunction) _setConsoleFunction("warn", message, ...params);
	else console.warn(message, ...params);
}
function error(...params) {
	const message = "THREE." + params.shift();
	if (_setConsoleFunction) _setConsoleFunction("error", message, ...params);
	else console.error(message, ...params);
}
function warnOnce(...params) {
	const message = params.join(" ");
	if (message in _cache$2) return;
	_cache$2[message] = true;
	warn(...params);
}
function probeAsync(gl, sync, interval) {
	return new Promise(function(resolve, reject) {
		function probe() {
			switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
				case gl.WAIT_FAILED:
					reject();
					break;
				case gl.TIMEOUT_EXPIRED:
					setTimeout(probe, interval);
					break;
				default: resolve();
			}
		}
		setTimeout(probe, interval);
	});
}
/**
* This modules allows to dispatch event objects on custom JavaScript objects.
*
* Main repository: [eventdispatcher.js](https://github.com/mrdoob/eventdispatcher.js/)
*
* Code Example:
* ```js
* class Car extends EventDispatcher {
* 	start() {
*		this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );
*	}
*};
*
* // Using events with the custom object
* const car = new Car();
* car.addEventListener( 'start', function ( event ) {
* 	alert( event.message );
* } );
*
* car.start();
* ```
*/
var EventDispatcher = class {
	/**
	* Adds the given event listener to the given event type.
	*
	* @param {string} type - The type of event to listen to.
	* @param {Function} listener - The function that gets called when the event is fired.
	*/
	addEventListener(type$1, listener) {
		if (this._listeners === void 0) this._listeners = {};
		const listeners = this._listeners;
		if (listeners[type$1] === void 0) listeners[type$1] = [];
		if (listeners[type$1].indexOf(listener) === -1) listeners[type$1].push(listener);
	}
	/**
	* Returns `true` if the given event listener has been added to the given event type.
	*
	* @param {string} type - The type of event.
	* @param {Function} listener - The listener to check.
	* @return {boolean} Whether the given event listener has been added to the given event type.
	*/
	hasEventListener(type$1, listener) {
		const listeners = this._listeners;
		if (listeners === void 0) return false;
		return listeners[type$1] !== void 0 && listeners[type$1].indexOf(listener) !== -1;
	}
	/**
	* Removes the given event listener from the given event type.
	*
	* @param {string} type - The type of event.
	* @param {Function} listener - The listener to remove.
	*/
	removeEventListener(type$1, listener) {
		const listeners = this._listeners;
		if (listeners === void 0) return;
		const listenerArray = listeners[type$1];
		if (listenerArray !== void 0) {
			const index = listenerArray.indexOf(listener);
			if (index !== -1) listenerArray.splice(index, 1);
		}
	}
	/**
	* Dispatches an event object.
	*
	* @param {Object} event - The event that gets fired.
	*/
	dispatchEvent(event) {
		const listeners = this._listeners;
		if (listeners === void 0) return;
		const listenerArray = listeners[event.type];
		if (listenerArray !== void 0) {
			event.target = this;
			const array$2 = listenerArray.slice(0);
			for (let i = 0, l = array$2.length; i < l; i++) array$2[i].call(this, event);
			event.target = null;
		}
	}
};
var _lut = [
	"00",
	"01",
	"02",
	"03",
	"04",
	"05",
	"06",
	"07",
	"08",
	"09",
	"0a",
	"0b",
	"0c",
	"0d",
	"0e",
	"0f",
	"10",
	"11",
	"12",
	"13",
	"14",
	"15",
	"16",
	"17",
	"18",
	"19",
	"1a",
	"1b",
	"1c",
	"1d",
	"1e",
	"1f",
	"20",
	"21",
	"22",
	"23",
	"24",
	"25",
	"26",
	"27",
	"28",
	"29",
	"2a",
	"2b",
	"2c",
	"2d",
	"2e",
	"2f",
	"30",
	"31",
	"32",
	"33",
	"34",
	"35",
	"36",
	"37",
	"38",
	"39",
	"3a",
	"3b",
	"3c",
	"3d",
	"3e",
	"3f",
	"40",
	"41",
	"42",
	"43",
	"44",
	"45",
	"46",
	"47",
	"48",
	"49",
	"4a",
	"4b",
	"4c",
	"4d",
	"4e",
	"4f",
	"50",
	"51",
	"52",
	"53",
	"54",
	"55",
	"56",
	"57",
	"58",
	"59",
	"5a",
	"5b",
	"5c",
	"5d",
	"5e",
	"5f",
	"60",
	"61",
	"62",
	"63",
	"64",
	"65",
	"66",
	"67",
	"68",
	"69",
	"6a",
	"6b",
	"6c",
	"6d",
	"6e",
	"6f",
	"70",
	"71",
	"72",
	"73",
	"74",
	"75",
	"76",
	"77",
	"78",
	"79",
	"7a",
	"7b",
	"7c",
	"7d",
	"7e",
	"7f",
	"80",
	"81",
	"82",
	"83",
	"84",
	"85",
	"86",
	"87",
	"88",
	"89",
	"8a",
	"8b",
	"8c",
	"8d",
	"8e",
	"8f",
	"90",
	"91",
	"92",
	"93",
	"94",
	"95",
	"96",
	"97",
	"98",
	"99",
	"9a",
	"9b",
	"9c",
	"9d",
	"9e",
	"9f",
	"a0",
	"a1",
	"a2",
	"a3",
	"a4",
	"a5",
	"a6",
	"a7",
	"a8",
	"a9",
	"aa",
	"ab",
	"ac",
	"ad",
	"ae",
	"af",
	"b0",
	"b1",
	"b2",
	"b3",
	"b4",
	"b5",
	"b6",
	"b7",
	"b8",
	"b9",
	"ba",
	"bb",
	"bc",
	"bd",
	"be",
	"bf",
	"c0",
	"c1",
	"c2",
	"c3",
	"c4",
	"c5",
	"c6",
	"c7",
	"c8",
	"c9",
	"ca",
	"cb",
	"cc",
	"cd",
	"ce",
	"cf",
	"d0",
	"d1",
	"d2",
	"d3",
	"d4",
	"d5",
	"d6",
	"d7",
	"d8",
	"d9",
	"da",
	"db",
	"dc",
	"dd",
	"de",
	"df",
	"e0",
	"e1",
	"e2",
	"e3",
	"e4",
	"e5",
	"e6",
	"e7",
	"e8",
	"e9",
	"ea",
	"eb",
	"ec",
	"ed",
	"ee",
	"ef",
	"f0",
	"f1",
	"f2",
	"f3",
	"f4",
	"f5",
	"f6",
	"f7",
	"f8",
	"f9",
	"fa",
	"fb",
	"fc",
	"fd",
	"fe",
	"ff"
];
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
/**
* Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
* (universally unique identifier).
*
* @return {string} The UUID.
*/
function generateUUID() {
	const d0$1 = Math.random() * 4294967295 | 0;
	const d1 = Math.random() * 4294967295 | 0;
	const d2 = Math.random() * 4294967295 | 0;
	const d3 = Math.random() * 4294967295 | 0;
	return (_lut[d0$1 & 255] + _lut[d0$1 >> 8 & 255] + _lut[d0$1 >> 16 & 255] + _lut[d0$1 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255]).toLowerCase();
}
/**
* Clamps the given value between min and max.
*
* @param {number} value - The value to clamp.
* @param {number} min - The min value.
* @param {number} max - The max value.
* @return {number} The clamped value.
*/
function clamp$3(value, min$3, max$3) {
	return Math.max(min$3, Math.min(max$3, value));
}
/**
* Computes the Euclidean modulo of the given parameters that
* is `( ( n % m ) + m ) % m`.
*
* @param {number} n - The first parameter.
* @param {number} m - The second parameter.
* @return {number} The Euclidean modulo.
*/
function euclideanModulo(n$2, m$1) {
	return (n$2 % m$1 + m$1) % m$1;
}
/**
* Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
* for the given value.
*
* @param {number} x - The value to be mapped.
* @param {number} a1 - Minimum value for range A.
* @param {number} a2 - Maximum value for range A.
* @param {number} b1 - Minimum value for range B.
* @param {number} b2 - Maximum value for range B.
* @return {number} The mapped value.
*/
function mapLinear(x, a1, a2, b1, b2) {
	return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
/**
* Returns the percentage in the closed interval `[0, 1]` of the given value
* between the start and end point.
*
* @param {number} x - The start point
* @param {number} y - The end point.
* @param {number} value - A value between start and end.
* @return {number} The interpolation factor.
*/
function inverseLerp(x, y, value) {
	if (x !== y) return (value - x) / (y - x);
	else return 0;
}
/**
* Returns a value linearly interpolated from two known points based on the given interval -
* `t = 0` will return `x` and `t = 1` will return `y`.
*
* @param {number} x - The start point
* @param {number} y - The end point.
* @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
* @return {number} The interpolated value.
*/
function lerp(x, y, t) {
	return (1 - t) * x + t * y;
}
/**
* Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
* time to maintain frame rate independent movement. For details, see
* [Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/).
*
* @param {number} x - The current point.
* @param {number} y - The target point.
* @param {number} lambda - A higher lambda value will make the movement more sudden,
* and a lower value will make the movement more gradual.
* @param {number} dt - Delta time in seconds.
* @return {number} The interpolated value.
*/
function damp(x, y, lambda, dt) {
	return lerp(x, y, 1 - Math.exp(-lambda * dt));
}
/**
* Returns a value that alternates between `0` and the given `length` parameter.
*
* @param {number} x - The value to pingpong.
* @param {number} [length=1] - The positive value the function will pingpong to.
* @return {number} The alternated value.
*/
function pingpong(x, length$2 = 1) {
	return length$2 - Math.abs(euclideanModulo(x, length$2 * 2) - length$2);
}
/**
* Returns a value in the range `[0,1]` that represents the percentage that `x` has
* moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
* the `min` and `max`.
*
* See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details.
*
* @param {number} x - The value to evaluate based on its position between min and max.
* @param {number} min - The min value. Any x value below min will be `0`.
* @param {number} max - The max value. Any x value above max will be `1`.
* @return {number} The alternated value.
*/
function smoothstep$2(x, min$3, max$3) {
	if (x <= min$3) return 0;
	if (x >= max$3) return 1;
	x = (x - min$3) / (max$3 - min$3);
	return x * x * (3 - 2 * x);
}
/**
* A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)
* that has zero 1st and 2nd order derivatives at x=0 and x=1.
*
* @param {number} x - The value to evaluate based on its position between min and max.
* @param {number} min - The min value. Any x value below min will be `0`.
* @param {number} max - The max value. Any x value above max will be `1`.
* @return {number} The alternated value.
*/
function smootherstep(x, min$3, max$3) {
	if (x <= min$3) return 0;
	if (x >= max$3) return 1;
	x = (x - min$3) / (max$3 - min$3);
	return x * x * x * (x * (x * 6 - 15) + 10);
}
/**
* Returns a random integer from `<low, high>` interval.
*
* @param {number} low - The lower value boundary.
* @param {number} high - The upper value boundary
* @return {number} A random integer.
*/
function randInt(low, high) {
	return low + Math.floor(Math.random() * (high - low + 1));
}
/**
* Returns a random float from `<low, high>` interval.
*
* @param {number} low - The lower value boundary.
* @param {number} high - The upper value boundary
* @return {number} A random float.
*/
function randFloat(low, high) {
	return low + Math.random() * (high - low);
}
/**
* Returns a random integer from `<-range/2, range/2>` interval.
*
* @param {number} range - Defines the value range.
* @return {number} A random float.
*/
function randFloatSpread(range$3) {
	return range$3 * (.5 - Math.random());
}
/**
* Returns a deterministic pseudo-random float in the interval `[0, 1]`.
*
* @param {number} [s] - The integer seed.
* @return {number} A random float.
*/
function seededRandom$1(s) {
	if (s !== void 0) _seed = s;
	let t = _seed += 1831565813;
	t = Math.imul(t ^ t >>> 15, t | 1);
	t ^= t + Math.imul(t ^ t >>> 7, t | 61);
	return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
/**
* Converts degrees to radians.
*
* @param {number} degrees - A value in degrees.
* @return {number} The converted value in radians.
*/
function degToRad(degrees$2) {
	return degrees$2 * DEG2RAD;
}
/**
* Converts radians to degrees.
*
* @param {number} radians - A value in radians.
* @return {number} The converted value in degrees.
*/
function radToDeg(radians$2) {
	return radians$2 * RAD2DEG;
}
/**
* Returns `true` if the given number is a power of two.
*
* @param {number} value - The value to check.
* @return {boolean} Whether the given number is a power of two or not.
*/
function isPowerOfTwo(value) {
	return (value & value - 1) === 0 && value !== 0;
}
/**
* Returns the smallest power of two that is greater than or equal to the given number.
*
* @param {number} value - The value to find a POT for.
* @return {number} The smallest power of two that is greater than or equal to the given number.
*/
function ceilPowerOfTwo(value) {
	return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
/**
* Returns the largest power of two that is less than or equal to the given number.
*
* @param {number} value - The value to find a POT for.
* @return {number} The largest power of two that is less than or equal to the given number.
*/
function floorPowerOfTwo(value) {
	return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
/**
* Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)
* defined by the given angles and order.
*
* Rotations are applied to the axes in the order specified by order:
* rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
*
* @param {Quaternion} q - The quaternion to set.
* @param {number} a - The rotation applied to the first axis, in radians.
* @param {number} b - The rotation applied to the second axis, in radians.
* @param {number} c - The rotation applied to the third axis, in radians.
* @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
*/
function setQuaternionFromProperEuler(q, a$1, b$2, c$1, order) {
	const cos$2 = Math.cos;
	const sin$2 = Math.sin;
	const c2$3 = cos$2(b$2 / 2);
	const s2 = sin$2(b$2 / 2);
	const c13 = cos$2((a$1 + c$1) / 2);
	const s13 = sin$2((a$1 + c$1) / 2);
	const c1_3 = cos$2((a$1 - c$1) / 2);
	const s1_3 = sin$2((a$1 - c$1) / 2);
	const c3_1 = cos$2((c$1 - a$1) / 2);
	const s3_1 = sin$2((c$1 - a$1) / 2);
	switch (order) {
		case "XYX":
			q.set(c2$3 * s13, s2 * c1_3, s2 * s1_3, c2$3 * c13);
			break;
		case "YZY":
			q.set(s2 * s1_3, c2$3 * s13, s2 * c1_3, c2$3 * c13);
			break;
		case "ZXZ":
			q.set(s2 * c1_3, s2 * s1_3, c2$3 * s13, c2$3 * c13);
			break;
		case "XZX":
			q.set(c2$3 * s13, s2 * s3_1, s2 * c3_1, c2$3 * c13);
			break;
		case "YXY":
			q.set(s2 * c3_1, c2$3 * s13, s2 * s3_1, c2$3 * c13);
			break;
		case "ZYZ":
			q.set(s2 * s3_1, s2 * c3_1, c2$3 * s13, c2$3 * c13);
			break;
		default: warn("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
	}
}
/**
* Denormalizes the given value according to the given typed array.
*
* @param {number} value - The value to denormalize.
* @param {TypedArray} array - The typed array that defines the data type of the value.
* @return {number} The denormalize (float) value in the range `[0,1]`.
*/
function denormalize(value, array$2) {
	switch (array$2.constructor) {
		case Float32Array: return value;
		case Uint32Array: return value / 4294967295;
		case Uint16Array: return value / 65535;
		case Uint8Array: return value / 255;
		case Int32Array: return Math.max(value / 2147483647, -1);
		case Int16Array: return Math.max(value / 32767, -1);
		case Int8Array: return Math.max(value / 127, -1);
		default: throw new Error("Invalid component type.");
	}
}
/**
* Normalizes the given value according to the given typed array.
*
* @param {number} value - The float value in the range `[0,1]` to normalize.
* @param {TypedArray} array - The typed array that defines the data type of the value.
* @return {number} The normalize value.
*/
function normalize$2(value, array$2) {
	switch (array$2.constructor) {
		case Float32Array: return value;
		case Uint32Array: return Math.round(value * 4294967295);
		case Uint16Array: return Math.round(value * 65535);
		case Uint8Array: return Math.round(value * 255);
		case Int32Array: return Math.round(value * 2147483647);
		case Int16Array: return Math.round(value * 32767);
		case Int8Array: return Math.round(value * 127);
		default: throw new Error("Invalid component type.");
	}
}
/**
* @class
* @classdesc A collection of math utility functions.
* @hideconstructor
*/
var MathUtils = {
	DEG2RAD,
	RAD2DEG,
	generateUUID,
	clamp: clamp$3,
	euclideanModulo,
	mapLinear,
	inverseLerp,
	lerp,
	damp,
	pingpong,
	smoothstep: smoothstep$2,
	smootherstep,
	randInt,
	randFloat,
	randFloatSpread,
	seededRandom: seededRandom$1,
	degToRad,
	radToDeg,
	isPowerOfTwo,
	ceilPowerOfTwo,
	floorPowerOfTwo,
	setQuaternionFromProperEuler,
	normalize: normalize$2,
	denormalize
};
/**
* Class representing a 2D vector. A 2D vector is an ordered pair of numbers
* (labeled x and y), which can be used to represent a number of things, such as:
*
* - A point in 2D space (i.e. a position on a plane).
* - A direction and length across a plane. In three.js the length will
* always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`
* and the direction is also measured from `(0, 0)` towards `(x, y)`.
* - Any arbitrary ordered pair of numbers.
*
* There are other things a 2D vector can be used to represent, such as
* momentum vectors, complex numbers and so on, however these are the most
* common uses in three.js.
*
* Iterating through a vector instance will yield its components `(x, y)` in
* the corresponding order.
* ```js
* const a = new THREE.Vector2( 0, 1 );
*
* //no arguments; will be initialised to (0, 0)
* const b = new THREE.Vector2( );
*
* const d = a.distanceTo( b );
* ```
*/
var Vector2 = class Vector2 {
	/**
	* Constructs a new 2D vector.
	*
	* @param {number} [x=0] - The x value of this vector.
	* @param {number} [y=0] - The y value of this vector.
	*/
	constructor(x = 0, y = 0) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		Vector2.prototype.isVector2 = true;
		/**
		* The x value of this vector.
		*
		* @type {number}
		*/
		this.x = x;
		/**
		* The y value of this vector.
		*
		* @type {number}
		*/
		this.y = y;
	}
	/**
	* Alias for {@link Vector2#x}.
	*
	* @type {number}
	*/
	get width() {
		return this.x;
	}
	set width(value) {
		this.x = value;
	}
	/**
	* Alias for {@link Vector2#y}.
	*
	* @type {number}
	*/
	get height() {
		return this.y;
	}
	set height(value) {
		this.y = value;
	}
	/**
	* Sets the vector components.
	*
	* @param {number} x - The value of the x component.
	* @param {number} y - The value of the y component.
	* @return {Vector2} A reference to this vector.
	*/
	set(x, y) {
		this.x = x;
		this.y = y;
		return this;
	}
	/**
	* Sets the vector components to the same value.
	*
	* @param {number} scalar - The value to set for all vector components.
	* @return {Vector2} A reference to this vector.
	*/
	setScalar(scalar) {
		this.x = scalar;
		this.y = scalar;
		return this;
	}
	/**
	* Sets the vector's x component to the given value
	*
	* @param {number} x - The value to set.
	* @return {Vector2} A reference to this vector.
	*/
	setX(x) {
		this.x = x;
		return this;
	}
	/**
	* Sets the vector's y component to the given value
	*
	* @param {number} y - The value to set.
	* @return {Vector2} A reference to this vector.
	*/
	setY(y) {
		this.y = y;
		return this;
	}
	/**
	* Allows to set a vector component with an index.
	*
	* @param {number} index - The component index. `0` equals to x, `1` equals to y.
	* @param {number} value - The value to set.
	* @return {Vector2} A reference to this vector.
	*/
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			default: throw new Error("index is out of range: " + index);
		}
		return this;
	}
	/**
	* Returns the value of the vector component which matches the given index.
	*
	* @param {number} index - The component index. `0` equals to x, `1` equals to y.
	* @return {number} A vector component value.
	*/
	getComponent(index) {
		switch (index) {
			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error("index is out of range: " + index);
		}
	}
	/**
	* Returns a new vector with copied values from this instance.
	*
	* @return {Vector2} A clone of this instance.
	*/
	clone() {
		return new this.constructor(this.x, this.y);
	}
	/**
	* Copies the values of the given vector to this instance.
	*
	* @param {Vector2} v - The vector to copy.
	* @return {Vector2} A reference to this vector.
	*/
	copy(v) {
		this.x = v.x;
		this.y = v.y;
		return this;
	}
	/**
	* Adds the given vector to this instance.
	*
	* @param {Vector2} v - The vector to add.
	* @return {Vector2} A reference to this vector.
	*/
	add(v) {
		this.x += v.x;
		this.y += v.y;
		return this;
	}
	/**
	* Adds the given scalar value to all components of this instance.
	*
	* @param {number} s - The scalar to add.
	* @return {Vector2} A reference to this vector.
	*/
	addScalar(s) {
		this.x += s;
		this.y += s;
		return this;
	}
	/**
	* Adds the given vectors and stores the result in this instance.
	*
	* @param {Vector2} a - The first vector.
	* @param {Vector2} b - The second vector.
	* @return {Vector2} A reference to this vector.
	*/
	addVectors(a$1, b$2) {
		this.x = a$1.x + b$2.x;
		this.y = a$1.y + b$2.y;
		return this;
	}
	/**
	* Adds the given vector scaled by the given factor to this instance.
	*
	* @param {Vector2} v - The vector.
	* @param {number} s - The factor that scales `v`.
	* @return {Vector2} A reference to this vector.
	*/
	addScaledVector(v, s) {
		this.x += v.x * s;
		this.y += v.y * s;
		return this;
	}
	/**
	* Subtracts the given vector from this instance.
	*
	* @param {Vector2} v - The vector to subtract.
	* @return {Vector2} A reference to this vector.
	*/
	sub(v) {
		this.x -= v.x;
		this.y -= v.y;
		return this;
	}
	/**
	* Subtracts the given scalar value from all components of this instance.
	*
	* @param {number} s - The scalar to subtract.
	* @return {Vector2} A reference to this vector.
	*/
	subScalar(s) {
		this.x -= s;
		this.y -= s;
		return this;
	}
	/**
	* Subtracts the given vectors and stores the result in this instance.
	*
	* @param {Vector2} a - The first vector.
	* @param {Vector2} b - The second vector.
	* @return {Vector2} A reference to this vector.
	*/
	subVectors(a$1, b$2) {
		this.x = a$1.x - b$2.x;
		this.y = a$1.y - b$2.y;
		return this;
	}
	/**
	* Multiplies the given vector with this instance.
	*
	* @param {Vector2} v - The vector to multiply.
	* @return {Vector2} A reference to this vector.
	*/
	multiply(v) {
		this.x *= v.x;
		this.y *= v.y;
		return this;
	}
	/**
	* Multiplies the given scalar value with all components of this instance.
	*
	* @param {number} scalar - The scalar to multiply.
	* @return {Vector2} A reference to this vector.
	*/
	multiplyScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		return this;
	}
	/**
	* Divides this instance by the given vector.
	*
	* @param {Vector2} v - The vector to divide.
	* @return {Vector2} A reference to this vector.
	*/
	divide(v) {
		this.x /= v.x;
		this.y /= v.y;
		return this;
	}
	/**
	* Divides this vector by the given scalar.
	*
	* @param {number} scalar - The scalar to divide.
	* @return {Vector2} A reference to this vector.
	*/
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar);
	}
	/**
	* Multiplies this vector (with an implicit 1 as the 3rd component) by
	* the given 3x3 matrix.
	*
	* @param {Matrix3} m - The matrix to apply.
	* @return {Vector2} A reference to this vector.
	*/
	applyMatrix3(m$1) {
		const x = this.x, y = this.y;
		const e = m$1.elements;
		this.x = e[0] * x + e[3] * y + e[6];
		this.y = e[1] * x + e[4] * y + e[7];
		return this;
	}
	/**
	* If this vector's x or y value is greater than the given vector's x or y
	* value, replace that value with the corresponding min value.
	*
	* @param {Vector2} v - The vector.
	* @return {Vector2} A reference to this vector.
	*/
	min(v) {
		this.x = Math.min(this.x, v.x);
		this.y = Math.min(this.y, v.y);
		return this;
	}
	/**
	* If this vector's x or y value is less than the given vector's x or y
	* value, replace that value with the corresponding max value.
	*
	* @param {Vector2} v - The vector.
	* @return {Vector2} A reference to this vector.
	*/
	max(v) {
		this.x = Math.max(this.x, v.x);
		this.y = Math.max(this.y, v.y);
		return this;
	}
	/**
	* If this vector's x or y value is greater than the max vector's x or y
	* value, it is replaced by the corresponding value.
	* If this vector's x or y value is less than the min vector's x or y value,
	* it is replaced by the corresponding value.
	*
	* @param {Vector2} min - The minimum x and y values.
	* @param {Vector2} max - The maximum x and y values in the desired range.
	* @return {Vector2} A reference to this vector.
	*/
	clamp(min$3, max$3) {
		this.x = clamp$3(this.x, min$3.x, max$3.x);
		this.y = clamp$3(this.y, min$3.y, max$3.y);
		return this;
	}
	/**
	* If this vector's x or y values are greater than the max value, they are
	* replaced by the max value.
	* If this vector's x or y values are less than the min value, they are
	* replaced by the min value.
	*
	* @param {number} minVal - The minimum value the components will be clamped to.
	* @param {number} maxVal - The maximum value the components will be clamped to.
	* @return {Vector2} A reference to this vector.
	*/
	clampScalar(minVal, maxVal) {
		this.x = clamp$3(this.x, minVal, maxVal);
		this.y = clamp$3(this.y, minVal, maxVal);
		return this;
	}
	/**
	* If this vector's length is greater than the max value, it is replaced by
	* the max value.
	* If this vector's length is less than the min value, it is replaced by the
	* min value.
	*
	* @param {number} min - The minimum value the vector length will be clamped to.
	* @param {number} max - The maximum value the vector length will be clamped to.
	* @return {Vector2} A reference to this vector.
	*/
	clampLength(min$3, max$3) {
		const length$2 = this.length();
		return this.divideScalar(length$2 || 1).multiplyScalar(clamp$3(length$2, min$3, max$3));
	}
	/**
	* The components of this vector are rounded down to the nearest integer value.
	*
	* @return {Vector2} A reference to this vector.
	*/
	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	}
	/**
	* The components of this vector are rounded up to the nearest integer value.
	*
	* @return {Vector2} A reference to this vector.
	*/
	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	}
	/**
	* The components of this vector are rounded to the nearest integer value
	*
	* @return {Vector2} A reference to this vector.
	*/
	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	}
	/**
	* The components of this vector are rounded towards zero (up if negative,
	* down if positive) to an integer value.
	*
	* @return {Vector2} A reference to this vector.
	*/
	roundToZero() {
		this.x = Math.trunc(this.x);
		this.y = Math.trunc(this.y);
		return this;
	}
	/**
	* Inverts this vector - i.e. sets x = -x and y = -y.
	*
	* @return {Vector2} A reference to this vector.
	*/
	negate() {
		this.x = -this.x;
		this.y = -this.y;
		return this;
	}
	/**
	* Calculates the dot product of the given vector with this instance.
	*
	* @param {Vector2} v - The vector to compute the dot product with.
	* @return {number} The result of the dot product.
	*/
	dot(v) {
		return this.x * v.x + this.y * v.y;
	}
	/**
	* Calculates the cross product of the given vector with this instance.
	*
	* @param {Vector2} v - The vector to compute the cross product with.
	* @return {number} The result of the cross product.
	*/
	cross(v) {
		return this.x * v.y - this.y * v.x;
	}
	/**
	* Computes the square of the Euclidean length (straight-line length) from
	* (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
	* compare the length squared instead as it is slightly more efficient to calculate.
	*
	* @return {number} The square length of this vector.
	*/
	lengthSq() {
		return this.x * this.x + this.y * this.y;
	}
	/**
	* Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
	*
	* @return {number} The length of this vector.
	*/
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	/**
	* Computes the Manhattan length of this vector.
	*
	* @return {number} The length of this vector.
	*/
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y);
	}
	/**
	* Converts this vector to a unit vector - that is, sets it equal to a vector
	* with the same direction as this one, but with a vector length of `1`.
	*
	* @return {Vector2} A reference to this vector.
	*/
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	/**
	* Computes the angle in radians of this vector with respect to the positive x-axis.
	*
	* @return {number} The angle in radians.
	*/
	angle() {
		return Math.atan2(-this.y, -this.x) + Math.PI;
	}
	/**
	* Returns the angle between the given vector and this instance in radians.
	*
	* @param {Vector2} v - The vector to compute the angle with.
	* @return {number} The angle in radians.
	*/
	angleTo(v) {
		const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
		if (denominator === 0) return Math.PI / 2;
		const theta = this.dot(v) / denominator;
		return Math.acos(clamp$3(theta, -1, 1));
	}
	/**
	* Computes the distance from the given vector to this instance.
	*
	* @param {Vector2} v - The vector to compute the distance to.
	* @return {number} The distance.
	*/
	distanceTo(v) {
		return Math.sqrt(this.distanceToSquared(v));
	}
	/**
	* Computes the squared distance from the given vector to this instance.
	* If you are just comparing the distance with another distance, you should compare
	* the distance squared instead as it is slightly more efficient to calculate.
	*
	* @param {Vector2} v - The vector to compute the squared distance to.
	* @return {number} The squared distance.
	*/
	distanceToSquared(v) {
		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;
	}
	/**
	* Computes the Manhattan distance from the given vector to this instance.
	*
	* @param {Vector2} v - The vector to compute the Manhattan distance to.
	* @return {number} The Manhattan distance.
	*/
	manhattanDistanceTo(v) {
		return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
	}
	/**
	* Sets this vector to a vector with the same direction as this one, but
	* with the specified length.
	*
	* @param {number} length - The new length of this vector.
	* @return {Vector2} A reference to this vector.
	*/
	setLength(length$2) {
		return this.normalize().multiplyScalar(length$2);
	}
	/**
	* Linearly interpolates between the given vector and this instance, where
	* alpha is the percent distance along the line - alpha = 0 will be this
	* vector, and alpha = 1 will be the given one.
	*
	* @param {Vector2} v - The vector to interpolate towards.
	* @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	* @return {Vector2} A reference to this vector.
	*/
	lerp(v, alpha) {
		this.x += (v.x - this.x) * alpha;
		this.y += (v.y - this.y) * alpha;
		return this;
	}
	/**
	* Linearly interpolates between the given vectors, where alpha is the percent
	* distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	* be the second one. The result is stored in this instance.
	*
	* @param {Vector2} v1 - The first vector.
	* @param {Vector2} v2 - The second vector.
	* @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	* @return {Vector2} A reference to this vector.
	*/
	lerpVectors(v1, v2, alpha) {
		this.x = v1.x + (v2.x - v1.x) * alpha;
		this.y = v1.y + (v2.y - v1.y) * alpha;
		return this;
	}
	/**
	* Returns `true` if this vector is equal with the given one.
	*
	* @param {Vector2} v - The vector to test for equality.
	* @return {boolean} Whether this vector is equal with the given one.
	*/
	equals(v) {
		return v.x === this.x && v.y === this.y;
	}
	/**
	* Sets this vector's x value to be `array[ offset ]` and y
	* value to be `array[ offset + 1 ]`.
	*
	* @param {Array<number>} array - An array holding the vector component values.
	* @param {number} [offset=0] - The offset into the array.
	* @return {Vector2} A reference to this vector.
	*/
	fromArray(array$2, offset = 0) {
		this.x = array$2[offset];
		this.y = array$2[offset + 1];
		return this;
	}
	/**
	* Writes the components of this vector to the given array. If no array is provided,
	* the method returns a new instance.
	*
	* @param {Array<number>} [array=[]] - The target array holding the vector components.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Array<number>} The vector components.
	*/
	toArray(array$2 = [], offset = 0) {
		array$2[offset] = this.x;
		array$2[offset + 1] = this.y;
		return array$2;
	}
	/**
	* Sets the components of this vector from the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	* @param {number} index - The index into the attribute.
	* @return {Vector2} A reference to this vector.
	*/
	fromBufferAttribute(attribute$2, index) {
		this.x = attribute$2.getX(index);
		this.y = attribute$2.getY(index);
		return this;
	}
	/**
	* Rotates this vector around the given center by the given angle.
	*
	* @param {Vector2} center - The point around which to rotate.
	* @param {number} angle - The angle to rotate, in radians.
	* @return {Vector2} A reference to this vector.
	*/
	rotateAround(center, angle) {
		const c$1 = Math.cos(angle), s = Math.sin(angle);
		const x = this.x - center.x;
		const y = this.y - center.y;
		this.x = x * c$1 - y * s + center.x;
		this.y = x * s + y * c$1 + center.y;
		return this;
	}
	/**
	* Sets each component of this vector to a pseudo-random value between `0` and
	* `1`, excluding `1`.
	*
	* @return {Vector2} A reference to this vector.
	*/
	random() {
		this.x = Math.random();
		this.y = Math.random();
		return this;
	}
	*[Symbol.iterator]() {
		yield this.x;
		yield this.y;
	}
};
/**
* Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.
*
* Iterating through a vector instance will yield its components `(x, y, z, w)` in
* the corresponding order.
*
* Note that three.js expects Quaternions to be normalized.
* ```js
* const quaternion = new THREE.Quaternion();
* quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
*
* const vector = new THREE.Vector3( 1, 0, 0 );
* vector.applyQuaternion( quaternion );
* ```
*/
var Quaternion = class {
	/**
	* Constructs a new quaternion.
	*
	* @param {number} [x=0] - The x value of this quaternion.
	* @param {number} [y=0] - The y value of this quaternion.
	* @param {number} [z=0] - The z value of this quaternion.
	* @param {number} [w=1] - The w value of this quaternion.
	*/
	constructor(x = 0, y = 0, z = 0, w = 1) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isQuaternion = true;
		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;
	}
	/**
	* Interpolates between two quaternions via SLERP. This implementation assumes the
	* quaternion data are managed in flat arrays.
	*
	* @param {Array<number>} dst - The destination array.
	* @param {number} dstOffset - An offset into the destination array.
	* @param {Array<number>} src0 - The source array of the first quaternion.
	* @param {number} srcOffset0 - An offset into the first source array.
	* @param {Array<number>} src1 -  The source array of the second quaternion.
	* @param {number} srcOffset1 - An offset into the second source array.
	* @param {number} t - The interpolation factor in the range `[0,1]`.
	* @see {@link Quaternion#slerp}
	*/
	static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
		let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0$1 = src0[srcOffset0 + 3];
		let x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1$1 = src1[srcOffset1 + 3];
		if (t <= 0) {
			dst[dstOffset + 0] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0$1;
			return;
		}
		if (t >= 1) {
			dst[dstOffset + 0] = x1;
			dst[dstOffset + 1] = y1;
			dst[dstOffset + 2] = z1;
			dst[dstOffset + 3] = w1$1;
			return;
		}
		if (w0$1 !== w1$1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
			let dot$2 = x0 * x1 + y0 * y1 + z0 * z1 + w0$1 * w1$1;
			if (dot$2 < 0) {
				x1 = -x1;
				y1 = -y1;
				z1 = -z1;
				w1$1 = -w1$1;
				dot$2 = -dot$2;
			}
			let s = 1 - t;
			if (dot$2 < .9995) {
				const theta = Math.acos(dot$2);
				const sin$2 = Math.sin(theta);
				s = Math.sin(s * theta) / sin$2;
				t = Math.sin(t * theta) / sin$2;
				x0 = x0 * s + x1 * t;
				y0 = y0 * s + y1 * t;
				z0 = z0 * s + z1 * t;
				w0$1 = w0$1 * s + w1$1 * t;
			} else {
				x0 = x0 * s + x1 * t;
				y0 = y0 * s + y1 * t;
				z0 = z0 * s + z1 * t;
				w0$1 = w0$1 * s + w1$1 * t;
				const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0$1 * w0$1);
				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0$1 *= f;
			}
		}
		dst[dstOffset] = x0;
		dst[dstOffset + 1] = y0;
		dst[dstOffset + 2] = z0;
		dst[dstOffset + 3] = w0$1;
	}
	/**
	* Multiplies two quaternions. This implementation assumes the quaternion data are managed
	* in flat arrays.
	*
	* @param {Array<number>} dst - The destination array.
	* @param {number} dstOffset - An offset into the destination array.
	* @param {Array<number>} src0 - The source array of the first quaternion.
	* @param {number} srcOffset0 - An offset into the first source array.
	* @param {Array<number>} src1 -  The source array of the second quaternion.
	* @param {number} srcOffset1 - An offset into the second source array.
	* @return {Array<number>} The destination array.
	* @see {@link Quaternion#multiplyQuaternions}.
	*/
	static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
		const x0 = src0[srcOffset0];
		const y0 = src0[srcOffset0 + 1];
		const z0 = src0[srcOffset0 + 2];
		const w0$1 = src0[srcOffset0 + 3];
		const x1 = src1[srcOffset1];
		const y1 = src1[srcOffset1 + 1];
		const z1 = src1[srcOffset1 + 2];
		const w1$1 = src1[srcOffset1 + 3];
		dst[dstOffset] = x0 * w1$1 + w0$1 * x1 + y0 * z1 - z0 * y1;
		dst[dstOffset + 1] = y0 * w1$1 + w0$1 * y1 + z0 * x1 - x0 * z1;
		dst[dstOffset + 2] = z0 * w1$1 + w0$1 * z1 + x0 * y1 - y0 * x1;
		dst[dstOffset + 3] = w0$1 * w1$1 - x0 * x1 - y0 * y1 - z0 * z1;
		return dst;
	}
	/**
	* The x value of this quaternion.
	*
	* @type {number}
	* @default 0
	*/
	get x() {
		return this._x;
	}
	set x(value) {
		this._x = value;
		this._onChangeCallback();
	}
	/**
	* The y value of this quaternion.
	*
	* @type {number}
	* @default 0
	*/
	get y() {
		return this._y;
	}
	set y(value) {
		this._y = value;
		this._onChangeCallback();
	}
	/**
	* The z value of this quaternion.
	*
	* @type {number}
	* @default 0
	*/
	get z() {
		return this._z;
	}
	set z(value) {
		this._z = value;
		this._onChangeCallback();
	}
	/**
	* The w value of this quaternion.
	*
	* @type {number}
	* @default 1
	*/
	get w() {
		return this._w;
	}
	set w(value) {
		this._w = value;
		this._onChangeCallback();
	}
	/**
	* Sets the quaternion components.
	*
	* @param {number} x - The x value of this quaternion.
	* @param {number} y - The y value of this quaternion.
	* @param {number} z - The z value of this quaternion.
	* @param {number} w - The w value of this quaternion.
	* @return {Quaternion} A reference to this quaternion.
	*/
	set(x, y, z, w) {
		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;
		this._onChangeCallback();
		return this;
	}
	/**
	* Returns a new quaternion with copied values from this instance.
	*
	* @return {Quaternion} A clone of this instance.
	*/
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._w);
	}
	/**
	* Copies the values of the given quaternion to this instance.
	*
	* @param {Quaternion} quaternion - The quaternion to copy.
	* @return {Quaternion} A reference to this quaternion.
	*/
	copy(quaternion) {
		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;
		this._onChangeCallback();
		return this;
	}
	/**
	* Sets this quaternion from the rotation specified by the given
	* Euler angles.
	*
	* @param {Euler} euler - The Euler angles.
	* @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	* @return {Quaternion} A reference to this quaternion.
	*/
	setFromEuler(euler, update = true) {
		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
		const cos$2 = Math.cos;
		const sin$2 = Math.sin;
		const c1$3 = cos$2(x / 2);
		const c2$3 = cos$2(y / 2);
		const c3$3 = cos$2(z / 2);
		const s1 = sin$2(x / 2);
		const s2 = sin$2(y / 2);
		const s3 = sin$2(z / 2);
		switch (order) {
			case "XYZ":
				this._x = s1 * c2$3 * c3$3 + c1$3 * s2 * s3;
				this._y = c1$3 * s2 * c3$3 - s1 * c2$3 * s3;
				this._z = c1$3 * c2$3 * s3 + s1 * s2 * c3$3;
				this._w = c1$3 * c2$3 * c3$3 - s1 * s2 * s3;
				break;
			case "YXZ":
				this._x = s1 * c2$3 * c3$3 + c1$3 * s2 * s3;
				this._y = c1$3 * s2 * c3$3 - s1 * c2$3 * s3;
				this._z = c1$3 * c2$3 * s3 - s1 * s2 * c3$3;
				this._w = c1$3 * c2$3 * c3$3 + s1 * s2 * s3;
				break;
			case "ZXY":
				this._x = s1 * c2$3 * c3$3 - c1$3 * s2 * s3;
				this._y = c1$3 * s2 * c3$3 + s1 * c2$3 * s3;
				this._z = c1$3 * c2$3 * s3 + s1 * s2 * c3$3;
				this._w = c1$3 * c2$3 * c3$3 - s1 * s2 * s3;
				break;
			case "ZYX":
				this._x = s1 * c2$3 * c3$3 - c1$3 * s2 * s3;
				this._y = c1$3 * s2 * c3$3 + s1 * c2$3 * s3;
				this._z = c1$3 * c2$3 * s3 - s1 * s2 * c3$3;
				this._w = c1$3 * c2$3 * c3$3 + s1 * s2 * s3;
				break;
			case "YZX":
				this._x = s1 * c2$3 * c3$3 + c1$3 * s2 * s3;
				this._y = c1$3 * s2 * c3$3 + s1 * c2$3 * s3;
				this._z = c1$3 * c2$3 * s3 - s1 * s2 * c3$3;
				this._w = c1$3 * c2$3 * c3$3 - s1 * s2 * s3;
				break;
			case "XZY":
				this._x = s1 * c2$3 * c3$3 - c1$3 * s2 * s3;
				this._y = c1$3 * s2 * c3$3 - s1 * c2$3 * s3;
				this._z = c1$3 * c2$3 * s3 + s1 * s2 * c3$3;
				this._w = c1$3 * c2$3 * c3$3 + s1 * s2 * s3;
				break;
			default: warn("Quaternion: .setFromEuler() encountered an unknown order: " + order);
		}
		if (update === true) this._onChangeCallback();
		return this;
	}
	/**
	* Sets this quaternion from the given axis and angle.
	*
	* @param {Vector3} axis - The normalized axis.
	* @param {number} angle - The angle in radians.
	* @return {Quaternion} A reference to this quaternion.
	*/
	setFromAxisAngle(axis, angle) {
		const halfAngle = angle / 2, s = Math.sin(halfAngle);
		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos(halfAngle);
		this._onChangeCallback();
		return this;
	}
	/**
	* Sets this quaternion from the given rotation matrix.
	*
	* @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
	* @return {Quaternion} A reference to this quaternion.
	*/
	setFromRotationMatrix(m$1) {
		const te = m$1.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
		if (trace > 0) {
			const s = .5 / Math.sqrt(trace + 1);
			this._w = .25 / s;
			this._x = (m32 - m23) * s;
			this._y = (m13 - m31) * s;
			this._z = (m21 - m12) * s;
		} else if (m11 > m22 && m11 > m33) {
			const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
			this._w = (m32 - m23) / s;
			this._x = .25 * s;
			this._y = (m12 + m21) / s;
			this._z = (m13 + m31) / s;
		} else if (m22 > m33) {
			const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
			this._w = (m13 - m31) / s;
			this._x = (m12 + m21) / s;
			this._y = .25 * s;
			this._z = (m23 + m32) / s;
		} else {
			const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
			this._w = (m21 - m12) / s;
			this._x = (m13 + m31) / s;
			this._y = (m23 + m32) / s;
			this._z = .25 * s;
		}
		this._onChangeCallback();
		return this;
	}
	/**
	* Sets this quaternion to the rotation required to rotate the direction vector
	* `vFrom` to the direction vector `vTo`.
	*
	* @param {Vector3} vFrom - The first (normalized) direction vector.
	* @param {Vector3} vTo - The second (normalized) direction vector.
	* @return {Quaternion} A reference to this quaternion.
	*/
	setFromUnitVectors(vFrom, vTo) {
		let r = vFrom.dot(vTo) + 1;
		if (r < 1e-8) {
			r = 0;
			if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
				this._x = -vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;
			} else {
				this._x = 0;
				this._y = -vFrom.z;
				this._z = vFrom.y;
				this._w = r;
			}
		} else {
			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;
		}
		return this.normalize();
	}
	/**
	* Returns the angle between this quaternion and the given one in radians.
	*
	* @param {Quaternion} q - The quaternion to compute the angle with.
	* @return {number} The angle in radians.
	*/
	angleTo(q) {
		return 2 * Math.acos(Math.abs(clamp$3(this.dot(q), -1, 1)));
	}
	/**
	* Rotates this quaternion by a given angular step to the given quaternion.
	* The method ensures that the final quaternion will not overshoot `q`.
	*
	* @param {Quaternion} q - The target quaternion.
	* @param {number} step - The angular step in radians.
	* @return {Quaternion} A reference to this quaternion.
	*/
	rotateTowards(q, step$2) {
		const angle = this.angleTo(q);
		if (angle === 0) return this;
		const t = Math.min(1, step$2 / angle);
		this.slerp(q, t);
		return this;
	}
	/**
	* Sets this quaternion to the identity quaternion; that is, to the
	* quaternion that represents "no rotation".
	*
	* @return {Quaternion} A reference to this quaternion.
	*/
	identity() {
		return this.set(0, 0, 0, 1);
	}
	/**
	* Inverts this quaternion via {@link Quaternion#conjugate}. The
	* quaternion is assumed to have unit length.
	*
	* @return {Quaternion} A reference to this quaternion.
	*/
	invert() {
		return this.conjugate();
	}
	/**
	* Returns the rotational conjugate of this quaternion. The conjugate of a
	* quaternion represents the same rotation in the opposite direction about
	* the rotational axis.
	*
	* @return {Quaternion} A reference to this quaternion.
	*/
	conjugate() {
		this._x *= -1;
		this._y *= -1;
		this._z *= -1;
		this._onChangeCallback();
		return this;
	}
	/**
	* Calculates the dot product of this quaternion and the given one.
	*
	* @param {Quaternion} v - The quaternion to compute the dot product with.
	* @return {number} The result of the dot product.
	*/
	dot(v) {
		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	}
	/**
	* Computes the squared Euclidean length (straight-line length) of this quaternion,
	* considered as a 4 dimensional vector. This can be useful if you are comparing the
	* lengths of two quaternions, as this is a slightly more efficient calculation than
	* {@link Quaternion#length}.
	*
	* @return {number} The squared Euclidean length.
	*/
	lengthSq() {
		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	}
	/**
	* Computes the Euclidean length (straight-line length) of this quaternion,
	* considered as a 4 dimensional vector.
	*
	* @return {number} The Euclidean length.
	*/
	length() {
		return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
	}
	/**
	* Normalizes this quaternion - that is, calculated the quaternion that performs
	* the same rotation as this one, but has a length equal to `1`.
	*
	* @return {Quaternion} A reference to this quaternion.
	*/
	normalize() {
		let l = this.length();
		if (l === 0) {
			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;
		} else {
			l = 1 / l;
			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;
		}
		this._onChangeCallback();
		return this;
	}
	/**
	* Multiplies this quaternion by the given one.
	*
	* @param {Quaternion} q - The quaternion.
	* @return {Quaternion} A reference to this quaternion.
	*/
	multiply(q) {
		return this.multiplyQuaternions(this, q);
	}
	/**
	* Pre-multiplies this quaternion by the given one.
	*
	* @param {Quaternion} q - The quaternion.
	* @return {Quaternion} A reference to this quaternion.
	*/
	premultiply(q) {
		return this.multiplyQuaternions(q, this);
	}
	/**
	* Multiplies the given quaternions and stores the result in this instance.
	*
	* @param {Quaternion} a - The first quaternion.
	* @param {Quaternion} b - The second quaternion.
	* @return {Quaternion} A reference to this quaternion.
	*/
	multiplyQuaternions(a$1, b$2) {
		const qax = a$1._x, qay = a$1._y, qaz = a$1._z, qaw = a$1._w;
		const qbx = b$2._x, qby = b$2._y, qbz = b$2._z, qbw = b$2._w;
		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
		this._onChangeCallback();
		return this;
	}
	/**
	* Performs a spherical linear interpolation between quaternions.
	*
	* @param {Quaternion} qb - The target quaternion.
	* @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	* @return {Quaternion} A reference to this quaternion.
	*/
	slerp(qb, t) {
		if (t <= 0) return this;
		if (t >= 1) return this.copy(qb);
		let x = qb._x, y = qb._y, z = qb._z, w = qb._w;
		let dot$2 = this.dot(qb);
		if (dot$2 < 0) {
			x = -x;
			y = -y;
			z = -z;
			w = -w;
			dot$2 = -dot$2;
		}
		let s = 1 - t;
		if (dot$2 < .9995) {
			const theta = Math.acos(dot$2);
			const sin$2 = Math.sin(theta);
			s = Math.sin(s * theta) / sin$2;
			t = Math.sin(t * theta) / sin$2;
			this._x = this._x * s + x * t;
			this._y = this._y * s + y * t;
			this._z = this._z * s + z * t;
			this._w = this._w * s + w * t;
			this._onChangeCallback();
		} else {
			this._x = this._x * s + x * t;
			this._y = this._y * s + y * t;
			this._z = this._z * s + z * t;
			this._w = this._w * s + w * t;
			this.normalize();
		}
		return this;
	}
	/**
	* Performs a spherical linear interpolation between the given quaternions
	* and stores the result in this quaternion.
	*
	* @param {Quaternion} qa - The source quaternion.
	* @param {Quaternion} qb - The target quaternion.
	* @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	* @return {Quaternion} A reference to this quaternion.
	*/
	slerpQuaternions(qa, qb, t) {
		return this.copy(qa).slerp(qb, t);
	}
	/**
	* Sets this quaternion to a uniformly random, normalized quaternion.
	*
	* @return {Quaternion} A reference to this quaternion.
	*/
	random() {
		const theta1 = 2 * Math.PI * Math.random();
		const theta2 = 2 * Math.PI * Math.random();
		const x0 = Math.random();
		const r1 = Math.sqrt(1 - x0);
		const r2 = Math.sqrt(x0);
		return this.set(r1 * Math.sin(theta1), r1 * Math.cos(theta1), r2 * Math.sin(theta2), r2 * Math.cos(theta2));
	}
	/**
	* Returns `true` if this quaternion is equal with the given one.
	*
	* @param {Quaternion} quaternion - The quaternion to test for equality.
	* @return {boolean} Whether this quaternion is equal with the given one.
	*/
	equals(quaternion) {
		return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
	}
	/**
	* Sets this quaternion's components from the given array.
	*
	* @param {Array<number>} array - An array holding the quaternion component values.
	* @param {number} [offset=0] - The offset into the array.
	* @return {Quaternion} A reference to this quaternion.
	*/
	fromArray(array$2, offset = 0) {
		this._x = array$2[offset];
		this._y = array$2[offset + 1];
		this._z = array$2[offset + 2];
		this._w = array$2[offset + 3];
		this._onChangeCallback();
		return this;
	}
	/**
	* Writes the components of this quaternion to the given array. If no array is provided,
	* the method returns a new instance.
	*
	* @param {Array<number>} [array=[]] - The target array holding the quaternion components.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Array<number>} The quaternion components.
	*/
	toArray(array$2 = [], offset = 0) {
		array$2[offset] = this._x;
		array$2[offset + 1] = this._y;
		array$2[offset + 2] = this._z;
		array$2[offset + 3] = this._w;
		return array$2;
	}
	/**
	* Sets the components of this quaternion from the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
	* @param {number} index - The index into the attribute.
	* @return {Quaternion} A reference to this quaternion.
	*/
	fromBufferAttribute(attribute$2, index) {
		this._x = attribute$2.getX(index);
		this._y = attribute$2.getY(index);
		this._z = attribute$2.getZ(index);
		this._w = attribute$2.getW(index);
		this._onChangeCallback();
		return this;
	}
	/**
	* This methods defines the serialization result of this class. Returns the
	* numerical elements of this quaternion in an array of format `[x, y, z, w]`.
	*
	* @return {Array<number>} The serialized quaternion.
	*/
	toJSON() {
		return this.toArray();
	}
	_onChange(callback) {
		this._onChangeCallback = callback;
		return this;
	}
	_onChangeCallback() {}
	*[Symbol.iterator]() {
		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;
	}
};
/**
* Class representing a 3D vector. A 3D vector is an ordered triplet of numbers
* (labeled x, y and z), which can be used to represent a number of things, such as:
*
* - A point in 3D space.
* - A direction and length in 3D space. In three.js the length will
* always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`
* and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.
* - Any arbitrary ordered triplet of numbers.
*
* There are other things a 3D vector can be used to represent, such as
* momentum vectors and so on, however these are the most
* common uses in three.js.
*
* Iterating through a vector instance will yield its components `(x, y, z)` in
* the corresponding order.
* ```js
* const a = new THREE.Vector3( 0, 1, 0 );
*
* //no arguments; will be initialised to (0, 0, 0)
* const b = new THREE.Vector3( );
*
* const d = a.distanceTo( b );
* ```
*/
var Vector3 = class Vector3 {
	/**
	* Constructs a new 3D vector.
	*
	* @param {number} [x=0] - The x value of this vector.
	* @param {number} [y=0] - The y value of this vector.
	* @param {number} [z=0] - The z value of this vector.
	*/
	constructor(x = 0, y = 0, z = 0) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		Vector3.prototype.isVector3 = true;
		/**
		* The x value of this vector.
		*
		* @type {number}
		*/
		this.x = x;
		/**
		* The y value of this vector.
		*
		* @type {number}
		*/
		this.y = y;
		/**
		* The z value of this vector.
		*
		* @type {number}
		*/
		this.z = z;
	}
	/**
	* Sets the vector components.
	*
	* @param {number} x - The value of the x component.
	* @param {number} y - The value of the y component.
	* @param {number} z - The value of the z component.
	* @return {Vector3} A reference to this vector.
	*/
	set(x, y, z) {
		if (z === void 0) z = this.z;
		this.x = x;
		this.y = y;
		this.z = z;
		return this;
	}
	/**
	* Sets the vector components to the same value.
	*
	* @param {number} scalar - The value to set for all vector components.
	* @return {Vector3} A reference to this vector.
	*/
	setScalar(scalar) {
		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		return this;
	}
	/**
	* Sets the vector's x component to the given value
	*
	* @param {number} x - The value to set.
	* @return {Vector3} A reference to this vector.
	*/
	setX(x) {
		this.x = x;
		return this;
	}
	/**
	* Sets the vector's y component to the given value
	*
	* @param {number} y - The value to set.
	* @return {Vector3} A reference to this vector.
	*/
	setY(y) {
		this.y = y;
		return this;
	}
	/**
	* Sets the vector's z component to the given value
	*
	* @param {number} z - The value to set.
	* @return {Vector3} A reference to this vector.
	*/
	setZ(z) {
		this.z = z;
		return this;
	}
	/**
	* Allows to set a vector component with an index.
	*
	* @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
	* @param {number} value - The value to set.
	* @return {Vector3} A reference to this vector.
	*/
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			case 2:
				this.z = value;
				break;
			default: throw new Error("index is out of range: " + index);
		}
		return this;
	}
	/**
	* Returns the value of the vector component which matches the given index.
	*
	* @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
	* @return {number} A vector component value.
	*/
	getComponent(index) {
		switch (index) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error("index is out of range: " + index);
		}
	}
	/**
	* Returns a new vector with copied values from this instance.
	*
	* @return {Vector3} A clone of this instance.
	*/
	clone() {
		return new this.constructor(this.x, this.y, this.z);
	}
	/**
	* Copies the values of the given vector to this instance.
	*
	* @param {Vector3} v - The vector to copy.
	* @return {Vector3} A reference to this vector.
	*/
	copy(v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		return this;
	}
	/**
	* Adds the given vector to this instance.
	*
	* @param {Vector3} v - The vector to add.
	* @return {Vector3} A reference to this vector.
	*/
	add(v) {
		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		return this;
	}
	/**
	* Adds the given scalar value to all components of this instance.
	*
	* @param {number} s - The scalar to add.
	* @return {Vector3} A reference to this vector.
	*/
	addScalar(s) {
		this.x += s;
		this.y += s;
		this.z += s;
		return this;
	}
	/**
	* Adds the given vectors and stores the result in this instance.
	*
	* @param {Vector3} a - The first vector.
	* @param {Vector3} b - The second vector.
	* @return {Vector3} A reference to this vector.
	*/
	addVectors(a$1, b$2) {
		this.x = a$1.x + b$2.x;
		this.y = a$1.y + b$2.y;
		this.z = a$1.z + b$2.z;
		return this;
	}
	/**
	* Adds the given vector scaled by the given factor to this instance.
	*
	* @param {Vector3|Vector4} v - The vector.
	* @param {number} s - The factor that scales `v`.
	* @return {Vector3} A reference to this vector.
	*/
	addScaledVector(v, s) {
		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		return this;
	}
	/**
	* Subtracts the given vector from this instance.
	*
	* @param {Vector3} v - The vector to subtract.
	* @return {Vector3} A reference to this vector.
	*/
	sub(v) {
		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		return this;
	}
	/**
	* Subtracts the given scalar value from all components of this instance.
	*
	* @param {number} s - The scalar to subtract.
	* @return {Vector3} A reference to this vector.
	*/
	subScalar(s) {
		this.x -= s;
		this.y -= s;
		this.z -= s;
		return this;
	}
	/**
	* Subtracts the given vectors and stores the result in this instance.
	*
	* @param {Vector3} a - The first vector.
	* @param {Vector3} b - The second vector.
	* @return {Vector3} A reference to this vector.
	*/
	subVectors(a$1, b$2) {
		this.x = a$1.x - b$2.x;
		this.y = a$1.y - b$2.y;
		this.z = a$1.z - b$2.z;
		return this;
	}
	/**
	* Multiplies the given vector with this instance.
	*
	* @param {Vector3} v - The vector to multiply.
	* @return {Vector3} A reference to this vector.
	*/
	multiply(v) {
		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		return this;
	}
	/**
	* Multiplies the given scalar value with all components of this instance.
	*
	* @param {number} scalar - The scalar to multiply.
	* @return {Vector3} A reference to this vector.
	*/
	multiplyScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		return this;
	}
	/**
	* Multiplies the given vectors and stores the result in this instance.
	*
	* @param {Vector3} a - The first vector.
	* @param {Vector3} b - The second vector.
	* @return {Vector3} A reference to this vector.
	*/
	multiplyVectors(a$1, b$2) {
		this.x = a$1.x * b$2.x;
		this.y = a$1.y * b$2.y;
		this.z = a$1.z * b$2.z;
		return this;
	}
	/**
	* Applies the given Euler rotation to this vector.
	*
	* @param {Euler} euler - The Euler angles.
	* @return {Vector3} A reference to this vector.
	*/
	applyEuler(euler) {
		return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
	}
	/**
	* Applies a rotation specified by an axis and an angle to this vector.
	*
	* @param {Vector3} axis - A normalized vector representing the rotation axis.
	* @param {number} angle - The angle in radians.
	* @return {Vector3} A reference to this vector.
	*/
	applyAxisAngle(axis, angle) {
		return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
	}
	/**
	* Multiplies this vector with the given 3x3 matrix.
	*
	* @param {Matrix3} m - The 3x3 matrix.
	* @return {Vector3} A reference to this vector.
	*/
	applyMatrix3(m$1) {
		const x = this.x, y = this.y, z = this.z;
		const e = m$1.elements;
		this.x = e[0] * x + e[3] * y + e[6] * z;
		this.y = e[1] * x + e[4] * y + e[7] * z;
		this.z = e[2] * x + e[5] * y + e[8] * z;
		return this;
	}
	/**
	* Multiplies this vector by the given normal matrix and normalizes
	* the result.
	*
	* @param {Matrix3} m - The normal matrix.
	* @return {Vector3} A reference to this vector.
	*/
	applyNormalMatrix(m$1) {
		return this.applyMatrix3(m$1).normalize();
	}
	/**
	* Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
	* divides by perspective.
	*
	* @param {Matrix4} m - The matrix to apply.
	* @return {Vector3} A reference to this vector.
	*/
	applyMatrix4(m$1) {
		const x = this.x, y = this.y, z = this.z;
		const e = m$1.elements;
		const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
		this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
		this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
		this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
		return this;
	}
	/**
	* Applies the given Quaternion to this vector.
	*
	* @param {Quaternion} q - The Quaternion.
	* @return {Vector3} A reference to this vector.
	*/
	applyQuaternion(q) {
		const vx = this.x, vy = this.y, vz = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
		const tx = 2 * (qy * vz - qz * vy);
		const ty = 2 * (qz * vx - qx * vz);
		const tz = 2 * (qx * vy - qy * vx);
		this.x = vx + qw * tx + qy * tz - qz * ty;
		this.y = vy + qw * ty + qz * tx - qx * tz;
		this.z = vz + qw * tz + qx * ty - qy * tx;
		return this;
	}
	/**
	* Projects this vector from world space into the camera's normalized
	* device coordinate (NDC) space.
	*
	* @param {Camera} camera - The camera.
	* @return {Vector3} A reference to this vector.
	*/
	project(camera) {
		return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
	}
	/**
	* Unprojects this vector from the camera's normalized device coordinate (NDC)
	* space into world space.
	*
	* @param {Camera} camera - The camera.
	* @return {Vector3} A reference to this vector.
	*/
	unproject(camera) {
		return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
	}
	/**
	* Transforms the direction of this vector by a matrix (the upper left 3 x 3
	* subset of the given 4x4 matrix and then normalizes the result.
	*
	* @param {Matrix4} m - The matrix.
	* @return {Vector3} A reference to this vector.
	*/
	transformDirection(m$1) {
		const x = this.x, y = this.y, z = this.z;
		const e = m$1.elements;
		this.x = e[0] * x + e[4] * y + e[8] * z;
		this.y = e[1] * x + e[5] * y + e[9] * z;
		this.z = e[2] * x + e[6] * y + e[10] * z;
		return this.normalize();
	}
	/**
	* Divides this instance by the given vector.
	*
	* @param {Vector3} v - The vector to divide.
	* @return {Vector3} A reference to this vector.
	*/
	divide(v) {
		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;
		return this;
	}
	/**
	* Divides this vector by the given scalar.
	*
	* @param {number} scalar - The scalar to divide.
	* @return {Vector3} A reference to this vector.
	*/
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar);
	}
	/**
	* If this vector's x, y or z value is greater than the given vector's x, y or z
	* value, replace that value with the corresponding min value.
	*
	* @param {Vector3} v - The vector.
	* @return {Vector3} A reference to this vector.
	*/
	min(v) {
		this.x = Math.min(this.x, v.x);
		this.y = Math.min(this.y, v.y);
		this.z = Math.min(this.z, v.z);
		return this;
	}
	/**
	* If this vector's x, y or z value is less than the given vector's x, y or z
	* value, replace that value with the corresponding max value.
	*
	* @param {Vector3} v - The vector.
	* @return {Vector3} A reference to this vector.
	*/
	max(v) {
		this.x = Math.max(this.x, v.x);
		this.y = Math.max(this.y, v.y);
		this.z = Math.max(this.z, v.z);
		return this;
	}
	/**
	* If this vector's x, y or z value is greater than the max vector's x, y or z
	* value, it is replaced by the corresponding value.
	* If this vector's x, y or z value is less than the min vector's x, y or z value,
	* it is replaced by the corresponding value.
	*
	* @param {Vector3} min - The minimum x, y and z values.
	* @param {Vector3} max - The maximum x, y and z values in the desired range.
	* @return {Vector3} A reference to this vector.
	*/
	clamp(min$3, max$3) {
		this.x = clamp$3(this.x, min$3.x, max$3.x);
		this.y = clamp$3(this.y, min$3.y, max$3.y);
		this.z = clamp$3(this.z, min$3.z, max$3.z);
		return this;
	}
	/**
	* If this vector's x, y or z values are greater than the max value, they are
	* replaced by the max value.
	* If this vector's x, y or z values are less than the min value, they are
	* replaced by the min value.
	*
	* @param {number} minVal - The minimum value the components will be clamped to.
	* @param {number} maxVal - The maximum value the components will be clamped to.
	* @return {Vector3} A reference to this vector.
	*/
	clampScalar(minVal, maxVal) {
		this.x = clamp$3(this.x, minVal, maxVal);
		this.y = clamp$3(this.y, minVal, maxVal);
		this.z = clamp$3(this.z, minVal, maxVal);
		return this;
	}
	/**
	* If this vector's length is greater than the max value, it is replaced by
	* the max value.
	* If this vector's length is less than the min value, it is replaced by the
	* min value.
	*
	* @param {number} min - The minimum value the vector length will be clamped to.
	* @param {number} max - The maximum value the vector length will be clamped to.
	* @return {Vector3} A reference to this vector.
	*/
	clampLength(min$3, max$3) {
		const length$2 = this.length();
		return this.divideScalar(length$2 || 1).multiplyScalar(clamp$3(length$2, min$3, max$3));
	}
	/**
	* The components of this vector are rounded down to the nearest integer value.
	*
	* @return {Vector3} A reference to this vector.
	*/
	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		return this;
	}
	/**
	* The components of this vector are rounded up to the nearest integer value.
	*
	* @return {Vector3} A reference to this vector.
	*/
	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		return this;
	}
	/**
	* The components of this vector are rounded to the nearest integer value
	*
	* @return {Vector3} A reference to this vector.
	*/
	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		return this;
	}
	/**
	* The components of this vector are rounded towards zero (up if negative,
	* down if positive) to an integer value.
	*
	* @return {Vector3} A reference to this vector.
	*/
	roundToZero() {
		this.x = Math.trunc(this.x);
		this.y = Math.trunc(this.y);
		this.z = Math.trunc(this.z);
		return this;
	}
	/**
	* Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
	*
	* @return {Vector3} A reference to this vector.
	*/
	negate() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		return this;
	}
	/**
	* Calculates the dot product of the given vector with this instance.
	*
	* @param {Vector3} v - The vector to compute the dot product with.
	* @return {number} The result of the dot product.
	*/
	dot(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z;
	}
	/**
	* Computes the square of the Euclidean length (straight-line length) from
	* (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
	* compare the length squared instead as it is slightly more efficient to calculate.
	*
	* @return {number} The square length of this vector.
	*/
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
	/**
	* Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
	*
	* @return {number} The length of this vector.
	*/
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	/**
	* Computes the Manhattan length of this vector.
	*
	* @return {number} The length of this vector.
	*/
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	}
	/**
	* Converts this vector to a unit vector - that is, sets it equal to a vector
	* with the same direction as this one, but with a vector length of `1`.
	*
	* @return {Vector3} A reference to this vector.
	*/
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	/**
	* Sets this vector to a vector with the same direction as this one, but
	* with the specified length.
	*
	* @param {number} length - The new length of this vector.
	* @return {Vector3} A reference to this vector.
	*/
	setLength(length$2) {
		return this.normalize().multiplyScalar(length$2);
	}
	/**
	* Linearly interpolates between the given vector and this instance, where
	* alpha is the percent distance along the line - alpha = 0 will be this
	* vector, and alpha = 1 will be the given one.
	*
	* @param {Vector3} v - The vector to interpolate towards.
	* @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	* @return {Vector3} A reference to this vector.
	*/
	lerp(v, alpha) {
		this.x += (v.x - this.x) * alpha;
		this.y += (v.y - this.y) * alpha;
		this.z += (v.z - this.z) * alpha;
		return this;
	}
	/**
	* Linearly interpolates between the given vectors, where alpha is the percent
	* distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	* be the second one. The result is stored in this instance.
	*
	* @param {Vector3} v1 - The first vector.
	* @param {Vector3} v2 - The second vector.
	* @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	* @return {Vector3} A reference to this vector.
	*/
	lerpVectors(v1, v2, alpha) {
		this.x = v1.x + (v2.x - v1.x) * alpha;
		this.y = v1.y + (v2.y - v1.y) * alpha;
		this.z = v1.z + (v2.z - v1.z) * alpha;
		return this;
	}
	/**
	* Calculates the cross product of the given vector with this instance.
	*
	* @param {Vector3} v - The vector to compute the cross product with.
	* @return {Vector3} The result of the cross product.
	*/
	cross(v) {
		return this.crossVectors(this, v);
	}
	/**
	* Calculates the cross product of the given vectors and stores the result
	* in this instance.
	*
	* @param {Vector3} a - The first vector.
	* @param {Vector3} b - The second vector.
	* @return {Vector3} A reference to this vector.
	*/
	crossVectors(a$1, b$2) {
		const ax = a$1.x, ay = a$1.y, az = a$1.z;
		const bx = b$2.x, by = b$2.y, bz = b$2.z;
		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;
		return this;
	}
	/**
	* Projects this vector onto the given one.
	*
	* @param {Vector3} v - The vector to project to.
	* @return {Vector3} A reference to this vector.
	*/
	projectOnVector(v) {
		const denominator = v.lengthSq();
		if (denominator === 0) return this.set(0, 0, 0);
		const scalar = v.dot(this) / denominator;
		return this.copy(v).multiplyScalar(scalar);
	}
	/**
	* Projects this vector onto a plane by subtracting this
	* vector projected onto the plane's normal from this vector.
	*
	* @param {Vector3} planeNormal - The plane normal.
	* @return {Vector3} A reference to this vector.
	*/
	projectOnPlane(planeNormal) {
		_vector$c.copy(this).projectOnVector(planeNormal);
		return this.sub(_vector$c);
	}
	/**
	* Reflects this vector off a plane orthogonal to the given normal vector.
	*
	* @param {Vector3} normal - The (normalized) normal vector.
	* @return {Vector3} A reference to this vector.
	*/
	reflect(normal$1) {
		return this.sub(_vector$c.copy(normal$1).multiplyScalar(2 * this.dot(normal$1)));
	}
	/**
	* Returns the angle between the given vector and this instance in radians.
	*
	* @param {Vector3} v - The vector to compute the angle with.
	* @return {number} The angle in radians.
	*/
	angleTo(v) {
		const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
		if (denominator === 0) return Math.PI / 2;
		const theta = this.dot(v) / denominator;
		return Math.acos(clamp$3(theta, -1, 1));
	}
	/**
	* Computes the distance from the given vector to this instance.
	*
	* @param {Vector3} v - The vector to compute the distance to.
	* @return {number} The distance.
	*/
	distanceTo(v) {
		return Math.sqrt(this.distanceToSquared(v));
	}
	/**
	* Computes the squared distance from the given vector to this instance.
	* If you are just comparing the distance with another distance, you should compare
	* the distance squared instead as it is slightly more efficient to calculate.
	*
	* @param {Vector3} v - The vector to compute the squared distance to.
	* @return {number} The squared distance.
	*/
	distanceToSquared(v) {
		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
		return dx * dx + dy * dy + dz * dz;
	}
	/**
	* Computes the Manhattan distance from the given vector to this instance.
	*
	* @param {Vector3} v - The vector to compute the Manhattan distance to.
	* @return {number} The Manhattan distance.
	*/
	manhattanDistanceTo(v) {
		return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
	}
	/**
	* Sets the vector components from the given spherical coordinates.
	*
	* @param {Spherical} s - The spherical coordinates.
	* @return {Vector3} A reference to this vector.
	*/
	setFromSpherical(s) {
		return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
	}
	/**
	* Sets the vector components from the given spherical coordinates.
	*
	* @param {number} radius - The radius.
	* @param {number} phi - The phi angle in radians.
	* @param {number} theta - The theta angle in radians.
	* @return {Vector3} A reference to this vector.
	*/
	setFromSphericalCoords(radius, phi$1, theta) {
		const sinPhiRadius = Math.sin(phi$1) * radius;
		this.x = sinPhiRadius * Math.sin(theta);
		this.y = Math.cos(phi$1) * radius;
		this.z = sinPhiRadius * Math.cos(theta);
		return this;
	}
	/**
	* Sets the vector components from the given cylindrical coordinates.
	*
	* @param {Cylindrical} c - The cylindrical coordinates.
	* @return {Vector3} A reference to this vector.
	*/
	setFromCylindrical(c$1) {
		return this.setFromCylindricalCoords(c$1.radius, c$1.theta, c$1.y);
	}
	/**
	* Sets the vector components from the given cylindrical coordinates.
	*
	* @param {number} radius - The radius.
	* @param {number} theta - The theta angle in radians.
	* @param {number} y - The y value.
	* @return {Vector3} A reference to this vector.
	*/
	setFromCylindricalCoords(radius, theta, y) {
		this.x = radius * Math.sin(theta);
		this.y = y;
		this.z = radius * Math.cos(theta);
		return this;
	}
	/**
	* Sets the vector components to the position elements of the
	* given transformation matrix.
	*
	* @param {Matrix4} m - The 4x4 matrix.
	* @return {Vector3} A reference to this vector.
	*/
	setFromMatrixPosition(m$1) {
		const e = m$1.elements;
		this.x = e[12];
		this.y = e[13];
		this.z = e[14];
		return this;
	}
	/**
	* Sets the vector components to the scale elements of the
	* given transformation matrix.
	*
	* @param {Matrix4} m - The 4x4 matrix.
	* @return {Vector3} A reference to this vector.
	*/
	setFromMatrixScale(m$1) {
		const sx = this.setFromMatrixColumn(m$1, 0).length();
		const sy = this.setFromMatrixColumn(m$1, 1).length();
		const sz = this.setFromMatrixColumn(m$1, 2).length();
		this.x = sx;
		this.y = sy;
		this.z = sz;
		return this;
	}
	/**
	* Sets the vector components from the specified matrix column.
	*
	* @param {Matrix4} m - The 4x4 matrix.
	* @param {number} index - The column index.
	* @return {Vector3} A reference to this vector.
	*/
	setFromMatrixColumn(m$1, index) {
		return this.fromArray(m$1.elements, index * 4);
	}
	/**
	* Sets the vector components from the specified matrix column.
	*
	* @param {Matrix3} m - The 3x3 matrix.
	* @param {number} index - The column index.
	* @return {Vector3} A reference to this vector.
	*/
	setFromMatrix3Column(m$1, index) {
		return this.fromArray(m$1.elements, index * 3);
	}
	/**
	* Sets the vector components from the given Euler angles.
	*
	* @param {Euler} e - The Euler angles to set.
	* @return {Vector3} A reference to this vector.
	*/
	setFromEuler(e) {
		this.x = e._x;
		this.y = e._y;
		this.z = e._z;
		return this;
	}
	/**
	* Sets the vector components from the RGB components of the
	* given color.
	*
	* @param {Color} c - The color to set.
	* @return {Vector3} A reference to this vector.
	*/
	setFromColor(c$1) {
		this.x = c$1.r;
		this.y = c$1.g;
		this.z = c$1.b;
		return this;
	}
	/**
	* Returns `true` if this vector is equal with the given one.
	*
	* @param {Vector3} v - The vector to test for equality.
	* @return {boolean} Whether this vector is equal with the given one.
	*/
	equals(v) {
		return v.x === this.x && v.y === this.y && v.z === this.z;
	}
	/**
	* Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
	* and z value to be `array[ offset + 2 ]`.
	*
	* @param {Array<number>} array - An array holding the vector component values.
	* @param {number} [offset=0] - The offset into the array.
	* @return {Vector3} A reference to this vector.
	*/
	fromArray(array$2, offset = 0) {
		this.x = array$2[offset];
		this.y = array$2[offset + 1];
		this.z = array$2[offset + 2];
		return this;
	}
	/**
	* Writes the components of this vector to the given array. If no array is provided,
	* the method returns a new instance.
	*
	* @param {Array<number>} [array=[]] - The target array holding the vector components.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Array<number>} The vector components.
	*/
	toArray(array$2 = [], offset = 0) {
		array$2[offset] = this.x;
		array$2[offset + 1] = this.y;
		array$2[offset + 2] = this.z;
		return array$2;
	}
	/**
	* Sets the components of this vector from the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	* @param {number} index - The index into the attribute.
	* @return {Vector3} A reference to this vector.
	*/
	fromBufferAttribute(attribute$2, index) {
		this.x = attribute$2.getX(index);
		this.y = attribute$2.getY(index);
		this.z = attribute$2.getZ(index);
		return this;
	}
	/**
	* Sets each component of this vector to a pseudo-random value between `0` and
	* `1`, excluding `1`.
	*
	* @return {Vector3} A reference to this vector.
	*/
	random() {
		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		return this;
	}
	/**
	* Sets this vector to a uniformly random point on a unit sphere.
	*
	* @return {Vector3} A reference to this vector.
	*/
	randomDirection() {
		const theta = Math.random() * Math.PI * 2;
		const u = Math.random() * 2 - 1;
		const c$1 = Math.sqrt(1 - u * u);
		this.x = c$1 * Math.cos(theta);
		this.y = u;
		this.z = c$1 * Math.sin(theta);
		return this;
	}
	*[Symbol.iterator]() {
		yield this.x;
		yield this.y;
		yield this.z;
	}
};
var _vector$c = /* @__PURE__ */ new Vector3();
var _quaternion$4 = /* @__PURE__ */ new Quaternion();
/**
* Represents a 3x3 matrix.
*
* A Note on Row-Major and Column-Major Ordering:
*
* The constructor and {@link Matrix3#set} method take arguments in
* [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
* order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
* This means that calling:
* ```js
* const m = new THREE.Matrix();
* m.set( 11, 12, 13,
*        21, 22, 23,
*        31, 32, 33 );
* ```
* will result in the elements array containing:
* ```js
* m.elements = [ 11, 21, 31,
*                12, 22, 32,
*                13, 23, 33 ];
* ```
* and internally all calculations are performed using column-major ordering.
* However, as the actual ordering makes no difference mathematically and
* most people are used to thinking about matrices in row-major order, the
* three.js documentation shows matrices in row-major order. Just bear in
* mind that if you are reading the source code, you'll have to take the
* transpose of any matrices outlined here to make sense of the calculations.
*/
var Matrix3 = class Matrix3 {
	/**
	* Constructs a new 3x3 matrix. The arguments are supposed to be
	* in row-major order. If no arguments are provided, the constructor
	* initializes the matrix as an identity matrix.
	*
	* @param {number} [n11] - 1-1 matrix element.
	* @param {number} [n12] - 1-2 matrix element.
	* @param {number} [n13] - 1-3 matrix element.
	* @param {number} [n21] - 2-1 matrix element.
	* @param {number} [n22] - 2-2 matrix element.
	* @param {number} [n23] - 2-3 matrix element.
	* @param {number} [n31] - 3-1 matrix element.
	* @param {number} [n32] - 3-2 matrix element.
	* @param {number} [n33] - 3-3 matrix element.
	*/
	constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		Matrix3.prototype.isMatrix3 = true;
		/**
		* A column-major list of matrix values.
		*
		* @type {Array<number>}
		*/
		this.elements = [
			1,
			0,
			0,
			0,
			1,
			0,
			0,
			0,
			1
		];
		if (n11 !== void 0) this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
	}
	/**
	* Sets the elements of the matrix.The arguments are supposed to be
	* in row-major order.
	*
	* @param {number} [n11] - 1-1 matrix element.
	* @param {number} [n12] - 1-2 matrix element.
	* @param {number} [n13] - 1-3 matrix element.
	* @param {number} [n21] - 2-1 matrix element.
	* @param {number} [n22] - 2-2 matrix element.
	* @param {number} [n23] - 2-3 matrix element.
	* @param {number} [n31] - 3-1 matrix element.
	* @param {number} [n32] - 3-2 matrix element.
	* @param {number} [n33] - 3-3 matrix element.
	* @return {Matrix3} A reference to this matrix.
	*/
	set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
		const te = this.elements;
		te[0] = n11;
		te[1] = n21;
		te[2] = n31;
		te[3] = n12;
		te[4] = n22;
		te[5] = n32;
		te[6] = n13;
		te[7] = n23;
		te[8] = n33;
		return this;
	}
	/**
	* Sets this matrix to the 3x3 identity matrix.
	*
	* @return {Matrix3} A reference to this matrix.
	*/
	identity() {
		this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
		return this;
	}
	/**
	* Copies the values of the given matrix to this instance.
	*
	* @param {Matrix3} m - The matrix to copy.
	* @return {Matrix3} A reference to this matrix.
	*/
	copy(m$1) {
		const te = this.elements;
		const me = m$1.elements;
		te[0] = me[0];
		te[1] = me[1];
		te[2] = me[2];
		te[3] = me[3];
		te[4] = me[4];
		te[5] = me[5];
		te[6] = me[6];
		te[7] = me[7];
		te[8] = me[8];
		return this;
	}
	/**
	* Extracts the basis of this matrix into the three axis vectors provided.
	*
	* @param {Vector3} xAxis - The basis's x axis.
	* @param {Vector3} yAxis - The basis's y axis.
	* @param {Vector3} zAxis - The basis's z axis.
	* @return {Matrix3} A reference to this matrix.
	*/
	extractBasis(xAxis, yAxis, zAxis) {
		xAxis.setFromMatrix3Column(this, 0);
		yAxis.setFromMatrix3Column(this, 1);
		zAxis.setFromMatrix3Column(this, 2);
		return this;
	}
	/**
	* Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
	*
	* @param {Matrix4} m - The 4x4 matrix.
	* @return {Matrix3} A reference to this matrix.
	*/
	setFromMatrix4(m$1) {
		const me = m$1.elements;
		this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
		return this;
	}
	/**
	* Post-multiplies this matrix by the given 3x3 matrix.
	*
	* @param {Matrix3} m - The matrix to multiply with.
	* @return {Matrix3} A reference to this matrix.
	*/
	multiply(m$1) {
		return this.multiplyMatrices(this, m$1);
	}
	/**
	* Pre-multiplies this matrix by the given 3x3 matrix.
	*
	* @param {Matrix3} m - The matrix to multiply with.
	* @return {Matrix3} A reference to this matrix.
	*/
	premultiply(m$1) {
		return this.multiplyMatrices(m$1, this);
	}
	/**
	* Multiples the given 3x3 matrices and stores the result
	* in this matrix.
	*
	* @param {Matrix3} a - The first matrix.
	* @param {Matrix3} b - The second matrix.
	* @return {Matrix3} A reference to this matrix.
	*/
	multiplyMatrices(a$1, b$2) {
		const ae = a$1.elements;
		const be = b$2.elements;
		const te = this.elements;
		const a11 = ae[0], a12 = ae[3], a13 = ae[6];
		const a21 = ae[1], a22 = ae[4], a23 = ae[7];
		const a31 = ae[2], a32 = ae[5], a33 = ae[8];
		const b11 = be[0], b12 = be[3], b13 = be[6];
		const b21 = be[1], b22 = be[4], b23 = be[7];
		const b31 = be[2], b32 = be[5], b33 = be[8];
		te[0] = a11 * b11 + a12 * b21 + a13 * b31;
		te[3] = a11 * b12 + a12 * b22 + a13 * b32;
		te[6] = a11 * b13 + a12 * b23 + a13 * b33;
		te[1] = a21 * b11 + a22 * b21 + a23 * b31;
		te[4] = a21 * b12 + a22 * b22 + a23 * b32;
		te[7] = a21 * b13 + a22 * b23 + a23 * b33;
		te[2] = a31 * b11 + a32 * b21 + a33 * b31;
		te[5] = a31 * b12 + a32 * b22 + a33 * b32;
		te[8] = a31 * b13 + a32 * b23 + a33 * b33;
		return this;
	}
	/**
	* Multiplies every component of the matrix by the given scalar.
	*
	* @param {number} s - The scalar.
	* @return {Matrix3} A reference to this matrix.
	*/
	multiplyScalar(s) {
		const te = this.elements;
		te[0] *= s;
		te[3] *= s;
		te[6] *= s;
		te[1] *= s;
		te[4] *= s;
		te[7] *= s;
		te[2] *= s;
		te[5] *= s;
		te[8] *= s;
		return this;
	}
	/**
	* Computes and returns the determinant of this matrix.
	*
	* @return {number} The determinant.
	*/
	determinant() {
		const te = this.elements;
		const a$1 = te[0], b$2 = te[1], c$1 = te[2], d$1 = te[3], e = te[4], f = te[5], g$1 = te[6], h = te[7], i = te[8];
		return a$1 * e * i - a$1 * f * h - b$2 * d$1 * i + b$2 * f * g$1 + c$1 * d$1 * h - c$1 * e * g$1;
	}
	/**
	* Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
	* You can not invert with a determinant of zero. If you attempt this, the method produces
	* a zero matrix instead.
	*
	* @return {Matrix3} A reference to this matrix.
	*/
	invert() {
		const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det$1 = n11 * t11 + n21 * t12 + n31 * t13;
		if (det$1 === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
		const detInv = 1 / det$1;
		te[0] = t11 * detInv;
		te[1] = (n31 * n23 - n33 * n21) * detInv;
		te[2] = (n32 * n21 - n31 * n22) * detInv;
		te[3] = t12 * detInv;
		te[4] = (n33 * n11 - n31 * n13) * detInv;
		te[5] = (n31 * n12 - n32 * n11) * detInv;
		te[6] = t13 * detInv;
		te[7] = (n21 * n13 - n23 * n11) * detInv;
		te[8] = (n22 * n11 - n21 * n12) * detInv;
		return this;
	}
	/**
	* Transposes this matrix in place.
	*
	* @return {Matrix3} A reference to this matrix.
	*/
	transpose() {
		let tmp;
		const m$1 = this.elements;
		tmp = m$1[1];
		m$1[1] = m$1[3];
		m$1[3] = tmp;
		tmp = m$1[2];
		m$1[2] = m$1[6];
		m$1[6] = tmp;
		tmp = m$1[5];
		m$1[5] = m$1[7];
		m$1[7] = tmp;
		return this;
	}
	/**
	* Computes the normal matrix which is the inverse transpose of the upper
	* left 3x3 portion of the given 4x4 matrix.
	*
	* @param {Matrix4} matrix4 - The 4x4 matrix.
	* @return {Matrix3} A reference to this matrix.
	*/
	getNormalMatrix(matrix4) {
		return this.setFromMatrix4(matrix4).invert().transpose();
	}
	/**
	* Transposes this matrix into the supplied array, and returns itself unchanged.
	*
	* @param {Array<number>} r - An array to store the transposed matrix elements.
	* @return {Matrix3} A reference to this matrix.
	*/
	transposeIntoArray(r) {
		const m$1 = this.elements;
		r[0] = m$1[0];
		r[1] = m$1[3];
		r[2] = m$1[6];
		r[3] = m$1[1];
		r[4] = m$1[4];
		r[5] = m$1[7];
		r[6] = m$1[2];
		r[7] = m$1[5];
		r[8] = m$1[8];
		return this;
	}
	/**
	* Sets the UV transform matrix from offset, repeat, rotation, and center.
	*
	* @param {number} tx - Offset x.
	* @param {number} ty - Offset y.
	* @param {number} sx - Repeat x.
	* @param {number} sy - Repeat y.
	* @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
	* @param {number} cx - Center x of rotation.
	* @param {number} cy - Center y of rotation
	* @return {Matrix3} A reference to this matrix.
	*/
	setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
		const c$1 = Math.cos(rotation);
		const s = Math.sin(rotation);
		this.set(sx * c$1, sx * s, -sx * (c$1 * cx + s * cy) + cx + tx, -sy * s, sy * c$1, -sy * (-s * cx + c$1 * cy) + cy + ty, 0, 0, 1);
		return this;
	}
	/**
	* Scales this matrix with the given scalar values.
	*
	* @param {number} sx - The amount to scale in the X axis.
	* @param {number} sy - The amount to scale in the Y axis.
	* @return {Matrix3} A reference to this matrix.
	*/
	scale(sx, sy) {
		this.premultiply(_m3.makeScale(sx, sy));
		return this;
	}
	/**
	* Rotates this matrix by the given angle.
	*
	* @param {number} theta - The rotation in radians.
	* @return {Matrix3} A reference to this matrix.
	*/
	rotate(theta) {
		this.premultiply(_m3.makeRotation(-theta));
		return this;
	}
	/**
	* Translates this matrix by the given scalar values.
	*
	* @param {number} tx - The amount to translate in the X axis.
	* @param {number} ty - The amount to translate in the Y axis.
	* @return {Matrix3} A reference to this matrix.
	*/
	translate(tx, ty) {
		this.premultiply(_m3.makeTranslation(tx, ty));
		return this;
	}
	/**
	* Sets this matrix as a 2D translation transform.
	*
	* @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
	* @param {number} y - The amount to translate in the Y axis.
	* @return {Matrix3} A reference to this matrix.
	*/
	makeTranslation(x, y) {
		if (x.isVector2) this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
		else this.set(1, 0, x, 0, 1, y, 0, 0, 1);
		return this;
	}
	/**
	* Sets this matrix as a 2D rotational transformation.
	*
	* @param {number} theta - The rotation in radians.
	* @return {Matrix3} A reference to this matrix.
	*/
	makeRotation(theta) {
		const c$1 = Math.cos(theta);
		const s = Math.sin(theta);
		this.set(c$1, -s, 0, s, c$1, 0, 0, 0, 1);
		return this;
	}
	/**
	* Sets this matrix as a 2D scale transform.
	*
	* @param {number} x - The amount to scale in the X axis.
	* @param {number} y - The amount to scale in the Y axis.
	* @return {Matrix3} A reference to this matrix.
	*/
	makeScale(x, y) {
		this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
		return this;
	}
	/**
	* Returns `true` if this matrix is equal with the given one.
	*
	* @param {Matrix3} matrix - The matrix to test for equality.
	* @return {boolean} Whether this matrix is equal with the given one.
	*/
	equals(matrix) {
		const te = this.elements;
		const me = matrix.elements;
		for (let i = 0; i < 9; i++) if (te[i] !== me[i]) return false;
		return true;
	}
	/**
	* Sets the elements of the matrix from the given array.
	*
	* @param {Array<number>} array - The matrix elements in column-major order.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Matrix3} A reference to this matrix.
	*/
	fromArray(array$2, offset = 0) {
		for (let i = 0; i < 9; i++) this.elements[i] = array$2[i + offset];
		return this;
	}
	/**
	* Writes the elements of this matrix to the given array. If no array is provided,
	* the method returns a new instance.
	*
	* @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Array<number>} The matrix elements in column-major order.
	*/
	toArray(array$2 = [], offset = 0) {
		const te = this.elements;
		array$2[offset] = te[0];
		array$2[offset + 1] = te[1];
		array$2[offset + 2] = te[2];
		array$2[offset + 3] = te[3];
		array$2[offset + 4] = te[4];
		array$2[offset + 5] = te[5];
		array$2[offset + 6] = te[6];
		array$2[offset + 7] = te[7];
		array$2[offset + 8] = te[8];
		return array$2;
	}
	/**
	* Returns a matrix with copied values from this instance.
	*
	* @return {Matrix3} A clone of this instance.
	*/
	clone() {
		return new this.constructor().fromArray(this.elements);
	}
};
var _m3 = /* @__PURE__ */ new Matrix3();
var LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322);
var XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
function createColorManagement() {
	const ColorManagement$1 = {
		enabled: true,
		workingColorSpace: LinearSRGBColorSpace,
		spaces: {},
		convert: function(color$2, sourceColorSpace, targetColorSpace) {
			if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) return color$2;
			if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
				color$2.r = SRGBToLinear(color$2.r);
				color$2.g = SRGBToLinear(color$2.g);
				color$2.b = SRGBToLinear(color$2.b);
			}
			if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
				color$2.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
				color$2.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
			}
			if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
				color$2.r = LinearToSRGB(color$2.r);
				color$2.g = LinearToSRGB(color$2.g);
				color$2.b = LinearToSRGB(color$2.b);
			}
			return color$2;
		},
		workingToColorSpace: function(color$2, targetColorSpace) {
			return this.convert(color$2, this.workingColorSpace, targetColorSpace);
		},
		colorSpaceToWorking: function(color$2, sourceColorSpace) {
			return this.convert(color$2, sourceColorSpace, this.workingColorSpace);
		},
		getPrimaries: function(colorSpace) {
			return this.spaces[colorSpace].primaries;
		},
		getTransfer: function(colorSpace) {
			if (colorSpace === NoColorSpace) return LinearTransfer;
			return this.spaces[colorSpace].transfer;
		},
		getToneMappingMode: function(colorSpace) {
			return this.spaces[colorSpace].outputColorSpaceConfig.toneMappingMode || "standard";
		},
		getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
			return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
		},
		define: function(colorSpaces) {
			Object.assign(this.spaces, colorSpaces);
		},
		_getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
			return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
		},
		_getDrawingBufferColorSpace: function(colorSpace) {
			return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
		},
		_getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
			return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
		},
		fromWorkingColorSpace: function(color$2, targetColorSpace) {
			warnOnce("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().");
			return ColorManagement$1.workingToColorSpace(color$2, targetColorSpace);
		},
		toWorkingColorSpace: function(color$2, sourceColorSpace) {
			warnOnce("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().");
			return ColorManagement$1.colorSpaceToWorking(color$2, sourceColorSpace);
		}
	};
	/******************************************************************************
	* sRGB definitions
	*/
	const REC709_PRIMARIES = [
		.64,
		.33,
		.3,
		.6,
		.15,
		.06
	];
	const REC709_LUMINANCE_COEFFICIENTS = [
		.2126,
		.7152,
		.0722
	];
	const D65 = [.3127, .329];
	ColorManagement$1.define({
		[LinearSRGBColorSpace]: {
			primaries: REC709_PRIMARIES,
			whitePoint: D65,
			transfer: LinearTransfer,
			toXYZ: LINEAR_REC709_TO_XYZ,
			fromXYZ: XYZ_TO_LINEAR_REC709,
			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
			workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
		},
		[SRGBColorSpace]: {
			primaries: REC709_PRIMARIES,
			whitePoint: D65,
			transfer: SRGBTransfer,
			toXYZ: LINEAR_REC709_TO_XYZ,
			fromXYZ: XYZ_TO_LINEAR_REC709,
			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
		}
	});
	return ColorManagement$1;
}
var ColorManagement = /* @__PURE__ */ createColorManagement();
function SRGBToLinear(c$1) {
	return c$1 < .04045 ? c$1 * .0773993808 : Math.pow(c$1 * .9478672986 + .0521327014, 2.4);
}
function LinearToSRGB(c$1) {
	return c$1 < .0031308 ? c$1 * 12.92 : 1.055 * Math.pow(c$1, .41666) - .055;
}
var _canvas;
/**
* A class containing utility functions for images.
*
* @hideconstructor
*/
var ImageUtils = class {
	/**
	* Returns a data URI containing a representation of the given image.
	*
	* @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
	* @param {string} [type='image/png'] - Indicates the image format.
	* @return {string} The data URI.
	*/
	static getDataURL(image, type$1 = "image/png") {
		if (/^data:/i.test(image.src)) return image.src;
		if (typeof HTMLCanvasElement === "undefined") return image.src;
		let canvas;
		if (image instanceof HTMLCanvasElement) canvas = image;
		else {
			if (_canvas === void 0) _canvas = createElementNS("canvas");
			_canvas.width = image.width;
			_canvas.height = image.height;
			const context$2 = _canvas.getContext("2d");
			if (image instanceof ImageData) context$2.putImageData(image, 0, 0);
			else context$2.drawImage(image, 0, 0, image.width, image.height);
			canvas = _canvas;
		}
		return canvas.toDataURL(type$1);
	}
	/**
	* Converts the given sRGB image data to linear color space.
	*
	* @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
	* @return {HTMLCanvasElement|Object} The converted image.
	*/
	static sRGBToLinear(image) {
		if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
			const canvas = createElementNS("canvas");
			canvas.width = image.width;
			canvas.height = image.height;
			const context$2 = canvas.getContext("2d");
			context$2.drawImage(image, 0, 0, image.width, image.height);
			const imageData = context$2.getImageData(0, 0, image.width, image.height);
			const data = imageData.data;
			for (let i = 0; i < data.length; i++) data[i] = SRGBToLinear(data[i] / 255) * 255;
			context$2.putImageData(imageData, 0, 0);
			return canvas;
		} else if (image.data) {
			const data = image.data.slice(0);
			for (let i = 0; i < data.length; i++) if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
			else data[i] = SRGBToLinear(data[i]);
			return {
				data,
				width: image.width,
				height: image.height
			};
		} else {
			warn("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
			return image;
		}
	}
};
var _sourceId = 0;
/**
* Represents the data source of a texture.
*
* The main purpose of this class is to decouple the data definition from the texture
* definition so the same data can be used with multiple texture instances.
*/
var Source = class {
	/**
	* Constructs a new video texture.
	*
	* @param {any} [data=null] - The data definition of a texture.
	*/
	constructor(data = null) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSource = true;
		/**
		* The ID of the source.
		*
		* @name Source#id
		* @type {number}
		* @readonly
		*/
		Object.defineProperty(this, "id", { value: _sourceId++ });
		/**
		* The UUID of the source.
		*
		* @type {string}
		* @readonly
		*/
		this.uuid = generateUUID();
		/**
		* The data definition of a texture.
		*
		* @type {any}
		*/
		this.data = data;
		/**
		* This property is only relevant when {@link Source#needsUpdate} is set to `true` and
		* provides more control on how texture data should be processed. When `dataReady` is set
		* to `false`, the engine performs the memory allocation (if necessary) but does not transfer
		* the data into the GPU memory.
		*
		* @type {boolean}
		* @default true
		*/
		this.dataReady = true;
		/**
		* This starts at `0` and counts how many times {@link Source#needsUpdate} is set to `true`.
		*
		* @type {number}
		* @readonly
		* @default 0
		*/
		this.version = 0;
	}
	/**
	* Returns the dimensions of the source into the given target vector.
	*
	* @param {(Vector2|Vector3)} target - The target object the result is written into.
	* @return {(Vector2|Vector3)} The dimensions of the source.
	*/
	getSize(target) {
		const data = this.data;
		if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) target.set(data.videoWidth, data.videoHeight, 0);
		else if (data instanceof VideoFrame) target.set(data.displayHeight, data.displayWidth, 0);
		else if (data !== null) target.set(data.width, data.height, data.depth || 0);
		else target.set(0, 0, 0);
		return target;
	}
	/**
	* When the property is set to `true`, the engine allocates the memory
	* for the texture (if necessary) and triggers the actual texture upload
	* to the GPU next time the source is used.
	*
	* @type {boolean}
	* @default false
	* @param {boolean} value
	*/
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
	/**
	* Serializes the source into JSON.
	*
	* @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	* @return {Object} A JSON object representing the serialized source.
	* @see {@link ObjectLoader#parse}
	*/
	toJSON(meta) {
		const isRootObject = meta === void 0 || typeof meta === "string";
		if (!isRootObject && meta.images[this.uuid] !== void 0) return meta.images[this.uuid];
		const output$2 = {
			uuid: this.uuid,
			url: ""
		};
		const data = this.data;
		if (data !== null) {
			let url;
			if (Array.isArray(data)) {
				url = [];
				for (let i = 0, l = data.length; i < l; i++) if (data[i].isDataTexture) url.push(serializeImage(data[i].image));
				else url.push(serializeImage(data[i]));
			} else url = serializeImage(data);
			output$2.url = url;
		}
		if (!isRootObject) meta.images[this.uuid] = output$2;
		return output$2;
	}
};
function serializeImage(image) {
	if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) return ImageUtils.getDataURL(image);
	else if (image.data) return {
		data: Array.from(image.data),
		width: image.width,
		height: image.height,
		type: image.data.constructor.name
	};
	else {
		warn("Texture: Unable to serialize Texture.");
		return {};
	}
}
var _textureId = 0;
var _tempVec3 = /* @__PURE__ */ new Vector3();
/**
* Base class for all textures.
*
* Note: After the initial use of a texture, its dimensions, format, and type
* cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.
*
* @augments EventDispatcher
*/
var Texture = class Texture extends EventDispatcher {
	/**
	* Constructs a new texture.
	*
	* @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
	* @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	* @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	* @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	* @param {number} [magFilter=LinearFilter] - The mag filter value.
	* @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
	* @param {number} [format=RGBAFormat] - The texture format.
	* @param {number} [type=UnsignedByteType] - The texture type.
	* @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	* @param {string} [colorSpace=NoColorSpace] - The color space.
	*/
	constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type$1 = UnsignedByteType, anisotropy$2 = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isTexture = true;
		/**
		* The ID of the texture.
		*
		* @name Texture#id
		* @type {number}
		* @readonly
		*/
		Object.defineProperty(this, "id", { value: _textureId++ });
		/**
		* The UUID of the material.
		*
		* @type {string}
		* @readonly
		*/
		this.uuid = generateUUID();
		/**
		* The name of the material.
		*
		* @type {string}
		*/
		this.name = "";
		/**
		* The data definition of a texture. A reference to the data source can be
		* shared across textures. This is often useful in context of spritesheets
		* where multiple textures render the same data but with different texture
		* transformations.
		*
		* @type {Source}
		*/
		this.source = new Source(image);
		/**
		* An array holding user-defined mipmaps.
		*
		* @type {Array<Object>}
		*/
		this.mipmaps = [];
		/**
		* How the texture is applied to the object. The value `UVMapping`
		* is the default, where texture or uv coordinates are used to apply the map.
		*
		* @type {(UVMapping|CubeReflectionMapping|CubeRefractionMapping|EquirectangularReflectionMapping|EquirectangularRefractionMapping|CubeUVReflectionMapping)}
		* @default UVMapping
		*/
		this.mapping = mapping;
		/**
		* Lets you select the uv attribute to map the texture to. `0` for `uv`,
		* `1` for `uv1`, `2` for `uv2` and `3` for `uv3`.
		*
		* @type {number}
		* @default 0
		*/
		this.channel = 0;
		/**
		* This defines how the texture is wrapped horizontally and corresponds to
		* *U* in UV mapping.
		*
		* @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		* @default ClampToEdgeWrapping
		*/
		this.wrapS = wrapS;
		/**
		* This defines how the texture is wrapped horizontally and corresponds to
		* *V* in UV mapping.
		*
		* @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		* @default ClampToEdgeWrapping
		*/
		this.wrapT = wrapT;
		/**
		* How the texture is sampled when a texel covers more than one pixel.
		*
		* @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		* @default LinearFilter
		*/
		this.magFilter = magFilter;
		/**
		* How the texture is sampled when a texel covers less than one pixel.
		*
		* @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		* @default LinearMipmapLinearFilter
		*/
		this.minFilter = minFilter;
		/**
		* The number of samples taken along the axis through the pixel that has the
		* highest density of texels. By default, this value is `1`. A higher value
		* gives a less blurry result than a basic mipmap, at the cost of more
		* texture samples being used.
		*
		* @type {number}
		* @default 0
		*/
		this.anisotropy = anisotropy$2;
		/**
		* The format of the texture.
		*
		* @type {number}
		* @default RGBAFormat
		*/
		this.format = format;
		/**
		* The default internal format is derived from {@link Texture#format} and {@link Texture#type} and
		* defines how the texture data is going to be stored on the GPU.
		*
		* This property allows to overwrite the default format.
		*
		* @type {?string}
		* @default null
		*/
		this.internalFormat = null;
		/**
		* The data type of the texture.
		*
		* @type {number}
		* @default UnsignedByteType
		*/
		this.type = type$1;
		/**
		* How much a single repetition of the texture is offset from the beginning,
		* in each direction U and V. Typical range is `0.0` to `1.0`.
		*
		* @type {Vector2}
		* @default (0,0)
		*/
		this.offset = new Vector2(0, 0);
		/**
		* How many times the texture is repeated across the surface, in each
		* direction U and V. If repeat is set greater than `1` in either direction,
		* the corresponding wrap parameter should also be set to `RepeatWrapping`
		* or `MirroredRepeatWrapping` to achieve the desired tiling effect.
		*
		* @type {Vector2}
		* @default (1,1)
		*/
		this.repeat = new Vector2(1, 1);
		/**
		* The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds
		* to the center of the texture. Default is `(0, 0)`, the lower left.
		*
		* @type {Vector2}
		* @default (0,0)
		*/
		this.center = new Vector2(0, 0);
		/**
		* How much the texture is rotated around the center point, in radians.
		* Positive values are counter-clockwise.
		*
		* @type {number}
		* @default 0
		*/
		this.rotation = 0;
		/**
		* Whether to update the texture's uv-transformation {@link Texture#matrix}
		* from the properties {@link Texture#offset}, {@link Texture#repeat},
		* {@link Texture#rotation}, and {@link Texture#center}.
		*
		* Set this to `false` if you are specifying the uv-transform matrix directly.
		*
		* @type {boolean}
		* @default true
		*/
		this.matrixAutoUpdate = true;
		/**
		* The uv-transformation matrix of the texture.
		*
		* @type {Matrix3}
		*/
		this.matrix = new Matrix3();
		/**
		* Whether to generate mipmaps (if possible) for a texture.
		*
		* Set this to `false` if you are creating mipmaps manually.
		*
		* @type {boolean}
		* @default true
		*/
		this.generateMipmaps = true;
		/**
		* If set to `true`, the alpha channel, if present, is multiplied into the
		* color channels when the texture is uploaded to the GPU.
		*
		* Note that this property has no effect when using `ImageBitmap`. You need to
		* configure premultiply alpha on bitmap creation instead.
		*
		* @type {boolean}
		* @default false
		*/
		this.premultiplyAlpha = false;
		/**
		* If set to `true`, the texture is flipped along the vertical axis when
		* uploaded to the GPU.
		*
		* Note that this property has no effect when using `ImageBitmap`. You need to
		* configure the flip on bitmap creation instead.
		*
		* @type {boolean}
		* @default true
		*/
		this.flipY = true;
		/**
		* Specifies the alignment requirements for the start of each pixel row in memory.
		* The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),
		* `4` (word-alignment), and `8` (rows start on double-word boundaries).
		*
		* @type {number}
		* @default 4
		*/
		this.unpackAlignment = 4;
		/**
		* Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.
		*
		* @type {string}
		* @default NoColorSpace
		*/
		this.colorSpace = colorSpace;
		/**
		* An object that can be used to store custom data about the texture. It
		* should not hold references to functions as these will not be cloned.
		*
		* @type {Object}
		*/
		this.userData = {};
		/**
		* This can be used to only update a subregion or specific rows of the texture (for example, just the
		* first 3 rows). Use the `addUpdateRange()` function to add ranges to this array.
		*
		* @type {Array<Object>}
		*/
		this.updateRanges = [];
		/**
		* This starts at `0` and counts how many times {@link Texture#needsUpdate} is set to `true`.
		*
		* @type {number}
		* @readonly
		* @default 0
		*/
		this.version = 0;
		/**
		* A callback function, called when the texture is updated (e.g., when
		* {@link Texture#needsUpdate} has been set to true and then the texture is used).
		*
		* @type {?Function}
		* @default null
		*/
		this.onUpdate = null;
		/**
		* An optional back reference to the textures render target.
		*
		* @type {?(RenderTarget|WebGLRenderTarget)}
		* @default null
		*/
		this.renderTarget = null;
		/**
		* Indicates whether a texture belongs to a render target or not.
		*
		* @type {boolean}
		* @readonly
		* @default false
		*/
		this.isRenderTargetTexture = false;
		/**
		* Indicates if a texture should be handled like a texture array.
		*
		* @type {boolean}
		* @readonly
		* @default false
		*/
		this.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;
		/**
		* Indicates whether this texture should be processed by `PMREMGenerator` or not
		* (only relevant for render target textures).
		*
		* @type {number}
		* @readonly
		* @default 0
		*/
		this.pmremVersion = 0;
	}
	/**
	* The width of the texture in pixels.
	*/
	get width() {
		return this.source.getSize(_tempVec3).x;
	}
	/**
	* The height of the texture in pixels.
	*/
	get height() {
		return this.source.getSize(_tempVec3).y;
	}
	/**
	* The depth of the texture in pixels.
	*/
	get depth() {
		return this.source.getSize(_tempVec3).z;
	}
	/**
	* The image object holding the texture data.
	*
	* @type {?Object}
	*/
	get image() {
		return this.source.data;
	}
	set image(value = null) {
		this.source.data = value;
	}
	/**
	* Updates the texture transformation matrix from the from the properties {@link Texture#offset},
	* {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
	*/
	updateMatrix() {
		this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
	}
	/**
	* Adds a range of data in the data texture to be updated on the GPU.
	*
	* @param {number} start - Position at which to start update.
	* @param {number} count - The number of components to update.
	*/
	addUpdateRange(start, count) {
		this.updateRanges.push({
			start,
			count
		});
	}
	/**
	* Clears the update ranges.
	*/
	clearUpdateRanges() {
		this.updateRanges.length = 0;
	}
	/**
	* Returns a new texture with copied values from this instance.
	*
	* @return {Texture} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	/**
	* Copies the values of the given texture to this instance.
	*
	* @param {Texture} source - The texture to copy.
	* @return {Texture} A reference to this instance.
	*/
	copy(source) {
		this.name = source.name;
		this.source = source.source;
		this.mipmaps = source.mipmaps.slice(0);
		this.mapping = source.mapping;
		this.channel = source.channel;
		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;
		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;
		this.anisotropy = source.anisotropy;
		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;
		this.offset.copy(source.offset);
		this.repeat.copy(source.repeat);
		this.center.copy(source.center);
		this.rotation = source.rotation;
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy(source.matrix);
		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.colorSpace = source.colorSpace;
		this.renderTarget = source.renderTarget;
		this.isRenderTargetTexture = source.isRenderTargetTexture;
		this.isArrayTexture = source.isArrayTexture;
		this.userData = JSON.parse(JSON.stringify(source.userData));
		this.needsUpdate = true;
		return this;
	}
	/**
	* Sets this texture's properties based on `values`.
	* @param {Object} values - A container with texture parameters.
	*/
	setValues(values) {
		for (const key in values) {
			const newValue = values[key];
			if (newValue === void 0) {
				warn(`Texture.setValues(): parameter '${key}' has value of undefined.`);
				continue;
			}
			const currentValue = this[key];
			if (currentValue === void 0) {
				warn(`Texture.setValues(): property '${key}' does not exist.`);
				continue;
			}
			if (currentValue && newValue && currentValue.isVector2 && newValue.isVector2) currentValue.copy(newValue);
			else if (currentValue && newValue && currentValue.isVector3 && newValue.isVector3) currentValue.copy(newValue);
			else if (currentValue && newValue && currentValue.isMatrix3 && newValue.isMatrix3) currentValue.copy(newValue);
			else this[key] = newValue;
		}
	}
	/**
	* Serializes the texture into JSON.
	*
	* @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	* @return {Object} A JSON object representing the serialized texture.
	* @see {@link ObjectLoader#parse}
	*/
	toJSON(meta) {
		const isRootObject = meta === void 0 || typeof meta === "string";
		if (!isRootObject && meta.textures[this.uuid] !== void 0) return meta.textures[this.uuid];
		const output$2 = {
			metadata: {
				version: 4.7,
				type: "Texture",
				generator: "Texture.toJSON"
			},
			uuid: this.uuid,
			name: this.name,
			image: this.source.toJSON(meta).uuid,
			mapping: this.mapping,
			channel: this.channel,
			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			center: [this.center.x, this.center.y],
			rotation: this.rotation,
			wrap: [this.wrapS, this.wrapT],
			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			colorSpace: this.colorSpace,
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,
			flipY: this.flipY,
			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment
		};
		if (Object.keys(this.userData).length > 0) output$2.userData = this.userData;
		if (!isRootObject) meta.textures[this.uuid] = output$2;
		return output$2;
	}
	/**
	* Frees the GPU-related resources allocated by this instance. Call this
	* method whenever this instance is no longer used in your app.
	*
	* @fires Texture#dispose
	*/
	dispose() {
		/**
		* Fires when the texture has been disposed of.
		*
		* @event Texture#dispose
		* @type {Object}
		*/
		this.dispatchEvent({ type: "dispose" });
	}
	/**
	* Transforms the given uv vector with the textures uv transformation matrix.
	*
	* @param {Vector2} uv - The uv vector.
	* @return {Vector2} The transformed uv vector.
	*/
	transformUv(uv$3) {
		if (this.mapping !== UVMapping) return uv$3;
		uv$3.applyMatrix3(this.matrix);
		if (uv$3.x < 0 || uv$3.x > 1) switch (this.wrapS) {
			case RepeatWrapping:
				uv$3.x = uv$3.x - Math.floor(uv$3.x);
				break;
			case ClampToEdgeWrapping:
				uv$3.x = uv$3.x < 0 ? 0 : 1;
				break;
			case MirroredRepeatWrapping:
				if (Math.abs(Math.floor(uv$3.x) % 2) === 1) uv$3.x = Math.ceil(uv$3.x) - uv$3.x;
				else uv$3.x = uv$3.x - Math.floor(uv$3.x);
				break;
		}
		if (uv$3.y < 0 || uv$3.y > 1) switch (this.wrapT) {
			case RepeatWrapping:
				uv$3.y = uv$3.y - Math.floor(uv$3.y);
				break;
			case ClampToEdgeWrapping:
				uv$3.y = uv$3.y < 0 ? 0 : 1;
				break;
			case MirroredRepeatWrapping:
				if (Math.abs(Math.floor(uv$3.y) % 2) === 1) uv$3.y = Math.ceil(uv$3.y) - uv$3.y;
				else uv$3.y = uv$3.y - Math.floor(uv$3.y);
				break;
		}
		if (this.flipY) uv$3.y = 1 - uv$3.y;
		return uv$3;
	}
	/**
	* Setting this property to `true` indicates the engine the texture
	* must be updated in the next render. This triggers a texture upload
	* to the GPU and ensures correct texture parameter configuration.
	*
	* @type {boolean}
	* @default false
	* @param {boolean} value
	*/
	set needsUpdate(value) {
		if (value === true) {
			this.version++;
			this.source.needsUpdate = true;
		}
	}
	/**
	* Setting this property to `true` indicates the engine the PMREM
	* must be regenerated.
	*
	* @type {boolean}
	* @default false
	* @param {boolean} value
	*/
	set needsPMREMUpdate(value) {
		if (value === true) this.pmremVersion++;
	}
};
/**
* The default image for all textures.
*
* @static
* @type {?Image}
* @default null
*/
Texture.DEFAULT_IMAGE = null;
/**
* The default mapping for all textures.
*
* @static
* @type {number}
* @default UVMapping
*/
Texture.DEFAULT_MAPPING = UVMapping;
/**
* The default anisotropy value for all textures.
*
* @static
* @type {number}
* @default 1
*/
Texture.DEFAULT_ANISOTROPY = 1;
/**
* Class representing a 4D vector. A 4D vector is an ordered quadruplet of numbers
* (labeled x, y, z and w), which can be used to represent a number of things, such as:
*
* - A point in 4D space.
* - A direction and length in 4D space. In three.js the length will
* always be the Euclidean distance(straight-line distance) from `(0, 0, 0, 0)` to `(x, y, z, w)`
* and the direction is also measured from `(0, 0, 0, 0)` towards `(x, y, z, w)`.
* - Any arbitrary ordered quadruplet of numbers.
*
* There are other things a 4D vector can be used to represent, however these
* are the most common uses in *three.js*.
*
* Iterating through a vector instance will yield its components `(x, y, z, w)` in
* the corresponding order.
* ```js
* const a = new THREE.Vector4( 0, 1, 0, 0 );
*
* //no arguments; will be initialised to (0, 0, 0, 1)
* const b = new THREE.Vector4( );
*
* const d = a.dot( b );
* ```
*/
var Vector4 = class Vector4 {
	/**
	* Constructs a new 4D vector.
	*
	* @param {number} [x=0] - The x value of this vector.
	* @param {number} [y=0] - The y value of this vector.
	* @param {number} [z=0] - The z value of this vector.
	* @param {number} [w=1] - The w value of this vector.
	*/
	constructor(x = 0, y = 0, z = 0, w = 1) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		Vector4.prototype.isVector4 = true;
		/**
		* The x value of this vector.
		*
		* @type {number}
		*/
		this.x = x;
		/**
		* The y value of this vector.
		*
		* @type {number}
		*/
		this.y = y;
		/**
		* The z value of this vector.
		*
		* @type {number}
		*/
		this.z = z;
		/**
		* The w value of this vector.
		*
		* @type {number}
		*/
		this.w = w;
	}
	/**
	* Alias for {@link Vector4#z}.
	*
	* @type {number}
	*/
	get width() {
		return this.z;
	}
	set width(value) {
		this.z = value;
	}
	/**
	* Alias for {@link Vector4#w}.
	*
	* @type {number}
	*/
	get height() {
		return this.w;
	}
	set height(value) {
		this.w = value;
	}
	/**
	* Sets the vector components.
	*
	* @param {number} x - The value of the x component.
	* @param {number} y - The value of the y component.
	* @param {number} z - The value of the z component.
	* @param {number} w - The value of the w component.
	* @return {Vector4} A reference to this vector.
	*/
	set(x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
		return this;
	}
	/**
	* Sets the vector components to the same value.
	*
	* @param {number} scalar - The value to set for all vector components.
	* @return {Vector4} A reference to this vector.
	*/
	setScalar(scalar) {
		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;
		return this;
	}
	/**
	* Sets the vector's x component to the given value
	*
	* @param {number} x - The value to set.
	* @return {Vector4} A reference to this vector.
	*/
	setX(x) {
		this.x = x;
		return this;
	}
	/**
	* Sets the vector's y component to the given value
	*
	* @param {number} y - The value to set.
	* @return {Vector4} A reference to this vector.
	*/
	setY(y) {
		this.y = y;
		return this;
	}
	/**
	* Sets the vector's z component to the given value
	*
	* @param {number} z - The value to set.
	* @return {Vector4} A reference to this vector.
	*/
	setZ(z) {
		this.z = z;
		return this;
	}
	/**
	* Sets the vector's w component to the given value
	*
	* @param {number} w - The value to set.
	* @return {Vector4} A reference to this vector.
	*/
	setW(w) {
		this.w = w;
		return this;
	}
	/**
	* Allows to set a vector component with an index.
	*
	* @param {number} index - The component index. `0` equals to x, `1` equals to y,
	* `2` equals to z, `3` equals to w.
	* @param {number} value - The value to set.
	* @return {Vector4} A reference to this vector.
	*/
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			case 2:
				this.z = value;
				break;
			case 3:
				this.w = value;
				break;
			default: throw new Error("index is out of range: " + index);
		}
		return this;
	}
	/**
	* Returns the value of the vector component which matches the given index.
	*
	* @param {number} index - The component index. `0` equals to x, `1` equals to y,
	* `2` equals to z, `3` equals to w.
	* @return {number} A vector component value.
	*/
	getComponent(index) {
		switch (index) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error("index is out of range: " + index);
		}
	}
	/**
	* Returns a new vector with copied values from this instance.
	*
	* @return {Vector4} A clone of this instance.
	*/
	clone() {
		return new this.constructor(this.x, this.y, this.z, this.w);
	}
	/**
	* Copies the values of the given vector to this instance.
	*
	* @param {Vector3|Vector4} v - The vector to copy.
	* @return {Vector4} A reference to this vector.
	*/
	copy(v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = v.w !== void 0 ? v.w : 1;
		return this;
	}
	/**
	* Adds the given vector to this instance.
	*
	* @param {Vector4} v - The vector to add.
	* @return {Vector4} A reference to this vector.
	*/
	add(v) {
		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;
		return this;
	}
	/**
	* Adds the given scalar value to all components of this instance.
	*
	* @param {number} s - The scalar to add.
	* @return {Vector4} A reference to this vector.
	*/
	addScalar(s) {
		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;
		return this;
	}
	/**
	* Adds the given vectors and stores the result in this instance.
	*
	* @param {Vector4} a - The first vector.
	* @param {Vector4} b - The second vector.
	* @return {Vector4} A reference to this vector.
	*/
	addVectors(a$1, b$2) {
		this.x = a$1.x + b$2.x;
		this.y = a$1.y + b$2.y;
		this.z = a$1.z + b$2.z;
		this.w = a$1.w + b$2.w;
		return this;
	}
	/**
	* Adds the given vector scaled by the given factor to this instance.
	*
	* @param {Vector4} v - The vector.
	* @param {number} s - The factor that scales `v`.
	* @return {Vector4} A reference to this vector.
	*/
	addScaledVector(v, s) {
		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;
		return this;
	}
	/**
	* Subtracts the given vector from this instance.
	*
	* @param {Vector4} v - The vector to subtract.
	* @return {Vector4} A reference to this vector.
	*/
	sub(v) {
		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;
		return this;
	}
	/**
	* Subtracts the given scalar value from all components of this instance.
	*
	* @param {number} s - The scalar to subtract.
	* @return {Vector4} A reference to this vector.
	*/
	subScalar(s) {
		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;
		return this;
	}
	/**
	* Subtracts the given vectors and stores the result in this instance.
	*
	* @param {Vector4} a - The first vector.
	* @param {Vector4} b - The second vector.
	* @return {Vector4} A reference to this vector.
	*/
	subVectors(a$1, b$2) {
		this.x = a$1.x - b$2.x;
		this.y = a$1.y - b$2.y;
		this.z = a$1.z - b$2.z;
		this.w = a$1.w - b$2.w;
		return this;
	}
	/**
	* Multiplies the given vector with this instance.
	*
	* @param {Vector4} v - The vector to multiply.
	* @return {Vector4} A reference to this vector.
	*/
	multiply(v) {
		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;
		return this;
	}
	/**
	* Multiplies the given scalar value with all components of this instance.
	*
	* @param {number} scalar - The scalar to multiply.
	* @return {Vector4} A reference to this vector.
	*/
	multiplyScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;
		return this;
	}
	/**
	* Multiplies this vector with the given 4x4 matrix.
	*
	* @param {Matrix4} m - The 4x4 matrix.
	* @return {Vector4} A reference to this vector.
	*/
	applyMatrix4(m$1) {
		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m$1.elements;
		this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
		this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
		this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
		return this;
	}
	/**
	* Divides this instance by the given vector.
	*
	* @param {Vector4} v - The vector to divide.
	* @return {Vector4} A reference to this vector.
	*/
	divide(v) {
		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;
		this.w /= v.w;
		return this;
	}
	/**
	* Divides this vector by the given scalar.
	*
	* @param {number} scalar - The scalar to divide.
	* @return {Vector4} A reference to this vector.
	*/
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar);
	}
	/**
	* Sets the x, y and z components of this
	* vector to the quaternion's axis and w to the angle.
	*
	* @param {Quaternion} q - The Quaternion to set.
	* @return {Vector4} A reference to this vector.
	*/
	setAxisAngleFromQuaternion(q) {
		this.w = 2 * Math.acos(q.w);
		const s = Math.sqrt(1 - q.w * q.w);
		if (s < 1e-4) {
			this.x = 1;
			this.y = 0;
			this.z = 0;
		} else {
			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;
		}
		return this;
	}
	/**
	* Sets the x, y and z components of this
	* vector to the axis of rotation and w to the angle.
	*
	* @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
	* @return {Vector4} A reference to this vector.
	*/
	setAxisAngleFromRotationMatrix(m$1) {
		let angle, x, y, z;
		const epsilon = .01, epsilon2 = .1, te = m$1.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
		if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
			if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
				this.set(1, 0, 0, 0);
				return this;
			}
			angle = Math.PI;
			const xx = (m11 + 1) / 2;
			const yy = (m22 + 1) / 2;
			const zz = (m33 + 1) / 2;
			const xy$1 = (m12 + m21) / 4;
			const xz = (m13 + m31) / 4;
			const yz = (m23 + m32) / 4;
			if (xx > yy && xx > zz) if (xx < epsilon) {
				x = 0;
				y = .707106781;
				z = .707106781;
			} else {
				x = Math.sqrt(xx);
				y = xy$1 / x;
				z = xz / x;
			}
			else if (yy > zz) if (yy < epsilon) {
				x = .707106781;
				y = 0;
				z = .707106781;
			} else {
				y = Math.sqrt(yy);
				x = xy$1 / y;
				z = yz / y;
			}
			else if (zz < epsilon) {
				x = .707106781;
				y = .707106781;
				z = 0;
			} else {
				z = Math.sqrt(zz);
				x = xz / z;
				y = yz / z;
			}
			this.set(x, y, z, angle);
			return this;
		}
		let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
		if (Math.abs(s) < .001) s = 1;
		this.x = (m32 - m23) / s;
		this.y = (m13 - m31) / s;
		this.z = (m21 - m12) / s;
		this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
		return this;
	}
	/**
	* Sets the vector components to the position elements of the
	* given transformation matrix.
	*
	* @param {Matrix4} m - The 4x4 matrix.
	* @return {Vector4} A reference to this vector.
	*/
	setFromMatrixPosition(m$1) {
		const e = m$1.elements;
		this.x = e[12];
		this.y = e[13];
		this.z = e[14];
		this.w = e[15];
		return this;
	}
	/**
	* If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
	* value, replace that value with the corresponding min value.
	*
	* @param {Vector4} v - The vector.
	* @return {Vector4} A reference to this vector.
	*/
	min(v) {
		this.x = Math.min(this.x, v.x);
		this.y = Math.min(this.y, v.y);
		this.z = Math.min(this.z, v.z);
		this.w = Math.min(this.w, v.w);
		return this;
	}
	/**
	* If this vector's x, y, z or w value is less than the given vector's x, y, z or w
	* value, replace that value with the corresponding max value.
	*
	* @param {Vector4} v - The vector.
	* @return {Vector4} A reference to this vector.
	*/
	max(v) {
		this.x = Math.max(this.x, v.x);
		this.y = Math.max(this.y, v.y);
		this.z = Math.max(this.z, v.z);
		this.w = Math.max(this.w, v.w);
		return this;
	}
	/**
	* If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
	* value, it is replaced by the corresponding value.
	* If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
	* it is replaced by the corresponding value.
	*
	* @param {Vector4} min - The minimum x, y and z values.
	* @param {Vector4} max - The maximum x, y and z values in the desired range.
	* @return {Vector4} A reference to this vector.
	*/
	clamp(min$3, max$3) {
		this.x = clamp$3(this.x, min$3.x, max$3.x);
		this.y = clamp$3(this.y, min$3.y, max$3.y);
		this.z = clamp$3(this.z, min$3.z, max$3.z);
		this.w = clamp$3(this.w, min$3.w, max$3.w);
		return this;
	}
	/**
	* If this vector's x, y, z or w values are greater than the max value, they are
	* replaced by the max value.
	* If this vector's x, y, z or w values are less than the min value, they are
	* replaced by the min value.
	*
	* @param {number} minVal - The minimum value the components will be clamped to.
	* @param {number} maxVal - The maximum value the components will be clamped to.
	* @return {Vector4} A reference to this vector.
	*/
	clampScalar(minVal, maxVal) {
		this.x = clamp$3(this.x, minVal, maxVal);
		this.y = clamp$3(this.y, minVal, maxVal);
		this.z = clamp$3(this.z, minVal, maxVal);
		this.w = clamp$3(this.w, minVal, maxVal);
		return this;
	}
	/**
	* If this vector's length is greater than the max value, it is replaced by
	* the max value.
	* If this vector's length is less than the min value, it is replaced by the
	* min value.
	*
	* @param {number} min - The minimum value the vector length will be clamped to.
	* @param {number} max - The maximum value the vector length will be clamped to.
	* @return {Vector4} A reference to this vector.
	*/
	clampLength(min$3, max$3) {
		const length$2 = this.length();
		return this.divideScalar(length$2 || 1).multiplyScalar(clamp$3(length$2, min$3, max$3));
	}
	/**
	* The components of this vector are rounded down to the nearest integer value.
	*
	* @return {Vector4} A reference to this vector.
	*/
	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		this.w = Math.floor(this.w);
		return this;
	}
	/**
	* The components of this vector are rounded up to the nearest integer value.
	*
	* @return {Vector4} A reference to this vector.
	*/
	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		this.w = Math.ceil(this.w);
		return this;
	}
	/**
	* The components of this vector are rounded to the nearest integer value
	*
	* @return {Vector4} A reference to this vector.
	*/
	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		this.w = Math.round(this.w);
		return this;
	}
	/**
	* The components of this vector are rounded towards zero (up if negative,
	* down if positive) to an integer value.
	*
	* @return {Vector4} A reference to this vector.
	*/
	roundToZero() {
		this.x = Math.trunc(this.x);
		this.y = Math.trunc(this.y);
		this.z = Math.trunc(this.z);
		this.w = Math.trunc(this.w);
		return this;
	}
	/**
	* Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
	*
	* @return {Vector4} A reference to this vector.
	*/
	negate() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		this.w = -this.w;
		return this;
	}
	/**
	* Calculates the dot product of the given vector with this instance.
	*
	* @param {Vector4} v - The vector to compute the dot product with.
	* @return {number} The result of the dot product.
	*/
	dot(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	}
	/**
	* Computes the square of the Euclidean length (straight-line length) from
	* (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
	* compare the length squared instead as it is slightly more efficient to calculate.
	*
	* @return {number} The square length of this vector.
	*/
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}
	/**
	* Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
	*
	* @return {number} The length of this vector.
	*/
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}
	/**
	* Computes the Manhattan length of this vector.
	*
	* @return {number} The length of this vector.
	*/
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
	}
	/**
	* Converts this vector to a unit vector - that is, sets it equal to a vector
	* with the same direction as this one, but with a vector length of `1`.
	*
	* @return {Vector4} A reference to this vector.
	*/
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	/**
	* Sets this vector to a vector with the same direction as this one, but
	* with the specified length.
	*
	* @param {number} length - The new length of this vector.
	* @return {Vector4} A reference to this vector.
	*/
	setLength(length$2) {
		return this.normalize().multiplyScalar(length$2);
	}
	/**
	* Linearly interpolates between the given vector and this instance, where
	* alpha is the percent distance along the line - alpha = 0 will be this
	* vector, and alpha = 1 will be the given one.
	*
	* @param {Vector4} v - The vector to interpolate towards.
	* @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	* @return {Vector4} A reference to this vector.
	*/
	lerp(v, alpha) {
		this.x += (v.x - this.x) * alpha;
		this.y += (v.y - this.y) * alpha;
		this.z += (v.z - this.z) * alpha;
		this.w += (v.w - this.w) * alpha;
		return this;
	}
	/**
	* Linearly interpolates between the given vectors, where alpha is the percent
	* distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	* be the second one. The result is stored in this instance.
	*
	* @param {Vector4} v1 - The first vector.
	* @param {Vector4} v2 - The second vector.
	* @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	* @return {Vector4} A reference to this vector.
	*/
	lerpVectors(v1, v2, alpha) {
		this.x = v1.x + (v2.x - v1.x) * alpha;
		this.y = v1.y + (v2.y - v1.y) * alpha;
		this.z = v1.z + (v2.z - v1.z) * alpha;
		this.w = v1.w + (v2.w - v1.w) * alpha;
		return this;
	}
	/**
	* Returns `true` if this vector is equal with the given one.
	*
	* @param {Vector4} v - The vector to test for equality.
	* @return {boolean} Whether this vector is equal with the given one.
	*/
	equals(v) {
		return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
	}
	/**
	* Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
	* z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
	*
	* @param {Array<number>} array - An array holding the vector component values.
	* @param {number} [offset=0] - The offset into the array.
	* @return {Vector4} A reference to this vector.
	*/
	fromArray(array$2, offset = 0) {
		this.x = array$2[offset];
		this.y = array$2[offset + 1];
		this.z = array$2[offset + 2];
		this.w = array$2[offset + 3];
		return this;
	}
	/**
	* Writes the components of this vector to the given array. If no array is provided,
	* the method returns a new instance.
	*
	* @param {Array<number>} [array=[]] - The target array holding the vector components.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Array<number>} The vector components.
	*/
	toArray(array$2 = [], offset = 0) {
		array$2[offset] = this.x;
		array$2[offset + 1] = this.y;
		array$2[offset + 2] = this.z;
		array$2[offset + 3] = this.w;
		return array$2;
	}
	/**
	* Sets the components of this vector from the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	* @param {number} index - The index into the attribute.
	* @return {Vector4} A reference to this vector.
	*/
	fromBufferAttribute(attribute$2, index) {
		this.x = attribute$2.getX(index);
		this.y = attribute$2.getY(index);
		this.z = attribute$2.getZ(index);
		this.w = attribute$2.getW(index);
		return this;
	}
	/**
	* Sets each component of this vector to a pseudo-random value between `0` and
	* `1`, excluding `1`.
	*
	* @return {Vector4} A reference to this vector.
	*/
	random() {
		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();
		return this;
	}
	*[Symbol.iterator]() {
		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;
	}
};
/**
* A render target is a buffer where the video card draws pixels for a scene
* that is being rendered in the background. It is used in different effects,
* such as applying postprocessing to a rendered image before displaying it
* on the screen.
*
* @augments EventDispatcher
*/
var RenderTarget = class extends EventDispatcher {
	/**
	* Render target options.
	*
	* @typedef {Object} RenderTarget~Options
	* @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
	* @property {number} [magFilter=LinearFilter] - The mag filter.
	* @property {number} [minFilter=LinearFilter] - The min filter.
	* @property {number} [format=RGBAFormat] - The texture format.
	* @property {number} [type=UnsignedByteType] - The texture type.
	* @property {?string} [internalFormat=null] - The texture's internal format.
	* @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
	* @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
	* @property {number} [anisotropy=1] - The texture's anisotropy value.
	* @property {string} [colorSpace=NoColorSpace] - The texture's color space.
	* @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
	* @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
	* @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
	* @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
	* @property {?Texture} [depthTexture=null] - Reference to a depth texture.
	* @property {number} [samples=0] - The MSAA samples count.
	* @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
	* @property {number} [depth=1] - The texture depth.
	* @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
	*/
	/**
	* Constructs a new render target.
	*
	* @param {number} [width=1] - The width of the render target.
	* @param {number} [height=1] - The height of the render target.
	* @param {RenderTarget~Options} [options] - The configuration object.
	*/
	constructor(width = 1, height = 1, options = {}) {
		super();
		options = Object.assign({
			generateMipmaps: false,
			internalFormat: null,
			minFilter: LinearFilter,
			depthBuffer: true,
			stencilBuffer: false,
			resolveDepthBuffer: true,
			resolveStencilBuffer: true,
			depthTexture: null,
			samples: 0,
			count: 1,
			depth: 1,
			multiview: false
		}, options);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isRenderTarget = true;
		/**
		* The width of the render target.
		*
		* @type {number}
		* @default 1
		*/
		this.width = width;
		/**
		* The height of the render target.
		*
		* @type {number}
		* @default 1
		*/
		this.height = height;
		/**
		* The depth of the render target.
		*
		* @type {number}
		* @default 1
		*/
		this.depth = options.depth;
		/**
		* A rectangular area inside the render target's viewport. Fragments that are
		* outside the area will be discarded.
		*
		* @type {Vector4}
		* @default (0,0,width,height)
		*/
		this.scissor = new Vector4(0, 0, width, height);
		/**
		* Indicates whether the scissor test should be enabled when rendering into
		* this render target or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.scissorTest = false;
		/**
		* A rectangular area representing the render target's viewport.
		*
		* @type {Vector4}
		* @default (0,0,width,height)
		*/
		this.viewport = new Vector4(0, 0, width, height);
		const image = {
			width,
			height,
			depth: options.depth
		};
		const texture$2 = new Texture(image);
		/**
		* An array of textures. Each color attachment is represented as a separate texture.
		* Has at least a single entry for the default color attachment.
		*
		* @type {Array<Texture>}
		*/
		this.textures = [];
		const count = options.count;
		for (let i = 0; i < count; i++) {
			this.textures[i] = texture$2.clone();
			this.textures[i].isRenderTargetTexture = true;
			this.textures[i].renderTarget = this;
		}
		this._setTextureOptions(options);
		/**
		* Whether to allocate a depth buffer or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.depthBuffer = options.depthBuffer;
		/**
		* Whether to allocate a stencil buffer or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.stencilBuffer = options.stencilBuffer;
		/**
		* Whether to resolve the depth buffer or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.resolveDepthBuffer = options.resolveDepthBuffer;
		/**
		* Whether to resolve the stencil buffer or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.resolveStencilBuffer = options.resolveStencilBuffer;
		this._depthTexture = null;
		this.depthTexture = options.depthTexture;
		/**
		* The number of MSAA samples.
		*
		* A value of `0` disables MSAA.
		*
		* @type {number}
		* @default 0
		*/
		this.samples = options.samples;
		/**
		* Whether to this target is used in multiview rendering.
		*
		* @type {boolean}
		* @default false
		*/
		this.multiview = options.multiview;
	}
	_setTextureOptions(options = {}) {
		const values = {
			minFilter: LinearFilter,
			generateMipmaps: false,
			flipY: false,
			internalFormat: null
		};
		if (options.mapping !== void 0) values.mapping = options.mapping;
		if (options.wrapS !== void 0) values.wrapS = options.wrapS;
		if (options.wrapT !== void 0) values.wrapT = options.wrapT;
		if (options.wrapR !== void 0) values.wrapR = options.wrapR;
		if (options.magFilter !== void 0) values.magFilter = options.magFilter;
		if (options.minFilter !== void 0) values.minFilter = options.minFilter;
		if (options.format !== void 0) values.format = options.format;
		if (options.type !== void 0) values.type = options.type;
		if (options.anisotropy !== void 0) values.anisotropy = options.anisotropy;
		if (options.colorSpace !== void 0) values.colorSpace = options.colorSpace;
		if (options.flipY !== void 0) values.flipY = options.flipY;
		if (options.generateMipmaps !== void 0) values.generateMipmaps = options.generateMipmaps;
		if (options.internalFormat !== void 0) values.internalFormat = options.internalFormat;
		for (let i = 0; i < this.textures.length; i++) this.textures[i].setValues(values);
	}
	/**
	* The texture representing the default color attachment.
	*
	* @type {Texture}
	*/
	get texture() {
		return this.textures[0];
	}
	set texture(value) {
		this.textures[0] = value;
	}
	set depthTexture(current) {
		if (this._depthTexture !== null) this._depthTexture.renderTarget = null;
		if (current !== null) current.renderTarget = this;
		this._depthTexture = current;
	}
	/**
	* Instead of saving the depth in a renderbuffer, a texture
	* can be used instead which is useful for further processing
	* e.g. in context of post-processing.
	*
	* @type {?DepthTexture}
	* @default null
	*/
	get depthTexture() {
		return this._depthTexture;
	}
	/**
	* Sets the size of this render target.
	*
	* @param {number} width - The width.
	* @param {number} height - The height.
	* @param {number} [depth=1] - The depth.
	*/
	setSize(width, height, depth$2 = 1) {
		if (this.width !== width || this.height !== height || this.depth !== depth$2) {
			this.width = width;
			this.height = height;
			this.depth = depth$2;
			for (let i = 0, il = this.textures.length; i < il; i++) {
				this.textures[i].image.width = width;
				this.textures[i].image.height = height;
				this.textures[i].image.depth = depth$2;
				if (this.textures[i].isData3DTexture !== true) this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
			}
			this.dispose();
		}
		this.viewport.set(0, 0, width, height);
		this.scissor.set(0, 0, width, height);
	}
	/**
	* Returns a new render target with copied values from this instance.
	*
	* @return {RenderTarget} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	/**
	* Copies the settings of the given render target. This is a structural copy so
	* no resources are shared between render targets after the copy. That includes
	* all MRT textures and the depth texture.
	*
	* @param {RenderTarget} source - The render target to copy.
	* @return {RenderTarget} A reference to this instance.
	*/
	copy(source) {
		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;
		this.scissor.copy(source.scissor);
		this.scissorTest = source.scissorTest;
		this.viewport.copy(source.viewport);
		this.textures.length = 0;
		for (let i = 0, il = source.textures.length; i < il; i++) {
			this.textures[i] = source.textures[i].clone();
			this.textures[i].isRenderTargetTexture = true;
			this.textures[i].renderTarget = this;
			const image = Object.assign({}, source.textures[i].image);
			this.textures[i].source = new Source(image);
		}
		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.resolveDepthBuffer = source.resolveDepthBuffer;
		this.resolveStencilBuffer = source.resolveStencilBuffer;
		if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
		this.samples = source.samples;
		return this;
	}
	/**
	* Frees the GPU-related resources allocated by this instance. Call this
	* method whenever this instance is no longer used in your app.
	*
	* @fires RenderTarget#dispose
	*/
	dispose() {
		this.dispatchEvent({ type: "dispose" });
	}
};
/**
* A render target used in context of {@link WebGLRenderer}.
*
* @augments RenderTarget
*/
var WebGLRenderTarget = class extends RenderTarget {
	/**
	* Constructs a new 3D render target.
	*
	* @param {number} [width=1] - The width of the render target.
	* @param {number} [height=1] - The height of the render target.
	* @param {RenderTarget~Options} [options] - The configuration object.
	*/
	constructor(width = 1, height = 1, options = {}) {
		super(width, height, options);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isWebGLRenderTarget = true;
	}
};
/**
* Creates an array of textures directly from raw buffer data.
*
* @augments Texture
*/
var DataArrayTexture = class extends Texture {
	/**
	* Constructs a new data array texture.
	*
	* @param {?TypedArray} [data=null] - The buffer data.
	* @param {number} [width=1] - The width of the texture.
	* @param {number} [height=1] - The height of the texture.
	* @param {number} [depth=1] - The depth of the texture.
	*/
	constructor(data = null, width = 1, height = 1, depth$2 = 1) {
		super(null);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isDataArrayTexture = true;
		/**
		* The image definition of a data texture.
		*
		* @type {{data:TypedArray,width:number,height:number,depth:number}}
		*/
		this.image = {
			data,
			width,
			height,
			depth: depth$2
		};
		/**
		* How the texture is sampled when a texel covers more than one pixel.
		*
		* Overwritten and set to `NearestFilter` by default.
		*
		* @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		* @default NearestFilter
		*/
		this.magFilter = NearestFilter;
		/**
		* How the texture is sampled when a texel covers less than one pixel.
		*
		* Overwritten and set to `NearestFilter` by default.
		*
		* @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		* @default NearestFilter
		*/
		this.minFilter = NearestFilter;
		/**
		* This defines how the texture is wrapped in the depth and corresponds to
		* *W* in UVW mapping.
		*
		* @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		* @default ClampToEdgeWrapping
		*/
		this.wrapR = ClampToEdgeWrapping;
		/**
		* Whether to generate mipmaps (if possible) for a texture.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.generateMipmaps = false;
		/**
		* If set to `true`, the texture is flipped along the vertical axis when
		* uploaded to the GPU.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.flipY = false;
		/**
		* Specifies the alignment requirements for the start of each pixel row in memory.
		*
		* Overwritten and set to `1` by default.
		*
		* @type {boolean}
		* @default 1
		*/
		this.unpackAlignment = 1;
		/**
		* A set of all layers which need to be updated in the texture.
		*
		* @type {Set<number>}
		*/
		this.layerUpdates = /* @__PURE__ */ new Set();
	}
	/**
	* Describes that a specific layer of the texture needs to be updated.
	* Normally when {@link Texture#needsUpdate} is set to `true`, the
	* entire data texture array is sent to the GPU. Marking specific
	* layers will only transmit subsets of all mipmaps associated with a
	* specific depth in the array which is often much more performant.
	*
	* @param {number} layerIndex - The layer index that should be updated.
	*/
	addLayerUpdate(layerIndex) {
		this.layerUpdates.add(layerIndex);
	}
	/**
	* Resets the layer updates registry.
	*/
	clearLayerUpdates() {
		this.layerUpdates.clear();
	}
};
/**
* Creates a three-dimensional texture from raw data, with parameters to
* divide it into width, height, and depth.
*
* @augments Texture
*/
var Data3DTexture = class extends Texture {
	/**
	* Constructs a new data array texture.
	*
	* @param {?TypedArray} [data=null] - The buffer data.
	* @param {number} [width=1] - The width of the texture.
	* @param {number} [height=1] - The height of the texture.
	* @param {number} [depth=1] - The depth of the texture.
	*/
	constructor(data = null, width = 1, height = 1, depth$2 = 1) {
		super(null);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isData3DTexture = true;
		/**
		* The image definition of a data texture.
		*
		* @type {{data:TypedArray,width:number,height:number,depth:number}}
		*/
		this.image = {
			data,
			width,
			height,
			depth: depth$2
		};
		/**
		* How the texture is sampled when a texel covers more than one pixel.
		*
		* Overwritten and set to `NearestFilter` by default.
		*
		* @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		* @default NearestFilter
		*/
		this.magFilter = NearestFilter;
		/**
		* How the texture is sampled when a texel covers less than one pixel.
		*
		* Overwritten and set to `NearestFilter` by default.
		*
		* @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		* @default NearestFilter
		*/
		this.minFilter = NearestFilter;
		/**
		* This defines how the texture is wrapped in the depth and corresponds to
		* *W* in UVW mapping.
		*
		* @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		* @default ClampToEdgeWrapping
		*/
		this.wrapR = ClampToEdgeWrapping;
		/**
		* Whether to generate mipmaps (if possible) for a texture.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.generateMipmaps = false;
		/**
		* If set to `true`, the texture is flipped along the vertical axis when
		* uploaded to the GPU.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.flipY = false;
		/**
		* Specifies the alignment requirements for the start of each pixel row in memory.
		*
		* Overwritten and set to `1` by default.
		*
		* @type {boolean}
		* @default 1
		*/
		this.unpackAlignment = 1;
	}
};
/**
* Represents an axis-aligned bounding box (AABB) in 3D space.
*/
var Box3 = class {
	/**
	* Constructs a new bounding box.
	*
	* @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
	* @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
	*/
	constructor(min$3 = new Vector3(Infinity, Infinity, Infinity), max$3 = new Vector3(-Infinity, -Infinity, -Infinity)) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isBox3 = true;
		/**
		* The lower boundary of the box.
		*
		* @type {Vector3}
		*/
		this.min = min$3;
		/**
		* The upper boundary of the box.
		*
		* @type {Vector3}
		*/
		this.max = max$3;
	}
	/**
	* Sets the lower and upper boundaries of this box.
	* Please note that this method only copies the values from the given objects.
	*
	* @param {Vector3} min - The lower boundary of the box.
	* @param {Vector3} max - The upper boundary of the box.
	* @return {Box3} A reference to this bounding box.
	*/
	set(min$3, max$3) {
		this.min.copy(min$3);
		this.max.copy(max$3);
		return this;
	}
	/**
	* Sets the upper and lower bounds of this box so it encloses the position data
	* in the given array.
	*
	* @param {Array<number>} array - An array holding 3D position data.
	* @return {Box3} A reference to this bounding box.
	*/
	setFromArray(array$2) {
		this.makeEmpty();
		for (let i = 0, il = array$2.length; i < il; i += 3) this.expandByPoint(_vector$b.fromArray(array$2, i));
		return this;
	}
	/**
	* Sets the upper and lower bounds of this box so it encloses the position data
	* in the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
	* @return {Box3} A reference to this bounding box.
	*/
	setFromBufferAttribute(attribute$2) {
		this.makeEmpty();
		for (let i = 0, il = attribute$2.count; i < il; i++) this.expandByPoint(_vector$b.fromBufferAttribute(attribute$2, i));
		return this;
	}
	/**
	* Sets the upper and lower bounds of this box so it encloses the position data
	* in the given array.
	*
	* @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
	* @return {Box3} A reference to this bounding box.
	*/
	setFromPoints(points) {
		this.makeEmpty();
		for (let i = 0, il = points.length; i < il; i++) this.expandByPoint(points[i]);
		return this;
	}
	/**
	* Centers this box on the given center vector and sets this box's width, height and
	* depth to the given size values.
	*
	* @param {Vector3} center - The center of the box.
	* @param {Vector3} size - The x, y and z dimensions of the box.
	* @return {Box3} A reference to this bounding box.
	*/
	setFromCenterAndSize(center, size) {
		const halfSize = _vector$b.copy(size).multiplyScalar(.5);
		this.min.copy(center).sub(halfSize);
		this.max.copy(center).add(halfSize);
		return this;
	}
	/**
	* Computes the world-axis-aligned bounding box for the given 3D object
	* (including its children), accounting for the object's, and children's,
	* world transforms. The function may result in a larger box than strictly necessary.
	*
	* @param {Object3D} object - The 3D object to compute the bounding box for.
	* @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
	* world-axis-aligned bounding box at the expense of more computation.
	* @return {Box3} A reference to this bounding box.
	*/
	setFromObject(object, precise = false) {
		this.makeEmpty();
		return this.expandByObject(object, precise);
	}
	/**
	* Returns a new box with copied values from this instance.
	*
	* @return {Box3} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	/**
	* Copies the values of the given box to this instance.
	*
	* @param {Box3} box - The box to copy.
	* @return {Box3} A reference to this bounding box.
	*/
	copy(box) {
		this.min.copy(box.min);
		this.max.copy(box.max);
		return this;
	}
	/**
	* Makes this box empty which means in encloses a zero space in 3D.
	*
	* @return {Box3} A reference to this bounding box.
	*/
	makeEmpty() {
		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = -Infinity;
		return this;
	}
	/**
	* Returns true if this box includes zero points within its bounds.
	* Note that a box with equal lower and upper bounds still includes one
	* point, the one both bounds share.
	*
	* @return {boolean} Whether this box is empty or not.
	*/
	isEmpty() {
		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
	}
	/**
	* Returns the center point of this box.
	*
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The center point.
	*/
	getCenter(target) {
		return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(.5);
	}
	/**
	* Returns the dimensions of this box.
	*
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The size.
	*/
	getSize(target) {
		return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
	}
	/**
	* Expands the boundaries of this box to include the given point.
	*
	* @param {Vector3} point - The point that should be included by the bounding box.
	* @return {Box3} A reference to this bounding box.
	*/
	expandByPoint(point) {
		this.min.min(point);
		this.max.max(point);
		return this;
	}
	/**
	* Expands this box equilaterally by the given vector. The width of this
	* box will be expanded by the x component of the vector in both
	* directions. The height of this box will be expanded by the y component of
	* the vector in both directions. The depth of this box will be
	* expanded by the z component of the vector in both directions.
	*
	* @param {Vector3} vector - The vector that should expand the bounding box.
	* @return {Box3} A reference to this bounding box.
	*/
	expandByVector(vector) {
		this.min.sub(vector);
		this.max.add(vector);
		return this;
	}
	/**
	* Expands each dimension of the box by the given scalar. If negative, the
	* dimensions of the box will be contracted.
	*
	* @param {number} scalar - The scalar value that should expand the bounding box.
	* @return {Box3} A reference to this bounding box.
	*/
	expandByScalar(scalar) {
		this.min.addScalar(-scalar);
		this.max.addScalar(scalar);
		return this;
	}
	/**
	* Expands the boundaries of this box to include the given 3D object and
	* its children, accounting for the object's, and children's, world
	* transforms. The function may result in a larger box than strictly
	* necessary (unless the precise parameter is set to true).
	*
	* @param {Object3D} object - The 3D object that should expand the bounding box.
	* @param {boolean} precise - If set to `true`, the method expands the bounding box
	* as little as necessary at the expense of more computation.
	* @return {Box3} A reference to this bounding box.
	*/
	expandByObject(object, precise = false) {
		object.updateWorldMatrix(false, false);
		const geometry = object.geometry;
		if (geometry !== void 0) {
			const positionAttribute = geometry.getAttribute("position");
			if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) for (let i = 0, l = positionAttribute.count; i < l; i++) {
				if (object.isMesh === true) object.getVertexPosition(i, _vector$b);
				else _vector$b.fromBufferAttribute(positionAttribute, i);
				_vector$b.applyMatrix4(object.matrixWorld);
				this.expandByPoint(_vector$b);
			}
			else {
				if (object.boundingBox !== void 0) {
					if (object.boundingBox === null) object.computeBoundingBox();
					_box$4.copy(object.boundingBox);
				} else {
					if (geometry.boundingBox === null) geometry.computeBoundingBox();
					_box$4.copy(geometry.boundingBox);
				}
				_box$4.applyMatrix4(object.matrixWorld);
				this.union(_box$4);
			}
		}
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) this.expandByObject(children[i], precise);
		return this;
	}
	/**
	* Returns `true` if the given point lies within or on the boundaries of this box.
	*
	* @param {Vector3} point - The point to test.
	* @return {boolean} Whether the bounding box contains the given point or not.
	*/
	containsPoint(point) {
		return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
	}
	/**
	* Returns `true` if this bounding box includes the entirety of the given bounding box.
	* If this box and the given one are identical, this function also returns `true`.
	*
	* @param {Box3} box - The bounding box to test.
	* @return {boolean} Whether the bounding box contains the given bounding box or not.
	*/
	containsBox(box) {
		return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
	}
	/**
	* Returns a point as a proportion of this box's width, height and depth.
	*
	* @param {Vector3} point - A point in 3D space.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} A point as a proportion of this box's width, height and depth.
	*/
	getParameter(point, target) {
		return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
	}
	/**
	* Returns `true` if the given bounding box intersects with this bounding box.
	*
	* @param {Box3} box - The bounding box to test.
	* @return {boolean} Whether the given bounding box intersects with this bounding box.
	*/
	intersectsBox(box) {
		return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
	}
	/**
	* Returns `true` if the given bounding sphere intersects with this bounding box.
	*
	* @param {Sphere} sphere - The bounding sphere to test.
	* @return {boolean} Whether the given bounding sphere intersects with this bounding box.
	*/
	intersectsSphere(sphere) {
		this.clampPoint(sphere.center, _vector$b);
		return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
	}
	/**
	* Returns `true` if the given plane intersects with this bounding box.
	*
	* @param {Plane} plane - The plane to test.
	* @return {boolean} Whether the given plane intersects with this bounding box.
	*/
	intersectsPlane(plane) {
		let min$3, max$3;
		if (plane.normal.x > 0) {
			min$3 = plane.normal.x * this.min.x;
			max$3 = plane.normal.x * this.max.x;
		} else {
			min$3 = plane.normal.x * this.max.x;
			max$3 = plane.normal.x * this.min.x;
		}
		if (plane.normal.y > 0) {
			min$3 += plane.normal.y * this.min.y;
			max$3 += plane.normal.y * this.max.y;
		} else {
			min$3 += plane.normal.y * this.max.y;
			max$3 += plane.normal.y * this.min.y;
		}
		if (plane.normal.z > 0) {
			min$3 += plane.normal.z * this.min.z;
			max$3 += plane.normal.z * this.max.z;
		} else {
			min$3 += plane.normal.z * this.max.z;
			max$3 += plane.normal.z * this.min.z;
		}
		return min$3 <= -plane.constant && max$3 >= -plane.constant;
	}
	/**
	* Returns `true` if the given triangle intersects with this bounding box.
	*
	* @param {Triangle} triangle - The triangle to test.
	* @return {boolean} Whether the given triangle intersects with this bounding box.
	*/
	intersectsTriangle(triangle) {
		if (this.isEmpty()) return false;
		this.getCenter(_center);
		_extents.subVectors(this.max, _center);
		_v0$2.subVectors(triangle.a, _center);
		_v1$7.subVectors(triangle.b, _center);
		_v2$4.subVectors(triangle.c, _center);
		_f0.subVectors(_v1$7, _v0$2);
		_f1.subVectors(_v2$4, _v1$7);
		_f2.subVectors(_v0$2, _v2$4);
		let axes = [
			0,
			-_f0.z,
			_f0.y,
			0,
			-_f1.z,
			_f1.y,
			0,
			-_f2.z,
			_f2.y,
			_f0.z,
			0,
			-_f0.x,
			_f1.z,
			0,
			-_f1.x,
			_f2.z,
			0,
			-_f2.x,
			-_f0.y,
			_f0.x,
			0,
			-_f1.y,
			_f1.x,
			0,
			-_f2.y,
			_f2.x,
			0
		];
		if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) return false;
		axes = [
			1,
			0,
			0,
			0,
			1,
			0,
			0,
			0,
			1
		];
		if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) return false;
		_triangleNormal.crossVectors(_f0, _f1);
		axes = [
			_triangleNormal.x,
			_triangleNormal.y,
			_triangleNormal.z
		];
		return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
	}
	/**
	* Clamps the given point within the bounds of this box.
	*
	* @param {Vector3} point - The point to clamp.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The clamped point.
	*/
	clampPoint(point, target) {
		return target.copy(point).clamp(this.min, this.max);
	}
	/**
	* Returns the euclidean distance from any edge of this box to the specified point. If
	* the given point lies inside of this box, the distance will be `0`.
	*
	* @param {Vector3} point - The point to compute the distance to.
	* @return {number} The euclidean distance.
	*/
	distanceToPoint(point) {
		return this.clampPoint(point, _vector$b).distanceTo(point);
	}
	/**
	* Returns a bounding sphere that encloses this bounding box.
	*
	* @param {Sphere} target - The target sphere that is used to store the method's result.
	* @return {Sphere} The bounding sphere that encloses this bounding box.
	*/
	getBoundingSphere(target) {
		if (this.isEmpty()) target.makeEmpty();
		else {
			this.getCenter(target.center);
			target.radius = this.getSize(_vector$b).length() * .5;
		}
		return target;
	}
	/**
	* Computes the intersection of this bounding box and the given one, setting the upper
	* bound of this box to the lesser of the two boxes' upper bounds and the
	* lower bound of this box to the greater of the two boxes' lower bounds. If
	* there's no overlap, makes this box empty.
	*
	* @param {Box3} box - The bounding box to intersect with.
	* @return {Box3} A reference to this bounding box.
	*/
	intersect(box) {
		this.min.max(box.min);
		this.max.min(box.max);
		if (this.isEmpty()) this.makeEmpty();
		return this;
	}
	/**
	* Computes the union of this box and another and the given one, setting the upper
	* bound of this box to the greater of the two boxes' upper bounds and the
	* lower bound of this box to the lesser of the two boxes' lower bounds.
	*
	* @param {Box3} box - The bounding box that will be unioned with this instance.
	* @return {Box3} A reference to this bounding box.
	*/
	union(box) {
		this.min.min(box.min);
		this.max.max(box.max);
		return this;
	}
	/**
	* Transforms this bounding box by the given 4x4 transformation matrix.
	*
	* @param {Matrix4} matrix - The transformation matrix.
	* @return {Box3} A reference to this bounding box.
	*/
	applyMatrix4(matrix) {
		if (this.isEmpty()) return this;
		_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
		_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
		_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
		_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
		_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
		_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
		_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
		_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
		this.setFromPoints(_points);
		return this;
	}
	/**
	* Adds the given offset to both the upper and lower bounds of this bounding box,
	* effectively moving it in 3D space.
	*
	* @param {Vector3} offset - The offset that should be used to translate the bounding box.
	* @return {Box3} A reference to this bounding box.
	*/
	translate(offset) {
		this.min.add(offset);
		this.max.add(offset);
		return this;
	}
	/**
	* Returns `true` if this bounding box is equal with the given one.
	*
	* @param {Box3} box - The box to test for equality.
	* @return {boolean} Whether this bounding box is equal with the given one.
	*/
	equals(box) {
		return box.min.equals(this.min) && box.max.equals(this.max);
	}
	/**
	* Returns a serialized structure of the bounding box.
	*
	* @return {Object} Serialized structure with fields representing the object state.
	*/
	toJSON() {
		return {
			min: this.min.toArray(),
			max: this.max.toArray()
		};
	}
	/**
	* Returns a serialized structure of the bounding box.
	*
	* @param {Object} json - The serialized json to set the box from.
	* @return {Box3} A reference to this bounding box.
	*/
	fromJSON(json) {
		this.min.fromArray(json.min);
		this.max.fromArray(json.max);
		return this;
	}
};
var _points = [
	/* @__PURE__ */ new Vector3(),
	/* @__PURE__ */ new Vector3(),
	/* @__PURE__ */ new Vector3(),
	/* @__PURE__ */ new Vector3(),
	/* @__PURE__ */ new Vector3(),
	/* @__PURE__ */ new Vector3(),
	/* @__PURE__ */ new Vector3(),
	/* @__PURE__ */ new Vector3()
];
var _vector$b = /* @__PURE__ */ new Vector3();
var _box$4 = /* @__PURE__ */ new Box3();
var _v0$2 = /* @__PURE__ */ new Vector3();
var _v1$7 = /* @__PURE__ */ new Vector3();
var _v2$4 = /* @__PURE__ */ new Vector3();
var _f0 = /* @__PURE__ */ new Vector3();
var _f1 = /* @__PURE__ */ new Vector3();
var _f2 = /* @__PURE__ */ new Vector3();
var _center = /* @__PURE__ */ new Vector3();
var _extents = /* @__PURE__ */ new Vector3();
var _triangleNormal = /* @__PURE__ */ new Vector3();
var _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
	for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
		_testAxis.fromArray(axes, i);
		const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
		const p0 = v0.dot(_testAxis);
		const p1 = v1.dot(_testAxis);
		const p2 = v2.dot(_testAxis);
		if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) return false;
	}
	return true;
}
var _box$3 = /* @__PURE__ */ new Box3();
var _v1$6 = /* @__PURE__ */ new Vector3();
var _v2$3 = /* @__PURE__ */ new Vector3();
/**
* An analytical 3D sphere defined by a center and radius. This class is mainly
* used as a Bounding Sphere for 3D objects.
*/
var Sphere = class {
	/**
	* Constructs a new sphere.
	*
	* @param {Vector3} [center=(0,0,0)] - The center of the sphere
	* @param {number} [radius=-1] - The radius of the sphere.
	*/
	constructor(center = new Vector3(), radius = -1) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSphere = true;
		/**
		* The center of the sphere
		*
		* @type {Vector3}
		*/
		this.center = center;
		/**
		* The radius of the sphere.
		*
		* @type {number}
		*/
		this.radius = radius;
	}
	/**
	* Sets the sphere's components by copying the given values.
	*
	* @param {Vector3} center - The center.
	* @param {number} radius - The radius.
	* @return {Sphere} A reference to this sphere.
	*/
	set(center, radius) {
		this.center.copy(center);
		this.radius = radius;
		return this;
	}
	/**
	* Computes the minimum bounding sphere for list of points.
	* If the optional center point is given, it is used as the sphere's
	* center. Otherwise, the center of the axis-aligned bounding box
	* encompassing the points is calculated.
	*
	* @param {Array<Vector3>} points - A list of points in 3D space.
	* @param {Vector3} [optionalCenter] - The center of the sphere.
	* @return {Sphere} A reference to this sphere.
	*/
	setFromPoints(points, optionalCenter) {
		const center = this.center;
		if (optionalCenter !== void 0) center.copy(optionalCenter);
		else _box$3.setFromPoints(points).getCenter(center);
		let maxRadiusSq = 0;
		for (let i = 0, il = points.length; i < il; i++) maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
		this.radius = Math.sqrt(maxRadiusSq);
		return this;
	}
	/**
	* Copies the values of the given sphere to this instance.
	*
	* @param {Sphere} sphere - The sphere to copy.
	* @return {Sphere} A reference to this sphere.
	*/
	copy(sphere) {
		this.center.copy(sphere.center);
		this.radius = sphere.radius;
		return this;
	}
	/**
	* Returns `true` if the sphere is empty (the radius set to a negative number).
	*
	* Spheres with a radius of `0` contain only their center point and are not
	* considered to be empty.
	*
	* @return {boolean} Whether this sphere is empty or not.
	*/
	isEmpty() {
		return this.radius < 0;
	}
	/**
	* Makes this sphere empty which means in encloses a zero space in 3D.
	*
	* @return {Sphere} A reference to this sphere.
	*/
	makeEmpty() {
		this.center.set(0, 0, 0);
		this.radius = -1;
		return this;
	}
	/**
	* Returns `true` if this sphere contains the given point inclusive of
	* the surface of the sphere.
	*
	* @param {Vector3} point - The point to check.
	* @return {boolean} Whether this sphere contains the given point or not.
	*/
	containsPoint(point) {
		return point.distanceToSquared(this.center) <= this.radius * this.radius;
	}
	/**
	* Returns the closest distance from the boundary of the sphere to the
	* given point. If the sphere contains the point, the distance will
	* be negative.
	*
	* @param {Vector3} point - The point to compute the distance to.
	* @return {number} The distance to the point.
	*/
	distanceToPoint(point) {
		return point.distanceTo(this.center) - this.radius;
	}
	/**
	* Returns `true` if this sphere intersects with the given one.
	*
	* @param {Sphere} sphere - The sphere to test.
	* @return {boolean} Whether this sphere intersects with the given one or not.
	*/
	intersectsSphere(sphere) {
		const radiusSum = this.radius + sphere.radius;
		return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
	}
	/**
	* Returns `true` if this sphere intersects with the given box.
	*
	* @param {Box3} box - The box to test.
	* @return {boolean} Whether this sphere intersects with the given box or not.
	*/
	intersectsBox(box) {
		return box.intersectsSphere(this);
	}
	/**
	* Returns `true` if this sphere intersects with the given plane.
	*
	* @param {Plane} plane - The plane to test.
	* @return {boolean} Whether this sphere intersects with the given plane or not.
	*/
	intersectsPlane(plane) {
		return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
	}
	/**
	* Clamps a point within the sphere. If the point is outside the sphere, it
	* will clamp it to the closest point on the edge of the sphere. Points
	* already inside the sphere will not be affected.
	*
	* @param {Vector3} point - The plane to clamp.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The clamped point.
	*/
	clampPoint(point, target) {
		const deltaLengthSq = this.center.distanceToSquared(point);
		target.copy(point);
		if (deltaLengthSq > this.radius * this.radius) {
			target.sub(this.center).normalize();
			target.multiplyScalar(this.radius).add(this.center);
		}
		return target;
	}
	/**
	* Returns a bounding box that encloses this sphere.
	*
	* @param {Box3} target - The target box that is used to store the method's result.
	* @return {Box3} The bounding box that encloses this sphere.
	*/
	getBoundingBox(target) {
		if (this.isEmpty()) {
			target.makeEmpty();
			return target;
		}
		target.set(this.center, this.center);
		target.expandByScalar(this.radius);
		return target;
	}
	/**
	* Transforms this sphere with the given 4x4 transformation matrix.
	*
	* @param {Matrix4} matrix - The transformation matrix.
	* @return {Sphere} A reference to this sphere.
	*/
	applyMatrix4(matrix) {
		this.center.applyMatrix4(matrix);
		this.radius = this.radius * matrix.getMaxScaleOnAxis();
		return this;
	}
	/**
	* Translates the sphere's center by the given offset.
	*
	* @param {Vector3} offset - The offset.
	* @return {Sphere} A reference to this sphere.
	*/
	translate(offset) {
		this.center.add(offset);
		return this;
	}
	/**
	* Expands the boundaries of this sphere to include the given point.
	*
	* @param {Vector3} point - The point to include.
	* @return {Sphere} A reference to this sphere.
	*/
	expandByPoint(point) {
		if (this.isEmpty()) {
			this.center.copy(point);
			this.radius = 0;
			return this;
		}
		_v1$6.subVectors(point, this.center);
		const lengthSq$2 = _v1$6.lengthSq();
		if (lengthSq$2 > this.radius * this.radius) {
			const length$2 = Math.sqrt(lengthSq$2);
			const delta = (length$2 - this.radius) * .5;
			this.center.addScaledVector(_v1$6, delta / length$2);
			this.radius += delta;
		}
		return this;
	}
	/**
	* Expands this sphere to enclose both the original sphere and the given sphere.
	*
	* @param {Sphere} sphere - The sphere to include.
	* @return {Sphere} A reference to this sphere.
	*/
	union(sphere) {
		if (sphere.isEmpty()) return this;
		if (this.isEmpty()) {
			this.copy(sphere);
			return this;
		}
		if (this.center.equals(sphere.center) === true) this.radius = Math.max(this.radius, sphere.radius);
		else {
			_v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
			this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
			this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
		}
		return this;
	}
	/**
	* Returns `true` if this sphere is equal with the given one.
	*
	* @param {Sphere} sphere - The sphere to test for equality.
	* @return {boolean} Whether this bounding sphere is equal with the given one.
	*/
	equals(sphere) {
		return sphere.center.equals(this.center) && sphere.radius === this.radius;
	}
	/**
	* Returns a new sphere with copied values from this instance.
	*
	* @return {Sphere} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	/**
	* Returns a serialized structure of the bounding sphere.
	*
	* @return {Object} Serialized structure with fields representing the object state.
	*/
	toJSON() {
		return {
			radius: this.radius,
			center: this.center.toArray()
		};
	}
	/**
	* Returns a serialized structure of the bounding sphere.
	*
	* @param {Object} json - The serialized json to set the sphere from.
	* @return {Box3} A reference to this bounding sphere.
	*/
	fromJSON(json) {
		this.radius = json.radius;
		this.center.fromArray(json.center);
		return this;
	}
};
var _vector$a = /* @__PURE__ */ new Vector3();
var _segCenter = /* @__PURE__ */ new Vector3();
var _segDir = /* @__PURE__ */ new Vector3();
var _diff = /* @__PURE__ */ new Vector3();
var _edge1 = /* @__PURE__ */ new Vector3();
var _edge2 = /* @__PURE__ */ new Vector3();
var _normal$1 = /* @__PURE__ */ new Vector3();
/**
* A ray that emits from an origin in a certain direction. The class is used by
* {@link Raycaster} to assist with raycasting. Raycasting is used for
* mouse picking (working out what objects in the 3D space the mouse is over)
* amongst other things.
*/
var Ray = class {
	/**
	* Constructs a new ray.
	*
	* @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
	* @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
	*/
	constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
		/**
		* The origin of the ray.
		*
		* @type {Vector3}
		*/
		this.origin = origin;
		/**
		* The (normalized) direction of the ray.
		*
		* @type {Vector3}
		*/
		this.direction = direction;
	}
	/**
	* Sets the ray's components by copying the given values.
	*
	* @param {Vector3} origin - The origin.
	* @param {Vector3} direction - The direction.
	* @return {Ray} A reference to this ray.
	*/
	set(origin, direction) {
		this.origin.copy(origin);
		this.direction.copy(direction);
		return this;
	}
	/**
	* Copies the values of the given ray to this instance.
	*
	* @param {Ray} ray - The ray to copy.
	* @return {Ray} A reference to this ray.
	*/
	copy(ray) {
		this.origin.copy(ray.origin);
		this.direction.copy(ray.direction);
		return this;
	}
	/**
	* Returns a vector that is located at a given distance along this ray.
	*
	* @param {number} t - The distance along the ray to retrieve a position for.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} A position on the ray.
	*/
	at(t, target) {
		return target.copy(this.origin).addScaledVector(this.direction, t);
	}
	/**
	* Adjusts the direction of the ray to point at the given vector in world space.
	*
	* @param {Vector3} v - The target position.
	* @return {Ray} A reference to this ray.
	*/
	lookAt(v) {
		this.direction.copy(v).sub(this.origin).normalize();
		return this;
	}
	/**
	* Shift the origin of this ray along its direction by the given distance.
	*
	* @param {number} t - The distance along the ray to interpolate.
	* @return {Ray} A reference to this ray.
	*/
	recast(t) {
		this.origin.copy(this.at(t, _vector$a));
		return this;
	}
	/**
	* Returns the point along this ray that is closest to the given point.
	*
	* @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The closest point on this ray.
	*/
	closestPointToPoint(point, target) {
		target.subVectors(point, this.origin);
		const directionDistance = target.dot(this.direction);
		if (directionDistance < 0) return target.copy(this.origin);
		return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
	}
	/**
	* Returns the distance of the closest approach between this ray and the given point.
	*
	* @param {Vector3} point - A point in 3D space to compute the distance to.
	* @return {number} The distance.
	*/
	distanceToPoint(point) {
		return Math.sqrt(this.distanceSqToPoint(point));
	}
	/**
	* Returns the squared distance of the closest approach between this ray and the given point.
	*
	* @param {Vector3} point - A point in 3D space to compute the distance to.
	* @return {number} The squared distance.
	*/
	distanceSqToPoint(point) {
		const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
		if (directionDistance < 0) return this.origin.distanceToSquared(point);
		_vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
		return _vector$a.distanceToSquared(point);
	}
	/**
	* Returns the squared distance between this ray and the given line segment.
	*
	* @param {Vector3} v0 - The start point of the line segment.
	* @param {Vector3} v1 - The end point of the line segment.
	* @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
	* @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
	* @return {number} The squared distance.
	*/
	distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
		_segCenter.copy(v0).add(v1).multiplyScalar(.5);
		_segDir.copy(v1).sub(v0).normalize();
		_diff.copy(this.origin).sub(_segCenter);
		const segExtent = v0.distanceTo(v1) * .5;
		const a01 = -this.direction.dot(_segDir);
		const b0 = _diff.dot(this.direction);
		const b1 = -_diff.dot(_segDir);
		const c$1 = _diff.lengthSq();
		const det$1 = Math.abs(1 - a01 * a01);
		let s0, s1, sqrDist, extDet;
		if (det$1 > 0) {
			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det$1;
			if (s0 >= 0) if (s1 >= -extDet) if (s1 <= extDet) {
				const invDet = 1 / det$1;
				s0 *= invDet;
				s1 *= invDet;
				sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c$1;
			} else {
				s1 = segExtent;
				s0 = Math.max(0, -(a01 * s1 + b0));
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c$1;
			}
			else {
				s1 = -segExtent;
				s0 = Math.max(0, -(a01 * s1 + b0));
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c$1;
			}
			else if (s1 <= -extDet) {
				s0 = Math.max(0, -(-a01 * segExtent + b0));
				s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c$1;
			} else if (s1 <= extDet) {
				s0 = 0;
				s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
				sqrDist = s1 * (s1 + 2 * b1) + c$1;
			} else {
				s0 = Math.max(0, -(a01 * segExtent + b0));
				s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c$1;
			}
		} else {
			s1 = a01 > 0 ? -segExtent : segExtent;
			s0 = Math.max(0, -(a01 * s1 + b0));
			sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c$1;
		}
		if (optionalPointOnRay) optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
		if (optionalPointOnSegment) optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
		return sqrDist;
	}
	/**
	* Intersects this ray with the given sphere, returning the intersection
	* point or `null` if there is no intersection.
	*
	* @param {Sphere} sphere - The sphere to intersect.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {?Vector3} The intersection point.
	*/
	intersectSphere(sphere, target) {
		_vector$a.subVectors(sphere.center, this.origin);
		const tca = _vector$a.dot(this.direction);
		const d2 = _vector$a.dot(_vector$a) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;
		if (d2 > radius2) return null;
		const thc = Math.sqrt(radius2 - d2);
		const t0 = tca - thc;
		const t1 = tca + thc;
		if (t1 < 0) return null;
		if (t0 < 0) return this.at(t1, target);
		return this.at(t0, target);
	}
	/**
	* Returns `true` if this ray intersects with the given sphere.
	*
	* @param {Sphere} sphere - The sphere to intersect.
	* @return {boolean} Whether this ray intersects with the given sphere or not.
	*/
	intersectsSphere(sphere) {
		if (sphere.radius < 0) return false;
		return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
	}
	/**
	* Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
	* does not intersect with the plane.
	*
	* @param {Plane} plane - The plane to compute the distance to.
	* @return {?number} Whether this ray intersects with the given sphere or not.
	*/
	distanceToPlane(plane) {
		const denominator = plane.normal.dot(this.direction);
		if (denominator === 0) {
			if (plane.distanceToPoint(this.origin) === 0) return 0;
			return null;
		}
		const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
		return t >= 0 ? t : null;
	}
	/**
	* Intersects this ray with the given plane, returning the intersection
	* point or `null` if there is no intersection.
	*
	* @param {Plane} plane - The plane to intersect.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {?Vector3} The intersection point.
	*/
	intersectPlane(plane, target) {
		const t = this.distanceToPlane(plane);
		if (t === null) return null;
		return this.at(t, target);
	}
	/**
	* Returns `true` if this ray intersects with the given plane.
	*
	* @param {Plane} plane - The plane to intersect.
	* @return {boolean} Whether this ray intersects with the given plane or not.
	*/
	intersectsPlane(plane) {
		const distToPoint = plane.distanceToPoint(this.origin);
		if (distToPoint === 0) return true;
		if (plane.normal.dot(this.direction) * distToPoint < 0) return true;
		return false;
	}
	/**
	* Intersects this ray with the given bounding box, returning the intersection
	* point or `null` if there is no intersection.
	*
	* @param {Box3} box - The box to intersect.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {?Vector3} The intersection point.
	*/
	intersectBox(box, target) {
		let tmin, tmax, tymin, tymax, tzmin, tzmax;
		const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
		const origin = this.origin;
		if (invdirx >= 0) {
			tmin = (box.min.x - origin.x) * invdirx;
			tmax = (box.max.x - origin.x) * invdirx;
		} else {
			tmin = (box.max.x - origin.x) * invdirx;
			tmax = (box.min.x - origin.x) * invdirx;
		}
		if (invdiry >= 0) {
			tymin = (box.min.y - origin.y) * invdiry;
			tymax = (box.max.y - origin.y) * invdiry;
		} else {
			tymin = (box.max.y - origin.y) * invdiry;
			tymax = (box.min.y - origin.y) * invdiry;
		}
		if (tmin > tymax || tymin > tmax) return null;
		if (tymin > tmin || isNaN(tmin)) tmin = tymin;
		if (tymax < tmax || isNaN(tmax)) tmax = tymax;
		if (invdirz >= 0) {
			tzmin = (box.min.z - origin.z) * invdirz;
			tzmax = (box.max.z - origin.z) * invdirz;
		} else {
			tzmin = (box.max.z - origin.z) * invdirz;
			tzmax = (box.min.z - origin.z) * invdirz;
		}
		if (tmin > tzmax || tzmin > tmax) return null;
		if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
		if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
		if (tmax < 0) return null;
		return this.at(tmin >= 0 ? tmin : tmax, target);
	}
	/**
	* Returns `true` if this ray intersects with the given box.
	*
	* @param {Box3} box - The box to intersect.
	* @return {boolean} Whether this ray intersects with the given box or not.
	*/
	intersectsBox(box) {
		return this.intersectBox(box, _vector$a) !== null;
	}
	/**
	* Intersects this ray with the given triangle, returning the intersection
	* point or `null` if there is no intersection.
	*
	* @param {Vector3} a - The first vertex of the triangle.
	* @param {Vector3} b - The second vertex of the triangle.
	* @param {Vector3} c - The third vertex of the triangle.
	* @param {boolean} backfaceCulling - Whether to use backface culling or not.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {?Vector3} The intersection point.
	*/
	intersectTriangle(a$1, b$2, c$1, backfaceCulling, target) {
		_edge1.subVectors(b$2, a$1);
		_edge2.subVectors(c$1, a$1);
		_normal$1.crossVectors(_edge1, _edge2);
		let DdN = this.direction.dot(_normal$1);
		let sign$2;
		if (DdN > 0) {
			if (backfaceCulling) return null;
			sign$2 = 1;
		} else if (DdN < 0) {
			sign$2 = -1;
			DdN = -DdN;
		} else return null;
		_diff.subVectors(this.origin, a$1);
		const DdQxE2 = sign$2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
		if (DdQxE2 < 0) return null;
		const DdE1xQ = sign$2 * this.direction.dot(_edge1.cross(_diff));
		if (DdE1xQ < 0) return null;
		if (DdQxE2 + DdE1xQ > DdN) return null;
		const QdN = -sign$2 * _diff.dot(_normal$1);
		if (QdN < 0) return null;
		return this.at(QdN / DdN, target);
	}
	/**
	* Transforms this ray with the given 4x4 transformation matrix.
	*
	* @param {Matrix4} matrix4 - The transformation matrix.
	* @return {Ray} A reference to this ray.
	*/
	applyMatrix4(matrix4) {
		this.origin.applyMatrix4(matrix4);
		this.direction.transformDirection(matrix4);
		return this;
	}
	/**
	* Returns `true` if this ray is equal with the given one.
	*
	* @param {Ray} ray - The ray to test for equality.
	* @return {boolean} Whether this ray is equal with the given one.
	*/
	equals(ray) {
		return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
	}
	/**
	* Returns a new ray with copied values from this instance.
	*
	* @return {Ray} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
};
/**
* Represents a 4x4 matrix.
*
* The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.
* For an introduction to transformation matrices as used in WebGL, check out [this tutorial](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices)
*
* This allows a 3D vector representing a point in 3D space to undergo
* transformations such as translation, rotation, shear, scale, reflection,
* orthogonal or perspective projection and so on, by being multiplied by the
* matrix. This is known as `applying` the matrix to the vector.
*
* A Note on Row-Major and Column-Major Ordering:
*
* The constructor and {@link Matrix3#set} method take arguments in
* [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
* order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
* This means that calling:
* ```js
* const m = new THREE.Matrix4();
* m.set( 11, 12, 13, 14,
*        21, 22, 23, 24,
*        31, 32, 33, 34,
*        41, 42, 43, 44 );
* ```
* will result in the elements array containing:
* ```js
* m.elements = [ 11, 21, 31, 41,
*                12, 22, 32, 42,
*                13, 23, 33, 43,
*                14, 24, 34, 44 ];
* ```
* and internally all calculations are performed using column-major ordering.
* However, as the actual ordering makes no difference mathematically and
* most people are used to thinking about matrices in row-major order, the
* three.js documentation shows matrices in row-major order. Just bear in
* mind that if you are reading the source code, you'll have to take the
* transpose of any matrices outlined here to make sense of the calculations.
*/
var Matrix4 = class Matrix4 {
	/**
	* Constructs a new 4x4 matrix. The arguments are supposed to be
	* in row-major order. If no arguments are provided, the constructor
	* initializes the matrix as an identity matrix.
	*
	* @param {number} [n11] - 1-1 matrix element.
	* @param {number} [n12] - 1-2 matrix element.
	* @param {number} [n13] - 1-3 matrix element.
	* @param {number} [n14] - 1-4 matrix element.
	* @param {number} [n21] - 2-1 matrix element.
	* @param {number} [n22] - 2-2 matrix element.
	* @param {number} [n23] - 2-3 matrix element.
	* @param {number} [n24] - 2-4 matrix element.
	* @param {number} [n31] - 3-1 matrix element.
	* @param {number} [n32] - 3-2 matrix element.
	* @param {number} [n33] - 3-3 matrix element.
	* @param {number} [n34] - 3-4 matrix element.
	* @param {number} [n41] - 4-1 matrix element.
	* @param {number} [n42] - 4-2 matrix element.
	* @param {number} [n43] - 4-3 matrix element.
	* @param {number} [n44] - 4-4 matrix element.
	*/
	constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		Matrix4.prototype.isMatrix4 = true;
		/**
		* A column-major list of matrix values.
		*
		* @type {Array<number>}
		*/
		this.elements = [
			1,
			0,
			0,
			0,
			0,
			1,
			0,
			0,
			0,
			0,
			1,
			0,
			0,
			0,
			0,
			1
		];
		if (n11 !== void 0) this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
	}
	/**
	* Sets the elements of the matrix.The arguments are supposed to be
	* in row-major order.
	*
	* @param {number} [n11] - 1-1 matrix element.
	* @param {number} [n12] - 1-2 matrix element.
	* @param {number} [n13] - 1-3 matrix element.
	* @param {number} [n14] - 1-4 matrix element.
	* @param {number} [n21] - 2-1 matrix element.
	* @param {number} [n22] - 2-2 matrix element.
	* @param {number} [n23] - 2-3 matrix element.
	* @param {number} [n24] - 2-4 matrix element.
	* @param {number} [n31] - 3-1 matrix element.
	* @param {number} [n32] - 3-2 matrix element.
	* @param {number} [n33] - 3-3 matrix element.
	* @param {number} [n34] - 3-4 matrix element.
	* @param {number} [n41] - 4-1 matrix element.
	* @param {number} [n42] - 4-2 matrix element.
	* @param {number} [n43] - 4-3 matrix element.
	* @param {number} [n44] - 4-4 matrix element.
	* @return {Matrix4} A reference to this matrix.
	*/
	set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
		const te = this.elements;
		te[0] = n11;
		te[4] = n12;
		te[8] = n13;
		te[12] = n14;
		te[1] = n21;
		te[5] = n22;
		te[9] = n23;
		te[13] = n24;
		te[2] = n31;
		te[6] = n32;
		te[10] = n33;
		te[14] = n34;
		te[3] = n41;
		te[7] = n42;
		te[11] = n43;
		te[15] = n44;
		return this;
	}
	/**
	* Sets this matrix to the 4x4 identity matrix.
	*
	* @return {Matrix4} A reference to this matrix.
	*/
	identity() {
		this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		return this;
	}
	/**
	* Returns a matrix with copied values from this instance.
	*
	* @return {Matrix4} A clone of this instance.
	*/
	clone() {
		return new Matrix4().fromArray(this.elements);
	}
	/**
	* Copies the values of the given matrix to this instance.
	*
	* @param {Matrix4} m - The matrix to copy.
	* @return {Matrix4} A reference to this matrix.
	*/
	copy(m$1) {
		const te = this.elements;
		const me = m$1.elements;
		te[0] = me[0];
		te[1] = me[1];
		te[2] = me[2];
		te[3] = me[3];
		te[4] = me[4];
		te[5] = me[5];
		te[6] = me[6];
		te[7] = me[7];
		te[8] = me[8];
		te[9] = me[9];
		te[10] = me[10];
		te[11] = me[11];
		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];
		te[15] = me[15];
		return this;
	}
	/**
	* Copies the translation component of the given matrix
	* into this matrix's translation component.
	*
	* @param {Matrix4} m - The matrix to copy the translation component.
	* @return {Matrix4} A reference to this matrix.
	*/
	copyPosition(m$1) {
		const te = this.elements, me = m$1.elements;
		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];
		return this;
	}
	/**
	* Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
	*
	* @param {Matrix3} m - The 3x3 matrix.
	* @return {Matrix4} A reference to this matrix.
	*/
	setFromMatrix3(m$1) {
		const me = m$1.elements;
		this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
		return this;
	}
	/**
	* Extracts the basis of this matrix into the three axis vectors provided.
	*
	* @param {Vector3} xAxis - The basis's x axis.
	* @param {Vector3} yAxis - The basis's y axis.
	* @param {Vector3} zAxis - The basis's z axis.
	* @return {Matrix4} A reference to this matrix.
	*/
	extractBasis(xAxis, yAxis, zAxis) {
		xAxis.setFromMatrixColumn(this, 0);
		yAxis.setFromMatrixColumn(this, 1);
		zAxis.setFromMatrixColumn(this, 2);
		return this;
	}
	/**
	* Sets the given basis vectors to this matrix.
	*
	* @param {Vector3} xAxis - The basis's x axis.
	* @param {Vector3} yAxis - The basis's y axis.
	* @param {Vector3} zAxis - The basis's z axis.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeBasis(xAxis, yAxis, zAxis) {
		this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
		return this;
	}
	/**
	* Extracts the rotation component of the given matrix
	* into this matrix's rotation component.
	*
	* Note: This method does not support reflection matrices.
	*
	* @param {Matrix4} m - The matrix.
	* @return {Matrix4} A reference to this matrix.
	*/
	extractRotation(m$1) {
		const te = this.elements;
		const me = m$1.elements;
		const scaleX = 1 / _v1$5.setFromMatrixColumn(m$1, 0).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn(m$1, 1).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn(m$1, 2).length();
		te[0] = me[0] * scaleX;
		te[1] = me[1] * scaleX;
		te[2] = me[2] * scaleX;
		te[3] = 0;
		te[4] = me[4] * scaleY;
		te[5] = me[5] * scaleY;
		te[6] = me[6] * scaleY;
		te[7] = 0;
		te[8] = me[8] * scaleZ;
		te[9] = me[9] * scaleZ;
		te[10] = me[10] * scaleZ;
		te[11] = 0;
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;
		return this;
	}
	/**
	* Sets the rotation component (the upper left 3x3 matrix) of this matrix to
	* the rotation specified by the given Euler angles. The rest of
	* the matrix is set to the identity. Depending on the {@link Euler#order},
	* there are six possible outcomes. See [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
	* for a complete list.
	*
	* @param {Euler} euler - The Euler angles.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeRotationFromEuler(euler) {
		const te = this.elements;
		const x = euler.x, y = euler.y, z = euler.z;
		const a$1 = Math.cos(x), b$2 = Math.sin(x);
		const c$1 = Math.cos(y), d$1 = Math.sin(y);
		const e = Math.cos(z), f = Math.sin(z);
		if (euler.order === "XYZ") {
			const ae = a$1 * e, af = a$1 * f, be = b$2 * e, bf = b$2 * f;
			te[0] = c$1 * e;
			te[4] = -c$1 * f;
			te[8] = d$1;
			te[1] = af + be * d$1;
			te[5] = ae - bf * d$1;
			te[9] = -b$2 * c$1;
			te[2] = bf - ae * d$1;
			te[6] = be + af * d$1;
			te[10] = a$1 * c$1;
		} else if (euler.order === "YXZ") {
			const ce = c$1 * e, cf = c$1 * f, de = d$1 * e, df = d$1 * f;
			te[0] = ce + df * b$2;
			te[4] = de * b$2 - cf;
			te[8] = a$1 * d$1;
			te[1] = a$1 * f;
			te[5] = a$1 * e;
			te[9] = -b$2;
			te[2] = cf * b$2 - de;
			te[6] = df + ce * b$2;
			te[10] = a$1 * c$1;
		} else if (euler.order === "ZXY") {
			const ce = c$1 * e, cf = c$1 * f, de = d$1 * e, df = d$1 * f;
			te[0] = ce - df * b$2;
			te[4] = -a$1 * f;
			te[8] = de + cf * b$2;
			te[1] = cf + de * b$2;
			te[5] = a$1 * e;
			te[9] = df - ce * b$2;
			te[2] = -a$1 * d$1;
			te[6] = b$2;
			te[10] = a$1 * c$1;
		} else if (euler.order === "ZYX") {
			const ae = a$1 * e, af = a$1 * f, be = b$2 * e, bf = b$2 * f;
			te[0] = c$1 * e;
			te[4] = be * d$1 - af;
			te[8] = ae * d$1 + bf;
			te[1] = c$1 * f;
			te[5] = bf * d$1 + ae;
			te[9] = af * d$1 - be;
			te[2] = -d$1;
			te[6] = b$2 * c$1;
			te[10] = a$1 * c$1;
		} else if (euler.order === "YZX") {
			const ac = a$1 * c$1, ad = a$1 * d$1, bc = b$2 * c$1, bd = b$2 * d$1;
			te[0] = c$1 * e;
			te[4] = bd - ac * f;
			te[8] = bc * f + ad;
			te[1] = f;
			te[5] = a$1 * e;
			te[9] = -b$2 * e;
			te[2] = -d$1 * e;
			te[6] = ad * f + bc;
			te[10] = ac - bd * f;
		} else if (euler.order === "XZY") {
			const ac = a$1 * c$1, ad = a$1 * d$1, bc = b$2 * c$1, bd = b$2 * d$1;
			te[0] = c$1 * e;
			te[4] = -f;
			te[8] = d$1 * e;
			te[1] = ac * f + bd;
			te[5] = a$1 * e;
			te[9] = ad * f - bc;
			te[2] = bc * f - ad;
			te[6] = b$2 * e;
			te[10] = bd * f + ac;
		}
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;
		return this;
	}
	/**
	* Sets the rotation component of this matrix to the rotation specified by
	* the given Quaternion as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion)
	* The rest of the matrix is set to the identity.
	*
	* @param {Quaternion} q - The Quaternion.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeRotationFromQuaternion(q) {
		return this.compose(_zero, q, _one);
	}
	/**
	* Sets the rotation component of the transformation matrix, looking from `eye` towards
	* `target`, and oriented by the up-direction.
	*
	* @param {Vector3} eye - The eye vector.
	* @param {Vector3} target - The target vector.
	* @param {Vector3} up - The up vector.
	* @return {Matrix4} A reference to this matrix.
	*/
	lookAt(eye, target, up) {
		const te = this.elements;
		_z.subVectors(eye, target);
		if (_z.lengthSq() === 0) _z.z = 1;
		_z.normalize();
		_x.crossVectors(up, _z);
		if (_x.lengthSq() === 0) {
			if (Math.abs(up.z) === 1) _z.x += 1e-4;
			else _z.z += 1e-4;
			_z.normalize();
			_x.crossVectors(up, _z);
		}
		_x.normalize();
		_y.crossVectors(_z, _x);
		te[0] = _x.x;
		te[4] = _y.x;
		te[8] = _z.x;
		te[1] = _x.y;
		te[5] = _y.y;
		te[9] = _z.y;
		te[2] = _x.z;
		te[6] = _y.z;
		te[10] = _z.z;
		return this;
	}
	/**
	* Post-multiplies this matrix by the given 4x4 matrix.
	*
	* @param {Matrix4} m - The matrix to multiply with.
	* @return {Matrix4} A reference to this matrix.
	*/
	multiply(m$1) {
		return this.multiplyMatrices(this, m$1);
	}
	/**
	* Pre-multiplies this matrix by the given 4x4 matrix.
	*
	* @param {Matrix4} m - The matrix to multiply with.
	* @return {Matrix4} A reference to this matrix.
	*/
	premultiply(m$1) {
		return this.multiplyMatrices(m$1, this);
	}
	/**
	* Multiples the given 4x4 matrices and stores the result
	* in this matrix.
	*
	* @param {Matrix4} a - The first matrix.
	* @param {Matrix4} b - The second matrix.
	* @return {Matrix4} A reference to this matrix.
	*/
	multiplyMatrices(a$1, b$2) {
		const ae = a$1.elements;
		const be = b$2.elements;
		const te = this.elements;
		const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
		const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
		const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
		const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
		const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
		const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
		const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
		const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
		te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
		te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
		te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
		te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
		return this;
	}
	/**
	* Multiplies every component of the matrix by the given scalar.
	*
	* @param {number} s - The scalar.
	* @return {Matrix4} A reference to this matrix.
	*/
	multiplyScalar(s) {
		const te = this.elements;
		te[0] *= s;
		te[4] *= s;
		te[8] *= s;
		te[12] *= s;
		te[1] *= s;
		te[5] *= s;
		te[9] *= s;
		te[13] *= s;
		te[2] *= s;
		te[6] *= s;
		te[10] *= s;
		te[14] *= s;
		te[3] *= s;
		te[7] *= s;
		te[11] *= s;
		te[15] *= s;
		return this;
	}
	/**
	* Computes and returns the determinant of this matrix.
	*
	* Based on the method outlined [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html).
	*
	* @return {number} The determinant.
	*/
	determinant() {
		const te = this.elements;
		const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
		const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
		const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
		const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
		return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
	}
	/**
	* Transposes this matrix in place.
	*
	* @return {Matrix4} A reference to this matrix.
	*/
	transpose() {
		const te = this.elements;
		let tmp;
		tmp = te[1];
		te[1] = te[4];
		te[4] = tmp;
		tmp = te[2];
		te[2] = te[8];
		te[8] = tmp;
		tmp = te[6];
		te[6] = te[9];
		te[9] = tmp;
		tmp = te[3];
		te[3] = te[12];
		te[12] = tmp;
		tmp = te[7];
		te[7] = te[13];
		te[13] = tmp;
		tmp = te[11];
		te[11] = te[14];
		te[14] = tmp;
		return this;
	}
	/**
	* Sets the position component for this matrix from the given vector,
	* without affecting the rest of the matrix.
	*
	* @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
	* @param {number} y - The y component of the vector.
	* @param {number} z - The z component of the vector.
	* @return {Matrix4} A reference to this matrix.
	*/
	setPosition(x, y, z) {
		const te = this.elements;
		if (x.isVector3) {
			te[12] = x.x;
			te[13] = x.y;
			te[14] = x.z;
		} else {
			te[12] = x;
			te[13] = y;
			te[14] = z;
		}
		return this;
	}
	/**
	* Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
	* You can not invert with a determinant of zero. If you attempt this, the method produces
	* a zero matrix instead.
	*
	* @return {Matrix4} A reference to this matrix.
	*/
	invert() {
		const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		const det$1 = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
		if (det$1 === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		const detInv = 1 / det$1;
		te[0] = t11 * detInv;
		te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
		te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
		te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
		te[4] = t12 * detInv;
		te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
		te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
		te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
		te[8] = t13 * detInv;
		te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
		te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
		te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
		te[12] = t14 * detInv;
		te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
		te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
		te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
		return this;
	}
	/**
	* Multiplies the columns of this matrix by the given vector.
	*
	* @param {Vector3} v - The scale vector.
	* @return {Matrix4} A reference to this matrix.
	*/
	scale(v) {
		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;
		te[0] *= x;
		te[4] *= y;
		te[8] *= z;
		te[1] *= x;
		te[5] *= y;
		te[9] *= z;
		te[2] *= x;
		te[6] *= y;
		te[10] *= z;
		te[3] *= x;
		te[7] *= y;
		te[11] *= z;
		return this;
	}
	/**
	* Gets the maximum scale value of the three axes.
	*
	* @return {number} The maximum scale.
	*/
	getMaxScaleOnAxis() {
		const te = this.elements;
		const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
		const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
		const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
		return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
	}
	/**
	* Sets this matrix as a translation transform from the given vector.
	*
	* @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
	* @param {number} y - The amount to translate in the Y axis.
	* @param {number} z - The amount to translate in the z axis.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeTranslation(x, y, z) {
		if (x.isVector3) this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
		else this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
		return this;
	}
	/**
	* Sets this matrix as a rotational transformation around the X axis by
	* the given angle.
	*
	* @param {number} theta - The rotation in radians.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeRotationX(theta) {
		const c$1 = Math.cos(theta), s = Math.sin(theta);
		this.set(1, 0, 0, 0, 0, c$1, -s, 0, 0, s, c$1, 0, 0, 0, 0, 1);
		return this;
	}
	/**
	* Sets this matrix as a rotational transformation around the Y axis by
	* the given angle.
	*
	* @param {number} theta - The rotation in radians.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeRotationY(theta) {
		const c$1 = Math.cos(theta), s = Math.sin(theta);
		this.set(c$1, 0, s, 0, 0, 1, 0, 0, -s, 0, c$1, 0, 0, 0, 0, 1);
		return this;
	}
	/**
	* Sets this matrix as a rotational transformation around the Z axis by
	* the given angle.
	*
	* @param {number} theta - The rotation in radians.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeRotationZ(theta) {
		const c$1 = Math.cos(theta), s = Math.sin(theta);
		this.set(c$1, -s, 0, 0, s, c$1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		return this;
	}
	/**
	* Sets this matrix as a rotational transformation around the given axis by
	* the given angle.
	*
	* This is a somewhat controversial but mathematically sound alternative to
	* rotating via Quaternions. See the discussion [here](https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199).
	*
	* @param {Vector3} axis - The normalized rotation axis.
	* @param {number} angle - The rotation in radians.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeRotationAxis(axis, angle) {
		const c$1 = Math.cos(angle);
		const s = Math.sin(angle);
		const t = 1 - c$1;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;
		this.set(tx * x + c$1, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c$1, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c$1, 0, 0, 0, 0, 1);
		return this;
	}
	/**
	* Sets this matrix as a scale transformation.
	*
	* @param {number} x - The amount to scale in the X axis.
	* @param {number} y - The amount to scale in the Y axis.
	* @param {number} z - The amount to scale in the Z axis.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeScale(x, y, z) {
		this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
		return this;
	}
	/**
	* Sets this matrix as a shear transformation.
	*
	* @param {number} xy - The amount to shear X by Y.
	* @param {number} xz - The amount to shear X by Z.
	* @param {number} yx - The amount to shear Y by X.
	* @param {number} yz - The amount to shear Y by Z.
	* @param {number} zx - The amount to shear Z by X.
	* @param {number} zy - The amount to shear Z by Y.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeShear(xy$1, xz, yx, yz, zx, zy) {
		this.set(1, yx, zx, 0, xy$1, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
		return this;
	}
	/**
	* Sets this matrix to the transformation composed of the given position,
	* rotation (Quaternion) and scale.
	*
	* @param {Vector3} position - The position vector.
	* @param {Quaternion} quaternion - The rotation as a Quaternion.
	* @param {Vector3} scale - The scale vector.
	* @return {Matrix4} A reference to this matrix.
	*/
	compose(position, quaternion, scale$3) {
		const te = this.elements;
		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x, y2 = y + y, z2 = z + z;
		const xx = x * x2, xy$1 = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;
		const sx = scale$3.x, sy = scale$3.y, sz = scale$3.z;
		te[0] = (1 - (yy + zz)) * sx;
		te[1] = (xy$1 + wz) * sx;
		te[2] = (xz - wy) * sx;
		te[3] = 0;
		te[4] = (xy$1 - wz) * sy;
		te[5] = (1 - (xx + zz)) * sy;
		te[6] = (yz + wx) * sy;
		te[7] = 0;
		te[8] = (xz + wy) * sz;
		te[9] = (yz - wx) * sz;
		te[10] = (1 - (xx + yy)) * sz;
		te[11] = 0;
		te[12] = position.x;
		te[13] = position.y;
		te[14] = position.z;
		te[15] = 1;
		return this;
	}
	/**
	* Decomposes this matrix into its position, rotation and scale components
	* and provides the result in the given objects.
	*
	* Note: Not all matrices are decomposable in this way. For example, if an
	* object has a non-uniformly scaled parent, then the object's world matrix
	* may not be decomposable, and this method may not be appropriate.
	*
	* @param {Vector3} position - The position vector.
	* @param {Quaternion} quaternion - The rotation as a Quaternion.
	* @param {Vector3} scale - The scale vector.
	* @return {Matrix4} A reference to this matrix.
	*/
	decompose(position, quaternion, scale$3) {
		const te = this.elements;
		let sx = _v1$5.set(te[0], te[1], te[2]).length();
		const sy = _v1$5.set(te[4], te[5], te[6]).length();
		const sz = _v1$5.set(te[8], te[9], te[10]).length();
		if (this.determinant() < 0) sx = -sx;
		position.x = te[12];
		position.y = te[13];
		position.z = te[14];
		_m1$2$1.copy(this);
		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;
		_m1$2$1.elements[0] *= invSX;
		_m1$2$1.elements[1] *= invSX;
		_m1$2$1.elements[2] *= invSX;
		_m1$2$1.elements[4] *= invSY;
		_m1$2$1.elements[5] *= invSY;
		_m1$2$1.elements[6] *= invSY;
		_m1$2$1.elements[8] *= invSZ;
		_m1$2$1.elements[9] *= invSZ;
		_m1$2$1.elements[10] *= invSZ;
		quaternion.setFromRotationMatrix(_m1$2$1);
		scale$3.x = sx;
		scale$3.y = sy;
		scale$3.z = sz;
		return this;
	}
	/**
	* Creates a perspective projection matrix. This is used internally by
	* {@link PerspectiveCamera#updateProjectionMatrix}.
	
	* @param {number} left - Left boundary of the viewing frustum at the near plane.
	* @param {number} right - Right boundary of the viewing frustum at the near plane.
	* @param {number} top - Top boundary of the viewing frustum at the near plane.
	* @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
	* @param {number} near - The distance from the camera to the near plane.
	* @param {number} far - The distance from the camera to the far plane.
	* @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
	* @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
	* @return {Matrix4} A reference to this matrix.
	*/
	makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
		const te = this.elements;
		const x = 2 * near / (right - left);
		const y = 2 * near / (top - bottom);
		const a$1 = (right + left) / (right - left);
		const b$2 = (top + bottom) / (top - bottom);
		let c$1, d$1;
		if (reversedDepth) {
			c$1 = near / (far - near);
			d$1 = far * near / (far - near);
		} else if (coordinateSystem === WebGLCoordinateSystem) {
			c$1 = -(far + near) / (far - near);
			d$1 = -2 * far * near / (far - near);
		} else if (coordinateSystem === WebGPUCoordinateSystem) {
			c$1 = -far / (far - near);
			d$1 = -far * near / (far - near);
		} else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
		te[0] = x;
		te[4] = 0;
		te[8] = a$1;
		te[12] = 0;
		te[1] = 0;
		te[5] = y;
		te[9] = b$2;
		te[13] = 0;
		te[2] = 0;
		te[6] = 0;
		te[10] = c$1;
		te[14] = d$1;
		te[3] = 0;
		te[7] = 0;
		te[11] = -1;
		te[15] = 0;
		return this;
	}
	/**
	* Creates a orthographic projection matrix. This is used internally by
	* {@link OrthographicCamera#updateProjectionMatrix}.
	
	* @param {number} left - Left boundary of the viewing frustum at the near plane.
	* @param {number} right - Right boundary of the viewing frustum at the near plane.
	* @param {number} top - Top boundary of the viewing frustum at the near plane.
	* @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
	* @param {number} near - The distance from the camera to the near plane.
	* @param {number} far - The distance from the camera to the far plane.
	* @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
	* @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
	* @return {Matrix4} A reference to this matrix.
	*/
	makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
		const te = this.elements;
		const x = 2 / (right - left);
		const y = 2 / (top - bottom);
		const a$1 = -(right + left) / (right - left);
		const b$2 = -(top + bottom) / (top - bottom);
		let c$1, d$1;
		if (reversedDepth) {
			c$1 = 1 / (far - near);
			d$1 = far / (far - near);
		} else if (coordinateSystem === WebGLCoordinateSystem) {
			c$1 = -2 / (far - near);
			d$1 = -(far + near) / (far - near);
		} else if (coordinateSystem === WebGPUCoordinateSystem) {
			c$1 = -1 / (far - near);
			d$1 = -near / (far - near);
		} else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
		te[0] = x;
		te[4] = 0;
		te[8] = 0;
		te[12] = a$1;
		te[1] = 0;
		te[5] = y;
		te[9] = 0;
		te[13] = b$2;
		te[2] = 0;
		te[6] = 0;
		te[10] = c$1;
		te[14] = d$1;
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;
		te[15] = 1;
		return this;
	}
	/**
	* Returns `true` if this matrix is equal with the given one.
	*
	* @param {Matrix4} matrix - The matrix to test for equality.
	* @return {boolean} Whether this matrix is equal with the given one.
	*/
	equals(matrix) {
		const te = this.elements;
		const me = matrix.elements;
		for (let i = 0; i < 16; i++) if (te[i] !== me[i]) return false;
		return true;
	}
	/**
	* Sets the elements of the matrix from the given array.
	*
	* @param {Array<number>} array - The matrix elements in column-major order.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Matrix4} A reference to this matrix.
	*/
	fromArray(array$2, offset = 0) {
		for (let i = 0; i < 16; i++) this.elements[i] = array$2[i + offset];
		return this;
	}
	/**
	* Writes the elements of this matrix to the given array. If no array is provided,
	* the method returns a new instance.
	*
	* @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Array<number>} The matrix elements in column-major order.
	*/
	toArray(array$2 = [], offset = 0) {
		const te = this.elements;
		array$2[offset] = te[0];
		array$2[offset + 1] = te[1];
		array$2[offset + 2] = te[2];
		array$2[offset + 3] = te[3];
		array$2[offset + 4] = te[4];
		array$2[offset + 5] = te[5];
		array$2[offset + 6] = te[6];
		array$2[offset + 7] = te[7];
		array$2[offset + 8] = te[8];
		array$2[offset + 9] = te[9];
		array$2[offset + 10] = te[10];
		array$2[offset + 11] = te[11];
		array$2[offset + 12] = te[12];
		array$2[offset + 13] = te[13];
		array$2[offset + 14] = te[14];
		array$2[offset + 15] = te[15];
		return array$2;
	}
};
var _v1$5 = /* @__PURE__ */ new Vector3();
var _m1$2$1 = /* @__PURE__ */ new Matrix4();
var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
var _x = /* @__PURE__ */ new Vector3();
var _y = /* @__PURE__ */ new Vector3();
var _z = /* @__PURE__ */ new Vector3();
var _matrix$2 = /* @__PURE__ */ new Matrix4();
var _quaternion$3 = /* @__PURE__ */ new Quaternion();
/**
* A class representing Euler angles.
*
* Euler angles describe a rotational transformation by rotating an object on
* its various axes in specified amounts per axis, and a specified axis
* order.
*
* Iterating through an instance will yield its components (x, y, z,
* order) in the corresponding order.
*
* ```js
* const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
* const b = new THREE.Vector3( 1, 0, 1 );
* b.applyEuler(a);
* ```
*/
var Euler = class Euler {
	/**
	* Constructs a new euler instance.
	*
	* @param {number} [x=0] - The angle of the x axis in radians.
	* @param {number} [y=0] - The angle of the y axis in radians.
	* @param {number} [z=0] - The angle of the z axis in radians.
	* @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
	*/
	constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isEuler = true;
		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;
	}
	/**
	* The angle of the x axis in radians.
	*
	* @type {number}
	* @default 0
	*/
	get x() {
		return this._x;
	}
	set x(value) {
		this._x = value;
		this._onChangeCallback();
	}
	/**
	* The angle of the y axis in radians.
	*
	* @type {number}
	* @default 0
	*/
	get y() {
		return this._y;
	}
	set y(value) {
		this._y = value;
		this._onChangeCallback();
	}
	/**
	* The angle of the z axis in radians.
	*
	* @type {number}
	* @default 0
	*/
	get z() {
		return this._z;
	}
	set z(value) {
		this._z = value;
		this._onChangeCallback();
	}
	/**
	* A string representing the order that the rotations are applied.
	*
	* @type {string}
	* @default 'XYZ'
	*/
	get order() {
		return this._order;
	}
	set order(value) {
		this._order = value;
		this._onChangeCallback();
	}
	/**
	* Sets the Euler components.
	*
	* @param {number} x - The angle of the x axis in radians.
	* @param {number} y - The angle of the y axis in radians.
	* @param {number} z - The angle of the z axis in radians.
	* @param {string} [order] - A string representing the order that the rotations are applied.
	* @return {Euler} A reference to this Euler instance.
	*/
	set(x, y, z, order = this._order) {
		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;
		this._onChangeCallback();
		return this;
	}
	/**
	* Returns a new Euler instance with copied values from this instance.
	*
	* @return {Euler} A clone of this instance.
	*/
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._order);
	}
	/**
	* Copies the values of the given Euler instance to this instance.
	*
	* @param {Euler} euler - The Euler instance to copy.
	* @return {Euler} A reference to this Euler instance.
	*/
	copy(euler) {
		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;
		this._onChangeCallback();
		return this;
	}
	/**
	* Sets the angles of this Euler instance from a pure rotation matrix.
	*
	* @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
	* @param {string} [order] - A string representing the order that the rotations are applied.
	* @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	* @return {Euler} A reference to this Euler instance.
	*/
	setFromRotationMatrix(m$1, order = this._order, update = true) {
		const te = m$1.elements;
		const m11 = te[0], m12 = te[4], m13 = te[8];
		const m21 = te[1], m22 = te[5], m23 = te[9];
		const m31 = te[2], m32 = te[6], m33 = te[10];
		switch (order) {
			case "XYZ":
				this._y = Math.asin(clamp$3(m13, -1, 1));
				if (Math.abs(m13) < .9999999) {
					this._x = Math.atan2(-m23, m33);
					this._z = Math.atan2(-m12, m11);
				} else {
					this._x = Math.atan2(m32, m22);
					this._z = 0;
				}
				break;
			case "YXZ":
				this._x = Math.asin(-clamp$3(m23, -1, 1));
				if (Math.abs(m23) < .9999999) {
					this._y = Math.atan2(m13, m33);
					this._z = Math.atan2(m21, m22);
				} else {
					this._y = Math.atan2(-m31, m11);
					this._z = 0;
				}
				break;
			case "ZXY":
				this._x = Math.asin(clamp$3(m32, -1, 1));
				if (Math.abs(m32) < .9999999) {
					this._y = Math.atan2(-m31, m33);
					this._z = Math.atan2(-m12, m22);
				} else {
					this._y = 0;
					this._z = Math.atan2(m21, m11);
				}
				break;
			case "ZYX":
				this._y = Math.asin(-clamp$3(m31, -1, 1));
				if (Math.abs(m31) < .9999999) {
					this._x = Math.atan2(m32, m33);
					this._z = Math.atan2(m21, m11);
				} else {
					this._x = 0;
					this._z = Math.atan2(-m12, m22);
				}
				break;
			case "YZX":
				this._z = Math.asin(clamp$3(m21, -1, 1));
				if (Math.abs(m21) < .9999999) {
					this._x = Math.atan2(-m23, m22);
					this._y = Math.atan2(-m31, m11);
				} else {
					this._x = 0;
					this._y = Math.atan2(m13, m33);
				}
				break;
			case "XZY":
				this._z = Math.asin(-clamp$3(m12, -1, 1));
				if (Math.abs(m12) < .9999999) {
					this._x = Math.atan2(m32, m22);
					this._y = Math.atan2(m13, m11);
				} else {
					this._x = Math.atan2(-m23, m33);
					this._y = 0;
				}
				break;
			default: warn("Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
		}
		this._order = order;
		if (update === true) this._onChangeCallback();
		return this;
	}
	/**
	* Sets the angles of this Euler instance from a normalized quaternion.
	*
	* @param {Quaternion} q - A normalized Quaternion.
	* @param {string} [order] - A string representing the order that the rotations are applied.
	* @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	* @return {Euler} A reference to this Euler instance.
	*/
	setFromQuaternion(q, order, update) {
		_matrix$2.makeRotationFromQuaternion(q);
		return this.setFromRotationMatrix(_matrix$2, order, update);
	}
	/**
	* Sets the angles of this Euler instance from the given vector.
	*
	* @param {Vector3} v - The vector.
	* @param {string} [order] - A string representing the order that the rotations are applied.
	* @return {Euler} A reference to this Euler instance.
	*/
	setFromVector3(v, order = this._order) {
		return this.set(v.x, v.y, v.z, order);
	}
	/**
	* Resets the euler angle with a new order by creating a quaternion from this
	* euler angle and then setting this euler angle with the quaternion and the
	* new order.
	*
	* Warning: This discards revolution information.
	*
	* @param {string} [newOrder] - A string representing the new order that the rotations are applied.
	* @return {Euler} A reference to this Euler instance.
	*/
	reorder(newOrder) {
		_quaternion$3.setFromEuler(this);
		return this.setFromQuaternion(_quaternion$3, newOrder);
	}
	/**
	* Returns `true` if this Euler instance is equal with the given one.
	*
	* @param {Euler} euler - The Euler instance to test for equality.
	* @return {boolean} Whether this Euler instance is equal with the given one.
	*/
	equals(euler) {
		return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
	}
	/**
	* Sets this Euler instance's components to values from the given array. The first three
	* entries of the array are assign to the x,y and z components. An optional fourth entry
	* defines the Euler order.
	*
	* @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
	* @return {Euler} A reference to this Euler instance.
	*/
	fromArray(array$2) {
		this._x = array$2[0];
		this._y = array$2[1];
		this._z = array$2[2];
		if (array$2[3] !== void 0) this._order = array$2[3];
		this._onChangeCallback();
		return this;
	}
	/**
	* Writes the components of this Euler instance to the given array. If no array is provided,
	* the method returns a new instance.
	*
	* @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Array<number,number,number,string>} The Euler components.
	*/
	toArray(array$2 = [], offset = 0) {
		array$2[offset] = this._x;
		array$2[offset + 1] = this._y;
		array$2[offset + 2] = this._z;
		array$2[offset + 3] = this._order;
		return array$2;
	}
	_onChange(callback) {
		this._onChangeCallback = callback;
		return this;
	}
	_onChangeCallback() {}
	*[Symbol.iterator]() {
		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;
	}
};
/**
* The default Euler angle order.
*
* @static
* @type {string}
* @default 'XYZ'
*/
Euler.DEFAULT_ORDER = "XYZ";
/**
* A layers object assigns an 3D object to 1 or more of 32
* layers numbered `0` to `31` - internally the layers are stored as a
* bit mask], and by default all 3D objects are a member of layer `0`.
*
* This can be used to control visibility - an object must share a layer with
* a camera to be visible when that camera's view is
* rendered.
*
* All classes that inherit from {@link Object3D} have an `layers` property which
* is an instance of this class.
*/
var Layers = class {
	/**
	* Constructs a new layers instance, with membership
	* initially set to layer `0`.
	*/
	constructor() {
		/**
		* A bit mask storing which of the 32 layers this layers object is currently
		* a member of.
		*
		* @type {number}
		*/
		this.mask = 1;
	}
	/**
	* Sets membership to the given layer, and remove membership all other layers.
	*
	* @param {number} layer - The layer to set.
	*/
	set(layer) {
		this.mask = (1 << layer | 0) >>> 0;
	}
	/**
	* Adds membership of the given layer.
	*
	* @param {number} layer - The layer to enable.
	*/
	enable(layer) {
		this.mask |= 1 << layer | 0;
	}
	/**
	* Adds membership to all layers.
	*/
	enableAll() {
		this.mask = -1;
	}
	/**
	* Toggles the membership of the given layer.
	*
	* @param {number} layer - The layer to toggle.
	*/
	toggle(layer) {
		this.mask ^= 1 << layer | 0;
	}
	/**
	* Removes membership of the given layer.
	*
	* @param {number} layer - The layer to enable.
	*/
	disable(layer) {
		this.mask &= ~(1 << layer | 0);
	}
	/**
	* Removes the membership from all layers.
	*/
	disableAll() {
		this.mask = 0;
	}
	/**
	* Returns `true` if this and the given layers object have at least one
	* layer in common.
	*
	* @param {Layers} layers - The layers to test.
	* @return {boolean } Whether this and the given layers object have at least one layer in common or not.
	*/
	test(layers) {
		return (this.mask & layers.mask) !== 0;
	}
	/**
	* Returns `true` if the given layer is enabled.
	*
	* @param {number} layer - The layer to test.
	* @return {boolean } Whether the given layer is enabled or not.
	*/
	isEnabled(layer) {
		return (this.mask & (1 << layer | 0)) !== 0;
	}
};
var _object3DId = 0;
var _v1$4 = /* @__PURE__ */ new Vector3();
var _q1 = /* @__PURE__ */ new Quaternion();
var _m1$1$3 = /* @__PURE__ */ new Matrix4();
var _target$1 = /* @__PURE__ */ new Vector3();
var _position$3 = /* @__PURE__ */ new Vector3();
var _scale$2 = /* @__PURE__ */ new Vector3();
var _quaternion$2 = /* @__PURE__ */ new Quaternion();
var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
/**
* Fires when the object has been added to its parent object.
*
* @event Object3D#added
* @type {Object}
*/
var _addedEvent = { type: "added" };
/**
* Fires when the object has been removed from its parent object.
*
* @event Object3D#removed
* @type {Object}
*/
var _removedEvent = { type: "removed" };
/**
* Fires when a new child object has been added.
*
* @event Object3D#childadded
* @type {Object}
*/
var _childaddedEvent = {
	type: "childadded",
	child: null
};
/**
* Fires when a child object has been removed.
*
* @event Object3D#childremoved
* @type {Object}
*/
var _childremovedEvent = {
	type: "childremoved",
	child: null
};
/**
* This is the base class for most objects in three.js and provides a set of
* properties and methods for manipulating objects in 3D space.
*
* @augments EventDispatcher
*/
var Object3D = class Object3D extends EventDispatcher {
	/**
	* Constructs a new 3D object.
	*/
	constructor() {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isObject3D = true;
		/**
		* The ID of the 3D object.
		*
		* @name Object3D#id
		* @type {number}
		* @readonly
		*/
		Object.defineProperty(this, "id", { value: _object3DId++ });
		/**
		* The UUID of the 3D object.
		*
		* @type {string}
		* @readonly
		*/
		this.uuid = generateUUID();
		/**
		* The name of the 3D object.
		*
		* @type {string}
		*/
		this.name = "";
		/**
		* The type property is used for detecting the object type
		* in context of serialization/deserialization.
		*
		* @type {string}
		* @readonly
		*/
		this.type = "Object3D";
		/**
		* A reference to the parent object.
		*
		* @type {?Object3D}
		* @default null
		*/
		this.parent = null;
		/**
		* An array holding the child 3D objects of this instance.
		*
		* @type {Array<Object3D>}
		*/
		this.children = [];
		/**
		* Defines the `up` direction of the 3D object which influences
		* the orientation via methods like {@link Object3D#lookAt}.
		*
		* The default values for all 3D objects is defined by `Object3D.DEFAULT_UP`.
		*
		* @type {Vector3}
		*/
		this.up = Object3D.DEFAULT_UP.clone();
		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale$3 = new Vector3(1, 1, 1);
		function onRotationChange() {
			quaternion.setFromEuler(rotation, false);
		}
		function onQuaternionChange() {
			rotation.setFromQuaternion(quaternion, void 0, false);
		}
		rotation._onChange(onRotationChange);
		quaternion._onChange(onQuaternionChange);
		Object.defineProperties(this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale$3
			},
			modelViewMatrix: { value: new Matrix4() },
			normalMatrix: { value: new Matrix3() }
		});
		/**
		* Represents the object's transformation matrix in local space.
		*
		* @type {Matrix4}
		*/
		this.matrix = new Matrix4();
		/**
		* Represents the object's transformation matrix in world space.
		* If the 3D object has no parent, then it's identical to the local transformation matrix
		*
		* @type {Matrix4}
		*/
		this.matrixWorld = new Matrix4();
		/**
		* When set to `true`, the engine automatically computes the local matrix from position,
		* rotation and scale every frame.
		*
		* The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.
		*
		* @type {boolean}
		* @default true
		*/
		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
		/**
		* When set to `true`, the engine automatically computes the world matrix from the current local
		* matrix and the object's transformation hierarchy.
		*
		* The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.
		*
		* @type {boolean}
		* @default true
		*/
		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
		/**
		* When set to `true`, it calculates the world matrix in that frame and resets this property
		* to `false`.
		*
		* @type {boolean}
		* @default false
		*/
		this.matrixWorldNeedsUpdate = false;
		/**
		* The layer membership of the 3D object. The 3D object is only visible if it has
		* at least one layer in common with the camera in use. This property can also be
		* used to filter out unwanted objects in ray-intersection tests when using {@link Raycaster}.
		*
		* @type {Layers}
		*/
		this.layers = new Layers();
		/**
		* When set to `true`, the 3D object gets rendered.
		*
		* @type {boolean}
		* @default true
		*/
		this.visible = true;
		/**
		* When set to `true`, the 3D object gets rendered into shadow maps.
		*
		* @type {boolean}
		* @default false
		*/
		this.castShadow = false;
		/**
		* When set to `true`, the 3D object is affected by shadows in the scene.
		*
		* @type {boolean}
		* @default false
		*/
		this.receiveShadow = false;
		/**
		* When set to `true`, the 3D object is honored by view frustum culling.
		*
		* @type {boolean}
		* @default true
		*/
		this.frustumCulled = true;
		/**
		* This value allows the default rendering order of scene graph objects to be
		* overridden although opaque and transparent objects remain sorted independently.
		* When this property is set for an instance of {@link Group},all descendants
		* objects will be sorted and rendered together. Sorting is from lowest to highest
		* render order.
		*
		* @type {number}
		* @default 0
		*/
		this.renderOrder = 0;
		/**
		* An array holding the animation clips of the 3D object.
		*
		* @type {Array<AnimationClip>}
		*/
		this.animations = [];
		/**
		* Custom depth material to be used when rendering to the depth map. Can only be used
		* in context of meshes. When shadow-casting with a {@link DirectionalLight} or {@link SpotLight},
		* if you are modifying vertex positions in the vertex shader you must specify a custom depth
		* material for proper shadows.
		*
		* Only relevant in context of {@link WebGLRenderer}.
		*
		* @type {(Material|undefined)}
		* @default undefined
		*/
		this.customDepthMaterial = void 0;
		/**
		* Same as {@link Object3D#customDepthMaterial}, but used with {@link PointLight}.
		*
		* Only relevant in context of {@link WebGLRenderer}.
		*
		* @type {(Material|undefined)}
		* @default undefined
		*/
		this.customDistanceMaterial = void 0;
		/**
		* An object that can be used to store custom data about the 3D object. It
		* should not hold references to functions as these will not be cloned.
		*
		* @type {Object}
		*/
		this.userData = {};
	}
	/**
	* A callback that is executed immediately before a 3D object is rendered to a shadow map.
	*
	* @param {Renderer|WebGLRenderer} renderer - The renderer.
	* @param {Object3D} object - The 3D object.
	* @param {Camera} camera - The camera that is used to render the scene.
	* @param {Camera} shadowCamera - The shadow camera.
	* @param {BufferGeometry} geometry - The 3D object's geometry.
	* @param {Material} depthMaterial - The depth material.
	* @param {Object} group - The geometry group data.
	*/
	onBeforeShadow() {}
	/**
	* A callback that is executed immediately after a 3D object is rendered to a shadow map.
	*
	* @param {Renderer|WebGLRenderer} renderer - The renderer.
	* @param {Object3D} object - The 3D object.
	* @param {Camera} camera - The camera that is used to render the scene.
	* @param {Camera} shadowCamera - The shadow camera.
	* @param {BufferGeometry} geometry - The 3D object's geometry.
	* @param {Material} depthMaterial - The depth material.
	* @param {Object} group - The geometry group data.
	*/
	onAfterShadow() {}
	/**
	* A callback that is executed immediately before a 3D object is rendered.
	*
	* @param {Renderer|WebGLRenderer} renderer - The renderer.
	* @param {Object3D} object - The 3D object.
	* @param {Camera} camera - The camera that is used to render the scene.
	* @param {BufferGeometry} geometry - The 3D object's geometry.
	* @param {Material} material - The 3D object's material.
	* @param {Object} group - The geometry group data.
	*/
	onBeforeRender() {}
	/**
	* A callback that is executed immediately after a 3D object is rendered.
	*
	* @param {Renderer|WebGLRenderer} renderer - The renderer.
	* @param {Object3D} object - The 3D object.
	* @param {Camera} camera - The camera that is used to render the scene.
	* @param {BufferGeometry} geometry - The 3D object's geometry.
	* @param {Material} material - The 3D object's material.
	* @param {Object} group - The geometry group data.
	*/
	onAfterRender() {}
	/**
	* Applies the given transformation matrix to the object and updates the object's position,
	* rotation and scale.
	*
	* @param {Matrix4} matrix - The transformation matrix.
	*/
	applyMatrix4(matrix) {
		if (this.matrixAutoUpdate) this.updateMatrix();
		this.matrix.premultiply(matrix);
		this.matrix.decompose(this.position, this.quaternion, this.scale);
	}
	/**
	* Applies a rotation represented by given the quaternion to the 3D object.
	*
	* @param {Quaternion} q - The quaternion.
	* @return {Object3D} A reference to this instance.
	*/
	applyQuaternion(q) {
		this.quaternion.premultiply(q);
		return this;
	}
	/**
	* Sets the given rotation represented as an axis/angle couple to the 3D object.
	*
	* @param {Vector3} axis - The (normalized) axis vector.
	* @param {number} angle - The angle in radians.
	*/
	setRotationFromAxisAngle(axis, angle) {
		this.quaternion.setFromAxisAngle(axis, angle);
	}
	/**
	* Sets the given rotation represented as Euler angles to the 3D object.
	*
	* @param {Euler} euler - The Euler angles.
	*/
	setRotationFromEuler(euler) {
		this.quaternion.setFromEuler(euler, true);
	}
	/**
	* Sets the given rotation represented as rotation matrix to the 3D object.
	*
	* @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
	* a pure rotation matrix (i.e, unscaled).
	*/
	setRotationFromMatrix(m$1) {
		this.quaternion.setFromRotationMatrix(m$1);
	}
	/**
	* Sets the given rotation represented as a Quaternion to the 3D object.
	*
	* @param {Quaternion} q - The Quaternion
	*/
	setRotationFromQuaternion(q) {
		this.quaternion.copy(q);
	}
	/**
	* Rotates the 3D object along an axis in local space.
	*
	* @param {Vector3} axis - The (normalized) axis vector.
	* @param {number} angle - The angle in radians.
	* @return {Object3D} A reference to this instance.
	*/
	rotateOnAxis(axis, angle) {
		_q1.setFromAxisAngle(axis, angle);
		this.quaternion.multiply(_q1);
		return this;
	}
	/**
	* Rotates the 3D object along an axis in world space.
	*
	* @param {Vector3} axis - The (normalized) axis vector.
	* @param {number} angle - The angle in radians.
	* @return {Object3D} A reference to this instance.
	*/
	rotateOnWorldAxis(axis, angle) {
		_q1.setFromAxisAngle(axis, angle);
		this.quaternion.premultiply(_q1);
		return this;
	}
	/**
	* Rotates the 3D object around its X axis in local space.
	*
	* @param {number} angle - The angle in radians.
	* @return {Object3D} A reference to this instance.
	*/
	rotateX(angle) {
		return this.rotateOnAxis(_xAxis, angle);
	}
	/**
	* Rotates the 3D object around its Y axis in local space.
	*
	* @param {number} angle - The angle in radians.
	* @return {Object3D} A reference to this instance.
	*/
	rotateY(angle) {
		return this.rotateOnAxis(_yAxis, angle);
	}
	/**
	* Rotates the 3D object around its Z axis in local space.
	*
	* @param {number} angle - The angle in radians.
	* @return {Object3D} A reference to this instance.
	*/
	rotateZ(angle) {
		return this.rotateOnAxis(_zAxis, angle);
	}
	/**
	* Translate the 3D object by a distance along the given axis in local space.
	*
	* @param {Vector3} axis - The (normalized) axis vector.
	* @param {number} distance - The distance in world units.
	* @return {Object3D} A reference to this instance.
	*/
	translateOnAxis(axis, distance$3) {
		_v1$4.copy(axis).applyQuaternion(this.quaternion);
		this.position.add(_v1$4.multiplyScalar(distance$3));
		return this;
	}
	/**
	* Translate the 3D object by a distance along its X-axis in local space.
	*
	* @param {number} distance - The distance in world units.
	* @return {Object3D} A reference to this instance.
	*/
	translateX(distance$3) {
		return this.translateOnAxis(_xAxis, distance$3);
	}
	/**
	* Translate the 3D object by a distance along its Y-axis in local space.
	*
	* @param {number} distance - The distance in world units.
	* @return {Object3D} A reference to this instance.
	*/
	translateY(distance$3) {
		return this.translateOnAxis(_yAxis, distance$3);
	}
	/**
	* Translate the 3D object by a distance along its Z-axis in local space.
	*
	* @param {number} distance - The distance in world units.
	* @return {Object3D} A reference to this instance.
	*/
	translateZ(distance$3) {
		return this.translateOnAxis(_zAxis, distance$3);
	}
	/**
	* Converts the given vector from this 3D object's local space to world space.
	*
	* @param {Vector3} vector - The vector to convert.
	* @return {Vector3} The converted vector.
	*/
	localToWorld(vector) {
		this.updateWorldMatrix(true, false);
		return vector.applyMatrix4(this.matrixWorld);
	}
	/**
	* Converts the given vector from this 3D object's word space to local space.
	*
	* @param {Vector3} vector - The vector to convert.
	* @return {Vector3} The converted vector.
	*/
	worldToLocal(vector) {
		this.updateWorldMatrix(true, false);
		return vector.applyMatrix4(_m1$1$3.copy(this.matrixWorld).invert());
	}
	/**
	* Rotates the object to face a point in world space.
	*
	* This method does not support objects having non-uniformly-scaled parent(s).
	*
	* @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
	* @param {number} [y] - The y coordinate in world space.
	* @param {number} [z] - The z coordinate in world space.
	*/
	lookAt(x, y, z) {
		if (x.isVector3) _target$1.copy(x);
		else _target$1.set(x, y, z);
		const parent = this.parent;
		this.updateWorldMatrix(true, false);
		_position$3.setFromMatrixPosition(this.matrixWorld);
		if (this.isCamera || this.isLight) _m1$1$3.lookAt(_position$3, _target$1, this.up);
		else _m1$1$3.lookAt(_target$1, _position$3, this.up);
		this.quaternion.setFromRotationMatrix(_m1$1$3);
		if (parent) {
			_m1$1$3.extractRotation(parent.matrixWorld);
			_q1.setFromRotationMatrix(_m1$1$3);
			this.quaternion.premultiply(_q1.invert());
		}
	}
	/**
	* Adds the given 3D object as a child to this 3D object. An arbitrary number of
	* objects may be added. Any current parent on an object passed in here will be
	* removed, since an object can have at most one parent.
	*
	* @fires Object3D#added
	* @fires Object3D#childadded
	* @param {Object3D} object - The 3D object to add.
	* @return {Object3D} A reference to this instance.
	*/
	add(object) {
		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
			return this;
		}
		if (object === this) {
			error("Object3D.add: object can't be added as a child of itself.", object);
			return this;
		}
		if (object && object.isObject3D) {
			object.removeFromParent();
			object.parent = this;
			this.children.push(object);
			object.dispatchEvent(_addedEvent);
			_childaddedEvent.child = object;
			this.dispatchEvent(_childaddedEvent);
			_childaddedEvent.child = null;
		} else error("Object3D.add: object not an instance of THREE.Object3D.", object);
		return this;
	}
	/**
	* Removes the given 3D object as child from this 3D object.
	* An arbitrary number of objects may be removed.
	*
	* @fires Object3D#removed
	* @fires Object3D#childremoved
	* @param {Object3D} object - The 3D object to remove.
	* @return {Object3D} A reference to this instance.
	*/
	remove(object) {
		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
			return this;
		}
		const index = this.children.indexOf(object);
		if (index !== -1) {
			object.parent = null;
			this.children.splice(index, 1);
			object.dispatchEvent(_removedEvent);
			_childremovedEvent.child = object;
			this.dispatchEvent(_childremovedEvent);
			_childremovedEvent.child = null;
		}
		return this;
	}
	/**
	* Removes this 3D object from its current parent.
	*
	* @fires Object3D#removed
	* @fires Object3D#childremoved
	* @return {Object3D} A reference to this instance.
	*/
	removeFromParent() {
		const parent = this.parent;
		if (parent !== null) parent.remove(this);
		return this;
	}
	/**
	* Removes all child objects.
	*
	* @fires Object3D#removed
	* @fires Object3D#childremoved
	* @return {Object3D} A reference to this instance.
	*/
	clear() {
		return this.remove(...this.children);
	}
	/**
	* Adds the given 3D object as a child of this 3D object, while maintaining the object's world
	* transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
	*
	* @fires Object3D#added
	* @fires Object3D#childadded
	* @param {Object3D} object - The 3D object to attach.
	* @return {Object3D} A reference to this instance.
	*/
	attach(object) {
		this.updateWorldMatrix(true, false);
		_m1$1$3.copy(this.matrixWorld).invert();
		if (object.parent !== null) {
			object.parent.updateWorldMatrix(true, false);
			_m1$1$3.multiply(object.parent.matrixWorld);
		}
		object.applyMatrix4(_m1$1$3);
		object.removeFromParent();
		object.parent = this;
		this.children.push(object);
		object.updateWorldMatrix(false, true);
		object.dispatchEvent(_addedEvent);
		_childaddedEvent.child = object;
		this.dispatchEvent(_childaddedEvent);
		_childaddedEvent.child = null;
		return this;
	}
	/**
	* Searches through the 3D object and its children, starting with the 3D object
	* itself, and returns the first with a matching ID.
	*
	* @param {number} id - The id.
	* @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	*/
	getObjectById(id) {
		return this.getObjectByProperty("id", id);
	}
	/**
	* Searches through the 3D object and its children, starting with the 3D object
	* itself, and returns the first with a matching name.
	*
	* @param {string} name - The name.
	* @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	*/
	getObjectByName(name) {
		return this.getObjectByProperty("name", name);
	}
	/**
	* Searches through the 3D object and its children, starting with the 3D object
	* itself, and returns the first with a matching property value.
	*
	* @param {string} name - The name of the property.
	* @param {any} value - The value.
	* @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	*/
	getObjectByProperty(name, value) {
		if (this[name] === value) return this;
		for (let i = 0, l = this.children.length; i < l; i++) {
			const object = this.children[i].getObjectByProperty(name, value);
			if (object !== void 0) return object;
		}
	}
	/**
	* Searches through the 3D object and its children, starting with the 3D object
	* itself, and returns all 3D objects with a matching property value.
	*
	* @param {string} name - The name of the property.
	* @param {any} value - The value.
	* @param {Array<Object3D>} result - The method stores the result in this array.
	* @return {Array<Object3D>} The found 3D objects.
	*/
	getObjectsByProperty(name, value, result = []) {
		if (this[name] === value) result.push(this);
		const children = this.children;
		for (let i = 0, l = children.length; i < l; i++) children[i].getObjectsByProperty(name, value, result);
		return result;
	}
	/**
	* Returns a vector representing the position of the 3D object in world space.
	*
	* @param {Vector3} target - The target vector the result is stored to.
	* @return {Vector3} The 3D object's position in world space.
	*/
	getWorldPosition(target) {
		this.updateWorldMatrix(true, false);
		return target.setFromMatrixPosition(this.matrixWorld);
	}
	/**
	* Returns a Quaternion representing the position of the 3D object in world space.
	*
	* @param {Quaternion} target - The target Quaternion the result is stored to.
	* @return {Quaternion} The 3D object's rotation in world space.
	*/
	getWorldQuaternion(target) {
		this.updateWorldMatrix(true, false);
		this.matrixWorld.decompose(_position$3, target, _scale$2);
		return target;
	}
	/**
	* Returns a vector representing the scale of the 3D object in world space.
	*
	* @param {Vector3} target - The target vector the result is stored to.
	* @return {Vector3} The 3D object's scale in world space.
	*/
	getWorldScale(target) {
		this.updateWorldMatrix(true, false);
		this.matrixWorld.decompose(_position$3, _quaternion$2, target);
		return target;
	}
	/**
	* Returns a vector representing the ("look") direction of the 3D object in world space.
	*
	* @param {Vector3} target - The target vector the result is stored to.
	* @return {Vector3} The 3D object's direction in world space.
	*/
	getWorldDirection(target) {
		this.updateWorldMatrix(true, false);
		const e = this.matrixWorld.elements;
		return target.set(e[8], e[9], e[10]).normalize();
	}
	/**
	* Abstract method to get intersections between a casted ray and this
	* 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
	* implement this method in order to use raycasting.
	*
	* @abstract
	* @param {Raycaster} raycaster - The raycaster.
	* @param {Array<Object>} intersects - An array holding the result of the method.
	*/
	raycast() {}
	/**
	* Executes the callback on this 3D object and all descendants.
	*
	* Note: Modifying the scene graph inside the callback is discouraged.
	*
	* @param {Function} callback - A callback function that allows to process the current 3D object.
	*/
	traverse(callback) {
		callback(this);
		const children = this.children;
		for (let i = 0, l = children.length; i < l; i++) children[i].traverse(callback);
	}
	/**
	* Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
	* Descendants of invisible 3D objects are not traversed.
	*
	* Note: Modifying the scene graph inside the callback is discouraged.
	*
	* @param {Function} callback - A callback function that allows to process the current 3D object.
	*/
	traverseVisible(callback) {
		if (this.visible === false) return;
		callback(this);
		const children = this.children;
		for (let i = 0, l = children.length; i < l; i++) children[i].traverseVisible(callback);
	}
	/**
	* Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
	*
	* Note: Modifying the scene graph inside the callback is discouraged.
	*
	* @param {Function} callback - A callback function that allows to process the current 3D object.
	*/
	traverseAncestors(callback) {
		const parent = this.parent;
		if (parent !== null) {
			callback(parent);
			parent.traverseAncestors(callback);
		}
	}
	/**
	* Updates the transformation matrix in local space by computing it from the current
	* position, rotation and scale values.
	*/
	updateMatrix() {
		this.matrix.compose(this.position, this.quaternion, this.scale);
		this.matrixWorldNeedsUpdate = true;
	}
	/**
	* Updates the transformation matrix in world space of this 3D objects and its descendants.
	*
	* To ensure correct results, this method also recomputes the 3D object's transformation matrix in
	* local space. The computation of the local and world matrix can be controlled with the
	* {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
	* `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
	*
	* @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
	* when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
	*/
	updateMatrixWorld(force) {
		if (this.matrixAutoUpdate) this.updateMatrix();
		if (this.matrixWorldNeedsUpdate || force) {
			if (this.matrixWorldAutoUpdate === true) if (this.parent === null) this.matrixWorld.copy(this.matrix);
			else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			this.matrixWorldNeedsUpdate = false;
			force = true;
		}
		const children = this.children;
		for (let i = 0, l = children.length; i < l; i++) children[i].updateMatrixWorld(force);
	}
	/**
	* An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
	* update of ancestor and descendant nodes.
	*
	* @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
	* @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
	*/
	updateWorldMatrix(updateParents, updateChildren) {
		const parent = this.parent;
		if (updateParents === true && parent !== null) parent.updateWorldMatrix(true, false);
		if (this.matrixAutoUpdate) this.updateMatrix();
		if (this.matrixWorldAutoUpdate === true) if (this.parent === null) this.matrixWorld.copy(this.matrix);
		else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
		if (updateChildren === true) {
			const children = this.children;
			for (let i = 0, l = children.length; i < l; i++) children[i].updateWorldMatrix(false, true);
		}
	}
	/**
	* Serializes the 3D object into JSON.
	*
	* @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	* @return {Object} A JSON object representing the serialized 3D object.
	* @see {@link ObjectLoader#parse}
	*/
	toJSON(meta) {
		const isRootObject = meta === void 0 || typeof meta === "string";
		const output$2 = {};
		if (isRootObject) {
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};
			output$2.metadata = {
				version: 4.7,
				type: "Object",
				generator: "Object3D.toJSON"
			};
		}
		const object = {};
		object.uuid = this.uuid;
		object.type = this.type;
		if (this.name !== "") object.name = this.name;
		if (this.castShadow === true) object.castShadow = true;
		if (this.receiveShadow === true) object.receiveShadow = true;
		if (this.visible === false) object.visible = false;
		if (this.frustumCulled === false) object.frustumCulled = false;
		if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
		if (Object.keys(this.userData).length > 0) object.userData = this.userData;
		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();
		object.up = this.up.toArray();
		if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
		if (this.isInstancedMesh) {
			object.type = "InstancedMesh";
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
		}
		if (this.isBatchedMesh) {
			object.type = "BatchedMesh";
			object.perObjectFrustumCulled = this.perObjectFrustumCulled;
			object.sortObjects = this.sortObjects;
			object.drawRanges = this._drawRanges;
			object.reservedRanges = this._reservedRanges;
			object.geometryInfo = this._geometryInfo.map((info) => ({
				...info,
				boundingBox: info.boundingBox ? info.boundingBox.toJSON() : void 0,
				boundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : void 0
			}));
			object.instanceInfo = this._instanceInfo.map((info) => ({ ...info }));
			object.availableInstanceIds = this._availableInstanceIds.slice();
			object.availableGeometryIds = this._availableGeometryIds.slice();
			object.nextIndexStart = this._nextIndexStart;
			object.nextVertexStart = this._nextVertexStart;
			object.geometryCount = this._geometryCount;
			object.maxInstanceCount = this._maxInstanceCount;
			object.maxVertexCount = this._maxVertexCount;
			object.maxIndexCount = this._maxIndexCount;
			object.geometryInitialized = this._geometryInitialized;
			object.matricesTexture = this._matricesTexture.toJSON(meta);
			object.indirectTexture = this._indirectTexture.toJSON(meta);
			if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
			if (this.boundingSphere !== null) object.boundingSphere = this.boundingSphere.toJSON();
			if (this.boundingBox !== null) object.boundingBox = this.boundingBox.toJSON();
		}
		function serialize$1(library, element$2) {
			if (library[element$2.uuid] === void 0) library[element$2.uuid] = element$2.toJSON(meta);
			return element$2.uuid;
		}
		if (this.isScene) {
			if (this.background) {
				if (this.background.isColor) object.background = this.background.toJSON();
				else if (this.background.isTexture) object.background = this.background.toJSON(meta).uuid;
			}
			if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) object.environment = this.environment.toJSON(meta).uuid;
		} else if (this.isMesh || this.isLine || this.isPoints) {
			object.geometry = serialize$1(meta.geometries, this.geometry);
			const parameters = this.geometry.parameters;
			if (parameters !== void 0 && parameters.shapes !== void 0) {
				const shapes = parameters.shapes;
				if (Array.isArray(shapes)) for (let i = 0, l = shapes.length; i < l; i++) {
					const shape = shapes[i];
					serialize$1(meta.shapes, shape);
				}
				else serialize$1(meta.shapes, shapes);
			}
		}
		if (this.isSkinnedMesh) {
			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();
			if (this.skeleton !== void 0) {
				serialize$1(meta.skeletons, this.skeleton);
				object.skeleton = this.skeleton.uuid;
			}
		}
		if (this.material !== void 0) if (Array.isArray(this.material)) {
			const uuids = [];
			for (let i = 0, l = this.material.length; i < l; i++) uuids.push(serialize$1(meta.materials, this.material[i]));
			object.material = uuids;
		} else object.material = serialize$1(meta.materials, this.material);
		if (this.children.length > 0) {
			object.children = [];
			for (let i = 0; i < this.children.length; i++) object.children.push(this.children[i].toJSON(meta).object);
		}
		if (this.animations.length > 0) {
			object.animations = [];
			for (let i = 0; i < this.animations.length; i++) {
				const animation = this.animations[i];
				object.animations.push(serialize$1(meta.animations, animation));
			}
		}
		if (isRootObject) {
			const geometries = extractFromCache(meta.geometries);
			const materials = extractFromCache(meta.materials);
			const textures = extractFromCache(meta.textures);
			const images = extractFromCache(meta.images);
			const shapes = extractFromCache(meta.shapes);
			const skeletons = extractFromCache(meta.skeletons);
			const animations = extractFromCache(meta.animations);
			const nodes = extractFromCache(meta.nodes);
			if (geometries.length > 0) output$2.geometries = geometries;
			if (materials.length > 0) output$2.materials = materials;
			if (textures.length > 0) output$2.textures = textures;
			if (images.length > 0) output$2.images = images;
			if (shapes.length > 0) output$2.shapes = shapes;
			if (skeletons.length > 0) output$2.skeletons = skeletons;
			if (animations.length > 0) output$2.animations = animations;
			if (nodes.length > 0) output$2.nodes = nodes;
		}
		output$2.object = object;
		return output$2;
		function extractFromCache(cache$2) {
			const values = [];
			for (const key in cache$2) {
				const data = cache$2[key];
				delete data.metadata;
				values.push(data);
			}
			return values;
		}
	}
	/**
	* Returns a new 3D object with copied values from this instance.
	*
	* @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
	* @return {Object3D} A clone of this instance.
	*/
	clone(recursive) {
		return new this.constructor().copy(this, recursive);
	}
	/**
	* Copies the values of the given 3D object to this instance.
	*
	* @param {Object3D} source - The 3D object to copy.
	* @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
	* @return {Object3D} A reference to this instance.
	*/
	copy(source, recursive = true) {
		this.name = source.name;
		this.up.copy(source.up);
		this.position.copy(source.position);
		this.rotation.order = source.rotation.order;
		this.quaternion.copy(source.quaternion);
		this.scale.copy(source.scale);
		this.matrix.copy(source.matrix);
		this.matrixWorld.copy(source.matrixWorld);
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
		this.layers.mask = source.layers.mask;
		this.visible = source.visible;
		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;
		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;
		this.animations = source.animations.slice();
		this.userData = JSON.parse(JSON.stringify(source.userData));
		if (recursive === true) for (let i = 0; i < source.children.length; i++) {
			const child = source.children[i];
			this.add(child.clone());
		}
		return this;
	}
};
/**
* The default up direction for objects, also used as the default
* position for {@link DirectionalLight} and {@link HemisphereLight}.
*
* @static
* @type {Vector3}
* @default (0,1,0)
*/
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
/**
* The default setting for {@link Object3D#matrixAutoUpdate} for
* newly created 3D objects.
*
* @static
* @type {boolean}
* @default true
*/
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
/**
* The default setting for {@link Object3D#matrixWorldAutoUpdate} for
* newly created 3D objects.
*
* @static
* @type {boolean}
* @default true
*/
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
var _v0$1 = /* @__PURE__ */ new Vector3();
var _v1$3 = /* @__PURE__ */ new Vector3();
var _v2$2 = /* @__PURE__ */ new Vector3();
var _v3$2 = /* @__PURE__ */ new Vector3();
var _vab = /* @__PURE__ */ new Vector3();
var _vac = /* @__PURE__ */ new Vector3();
var _vbc = /* @__PURE__ */ new Vector3();
var _vap = /* @__PURE__ */ new Vector3();
var _vbp = /* @__PURE__ */ new Vector3();
var _vcp = /* @__PURE__ */ new Vector3();
var _v40 = /* @__PURE__ */ new Vector4();
var _v41 = /* @__PURE__ */ new Vector4();
var _v42 = /* @__PURE__ */ new Vector4();
/**
* A geometric triangle as defined by three vectors representing its three corners.
*/
var Triangle = class Triangle {
	/**
	* Constructs a new triangle.
	*
	* @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
	* @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
	* @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
	*/
	constructor(a$1 = new Vector3(), b$2 = new Vector3(), c$1 = new Vector3()) {
		/**
		* The first corner of the triangle.
		*
		* @type {Vector3}
		*/
		this.a = a$1;
		/**
		* The second corner of the triangle.
		*
		* @type {Vector3}
		*/
		this.b = b$2;
		/**
		* The third corner of the triangle.
		*
		* @type {Vector3}
		*/
		this.c = c$1;
	}
	/**
	* Computes the normal vector of a triangle.
	*
	* @param {Vector3} a - The first corner of the triangle.
	* @param {Vector3} b - The second corner of the triangle.
	* @param {Vector3} c - The third corner of the triangle.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The triangle's normal.
	*/
	static getNormal(a$1, b$2, c$1, target) {
		target.subVectors(c$1, b$2);
		_v0$1.subVectors(a$1, b$2);
		target.cross(_v0$1);
		const targetLengthSq = target.lengthSq();
		if (targetLengthSq > 0) return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
		return target.set(0, 0, 0);
	}
	/**
	* Computes a barycentric coordinates from the given vector.
	* Returns `null` if the triangle is degenerate.
	*
	* @param {Vector3} point - A point in 3D space.
	* @param {Vector3} a - The first corner of the triangle.
	* @param {Vector3} b - The second corner of the triangle.
	* @param {Vector3} c - The third corner of the triangle.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {?Vector3} The barycentric coordinates for the given point
	*/
	static getBarycoord(point, a$1, b$2, c$1, target) {
		_v0$1.subVectors(c$1, a$1);
		_v1$3.subVectors(b$2, a$1);
		_v2$2.subVectors(point, a$1);
		const dot00 = _v0$1.dot(_v0$1);
		const dot01 = _v0$1.dot(_v1$3);
		const dot02 = _v0$1.dot(_v2$2);
		const dot11 = _v1$3.dot(_v1$3);
		const dot12 = _v1$3.dot(_v2$2);
		const denom = dot00 * dot11 - dot01 * dot01;
		if (denom === 0) {
			target.set(0, 0, 0);
			return null;
		}
		const invDenom = 1 / denom;
		const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
		const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
		return target.set(1 - u - v, v, u);
	}
	/**
	* Returns `true` if the given point, when projected onto the plane of the
	* triangle, lies within the triangle.
	*
	* @param {Vector3} point - The point in 3D space to test.
	* @param {Vector3} a - The first corner of the triangle.
	* @param {Vector3} b - The second corner of the triangle.
	* @param {Vector3} c - The third corner of the triangle.
	* @return {boolean} Whether the given point, when projected onto the plane of the
	* triangle, lies within the triangle or not.
	*/
	static containsPoint(point, a$1, b$2, c$1) {
		if (this.getBarycoord(point, a$1, b$2, c$1, _v3$2) === null) return false;
		return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
	}
	/**
	* Computes the value barycentrically interpolated for the given point on the
	* triangle. Returns `null` if the triangle is degenerate.
	*
	* @param {Vector3} point - Position of interpolated point.
	* @param {Vector3} p1 - The first corner of the triangle.
	* @param {Vector3} p2 - The second corner of the triangle.
	* @param {Vector3} p3 - The third corner of the triangle.
	* @param {Vector3} v1 - Value to interpolate of first vertex.
	* @param {Vector3} v2 - Value to interpolate of second vertex.
	* @param {Vector3} v3 - Value to interpolate of third vertex.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {?Vector3} The interpolated value.
	*/
	static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
		if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
			target.x = 0;
			target.y = 0;
			if ("z" in target) target.z = 0;
			if ("w" in target) target.w = 0;
			return null;
		}
		target.setScalar(0);
		target.addScaledVector(v1, _v3$2.x);
		target.addScaledVector(v2, _v3$2.y);
		target.addScaledVector(v3, _v3$2.z);
		return target;
	}
	/**
	* Computes the value barycentrically interpolated for the given attribute and indices.
	*
	* @param {BufferAttribute} attr - The attribute to interpolate.
	* @param {number} i1 - Index of first vertex.
	* @param {number} i2 - Index of second vertex.
	* @param {number} i3 - Index of third vertex.
	* @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The interpolated attribute value.
	*/
	static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
		_v40.setScalar(0);
		_v41.setScalar(0);
		_v42.setScalar(0);
		_v40.fromBufferAttribute(attr, i1);
		_v41.fromBufferAttribute(attr, i2);
		_v42.fromBufferAttribute(attr, i3);
		target.setScalar(0);
		target.addScaledVector(_v40, barycoord.x);
		target.addScaledVector(_v41, barycoord.y);
		target.addScaledVector(_v42, barycoord.z);
		return target;
	}
	/**
	* Returns `true` if the triangle is oriented towards the given direction.
	*
	* @param {Vector3} a - The first corner of the triangle.
	* @param {Vector3} b - The second corner of the triangle.
	* @param {Vector3} c - The third corner of the triangle.
	* @param {Vector3} direction - The (normalized) direction vector.
	* @return {boolean} Whether the triangle is oriented towards the given direction or not.
	*/
	static isFrontFacing(a$1, b$2, c$1, direction) {
		_v0$1.subVectors(c$1, b$2);
		_v1$3.subVectors(a$1, b$2);
		return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
	}
	/**
	* Sets the triangle's vertices by copying the given values.
	*
	* @param {Vector3} a - The first corner of the triangle.
	* @param {Vector3} b - The second corner of the triangle.
	* @param {Vector3} c - The third corner of the triangle.
	* @return {Triangle} A reference to this triangle.
	*/
	set(a$1, b$2, c$1) {
		this.a.copy(a$1);
		this.b.copy(b$2);
		this.c.copy(c$1);
		return this;
	}
	/**
	* Sets the triangle's vertices by copying the given array values.
	*
	* @param {Array<Vector3>} points - An array with 3D points.
	* @param {number} i0 - The array index representing the first corner of the triangle.
	* @param {number} i1 - The array index representing the second corner of the triangle.
	* @param {number} i2 - The array index representing the third corner of the triangle.
	* @return {Triangle} A reference to this triangle.
	*/
	setFromPointsAndIndices(points, i0, i1, i2) {
		this.a.copy(points[i0]);
		this.b.copy(points[i1]);
		this.c.copy(points[i2]);
		return this;
	}
	/**
	* Sets the triangle's vertices by copying the given attribute values.
	*
	* @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
	* @param {number} i0 - The attribute index representing the first corner of the triangle.
	* @param {number} i1 - The attribute index representing the second corner of the triangle.
	* @param {number} i2 - The attribute index representing the third corner of the triangle.
	* @return {Triangle} A reference to this triangle.
	*/
	setFromAttributeAndIndices(attribute$2, i0, i1, i2) {
		this.a.fromBufferAttribute(attribute$2, i0);
		this.b.fromBufferAttribute(attribute$2, i1);
		this.c.fromBufferAttribute(attribute$2, i2);
		return this;
	}
	/**
	* Returns a new triangle with copied values from this instance.
	*
	* @return {Triangle} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	/**
	* Copies the values of the given triangle to this instance.
	*
	* @param {Triangle} triangle - The triangle to copy.
	* @return {Triangle} A reference to this triangle.
	*/
	copy(triangle) {
		this.a.copy(triangle.a);
		this.b.copy(triangle.b);
		this.c.copy(triangle.c);
		return this;
	}
	/**
	* Computes the area of the triangle.
	*
	* @return {number} The triangle's area.
	*/
	getArea() {
		_v0$1.subVectors(this.c, this.b);
		_v1$3.subVectors(this.a, this.b);
		return _v0$1.cross(_v1$3).length() * .5;
	}
	/**
	* Computes the midpoint of the triangle.
	*
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The triangle's midpoint.
	*/
	getMidpoint(target) {
		return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
	}
	/**
	* Computes the normal of the triangle.
	*
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The triangle's normal.
	*/
	getNormal(target) {
		return Triangle.getNormal(this.a, this.b, this.c, target);
	}
	/**
	* Computes a plane the triangle lies within.
	*
	* @param {Plane} target - The target vector that is used to store the method's result.
	* @return {Plane} The plane the triangle lies within.
	*/
	getPlane(target) {
		return target.setFromCoplanarPoints(this.a, this.b, this.c);
	}
	/**
	* Computes a barycentric coordinates from the given vector.
	* Returns `null` if the triangle is degenerate.
	*
	* @param {Vector3} point - A point in 3D space.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {?Vector3} The barycentric coordinates for the given point
	*/
	getBarycoord(point, target) {
		return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
	}
	/**
	* Computes the value barycentrically interpolated for the given point on the
	* triangle. Returns `null` if the triangle is degenerate.
	*
	* @param {Vector3} point - Position of interpolated point.
	* @param {Vector3} v1 - Value to interpolate of first vertex.
	* @param {Vector3} v2 - Value to interpolate of second vertex.
	* @param {Vector3} v3 - Value to interpolate of third vertex.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {?Vector3} The interpolated value.
	*/
	getInterpolation(point, v1, v2, v3, target) {
		return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
	}
	/**
	* Returns `true` if the given point, when projected onto the plane of the
	* triangle, lies within the triangle.
	*
	* @param {Vector3} point - The point in 3D space to test.
	* @return {boolean} Whether the given point, when projected onto the plane of the
	* triangle, lies within the triangle or not.
	*/
	containsPoint(point) {
		return Triangle.containsPoint(point, this.a, this.b, this.c);
	}
	/**
	* Returns `true` if the triangle is oriented towards the given direction.
	*
	* @param {Vector3} direction - The (normalized) direction vector.
	* @return {boolean} Whether the triangle is oriented towards the given direction or not.
	*/
	isFrontFacing(direction) {
		return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
	}
	/**
	* Returns `true` if this triangle intersects with the given box.
	*
	* @param {Box3} box - The box to intersect.
	* @return {boolean} Whether this triangle intersects with the given box or not.
	*/
	intersectsBox(box) {
		return box.intersectsTriangle(this);
	}
	/**
	* Returns the closest point on the triangle to the given point.
	*
	* @param {Vector3} p - The point to compute the closest point for.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The closest point on the triangle.
	*/
	closestPointToPoint(p$1, target) {
		const a$1 = this.a, b$2 = this.b, c$1 = this.c;
		let v, w;
		_vab.subVectors(b$2, a$1);
		_vac.subVectors(c$1, a$1);
		_vap.subVectors(p$1, a$1);
		const d1 = _vab.dot(_vap);
		const d2 = _vac.dot(_vap);
		if (d1 <= 0 && d2 <= 0) return target.copy(a$1);
		_vbp.subVectors(p$1, b$2);
		const d3 = _vab.dot(_vbp);
		const d4 = _vac.dot(_vbp);
		if (d3 >= 0 && d4 <= d3) return target.copy(b$2);
		const vc = d1 * d4 - d3 * d2;
		if (vc <= 0 && d1 >= 0 && d3 <= 0) {
			v = d1 / (d1 - d3);
			return target.copy(a$1).addScaledVector(_vab, v);
		}
		_vcp.subVectors(p$1, c$1);
		const d5 = _vab.dot(_vcp);
		const d6 = _vac.dot(_vcp);
		if (d6 >= 0 && d5 <= d6) return target.copy(c$1);
		const vb = d5 * d2 - d1 * d6;
		if (vb <= 0 && d2 >= 0 && d6 <= 0) {
			w = d2 / (d2 - d6);
			return target.copy(a$1).addScaledVector(_vac, w);
		}
		const va = d3 * d6 - d5 * d4;
		if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
			_vbc.subVectors(c$1, b$2);
			w = (d4 - d3) / (d4 - d3 + (d5 - d6));
			return target.copy(b$2).addScaledVector(_vbc, w);
		}
		const denom = 1 / (va + vb + vc);
		v = vb * denom;
		w = vc * denom;
		return target.copy(a$1).addScaledVector(_vab, v).addScaledVector(_vac, w);
	}
	/**
	* Returns `true` if this triangle is equal with the given one.
	*
	* @param {Triangle} triangle - The triangle to test for equality.
	* @return {boolean} Whether this triangle is equal with the given one.
	*/
	equals(triangle) {
		return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
	}
};
var _colorKeywords = {
	"aliceblue": 15792383,
	"antiquewhite": 16444375,
	"aqua": 65535,
	"aquamarine": 8388564,
	"azure": 15794175,
	"beige": 16119260,
	"bisque": 16770244,
	"black": 0,
	"blanchedalmond": 16772045,
	"blue": 255,
	"blueviolet": 9055202,
	"brown": 10824234,
	"burlywood": 14596231,
	"cadetblue": 6266528,
	"chartreuse": 8388352,
	"chocolate": 13789470,
	"coral": 16744272,
	"cornflowerblue": 6591981,
	"cornsilk": 16775388,
	"crimson": 14423100,
	"cyan": 65535,
	"darkblue": 139,
	"darkcyan": 35723,
	"darkgoldenrod": 12092939,
	"darkgray": 11119017,
	"darkgreen": 25600,
	"darkgrey": 11119017,
	"darkkhaki": 12433259,
	"darkmagenta": 9109643,
	"darkolivegreen": 5597999,
	"darkorange": 16747520,
	"darkorchid": 10040012,
	"darkred": 9109504,
	"darksalmon": 15308410,
	"darkseagreen": 9419919,
	"darkslateblue": 4734347,
	"darkslategray": 3100495,
	"darkslategrey": 3100495,
	"darkturquoise": 52945,
	"darkviolet": 9699539,
	"deeppink": 16716947,
	"deepskyblue": 49151,
	"dimgray": 6908265,
	"dimgrey": 6908265,
	"dodgerblue": 2003199,
	"firebrick": 11674146,
	"floralwhite": 16775920,
	"forestgreen": 2263842,
	"fuchsia": 16711935,
	"gainsboro": 14474460,
	"ghostwhite": 16316671,
	"gold": 16766720,
	"goldenrod": 14329120,
	"gray": 8421504,
	"green": 32768,
	"greenyellow": 11403055,
	"grey": 8421504,
	"honeydew": 15794160,
	"hotpink": 16738740,
	"indianred": 13458524,
	"indigo": 4915330,
	"ivory": 16777200,
	"khaki": 15787660,
	"lavender": 15132410,
	"lavenderblush": 16773365,
	"lawngreen": 8190976,
	"lemonchiffon": 16775885,
	"lightblue": 11393254,
	"lightcoral": 15761536,
	"lightcyan": 14745599,
	"lightgoldenrodyellow": 16448210,
	"lightgray": 13882323,
	"lightgreen": 9498256,
	"lightgrey": 13882323,
	"lightpink": 16758465,
	"lightsalmon": 16752762,
	"lightseagreen": 2142890,
	"lightskyblue": 8900346,
	"lightslategray": 7833753,
	"lightslategrey": 7833753,
	"lightsteelblue": 11584734,
	"lightyellow": 16777184,
	"lime": 65280,
	"limegreen": 3329330,
	"linen": 16445670,
	"magenta": 16711935,
	"maroon": 8388608,
	"mediumaquamarine": 6737322,
	"mediumblue": 205,
	"mediumorchid": 12211667,
	"mediumpurple": 9662683,
	"mediumseagreen": 3978097,
	"mediumslateblue": 8087790,
	"mediumspringgreen": 64154,
	"mediumturquoise": 4772300,
	"mediumvioletred": 13047173,
	"midnightblue": 1644912,
	"mintcream": 16121850,
	"mistyrose": 16770273,
	"moccasin": 16770229,
	"navajowhite": 16768685,
	"navy": 128,
	"oldlace": 16643558,
	"olive": 8421376,
	"olivedrab": 7048739,
	"orange": 16753920,
	"orangered": 16729344,
	"orchid": 14315734,
	"palegoldenrod": 15657130,
	"palegreen": 10025880,
	"paleturquoise": 11529966,
	"palevioletred": 14381203,
	"papayawhip": 16773077,
	"peachpuff": 16767673,
	"peru": 13468991,
	"pink": 16761035,
	"plum": 14524637,
	"powderblue": 11591910,
	"purple": 8388736,
	"rebeccapurple": 6697881,
	"red": 16711680,
	"rosybrown": 12357519,
	"royalblue": 4286945,
	"saddlebrown": 9127187,
	"salmon": 16416882,
	"sandybrown": 16032864,
	"seagreen": 3050327,
	"seashell": 16774638,
	"sienna": 10506797,
	"silver": 12632256,
	"skyblue": 8900331,
	"slateblue": 6970061,
	"slategray": 7372944,
	"slategrey": 7372944,
	"snow": 16775930,
	"springgreen": 65407,
	"steelblue": 4620980,
	"tan": 13808780,
	"teal": 32896,
	"thistle": 14204888,
	"tomato": 16737095,
	"turquoise": 4251856,
	"violet": 15631086,
	"wheat": 16113331,
	"white": 16777215,
	"whitesmoke": 16119285,
	"yellow": 16776960,
	"yellowgreen": 10145074
};
var _hslA = {
	h: 0,
	s: 0,
	l: 0
};
var _hslB = {
	h: 0,
	s: 0,
	l: 0
};
function hue2rgb(p$1, q, t) {
	if (t < 0) t += 1;
	if (t > 1) t -= 1;
	if (t < 1 / 6) return p$1 + (q - p$1) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p$1 + (q - p$1) * 6 * (2 / 3 - t);
	return p$1;
}
/**
* A Color instance is represented by RGB components in the linear <i>working
* color space</i>, which defaults to `LinearSRGBColorSpace`. Inputs
* conventionally using `SRGBColorSpace` (such as hexadecimals and CSS
* strings) are converted to the working color space automatically.
*
* ```js
* // converted automatically from SRGBColorSpace to LinearSRGBColorSpace
* const color = new THREE.Color().setHex( 0x112233 );
* ```
* Source color spaces may be specified explicitly, to ensure correct conversions.
* ```js
* // assumed already LinearSRGBColorSpace; no conversion
* const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );
*
* // converted explicitly from SRGBColorSpace to LinearSRGBColorSpace
* const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5, SRGBColorSpace );
* ```
* If THREE.ColorManagement is disabled, no conversions occur. For details,
* see <i>Color management</i>. Iterating through a Color instance will yield
* its components (r, g, b) in the corresponding order. A Color can be initialised
* in any of the following ways:
* ```js
* //empty constructor - will default white
* const color1 = new THREE.Color();
*
* //Hexadecimal color (recommended)
* const color2 = new THREE.Color( 0xff0000 );
*
* //RGB string
* const color3 = new THREE.Color("rgb(255, 0, 0)");
* const color4 = new THREE.Color("rgb(100%, 0%, 0%)");
*
* //X11 color name - all 140 color names are supported.
* //Note the lack of CamelCase in the name
* const color5 = new THREE.Color( 'skyblue' );
* //HSL string
* const color6 = new THREE.Color("hsl(0, 100%, 50%)");
*
* //Separate RGB values between 0 and 1
* const color7 = new THREE.Color( 1, 0, 0 );
* ```
*/
var Color$1 = class {
	/**
	* Constructs a new color.
	*
	* Note that standard method of specifying color in three.js is with a hexadecimal triplet,
	* and that method is used throughout the rest of the documentation.
	*
	* @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
	* not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
	* @param {number} [g] - The green component.
	* @param {number} [b] - The blue component.
	*/
	constructor(r, g$1, b$2) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isColor = true;
		/**
		* The red component.
		*
		* @type {number}
		* @default 1
		*/
		this.r = 1;
		/**
		* The green component.
		*
		* @type {number}
		* @default 1
		*/
		this.g = 1;
		/**
		* The blue component.
		*
		* @type {number}
		* @default 1
		*/
		this.b = 1;
		return this.set(r, g$1, b$2);
	}
	/**
	* Sets the colors's components from the given values.
	*
	* @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
	* not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
	* @param {number} [g] - The green component.
	* @param {number} [b] - The blue component.
	* @return {Color} A reference to this color.
	*/
	set(r, g$1, b$2) {
		if (g$1 === void 0 && b$2 === void 0) {
			const value = r;
			if (value && value.isColor) this.copy(value);
			else if (typeof value === "number") this.setHex(value);
			else if (typeof value === "string") this.setStyle(value);
		} else this.setRGB(r, g$1, b$2);
		return this;
	}
	/**
	* Sets the colors's components to the given scalar value.
	*
	* @param {number} scalar - The scalar value.
	* @return {Color} A reference to this color.
	*/
	setScalar(scalar) {
		this.r = scalar;
		this.g = scalar;
		this.b = scalar;
		return this;
	}
	/**
	* Sets this color from a hexadecimal value.
	*
	* @param {number} hex - The hexadecimal value.
	* @param {string} [colorSpace=SRGBColorSpace] - The color space.
	* @return {Color} A reference to this color.
	*/
	setHex(hex, colorSpace = SRGBColorSpace) {
		hex = Math.floor(hex);
		this.r = (hex >> 16 & 255) / 255;
		this.g = (hex >> 8 & 255) / 255;
		this.b = (hex & 255) / 255;
		ColorManagement.colorSpaceToWorking(this, colorSpace);
		return this;
	}
	/**
	* Sets this color from RGB values.
	*
	* @param {number} r - Red channel value between `0.0` and `1.0`.
	* @param {number} g - Green channel value between `0.0` and `1.0`.
	* @param {number} b - Blue channel value between `0.0` and `1.0`.
	* @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	* @return {Color} A reference to this color.
	*/
	setRGB(r, g$1, b$2, colorSpace = ColorManagement.workingColorSpace) {
		this.r = r;
		this.g = g$1;
		this.b = b$2;
		ColorManagement.colorSpaceToWorking(this, colorSpace);
		return this;
	}
	/**
	* Sets this color from RGB values.
	*
	* @param {number} h - Hue value between `0.0` and `1.0`.
	* @param {number} s - Saturation value between `0.0` and `1.0`.
	* @param {number} l - Lightness value between `0.0` and `1.0`.
	* @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	* @return {Color} A reference to this color.
	*/
	setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
		h = euclideanModulo(h, 1);
		s = clamp$3(s, 0, 1);
		l = clamp$3(l, 0, 1);
		if (s === 0) this.r = this.g = this.b = l;
		else {
			const p$1 = l <= .5 ? l * (1 + s) : l + s - l * s;
			const q = 2 * l - p$1;
			this.r = hue2rgb(q, p$1, h + 1 / 3);
			this.g = hue2rgb(q, p$1, h);
			this.b = hue2rgb(q, p$1, h - 1 / 3);
		}
		ColorManagement.colorSpaceToWorking(this, colorSpace);
		return this;
	}
	/**
	* Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
	* `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
	* any [X11 color name](https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart) -
	* all 140 color names are supported).
	*
	* @param {string} style - Color as a CSS-style string.
	* @param {string} [colorSpace=SRGBColorSpace] - The color space.
	* @return {Color} A reference to this color.
	*/
	setStyle(style, colorSpace = SRGBColorSpace) {
		function handleAlpha(string$2) {
			if (string$2 === void 0) return;
			if (parseFloat(string$2) < 1) warn("Color: Alpha component of " + style + " will be ignored.");
		}
		let m$1;
		if (m$1 = /^(\w+)\(([^\)]*)\)/.exec(style)) {
			let color$2;
			const name = m$1[1];
			const components = m$1[2];
			switch (name) {
				case "rgb":
				case "rgba":
					if (color$2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
						handleAlpha(color$2[4]);
						return this.setRGB(Math.min(255, parseInt(color$2[1], 10)) / 255, Math.min(255, parseInt(color$2[2], 10)) / 255, Math.min(255, parseInt(color$2[3], 10)) / 255, colorSpace);
					}
					if (color$2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
						handleAlpha(color$2[4]);
						return this.setRGB(Math.min(100, parseInt(color$2[1], 10)) / 100, Math.min(100, parseInt(color$2[2], 10)) / 100, Math.min(100, parseInt(color$2[3], 10)) / 100, colorSpace);
					}
					break;
				case "hsl":
				case "hsla":
					if (color$2 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
						handleAlpha(color$2[4]);
						return this.setHSL(parseFloat(color$2[1]) / 360, parseFloat(color$2[2]) / 100, parseFloat(color$2[3]) / 100, colorSpace);
					}
					break;
				default: warn("Color: Unknown color model " + style);
			}
		} else if (m$1 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
			const hex = m$1[1];
			const size = hex.length;
			if (size === 3) return this.setRGB(parseInt(hex.charAt(0), 16) / 15, parseInt(hex.charAt(1), 16) / 15, parseInt(hex.charAt(2), 16) / 15, colorSpace);
			else if (size === 6) return this.setHex(parseInt(hex, 16), colorSpace);
			else warn("Color: Invalid hex color " + style);
		} else if (style && style.length > 0) return this.setColorName(style, colorSpace);
		return this;
	}
	/**
	* Sets this color from a color name. Faster than {@link Color#setStyle} if
	* you don't need the other CSS-style formats.
	*
	* For convenience, the list of names is exposed in `Color.NAMES` as a hash.
	* ```js
	* Color.NAMES.aliceblue // returns 0xF0F8FF
	* ```
	*
	* @param {string} style - The color name.
	* @param {string} [colorSpace=SRGBColorSpace] - The color space.
	* @return {Color} A reference to this color.
	*/
	setColorName(style, colorSpace = SRGBColorSpace) {
		const hex = _colorKeywords[style.toLowerCase()];
		if (hex !== void 0) this.setHex(hex, colorSpace);
		else warn("Color: Unknown color " + style);
		return this;
	}
	/**
	* Returns a new color with copied values from this instance.
	*
	* @return {Color} A clone of this instance.
	*/
	clone() {
		return new this.constructor(this.r, this.g, this.b);
	}
	/**
	* Copies the values of the given color to this instance.
	*
	* @param {Color} color - The color to copy.
	* @return {Color} A reference to this color.
	*/
	copy(color$2) {
		this.r = color$2.r;
		this.g = color$2.g;
		this.b = color$2.b;
		return this;
	}
	/**
	* Copies the given color into this color, and then converts this color from
	* `SRGBColorSpace` to `LinearSRGBColorSpace`.
	*
	* @param {Color} color - The color to copy/convert.
	* @return {Color} A reference to this color.
	*/
	copySRGBToLinear(color$2) {
		this.r = SRGBToLinear(color$2.r);
		this.g = SRGBToLinear(color$2.g);
		this.b = SRGBToLinear(color$2.b);
		return this;
	}
	/**
	* Copies the given color into this color, and then converts this color from
	* `LinearSRGBColorSpace` to `SRGBColorSpace`.
	*
	* @param {Color} color - The color to copy/convert.
	* @return {Color} A reference to this color.
	*/
	copyLinearToSRGB(color$2) {
		this.r = LinearToSRGB(color$2.r);
		this.g = LinearToSRGB(color$2.g);
		this.b = LinearToSRGB(color$2.b);
		return this;
	}
	/**
	* Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
	*
	* @return {Color} A reference to this color.
	*/
	convertSRGBToLinear() {
		this.copySRGBToLinear(this);
		return this;
	}
	/**
	* Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
	*
	* @return {Color} A reference to this color.
	*/
	convertLinearToSRGB() {
		this.copyLinearToSRGB(this);
		return this;
	}
	/**
	* Returns the hexadecimal value of this color.
	*
	* @param {string} [colorSpace=SRGBColorSpace] - The color space.
	* @return {number} The hexadecimal value.
	*/
	getHex(colorSpace = SRGBColorSpace) {
		ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
		return Math.round(clamp$3(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp$3(_color.g * 255, 0, 255)) * 256 + Math.round(clamp$3(_color.b * 255, 0, 255));
	}
	/**
	* Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
	*
	* @param {string} [colorSpace=SRGBColorSpace] - The color space.
	* @return {string} The hexadecimal value as a string.
	*/
	getHexString(colorSpace = SRGBColorSpace) {
		return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
	}
	/**
	* Converts the colors RGB values into the HSL format and stores them into the
	* given target object.
	*
	* @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
	* @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	* @return {{h:number,s:number,l:number}} The HSL representation of this color.
	*/
	getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
		ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
		const r = _color.r, g$1 = _color.g, b$2 = _color.b;
		const max$3 = Math.max(r, g$1, b$2);
		const min$3 = Math.min(r, g$1, b$2);
		let hue$2, saturation$2;
		const lightness = (min$3 + max$3) / 2;
		if (min$3 === max$3) {
			hue$2 = 0;
			saturation$2 = 0;
		} else {
			const delta = max$3 - min$3;
			saturation$2 = lightness <= .5 ? delta / (max$3 + min$3) : delta / (2 - max$3 - min$3);
			switch (max$3) {
				case r:
					hue$2 = (g$1 - b$2) / delta + (g$1 < b$2 ? 6 : 0);
					break;
				case g$1:
					hue$2 = (b$2 - r) / delta + 2;
					break;
				case b$2:
					hue$2 = (r - g$1) / delta + 4;
					break;
			}
			hue$2 /= 6;
		}
		target.h = hue$2;
		target.s = saturation$2;
		target.l = lightness;
		return target;
	}
	/**
	* Returns the RGB values of this color and stores them into the given target object.
	*
	* @param {Color} target - The target color that is used to store the method's result.
	* @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	* @return {Color} The RGB representation of this color.
	*/
	getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
		ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
		target.r = _color.r;
		target.g = _color.g;
		target.b = _color.b;
		return target;
	}
	/**
	* Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
	*
	* @param {string} [colorSpace=SRGBColorSpace] - The color space.
	* @return {string} The CSS representation of this color.
	*/
	getStyle(colorSpace = SRGBColorSpace) {
		ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
		const r = _color.r, g$1 = _color.g, b$2 = _color.b;
		if (colorSpace !== SRGBColorSpace) return `color(${colorSpace} ${r.toFixed(3)} ${g$1.toFixed(3)} ${b$2.toFixed(3)})`;
		return `rgb(${Math.round(r * 255)},${Math.round(g$1 * 255)},${Math.round(b$2 * 255)})`;
	}
	/**
	* Adds the given HSL values to this color's values.
	* Internally, this converts the color's RGB values to HSL, adds HSL
	* and then converts the color back to RGB.
	*
	* @param {number} h - Hue value between `0.0` and `1.0`.
	* @param {number} s - Saturation value between `0.0` and `1.0`.
	* @param {number} l - Lightness value between `0.0` and `1.0`.
	* @return {Color} A reference to this color.
	*/
	offsetHSL(h, s, l) {
		this.getHSL(_hslA);
		return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
	}
	/**
	* Adds the RGB values of the given color to the RGB values of this color.
	*
	* @param {Color} color - The color to add.
	* @return {Color} A reference to this color.
	*/
	add(color$2) {
		this.r += color$2.r;
		this.g += color$2.g;
		this.b += color$2.b;
		return this;
	}
	/**
	* Adds the RGB values of the given colors and stores the result in this instance.
	*
	* @param {Color} color1 - The first color.
	* @param {Color} color2 - The second color.
	* @return {Color} A reference to this color.
	*/
	addColors(color1, color2) {
		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;
		return this;
	}
	/**
	* Adds the given scalar value to the RGB values of this color.
	*
	* @param {number} s - The scalar to add.
	* @return {Color} A reference to this color.
	*/
	addScalar(s) {
		this.r += s;
		this.g += s;
		this.b += s;
		return this;
	}
	/**
	* Subtracts the RGB values of the given color from the RGB values of this color.
	*
	* @param {Color} color - The color to subtract.
	* @return {Color} A reference to this color.
	*/
	sub(color$2) {
		this.r = Math.max(0, this.r - color$2.r);
		this.g = Math.max(0, this.g - color$2.g);
		this.b = Math.max(0, this.b - color$2.b);
		return this;
	}
	/**
	* Multiplies the RGB values of the given color with the RGB values of this color.
	*
	* @param {Color} color - The color to multiply.
	* @return {Color} A reference to this color.
	*/
	multiply(color$2) {
		this.r *= color$2.r;
		this.g *= color$2.g;
		this.b *= color$2.b;
		return this;
	}
	/**
	* Multiplies the given scalar value with the RGB values of this color.
	*
	* @param {number} s - The scalar to multiply.
	* @return {Color} A reference to this color.
	*/
	multiplyScalar(s) {
		this.r *= s;
		this.g *= s;
		this.b *= s;
		return this;
	}
	/**
	* Linearly interpolates this color's RGB values toward the RGB values of the
	* given color. The alpha argument can be thought of as the ratio between
	* the two colors, where `0.0` is this color and `1.0` is the first argument.
	*
	* @param {Color} color - The color to converge on.
	* @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
	* @return {Color} A reference to this color.
	*/
	lerp(color$2, alpha) {
		this.r += (color$2.r - this.r) * alpha;
		this.g += (color$2.g - this.g) * alpha;
		this.b += (color$2.b - this.b) * alpha;
		return this;
	}
	/**
	* Linearly interpolates between the given colors and stores the result in this instance.
	* The alpha argument can be thought of as the ratio between the two colors, where `0.0`
	* is the first and `1.0` is the second color.
	*
	* @param {Color} color1 - The first color.
	* @param {Color} color2 - The second color.
	* @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
	* @return {Color} A reference to this color.
	*/
	lerpColors(color1, color2, alpha) {
		this.r = color1.r + (color2.r - color1.r) * alpha;
		this.g = color1.g + (color2.g - color1.g) * alpha;
		this.b = color1.b + (color2.b - color1.b) * alpha;
		return this;
	}
	/**
	* Linearly interpolates this color's HSL values toward the HSL values of the
	* given color. It differs from {@link Color#lerp} by not interpolating straight
	* from one color to the other, but instead going through all the hues in between
	* those two colors. The alpha argument can be thought of as the ratio between
	* the two colors, where 0.0 is this color and 1.0 is the first argument.
	*
	* @param {Color} color - The color to converge on.
	* @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
	* @return {Color} A reference to this color.
	*/
	lerpHSL(color$2, alpha) {
		this.getHSL(_hslA);
		color$2.getHSL(_hslB);
		const h = lerp(_hslA.h, _hslB.h, alpha);
		const s = lerp(_hslA.s, _hslB.s, alpha);
		const l = lerp(_hslA.l, _hslB.l, alpha);
		this.setHSL(h, s, l);
		return this;
	}
	/**
	* Sets the color's RGB components from the given 3D vector.
	*
	* @param {Vector3} v - The vector to set.
	* @return {Color} A reference to this color.
	*/
	setFromVector3(v) {
		this.r = v.x;
		this.g = v.y;
		this.b = v.z;
		return this;
	}
	/**
	* Transforms this color with the given 3x3 matrix.
	*
	* @param {Matrix3} m - The matrix.
	* @return {Color} A reference to this color.
	*/
	applyMatrix3(m$1) {
		const r = this.r, g$1 = this.g, b$2 = this.b;
		const e = m$1.elements;
		this.r = e[0] * r + e[3] * g$1 + e[6] * b$2;
		this.g = e[1] * r + e[4] * g$1 + e[7] * b$2;
		this.b = e[2] * r + e[5] * g$1 + e[8] * b$2;
		return this;
	}
	/**
	* Returns `true` if this color is equal with the given one.
	*
	* @param {Color} c - The color to test for equality.
	* @return {boolean} Whether this bounding color is equal with the given one.
	*/
	equals(c$1) {
		return c$1.r === this.r && c$1.g === this.g && c$1.b === this.b;
	}
	/**
	* Sets this color's RGB components from the given array.
	*
	* @param {Array<number>} array - An array holding the RGB values.
	* @param {number} [offset=0] - The offset into the array.
	* @return {Color} A reference to this color.
	*/
	fromArray(array$2, offset = 0) {
		this.r = array$2[offset];
		this.g = array$2[offset + 1];
		this.b = array$2[offset + 2];
		return this;
	}
	/**
	* Writes the RGB components of this color to the given array. If no array is provided,
	* the method returns a new instance.
	*
	* @param {Array<number>} [array=[]] - The target array holding the color components.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Array<number>} The color components.
	*/
	toArray(array$2 = [], offset = 0) {
		array$2[offset] = this.r;
		array$2[offset + 1] = this.g;
		array$2[offset + 2] = this.b;
		return array$2;
	}
	/**
	* Sets the components of this color from the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute holding color data.
	* @param {number} index - The index into the attribute.
	* @return {Color} A reference to this color.
	*/
	fromBufferAttribute(attribute$2, index) {
		this.r = attribute$2.getX(index);
		this.g = attribute$2.getY(index);
		this.b = attribute$2.getZ(index);
		return this;
	}
	/**
	* This methods defines the serialization result of this class. Returns the color
	* as a hexadecimal value.
	*
	* @return {number} The hexadecimal value.
	*/
	toJSON() {
		return this.getHex();
	}
	*[Symbol.iterator]() {
		yield this.r;
		yield this.g;
		yield this.b;
	}
};
var _color = /* @__PURE__ */ new Color$1();
/**
* A dictionary with X11 color names.
*
* Note that multiple words such as Dark Orange become the string 'darkorange'.
*
* @static
* @type {Object}
*/
Color$1.NAMES = _colorKeywords;
var _materialId = 0;
/**
* Abstract base class for materials.
*
* Materials define the appearance of renderable 3D objects.
*
* @abstract
* @augments EventDispatcher
*/
var Material = class extends EventDispatcher {
	/**
	* Constructs a new material.
	*/
	constructor() {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMaterial = true;
		/**
		* The ID of the material.
		*
		* @name Material#id
		* @type {number}
		* @readonly
		*/
		Object.defineProperty(this, "id", { value: _materialId++ });
		/**
		* The UUID of the material.
		*
		* @type {string}
		* @readonly
		*/
		this.uuid = generateUUID();
		/**
		* The name of the material.
		*
		* @type {string}
		*/
		this.name = "";
		/**
		* The type property is used for detecting the object type
		* in context of serialization/deserialization.
		*
		* @type {string}
		* @readonly
		*/
		this.type = "Material";
		/**
		* Defines the blending type of the material.
		*
		* It must be set to `CustomBlending` if custom blending properties like
		* {@link Material#blendSrc}, {@link Material#blendDst} or {@link Material#blendEquation}
		* should have any effect.
		*
		* @type {(NoBlending|NormalBlending|AdditiveBlending|SubtractiveBlending|MultiplyBlending|CustomBlending)}
		* @default NormalBlending
		*/
		this.blending = NormalBlending;
		/**
		* Defines which side of faces will be rendered - front, back or both.
		*
		* @type {(FrontSide|BackSide|DoubleSide)}
		* @default FrontSide
		*/
		this.side = FrontSide;
		/**
		* If set to `true`, vertex colors should be used.
		*
		* The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
		* four (RGBA) component color buffer attribute is used.
		*
		* @type {boolean}
		* @default false
		*/
		this.vertexColors = false;
		/**
		* Defines how transparent the material is.
		* A value of `0.0` indicates fully transparent, `1.0` is fully opaque.
		*
		* If the {@link Material#transparent} is not set to `true`,
		* the material will remain fully opaque and this value will only affect its color.
		*
		* @type {number}
		* @default 1
		*/
		this.opacity = 1;
		/**
		* Defines whether this material is transparent. This has an effect on
		* rendering as transparent objects need special treatment and are rendered
		* after non-transparent objects.
		*
		* When set to true, the extent to which the material is transparent is
		* controlled by {@link Material#opacity}.
		*
		* @type {boolean}
		* @default false
		*/
		this.transparent = false;
		/**
		* Enables alpha hashed transparency, an alternative to {@link Material#transparent} or
		* {@link Material#alphaTest}. The material will not be rendered if opacity is lower than
		* a random threshold. Randomization introduces some grain or noise, but approximates alpha
		* blending without the associated problems of sorting. Using TAA can reduce the resulting noise.
		*
		* @type {boolean}
		* @default false
		*/
		this.alphaHash = false;
		/**
		* Defines the blending source factor.
		*
		* @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		* @default SrcAlphaFactor
		*/
		this.blendSrc = SrcAlphaFactor;
		/**
		* Defines the blending destination factor.
		*
		* @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		* @default OneMinusSrcAlphaFactor
		*/
		this.blendDst = OneMinusSrcAlphaFactor;
		/**
		* Defines the blending equation.
		*
		* @type {(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
		* @default AddEquation
		*/
		this.blendEquation = AddEquation;
		/**
		* Defines the blending source alpha factor.
		*
		* @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		* @default null
		*/
		this.blendSrcAlpha = null;
		/**
		* Defines the blending destination alpha factor.
		*
		* @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		* @default null
		*/
		this.blendDstAlpha = null;
		/**
		* Defines the blending equation of the alpha channel.
		*
		* @type {?(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
		* @default null
		*/
		this.blendEquationAlpha = null;
		/**
		* Represents the RGB values of the constant blend color.
		*
		* This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.
		*
		* @type {Color}
		* @default (0,0,0)
		*/
		this.blendColor = new Color$1(0, 0, 0);
		/**
		* Represents the alpha value of the constant blend color.
		*
		* This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.
		*
		* @type {number}
		* @default 0
		*/
		this.blendAlpha = 0;
		/**
		* Defines the depth function.
		*
		* @type {(NeverDepth|AlwaysDepth|LessDepth|LessEqualDepth|EqualDepth|GreaterEqualDepth|GreaterDepth|NotEqualDepth)}
		* @default LessEqualDepth
		*/
		this.depthFunc = LessEqualDepth;
		/**
		* Whether to have depth test enabled when rendering this material.
		* When the depth test is disabled, the depth write will also be implicitly disabled.
		*
		* @type {boolean}
		* @default true
		*/
		this.depthTest = true;
		/**
		* Whether rendering this material has any effect on the depth buffer.
		*
		* When drawing 2D overlays it can be useful to disable the depth writing in
		* order to layer several things together without creating z-index artifacts.
		*
		* @type {boolean}
		* @default true
		*/
		this.depthWrite = true;
		/**
		* The bit mask to use when writing to the stencil buffer.
		*
		* @type {number}
		* @default 0xff
		*/
		this.stencilWriteMask = 255;
		/**
		* The stencil comparison function to use.
		*
		* @type {NeverStencilFunc|LessStencilFunc|EqualStencilFunc|LessEqualStencilFunc|GreaterStencilFunc|NotEqualStencilFunc|GreaterEqualStencilFunc|AlwaysStencilFunc}
		* @default AlwaysStencilFunc
		*/
		this.stencilFunc = AlwaysStencilFunc;
		/**
		* The value to use when performing stencil comparisons or stencil operations.
		*
		* @type {number}
		* @default 0
		*/
		this.stencilRef = 0;
		/**
		* The bit mask to use when comparing against the stencil buffer.
		*
		* @type {number}
		* @default 0xff
		*/
		this.stencilFuncMask = 255;
		/**
		* Which stencil operation to perform when the comparison function returns `false`.
		*
		* @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
		* @default KeepStencilOp
		*/
		this.stencilFail = KeepStencilOp;
		/**
		* Which stencil operation to perform when the comparison function returns
		* `true` but the depth test fails.
		*
		* @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
		* @default KeepStencilOp
		*/
		this.stencilZFail = KeepStencilOp;
		/**
		* Which stencil operation to perform when the comparison function returns
		* `true` and the depth test passes.
		*
		* @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
		* @default KeepStencilOp
		*/
		this.stencilZPass = KeepStencilOp;
		/**
		* Whether stencil operations are performed against the stencil buffer. In
		* order to perform writes or comparisons against the stencil buffer this
		* value must be `true`.
		*
		* @type {boolean}
		* @default false
		*/
		this.stencilWrite = false;
		/**
		* User-defined clipping planes specified as THREE.Plane objects in world
		* space. These planes apply to the objects this material is attached to.
		* Points in space whose signed distance to the plane is negative are clipped
		* (not rendered). This requires {@link WebGLRenderer#localClippingEnabled} to
		* be `true`.
		*
		* @type {?Array<Plane>}
		* @default null
		*/
		this.clippingPlanes = null;
		/**
		* Changes the behavior of clipping planes so that only their intersection is
		* clipped, rather than their union.
		*
		* @type {boolean}
		* @default false
		*/
		this.clipIntersection = false;
		/**
		* Defines whether to clip shadows according to the clipping planes specified
		* on this material.
		*
		* @type {boolean}
		* @default false
		*/
		this.clipShadows = false;
		/**
		* Defines which side of faces cast shadows. If `null`, the side casting shadows
		* is determined as follows:
		*
		* - When {@link Material#side} is set to `FrontSide`, the back side cast shadows.
		* - When {@link Material#side} is set to `BackSide`, the front side cast shadows.
		* - When {@link Material#side} is set to `DoubleSide`, both sides cast shadows.
		*
		* @type {?(FrontSide|BackSide|DoubleSide)}
		* @default null
		*/
		this.shadowSide = null;
		/**
		* Whether to render the material's color.
		*
		* This can be used in conjunction with {@link Object3D#renderOder} to create invisible
		* objects that occlude other objects.
		*
		* @type {boolean}
		* @default true
		*/
		this.colorWrite = true;
		/**
		* Override the renderer's default precision for this material.
		*
		* @type {?('highp'|'mediump'|'lowp')}
		* @default null
		*/
		this.precision = null;
		/**
		* Whether to use polygon offset or not. When enabled, each fragment's depth value will
		* be offset after it is interpolated from the depth values of the appropriate vertices.
		* The offset is added before the depth test is performed and before the value is written
		* into the depth buffer.
		*
		* Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
		* rendering solids with highlighted edges.
		*
		* @type {boolean}
		* @default false
		*/
		this.polygonOffset = false;
		/**
		* Specifies a scale factor that is used to create a variable depth offset for each polygon.
		*
		* @type {number}
		* @default 0
		*/
		this.polygonOffsetFactor = 0;
		/**
		* Is multiplied by an implementation-specific value to create a constant depth offset.
		*
		* @type {number}
		* @default 0
		*/
		this.polygonOffsetUnits = 0;
		/**
		* Whether to apply dithering to the color to remove the appearance of banding.
		*
		* @type {boolean}
		* @default false
		*/
		this.dithering = false;
		/**
		* Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
		* (meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
		* will smooth aliasing on clip plane edges and alphaTest-clipped edges.
		*
		* @type {boolean}
		* @default false
		*/
		this.alphaToCoverage = false;
		/**
		* Whether to premultiply the alpha (transparency) value.
		*
		* @type {boolean}
		* @default false
		*/
		this.premultipliedAlpha = false;
		/**
		* Whether double-sided, transparent objects should be rendered with a single pass or not.
		*
		* The engine renders double-sided, transparent objects with two draw calls (back faces first,
		* then front faces) to mitigate transparency artifacts. There are scenarios however where this
		* approach produces no quality gains but still doubles draw calls e.g. when rendering flat
		* vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
		* disable the two pass rendering to avoid performance issues.
		*
		* @type {boolean}
		* @default false
		*/
		this.forceSinglePass = false;
		/**
		* Whether it's possible to override the material with {@link Scene#overrideMaterial} or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.allowOverride = true;
		/**
		* Defines whether 3D objects using this material are visible.
		*
		* @type {boolean}
		* @default true
		*/
		this.visible = true;
		/**
		* Defines whether this material is tone mapped according to the renderer's tone mapping setting.
		*
		* It is ignored when rendering to a render target or using post processing or when using
		* `WebGPURenderer`. In all these cases, all materials are honored by tone mapping.
		*
		* @type {boolean}
		* @default true
		*/
		this.toneMapped = true;
		/**
		* An object that can be used to store custom data about the Material. It
		* should not hold references to functions as these will not be cloned.
		*
		* @type {Object}
		*/
		this.userData = {};
		/**
		* This starts at `0` and counts how many times {@link Material#needsUpdate} is set to `true`.
		*
		* @type {number}
		* @readonly
		* @default 0
		*/
		this.version = 0;
		this._alphaTest = 0;
	}
	/**
	* Sets the alpha value to be used when running an alpha test. The material
	* will not be rendered if the opacity is lower than this value.
	*
	* @type {number}
	* @readonly
	* @default 0
	*/
	get alphaTest() {
		return this._alphaTest;
	}
	set alphaTest(value) {
		if (this._alphaTest > 0 !== value > 0) this.version++;
		this._alphaTest = value;
	}
	/**
	* An optional callback that is executed immediately before the material is used to render a 3D object.
	*
	* This method can only be used when rendering with {@link WebGLRenderer}.
	*
	* @param {WebGLRenderer} renderer - The renderer.
	* @param {Scene} scene - The scene.
	* @param {Camera} camera - The camera that is used to render the scene.
	* @param {BufferGeometry} geometry - The 3D object's geometry.
	* @param {Object3D} object - The 3D object.
	* @param {Object} group - The geometry group data.
	*/
	onBeforeRender() {}
	/**
	* An optional callback that is executed immediately before the shader
	* program is compiled. This function is called with the shader source code
	* as a parameter. Useful for the modification of built-in materials.
	*
	* This method can only be used when rendering with {@link WebGLRenderer}. The
	* recommended approach when customizing materials is to use `WebGPURenderer` with the new
	* Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language).
	*
	* @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
	* @param {WebGLRenderer} renderer - A reference to the renderer.
	*/
	onBeforeCompile() {}
	/**
	* In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
	* values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
	* shader or recompile the shader for this material as needed.
	*
	* This method can only be used when rendering with {@link WebGLRenderer}.
	*
	* @return {string} The custom program cache key.
	*/
	customProgramCacheKey() {
		return this.onBeforeCompile.toString();
	}
	/**
	* This method can be used to set default values from parameter objects.
	* It is a generic implementation so it can be used with different types
	* of materials.
	*
	* @param {Object} [values] - The material values to set.
	*/
	setValues(values) {
		if (values === void 0) return;
		for (const key in values) {
			const newValue = values[key];
			if (newValue === void 0) {
				warn(`Material: parameter '${key}' has value of undefined.`);
				continue;
			}
			const currentValue = this[key];
			if (currentValue === void 0) {
				warn(`Material: '${key}' is not a property of THREE.${this.type}.`);
				continue;
			}
			if (currentValue && currentValue.isColor) currentValue.set(newValue);
			else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) currentValue.copy(newValue);
			else this[key] = newValue;
		}
	}
	/**
	* Serializes the material into JSON.
	*
	* @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	* @return {Object} A JSON object representing the serialized material.
	* @see {@link ObjectLoader#parse}
	*/
	toJSON(meta) {
		const isRootObject = meta === void 0 || typeof meta === "string";
		if (isRootObject) meta = {
			textures: {},
			images: {}
		};
		const data = { metadata: {
			version: 4.7,
			type: "Material",
			generator: "Material.toJSON"
		} };
		data.uuid = this.uuid;
		data.type = this.type;
		if (this.name !== "") data.name = this.name;
		if (this.color && this.color.isColor) data.color = this.color.getHex();
		if (this.roughness !== void 0) data.roughness = this.roughness;
		if (this.metalness !== void 0) data.metalness = this.metalness;
		if (this.sheen !== void 0) data.sheen = this.sheen;
		if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
		if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
		if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
		if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
		if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
		if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
		if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
		if (this.shininess !== void 0) data.shininess = this.shininess;
		if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
		if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
		if (this.clearcoatMap && this.clearcoatMap.isTexture) data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
		if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
		if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
		}
		if (this.sheenColorMap && this.sheenColorMap.isTexture) data.sheenColorMap = this.sheenColorMap.toJSON(meta).uuid;
		if (this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture) data.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(meta).uuid;
		if (this.dispersion !== void 0) data.dispersion = this.dispersion;
		if (this.iridescence !== void 0) data.iridescence = this.iridescence;
		if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
		if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
		if (this.iridescenceMap && this.iridescenceMap.isTexture) data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
		if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
		if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
		if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
		if (this.anisotropyMap && this.anisotropyMap.isTexture) data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
		if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
		if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
		if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
		if (this.lightMap && this.lightMap.isTexture) {
			data.lightMap = this.lightMap.toJSON(meta).uuid;
			data.lightMapIntensity = this.lightMapIntensity;
		}
		if (this.aoMap && this.aoMap.isTexture) {
			data.aoMap = this.aoMap.toJSON(meta).uuid;
			data.aoMapIntensity = this.aoMapIntensity;
		}
		if (this.bumpMap && this.bumpMap.isTexture) {
			data.bumpMap = this.bumpMap.toJSON(meta).uuid;
			data.bumpScale = this.bumpScale;
		}
		if (this.normalMap && this.normalMap.isTexture) {
			data.normalMap = this.normalMap.toJSON(meta).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();
		}
		if (this.displacementMap && this.displacementMap.isTexture) {
			data.displacementMap = this.displacementMap.toJSON(meta).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;
		}
		if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
		if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
		if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
		if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
		if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
		if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
		if (this.envMap && this.envMap.isTexture) {
			data.envMap = this.envMap.toJSON(meta).uuid;
			if (this.combine !== void 0) data.combine = this.combine;
		}
		if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();
		if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
		if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
		if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
		if (this.gradientMap && this.gradientMap.isTexture) data.gradientMap = this.gradientMap.toJSON(meta).uuid;
		if (this.transmission !== void 0) data.transmission = this.transmission;
		if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
		if (this.thickness !== void 0) data.thickness = this.thickness;
		if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
		if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
		if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
		if (this.size !== void 0) data.size = this.size;
		if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
		if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
		if (this.blending !== NormalBlending) data.blending = this.blending;
		if (this.side !== FrontSide) data.side = this.side;
		if (this.vertexColors === true) data.vertexColors = true;
		if (this.opacity < 1) data.opacity = this.opacity;
		if (this.transparent === true) data.transparent = true;
		if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
		if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
		if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
		if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
		if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
		if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
		if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
		if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
		if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
		if (this.depthTest === false) data.depthTest = this.depthTest;
		if (this.depthWrite === false) data.depthWrite = this.depthWrite;
		if (this.colorWrite === false) data.colorWrite = this.colorWrite;
		if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;
		if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
		if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
		if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;
		if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
		if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
		if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
		if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
		if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
		if (this.polygonOffset === true) data.polygonOffset = true;
		if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
		if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
		if (this.dashSize !== void 0) data.dashSize = this.dashSize;
		if (this.gapSize !== void 0) data.gapSize = this.gapSize;
		if (this.scale !== void 0) data.scale = this.scale;
		if (this.dithering === true) data.dithering = true;
		if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
		if (this.alphaHash === true) data.alphaHash = true;
		if (this.alphaToCoverage === true) data.alphaToCoverage = true;
		if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
		if (this.forceSinglePass === true) data.forceSinglePass = true;
		if (this.wireframe === true) data.wireframe = true;
		if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
		if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
		if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
		if (this.flatShading === true) data.flatShading = true;
		if (this.visible === false) data.visible = false;
		if (this.toneMapped === false) data.toneMapped = false;
		if (this.fog === false) data.fog = false;
		if (Object.keys(this.userData).length > 0) data.userData = this.userData;
		function extractFromCache(cache$2) {
			const values = [];
			for (const key in cache$2) {
				const data$1 = cache$2[key];
				delete data$1.metadata;
				values.push(data$1);
			}
			return values;
		}
		if (isRootObject) {
			const textures = extractFromCache(meta.textures);
			const images = extractFromCache(meta.images);
			if (textures.length > 0) data.textures = textures;
			if (images.length > 0) data.images = images;
		}
		return data;
	}
	/**
	* Returns a new material with copied values from this instance.
	*
	* @return {Material} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	/**
	* Copies the values of the given material to this instance.
	*
	* @param {Material} source - The material to copy.
	* @return {Material} A reference to this instance.
	*/
	copy(source) {
		this.name = source.name;
		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;
		this.opacity = source.opacity;
		this.transparent = source.transparent;
		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;
		this.blendColor.copy(source.blendColor);
		this.blendAlpha = source.blendAlpha;
		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;
		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;
		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;
		if (srcPlanes !== null) {
			const n$2 = srcPlanes.length;
			dstPlanes = new Array(n$2);
			for (let i = 0; i !== n$2; ++i) dstPlanes[i] = srcPlanes[i].clone();
		}
		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;
		this.shadowSide = source.shadowSide;
		this.colorWrite = source.colorWrite;
		this.precision = source.precision;
		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;
		this.dithering = source.dithering;
		this.alphaTest = source.alphaTest;
		this.alphaHash = source.alphaHash;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.forceSinglePass = source.forceSinglePass;
		this.visible = source.visible;
		this.toneMapped = source.toneMapped;
		this.userData = JSON.parse(JSON.stringify(source.userData));
		return this;
	}
	/**
	* Frees the GPU-related resources allocated by this instance. Call this
	* method whenever this instance is no longer used in your app.
	*
	* @fires Material#dispose
	*/
	dispose() {
		/**
		* Fires when the material has been disposed of.
		*
		* @event Material#dispose
		* @type {Object}
		*/
		this.dispatchEvent({ type: "dispose" });
	}
	/**
	* Setting this property to `true` indicates the engine the material
	* needs to be recompiled.
	*
	* @type {boolean}
	* @default false
	* @param {boolean} value
	*/
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
};
/**
* A material for drawing geometries in a simple shaded (flat or wireframe) way.
*
* This material is not affected by lights.
*
* @augments Material
* @demo scenes/material-browser.html#MeshBasicMaterial
*/
var MeshBasicMaterial = class extends Material {
	/**
	* Constructs a new mesh basic material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshBasicMaterial = true;
		this.type = "MeshBasicMaterial";
		/**
		* Color of the material.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.color = new Color$1(16777215);
		/**
		* The color map. May optionally include an alpha channel, typically combined
		* with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		* color is modulated by the diffuse `color`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* The light map. Requires a second set of UVs.
		*
		* @type {?Texture}
		* @default null
		*/
		this.lightMap = null;
		/**
		* Intensity of the baked light.
		*
		* @type {number}
		* @default 1
		*/
		this.lightMapIntensity = 1;
		/**
		* The red channel of this texture is used as the ambient occlusion map.
		* Requires a second set of UVs.
		*
		* @type {?Texture}
		* @default null
		*/
		this.aoMap = null;
		/**
		* Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		* disables ambient occlusion. Where intensity is `1` and the AO map's
		* red channel is also `1`, ambient light is fully occluded on a surface.
		*
		* @type {number}
		* @default 1
		*/
		this.aoMapIntensity = 1;
		/**
		* Specular map used by the material.
		*
		* @type {?Texture}
		* @default null
		*/
		this.specularMap = null;
		/**
		* The alpha map is a grayscale texture that controls the opacity across the
		* surface (black: fully transparent; white: fully opaque).
		*
		* Only the color of the texture is used, ignoring the alpha channel if one
		* exists. For RGB and RGBA textures, the renderer will use the green channel
		* when sampling this texture due to the extra bit of precision provided for
		* green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		* luminance/alpha textures will also still work as expected.
		*
		* @type {?Texture}
		* @default null
		*/
		this.alphaMap = null;
		/**
		* The environment map.
		*
		* @type {?Texture}
		* @default null
		*/
		this.envMap = null;
		/**
		* The rotation of the environment map in radians.
		*
		* @type {Euler}
		* @default (0,0,0)
		*/
		this.envMapRotation = new Euler();
		/**
		* How to combine the result of the surface's color with the environment map, if any.
		*
		* When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
		* blend between the two colors.
		*
		* @type {(MultiplyOperation|MixOperation|AddOperation)}
		* @default MultiplyOperation
		*/
		this.combine = MultiplyOperation;
		/**
		* How much the environment map affects the surface.
		* The valid range is between `0` (no reflections) and `1` (full reflections).
		*
		* @type {number}
		* @default 1
		*/
		this.reflectivity = 1;
		/**
		* The index of refraction (IOR) of air (approximately 1) divided by the
		* index of refraction of the material. It is used with environment mapping
		* modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
		* The refraction ratio should not exceed `1`.
		*
		* @type {number}
		* @default 0.98
		*/
		this.refractionRatio = .98;
		/**
		* Renders the geometry as a wireframe.
		*
		* @type {boolean}
		* @default false
		*/
		this.wireframe = false;
		/**
		* Controls the thickness of the wireframe.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {number}
		* @default 1
		*/
		this.wireframeLinewidth = 1;
		/**
		* Defines appearance of wireframe ends.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.wireframeLinecap = "round";
		/**
		* Defines appearance of wireframe joints.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.wireframeLinejoin = "round";
		/**
		* Whether the material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.envMapRotation.copy(source.envMapRotation);
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.fog = source.fog;
		return this;
	}
};
var _tables = /* @__PURE__ */ _generateTables();
function _generateTables() {
	const buffer$2 = /* @__PURE__ */ new ArrayBuffer(4);
	const floatView = new Float32Array(buffer$2);
	const uint32View = new Uint32Array(buffer$2);
	const baseTable = new Uint32Array(512);
	const shiftTable = new Uint32Array(512);
	for (let i = 0; i < 256; ++i) {
		const e = i - 127;
		if (e < -27) {
			baseTable[i] = 0;
			baseTable[i | 256] = 32768;
			shiftTable[i] = 24;
			shiftTable[i | 256] = 24;
		} else if (e < -14) {
			baseTable[i] = 1024 >> -e - 14;
			baseTable[i | 256] = 1024 >> -e - 14 | 32768;
			shiftTable[i] = -e - 1;
			shiftTable[i | 256] = -e - 1;
		} else if (e <= 15) {
			baseTable[i] = e + 15 << 10;
			baseTable[i | 256] = e + 15 << 10 | 32768;
			shiftTable[i] = 13;
			shiftTable[i | 256] = 13;
		} else if (e < 128) {
			baseTable[i] = 31744;
			baseTable[i | 256] = 64512;
			shiftTable[i] = 24;
			shiftTable[i | 256] = 24;
		} else {
			baseTable[i] = 31744;
			baseTable[i | 256] = 64512;
			shiftTable[i] = 13;
			shiftTable[i | 256] = 13;
		}
	}
	const mantissaTable = new Uint32Array(2048);
	const exponentTable = new Uint32Array(64);
	const offsetTable = new Uint32Array(64);
	for (let i = 1; i < 1024; ++i) {
		let m$1 = i << 13;
		let e = 0;
		while ((m$1 & 8388608) === 0) {
			m$1 <<= 1;
			e -= 8388608;
		}
		m$1 &= -8388609;
		e += 947912704;
		mantissaTable[i] = m$1 | e;
	}
	for (let i = 1024; i < 2048; ++i) mantissaTable[i] = 939524096 + (i - 1024 << 13);
	for (let i = 1; i < 31; ++i) exponentTable[i] = i << 23;
	exponentTable[31] = 1199570944;
	exponentTable[32] = 2147483648;
	for (let i = 33; i < 63; ++i) exponentTable[i] = 2147483648 + (i - 32 << 23);
	exponentTable[63] = 3347054592;
	for (let i = 1; i < 64; ++i) if (i !== 32) offsetTable[i] = 1024;
	return {
		floatView,
		uint32View,
		baseTable,
		shiftTable,
		mantissaTable,
		exponentTable,
		offsetTable
	};
}
/**
* Returns a half precision floating point value (FP16) from the given single
* precision floating point value (FP32).
*
* @param {number} val - A single precision floating point value.
* @return {number} The FP16 value.
*/
function toHalfFloat(val) {
	if (Math.abs(val) > 65504) warn("DataUtils.toHalfFloat(): Value out of range.");
	val = clamp$3(val, -65504, 65504);
	_tables.floatView[0] = val;
	const f = _tables.uint32View[0];
	const e = f >> 23 & 511;
	return _tables.baseTable[e] + ((f & 8388607) >> _tables.shiftTable[e]);
}
/**
* Returns a single precision floating point value (FP32) from the given half
* precision floating point value (FP16).
*
* @param {number} val - A half precision floating point value.
* @return {number} The FP32 value.
*/
function fromHalfFloat(val) {
	const m$1 = val >> 10;
	_tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m$1] + (val & 1023)] + _tables.exponentTable[m$1];
	return _tables.floatView[0];
}
var _vector$9 = /* @__PURE__ */ new Vector3();
var _vector2$1 = /* @__PURE__ */ new Vector2();
var _id$2$2 = 0;
/**
* This class stores data for an attribute (such as vertex positions, face
* indices, normals, colors, UVs, and any custom attributes ) associated with
* a geometry, which allows for more efficient passing of data to the GPU.
*
* When working with vector-like data, the `fromBufferAttribute( attribute, index )`
* helper methods on vector and color class might be helpful. E.g. {@link Vector3#fromBufferAttribute}.
*/
var BufferAttribute = class {
	/**
	* Constructs a new buffer attribute.
	*
	* @param {TypedArray} array - The array holding the attribute data.
	* @param {number} itemSize - The item size.
	* @param {boolean} [normalized=false] - Whether the data are normalized or not.
	*/
	constructor(array$2, itemSize, normalized = false) {
		if (Array.isArray(array$2)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isBufferAttribute = true;
		/**
		* The ID of the buffer attribute.
		*
		* @name BufferAttribute#id
		* @type {number}
		* @readonly
		*/
		Object.defineProperty(this, "id", { value: _id$2$2++ });
		/**
		* The name of the buffer attribute.
		*
		* @type {string}
		*/
		this.name = "";
		/**
		* The array holding the attribute data. It should have `itemSize * numVertices`
		* elements, where `numVertices` is the number of vertices in the associated geometry.
		*
		* @type {TypedArray}
		*/
		this.array = array$2;
		/**
		* The number of values of the array that should be associated with a particular vertex.
		* For instance, if this attribute is storing a 3-component vector (such as a position,
		* normal, or color), then the value should be `3`.
		*
		* @type {number}
		*/
		this.itemSize = itemSize;
		/**
		* Represents the number of items this buffer attribute stores. It is internally computed
		* by dividing the `array` length by the `itemSize`.
		*
		* @type {number}
		* @readonly
		*/
		this.count = array$2 !== void 0 ? array$2.length / itemSize : 0;
		/**
		* Applies to integer data only. Indicates how the underlying data in the buffer maps to
		* the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
		* and `normalized` is `true`, the values `0 - +65535` in the array data will be mapped to
		* `0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
		* to floats unmodified, i.e. `65535` becomes `65535.0f`.
		*
		* @type {boolean}
		*/
		this.normalized = normalized;
		/**
		* Defines the intended usage pattern of the data store for optimization purposes.
		*
		* Note: After the initial use of a buffer, its usage cannot be changed. Instead,
		* instantiate a new one and set the desired usage before the next render.
		*
		* @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
		* @default StaticDrawUsage
		*/
		this.usage = StaticDrawUsage;
		/**
		* This can be used to only update some components of stored vectors (for example, just the
		* component related to color). Use the `addUpdateRange()` function to add ranges to this array.
		*
		* @type {Array<Object>}
		*/
		this.updateRanges = [];
		/**
		* Configures the bound GPU type for use in shaders.
		*
		* Note: this only has an effect for integer arrays and is not configurable for float arrays.
		* For lower precision float types, use `Float16BufferAttribute`.
		*
		* @type {(FloatType|IntType)}
		* @default FloatType
		*/
		this.gpuType = FloatType;
		/**
		* A version number, incremented every time the `needsUpdate` is set to `true`.
		*
		* @type {number}
		*/
		this.version = 0;
	}
	/**
	* A callback function that is executed after the renderer has transferred the attribute
	* array data to the GPU.
	*/
	onUploadCallback() {}
	/**
	* Flag to indicate that this attribute has changed and should be re-sent to
	* the GPU. Set this to `true` when you modify the value of the array.
	*
	* @type {number}
	* @default false
	* @param {boolean} value
	*/
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
	/**
	* Sets the usage of this buffer attribute.
	*
	* @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
	* @return {BufferAttribute} A reference to this buffer attribute.
	*/
	setUsage(value) {
		this.usage = value;
		return this;
	}
	/**
	* Adds a range of data in the data array to be updated on the GPU.
	*
	* @param {number} start - Position at which to start update.
	* @param {number} count - The number of components to update.
	*/
	addUpdateRange(start, count) {
		this.updateRanges.push({
			start,
			count
		});
	}
	/**
	* Clears the update ranges.
	*/
	clearUpdateRanges() {
		this.updateRanges.length = 0;
	}
	/**
	* Copies the values of the given buffer attribute to this instance.
	*
	* @param {BufferAttribute} source - The buffer attribute to copy.
	* @return {BufferAttribute} A reference to this instance.
	*/
	copy(source) {
		this.name = source.name;
		this.array = new source.array.constructor(source.array);
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;
		this.usage = source.usage;
		this.gpuType = source.gpuType;
		return this;
	}
	/**
	* Copies a vector from the given buffer attribute to this one. The start
	* and destination position in the attribute buffers are represented by the
	* given indices.
	*
	* @param {number} index1 - The destination index into this buffer attribute.
	* @param {BufferAttribute} attribute - The buffer attribute to copy from.
	* @param {number} index2 - The source index into the given buffer attribute.
	* @return {BufferAttribute} A reference to this instance.
	*/
	copyAt(index1, attribute$2, index2) {
		index1 *= this.itemSize;
		index2 *= attribute$2.itemSize;
		for (let i = 0, l = this.itemSize; i < l; i++) this.array[index1 + i] = attribute$2.array[index2 + i];
		return this;
	}
	/**
	* Copies the given array data into this buffer attribute.
	*
	* @param {(TypedArray|Array)} array - The array to copy.
	* @return {BufferAttribute} A reference to this instance.
	*/
	copyArray(array$2) {
		this.array.set(array$2);
		return this;
	}
	/**
	* Applies the given 3x3 matrix to the given attribute. Works with
	* item size `2` and `3`.
	*
	* @param {Matrix3} m - The matrix to apply.
	* @return {BufferAttribute} A reference to this instance.
	*/
	applyMatrix3(m$1) {
		if (this.itemSize === 2) for (let i = 0, l = this.count; i < l; i++) {
			_vector2$1.fromBufferAttribute(this, i);
			_vector2$1.applyMatrix3(m$1);
			this.setXY(i, _vector2$1.x, _vector2$1.y);
		}
		else if (this.itemSize === 3) for (let i = 0, l = this.count; i < l; i++) {
			_vector$9.fromBufferAttribute(this, i);
			_vector$9.applyMatrix3(m$1);
			this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		}
		return this;
	}
	/**
	* Applies the given 4x4 matrix to the given attribute. Only works with
	* item size `3`.
	*
	* @param {Matrix4} m - The matrix to apply.
	* @return {BufferAttribute} A reference to this instance.
	*/
	applyMatrix4(m$1) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$9.fromBufferAttribute(this, i);
			_vector$9.applyMatrix4(m$1);
			this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		}
		return this;
	}
	/**
	* Applies the given 3x3 normal matrix to the given attribute. Only works with
	* item size `3`.
	*
	* @param {Matrix3} m - The normal matrix to apply.
	* @return {BufferAttribute} A reference to this instance.
	*/
	applyNormalMatrix(m$1) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$9.fromBufferAttribute(this, i);
			_vector$9.applyNormalMatrix(m$1);
			this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		}
		return this;
	}
	/**
	* Applies the given 4x4 matrix to the given attribute. Only works with
	* item size `3` and with direction vectors.
	*
	* @param {Matrix4} m - The matrix to apply.
	* @return {BufferAttribute} A reference to this instance.
	*/
	transformDirection(m$1) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$9.fromBufferAttribute(this, i);
			_vector$9.transformDirection(m$1);
			this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		}
		return this;
	}
	/**
	* Sets the given array data in the buffer attribute.
	*
	* @param {(TypedArray|Array)} value - The array data to set.
	* @param {number} [offset=0] - The offset in this buffer attribute's array.
	* @return {BufferAttribute} A reference to this instance.
	*/
	set(value, offset = 0) {
		this.array.set(value, offset);
		return this;
	}
	/**
	* Returns the given component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} component - The component index.
	* @return {number} The returned value.
	*/
	getComponent(index, component) {
		let value = this.array[index * this.itemSize + component];
		if (this.normalized) value = denormalize(value, this.array);
		return value;
	}
	/**
	* Sets the given value to the given component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} component - The component index.
	* @param {number} value - The value to set.
	* @return {BufferAttribute} A reference to this instance.
	*/
	setComponent(index, component, value) {
		if (this.normalized) value = normalize$2(value, this.array);
		this.array[index * this.itemSize + component] = value;
		return this;
	}
	/**
	* Returns the x component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @return {number} The x component.
	*/
	getX(index) {
		let x = this.array[index * this.itemSize];
		if (this.normalized) x = denormalize(x, this.array);
		return x;
	}
	/**
	* Sets the x component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} x - The value to set.
	* @return {BufferAttribute} A reference to this instance.
	*/
	setX(index, x) {
		if (this.normalized) x = normalize$2(x, this.array);
		this.array[index * this.itemSize] = x;
		return this;
	}
	/**
	* Returns the y component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @return {number} The y component.
	*/
	getY(index) {
		let y = this.array[index * this.itemSize + 1];
		if (this.normalized) y = denormalize(y, this.array);
		return y;
	}
	/**
	* Sets the y component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} y - The value to set.
	* @return {BufferAttribute} A reference to this instance.
	*/
	setY(index, y) {
		if (this.normalized) y = normalize$2(y, this.array);
		this.array[index * this.itemSize + 1] = y;
		return this;
	}
	/**
	* Returns the z component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @return {number} The z component.
	*/
	getZ(index) {
		let z = this.array[index * this.itemSize + 2];
		if (this.normalized) z = denormalize(z, this.array);
		return z;
	}
	/**
	* Sets the z component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} z - The value to set.
	* @return {BufferAttribute} A reference to this instance.
	*/
	setZ(index, z) {
		if (this.normalized) z = normalize$2(z, this.array);
		this.array[index * this.itemSize + 2] = z;
		return this;
	}
	/**
	* Returns the w component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @return {number} The w component.
	*/
	getW(index) {
		let w = this.array[index * this.itemSize + 3];
		if (this.normalized) w = denormalize(w, this.array);
		return w;
	}
	/**
	* Sets the w component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} w - The value to set.
	* @return {BufferAttribute} A reference to this instance.
	*/
	setW(index, w) {
		if (this.normalized) w = normalize$2(w, this.array);
		this.array[index * this.itemSize + 3] = w;
		return this;
	}
	/**
	* Sets the x and y component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} x - The value for the x component to set.
	* @param {number} y - The value for the y component to set.
	* @return {BufferAttribute} A reference to this instance.
	*/
	setXY(index, x, y) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize$2(x, this.array);
			y = normalize$2(y, this.array);
		}
		this.array[index + 0] = x;
		this.array[index + 1] = y;
		return this;
	}
	/**
	* Sets the x, y and z component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} x - The value for the x component to set.
	* @param {number} y - The value for the y component to set.
	* @param {number} z - The value for the z component to set.
	* @return {BufferAttribute} A reference to this instance.
	*/
	setXYZ(index, x, y, z) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize$2(x, this.array);
			y = normalize$2(y, this.array);
			z = normalize$2(z, this.array);
		}
		this.array[index + 0] = x;
		this.array[index + 1] = y;
		this.array[index + 2] = z;
		return this;
	}
	/**
	* Sets the x, y, z and w component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} x - The value for the x component to set.
	* @param {number} y - The value for the y component to set.
	* @param {number} z - The value for the z component to set.
	* @param {number} w - The value for the w component to set.
	* @return {BufferAttribute} A reference to this instance.
	*/
	setXYZW(index, x, y, z, w) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize$2(x, this.array);
			y = normalize$2(y, this.array);
			z = normalize$2(z, this.array);
			w = normalize$2(w, this.array);
		}
		this.array[index + 0] = x;
		this.array[index + 1] = y;
		this.array[index + 2] = z;
		this.array[index + 3] = w;
		return this;
	}
	/**
	* Sets the given callback function that is executed after the Renderer has transferred
	* the attribute array data to the GPU. Can be used to perform clean-up operations after
	* the upload when attribute data are not needed anymore on the CPU side.
	*
	* @param {Function} callback - The `onUpload()` callback.
	* @return {BufferAttribute} A reference to this instance.
	*/
	onUpload(callback) {
		this.onUploadCallback = callback;
		return this;
	}
	/**
	* Returns a new buffer attribute with copied values from this instance.
	*
	* @return {BufferAttribute} A clone of this instance.
	*/
	clone() {
		return new this.constructor(this.array, this.itemSize).copy(this);
	}
	/**
	* Serializes the buffer attribute into JSON.
	*
	* @return {Object} A JSON object representing the serialized buffer attribute.
	*/
	toJSON() {
		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from(this.array),
			normalized: this.normalized
		};
		if (this.name !== "") data.name = this.name;
		if (this.usage !== StaticDrawUsage) data.usage = this.usage;
		return data;
	}
};
/**
* Convenient class that can be used when creating a `UInt16` buffer attribute with
* a plain `Array` instance.
*
* @augments BufferAttribute
*/
var Uint16BufferAttribute = class extends BufferAttribute {
	/**
	* Constructs a new buffer attribute.
	*
	* @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
	* @param {number} itemSize - The item size.
	* @param {boolean} [normalized=false] - Whether the data are normalized or not.
	*/
	constructor(array$2, itemSize, normalized) {
		super(new Uint16Array(array$2), itemSize, normalized);
	}
};
/**
* Convenient class that can be used when creating a `UInt32` buffer attribute with
* a plain `Array` instance.
*
* @augments BufferAttribute
*/
var Uint32BufferAttribute = class extends BufferAttribute {
	/**
	* Constructs a new buffer attribute.
	*
	* @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
	* @param {number} itemSize - The item size.
	* @param {boolean} [normalized=false] - Whether the data are normalized or not.
	*/
	constructor(array$2, itemSize, normalized) {
		super(new Uint32Array(array$2), itemSize, normalized);
	}
};
/**
* Convenient class that can be used when creating a `Float16` buffer attribute with
* a plain `Array` instance.
*
* This class automatically converts to and from FP16 via `Uint16Array` since `Float16Array`
* browser support is still problematic.
*
* @augments BufferAttribute
*/
var Float16BufferAttribute = class extends BufferAttribute {
	/**
	* Constructs a new buffer attribute.
	*
	* @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
	* @param {number} itemSize - The item size.
	* @param {boolean} [normalized=false] - Whether the data are normalized or not.
	*/
	constructor(array$2, itemSize, normalized) {
		super(new Uint16Array(array$2), itemSize, normalized);
		this.isFloat16BufferAttribute = true;
	}
	getX(index) {
		let x = fromHalfFloat(this.array[index * this.itemSize]);
		if (this.normalized) x = denormalize(x, this.array);
		return x;
	}
	setX(index, x) {
		if (this.normalized) x = normalize$2(x, this.array);
		this.array[index * this.itemSize] = toHalfFloat(x);
		return this;
	}
	getY(index) {
		let y = fromHalfFloat(this.array[index * this.itemSize + 1]);
		if (this.normalized) y = denormalize(y, this.array);
		return y;
	}
	setY(index, y) {
		if (this.normalized) y = normalize$2(y, this.array);
		this.array[index * this.itemSize + 1] = toHalfFloat(y);
		return this;
	}
	getZ(index) {
		let z = fromHalfFloat(this.array[index * this.itemSize + 2]);
		if (this.normalized) z = denormalize(z, this.array);
		return z;
	}
	setZ(index, z) {
		if (this.normalized) z = normalize$2(z, this.array);
		this.array[index * this.itemSize + 2] = toHalfFloat(z);
		return this;
	}
	getW(index) {
		let w = fromHalfFloat(this.array[index * this.itemSize + 3]);
		if (this.normalized) w = denormalize(w, this.array);
		return w;
	}
	setW(index, w) {
		if (this.normalized) w = normalize$2(w, this.array);
		this.array[index * this.itemSize + 3] = toHalfFloat(w);
		return this;
	}
	setXY(index, x, y) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize$2(x, this.array);
			y = normalize$2(y, this.array);
		}
		this.array[index + 0] = toHalfFloat(x);
		this.array[index + 1] = toHalfFloat(y);
		return this;
	}
	setXYZ(index, x, y, z) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize$2(x, this.array);
			y = normalize$2(y, this.array);
			z = normalize$2(z, this.array);
		}
		this.array[index + 0] = toHalfFloat(x);
		this.array[index + 1] = toHalfFloat(y);
		this.array[index + 2] = toHalfFloat(z);
		return this;
	}
	setXYZW(index, x, y, z, w) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize$2(x, this.array);
			y = normalize$2(y, this.array);
			z = normalize$2(z, this.array);
			w = normalize$2(w, this.array);
		}
		this.array[index + 0] = toHalfFloat(x);
		this.array[index + 1] = toHalfFloat(y);
		this.array[index + 2] = toHalfFloat(z);
		this.array[index + 3] = toHalfFloat(w);
		return this;
	}
};
/**
* Convenient class that can be used when creating a `Float32` buffer attribute with
* a plain `Array` instance.
*
* @augments BufferAttribute
*/
var Float32BufferAttribute = class extends BufferAttribute {
	/**
	* Constructs a new buffer attribute.
	*
	* @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
	* @param {number} itemSize - The item size.
	* @param {boolean} [normalized=false] - Whether the data are normalized or not.
	*/
	constructor(array$2, itemSize, normalized) {
		super(new Float32Array(array$2), itemSize, normalized);
	}
};
var _id$1$11 = 0;
var _m1$3 = /* @__PURE__ */ new Matrix4();
var _obj = /* @__PURE__ */ new Object3D();
var _offset = /* @__PURE__ */ new Vector3();
var _box$2 = /* @__PURE__ */ new Box3();
var _boxMorphTargets = /* @__PURE__ */ new Box3();
var _vector$8 = /* @__PURE__ */ new Vector3();
/**
* A representation of mesh, line, or point geometry. Includes vertex
* positions, face indices, normals, colors, UVs, and custom attributes
* within buffers, reducing the cost of passing all this data to the GPU.
*
* ```js
* const geometry = new THREE.BufferGeometry();
* // create a simple square shape. We duplicate the top left and bottom right
* // vertices because each vertex needs to appear once per triangle.
* const vertices = new Float32Array( [
* 	-1.0, -1.0,  1.0, // v0
* 	 1.0, -1.0,  1.0, // v1
* 	 1.0,  1.0,  1.0, // v2
*
* 	 1.0,  1.0,  1.0, // v3
* 	-1.0,  1.0,  1.0, // v4
* 	-1.0, -1.0,  1.0  // v5
* ] );
* // itemSize = 3 because there are 3 values (components) per vertex
* geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
* const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
* const mesh = new THREE.Mesh( geometry, material );
* ```
*
* @augments EventDispatcher
*/
var BufferGeometry = class BufferGeometry extends EventDispatcher {
	/**
	* Constructs a new geometry.
	*/
	constructor() {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isBufferGeometry = true;
		/**
		* The ID of the geometry.
		*
		* @name BufferGeometry#id
		* @type {number}
		* @readonly
		*/
		Object.defineProperty(this, "id", { value: _id$1$11++ });
		/**
		* The UUID of the geometry.
		*
		* @type {string}
		* @readonly
		*/
		this.uuid = generateUUID();
		/**
		* The name of the geometry.
		*
		* @type {string}
		*/
		this.name = "";
		this.type = "BufferGeometry";
		/**
		* Allows for vertices to be re-used across multiple triangles; this is
		* called using "indexed triangles". Each triangle is associated with the
		* indices of three vertices. This attribute therefore stores the index of
		* each vertex for each triangular face. If this attribute is not set, the
		* renderer assumes that each three contiguous positions represent a single triangle.
		*
		* @type {?BufferAttribute}
		* @default null
		*/
		this.index = null;
		/**
		* A (storage) buffer attribute which was generated with a compute shader and
		* now defines indirect draw calls.
		*
		* Can only be used with {@link WebGPURenderer} and a WebGPU backend.
		*
		* @type {?BufferAttribute}
		* @default null
		*/
		this.indirect = null;
		/**
		* This dictionary has as id the name of the attribute to be set and as value
		* the buffer attribute to set it to. Rather than accessing this property directly,
		* use `setAttribute()` and `getAttribute()` to access attributes of this geometry.
		*
		* @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}
		*/
		this.attributes = {};
		/**
		* This dictionary holds the morph targets of the geometry.
		*
		* Note: Once the geometry has been rendered, the morph attribute data cannot
		* be changed. You will have to call `dispose()?, and create a new geometry instance.
		*
		* @type {Object}
		*/
		this.morphAttributes = {};
		/**
		* Used to control the morph target behavior; when set to `true`, the morph
		* target data is treated as relative offsets, rather than as absolute
		* positions/normals.
		*
		* @type {boolean}
		* @default false
		*/
		this.morphTargetsRelative = false;
		/**
		* Split the geometry into groups, each of which will be rendered in a
		* separate draw call. This allows an array of materials to be used with the geometry.
		*
		* Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.
		*
		* Every vertex and index must belong to exactly one group — groups must not share vertices or
		* indices, and must not leave vertices or indices unused.
		*
		* @type {Array<Object>}
		*/
		this.groups = [];
		/**
		* Bounding box for the geometry which can be calculated with `computeBoundingBox()`.
		*
		* @type {?Box3}
		* @default null
		*/
		this.boundingBox = null;
		/**
		* Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.
		*
		* @type {?Sphere}
		* @default null
		*/
		this.boundingSphere = null;
		/**
		* Determines the part of the geometry to render. This should not be set directly,
		* instead use `setDrawRange()`.
		*
		* @type {{start:number,count:number}}
		*/
		this.drawRange = {
			start: 0,
			count: Infinity
		};
		/**
		* An object that can be used to store custom data about the geometry.
		* It should not hold references to functions as these will not be cloned.
		*
		* @type {Object}
		*/
		this.userData = {};
	}
	/**
	* Returns the index of this geometry.
	*
	* @return {?BufferAttribute} The index. Returns `null` if no index is defined.
	*/
	getIndex() {
		return this.index;
	}
	/**
	* Sets the given index to this geometry.
	*
	* @param {Array<number>|BufferAttribute} index - The index to set.
	* @return {BufferGeometry} A reference to this instance.
	*/
	setIndex(index) {
		if (Array.isArray(index)) this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
		else this.index = index;
		return this;
	}
	/**
	* Sets the given indirect attribute to this geometry.
	*
	* @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
	* @return {BufferGeometry} A reference to this instance.
	*/
	setIndirect(indirect) {
		this.indirect = indirect;
		return this;
	}
	/**
	* Returns the indirect attribute of this geometry.
	*
	* @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
	*/
	getIndirect() {
		return this.indirect;
	}
	/**
	* Returns the buffer attribute for the given name.
	*
	* @param {string} name - The attribute name.
	* @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
	* Returns `undefined` if not attribute has been found.
	*/
	getAttribute(name) {
		return this.attributes[name];
	}
	/**
	* Sets the given attribute for the given name.
	*
	* @param {string} name - The attribute name.
	* @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
	* @return {BufferGeometry} A reference to this instance.
	*/
	setAttribute(name, attribute$2) {
		this.attributes[name] = attribute$2;
		return this;
	}
	/**
	* Deletes the attribute for the given name.
	*
	* @param {string} name - The attribute name to delete.
	* @return {BufferGeometry} A reference to this instance.
	*/
	deleteAttribute(name) {
		delete this.attributes[name];
		return this;
	}
	/**
	* Returns `true` if this geometry has an attribute for the given name.
	*
	* @param {string} name - The attribute name.
	* @return {boolean} Whether this geometry has an attribute for the given name or not.
	*/
	hasAttribute(name) {
		return this.attributes[name] !== void 0;
	}
	/**
	* Adds a group to this geometry.
	*
	* @param {number} start - The first element in this draw call. That is the first
	* vertex for non-indexed geometry, otherwise the first triangle index.
	* @param {number} count - Specifies how many vertices (or indices) are part of this group.
	* @param {number} [materialIndex=0] - The material array index to use.
	*/
	addGroup(start, count, materialIndex = 0) {
		this.groups.push({
			start,
			count,
			materialIndex
		});
	}
	/**
	* Clears all groups.
	*/
	clearGroups() {
		this.groups = [];
	}
	/**
	* Sets the draw range for this geometry.
	*
	* @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
	* @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
	* For indexed BufferGeometry, `count` is the number of indices to render.
	*/
	setDrawRange(start, count) {
		this.drawRange.start = start;
		this.drawRange.count = count;
	}
	/**
	* Applies the given 4x4 transformation matrix to the geometry.
	*
	* @param {Matrix4} matrix - The matrix to apply.
	* @return {BufferGeometry} A reference to this instance.
	*/
	applyMatrix4(matrix) {
		const position = this.attributes.position;
		if (position !== void 0) {
			position.applyMatrix4(matrix);
			position.needsUpdate = true;
		}
		const normal$1 = this.attributes.normal;
		if (normal$1 !== void 0) {
			const normalMatrix = new Matrix3().getNormalMatrix(matrix);
			normal$1.applyNormalMatrix(normalMatrix);
			normal$1.needsUpdate = true;
		}
		const tangent = this.attributes.tangent;
		if (tangent !== void 0) {
			tangent.transformDirection(matrix);
			tangent.needsUpdate = true;
		}
		if (this.boundingBox !== null) this.computeBoundingBox();
		if (this.boundingSphere !== null) this.computeBoundingSphere();
		return this;
	}
	/**
	* Applies the rotation represented by the Quaternion to the geometry.
	*
	* @param {Quaternion} q - The Quaternion to apply.
	* @return {BufferGeometry} A reference to this instance.
	*/
	applyQuaternion(q) {
		_m1$3.makeRotationFromQuaternion(q);
		this.applyMatrix4(_m1$3);
		return this;
	}
	/**
	* Rotates the geometry about the X axis. This is typically done as a one time
	* operation, and not during a loop. Use {@link Object3D#rotation} for typical
	* real-time mesh rotation.
	*
	* @param {number} angle - The angle in radians.
	* @return {BufferGeometry} A reference to this instance.
	*/
	rotateX(angle) {
		_m1$3.makeRotationX(angle);
		this.applyMatrix4(_m1$3);
		return this;
	}
	/**
	* Rotates the geometry about the Y axis. This is typically done as a one time
	* operation, and not during a loop. Use {@link Object3D#rotation} for typical
	* real-time mesh rotation.
	*
	* @param {number} angle - The angle in radians.
	* @return {BufferGeometry} A reference to this instance.
	*/
	rotateY(angle) {
		_m1$3.makeRotationY(angle);
		this.applyMatrix4(_m1$3);
		return this;
	}
	/**
	* Rotates the geometry about the Z axis. This is typically done as a one time
	* operation, and not during a loop. Use {@link Object3D#rotation} for typical
	* real-time mesh rotation.
	*
	* @param {number} angle - The angle in radians.
	* @return {BufferGeometry} A reference to this instance.
	*/
	rotateZ(angle) {
		_m1$3.makeRotationZ(angle);
		this.applyMatrix4(_m1$3);
		return this;
	}
	/**
	* Translates the geometry. This is typically done as a one time
	* operation, and not during a loop. Use {@link Object3D#position} for typical
	* real-time mesh rotation.
	*
	* @param {number} x - The x offset.
	* @param {number} y - The y offset.
	* @param {number} z - The z offset.
	* @return {BufferGeometry} A reference to this instance.
	*/
	translate(x, y, z) {
		_m1$3.makeTranslation(x, y, z);
		this.applyMatrix4(_m1$3);
		return this;
	}
	/**
	* Scales the geometry. This is typically done as a one time
	* operation, and not during a loop. Use {@link Object3D#scale} for typical
	* real-time mesh rotation.
	*
	* @param {number} x - The x scale.
	* @param {number} y - The y scale.
	* @param {number} z - The z scale.
	* @return {BufferGeometry} A reference to this instance.
	*/
	scale(x, y, z) {
		_m1$3.makeScale(x, y, z);
		this.applyMatrix4(_m1$3);
		return this;
	}
	/**
	* Rotates the geometry to face a point in 3D space. This is typically done as a one time
	* operation, and not during a loop. Use {@link Object3D#lookAt} for typical
	* real-time mesh rotation.
	*
	* @param {Vector3} vector - The target point.
	* @return {BufferGeometry} A reference to this instance.
	*/
	lookAt(vector) {
		_obj.lookAt(vector);
		_obj.updateMatrix();
		this.applyMatrix4(_obj.matrix);
		return this;
	}
	/**
	* Center the geometry based on its bounding box.
	*
	* @return {BufferGeometry} A reference to this instance.
	*/
	center() {
		this.computeBoundingBox();
		this.boundingBox.getCenter(_offset).negate();
		this.translate(_offset.x, _offset.y, _offset.z);
		return this;
	}
	/**
	* Defines a geometry by creating a `position` attribute based on the given array of points. The array
	* can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
	* set to `0`.
	*
	* If the method is used with an existing `position` attribute, the vertex data are overwritten with the
	* data from the array. The length of the array must match the vertex count.
	*
	* @param {Array<Vector2>|Array<Vector3>} points - The points.
	* @return {BufferGeometry} A reference to this instance.
	*/
	setFromPoints(points) {
		const positionAttribute = this.getAttribute("position");
		if (positionAttribute === void 0) {
			const position = [];
			for (let i = 0, l = points.length; i < l; i++) {
				const point = points[i];
				position.push(point.x, point.y, point.z || 0);
			}
			this.setAttribute("position", new Float32BufferAttribute(position, 3));
		} else {
			const l = Math.min(points.length, positionAttribute.count);
			for (let i = 0; i < l; i++) {
				const point = points[i];
				positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);
			}
			if (points.length > positionAttribute.count) warn("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");
			positionAttribute.needsUpdate = true;
		}
		return this;
	}
	/**
	* Computes the bounding box of the geometry, and updates the `boundingBox` member.
	* The bounding box is not computed by the engine; it must be computed by your app.
	* You may need to recompute the bounding box if the geometry vertices are modified.
	*/
	computeBoundingBox() {
		if (this.boundingBox === null) this.boundingBox = new Box3();
		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;
		if (position && position.isGLBufferAttribute) {
			error("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
			this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
			return;
		}
		if (position !== void 0) {
			this.boundingBox.setFromBufferAttribute(position);
			if (morphAttributesPosition) for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
				const morphAttribute = morphAttributesPosition[i];
				_box$2.setFromBufferAttribute(morphAttribute);
				if (this.morphTargetsRelative) {
					_vector$8.addVectors(this.boundingBox.min, _box$2.min);
					this.boundingBox.expandByPoint(_vector$8);
					_vector$8.addVectors(this.boundingBox.max, _box$2.max);
					this.boundingBox.expandByPoint(_vector$8);
				} else {
					this.boundingBox.expandByPoint(_box$2.min);
					this.boundingBox.expandByPoint(_box$2.max);
				}
			}
		} else this.boundingBox.makeEmpty();
		if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) error("BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.", this);
	}
	/**
	* Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
	* The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
	* You may need to recompute the bounding sphere if the geometry vertices are modified.
	*/
	computeBoundingSphere() {
		if (this.boundingSphere === null) this.boundingSphere = new Sphere();
		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;
		if (position && position.isGLBufferAttribute) {
			error("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
			this.boundingSphere.set(new Vector3(), Infinity);
			return;
		}
		if (position) {
			const center = this.boundingSphere.center;
			_box$2.setFromBufferAttribute(position);
			if (morphAttributesPosition) for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
				const morphAttribute = morphAttributesPosition[i];
				_boxMorphTargets.setFromBufferAttribute(morphAttribute);
				if (this.morphTargetsRelative) {
					_vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
					_box$2.expandByPoint(_vector$8);
					_vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
					_box$2.expandByPoint(_vector$8);
				} else {
					_box$2.expandByPoint(_boxMorphTargets.min);
					_box$2.expandByPoint(_boxMorphTargets.max);
				}
			}
			_box$2.getCenter(center);
			let maxRadiusSq = 0;
			for (let i = 0, il = position.count; i < il; i++) {
				_vector$8.fromBufferAttribute(position, i);
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
			}
			if (morphAttributesPosition) for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
				const morphAttribute = morphAttributesPosition[i];
				const morphTargetsRelative = this.morphTargetsRelative;
				for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
					_vector$8.fromBufferAttribute(morphAttribute, j);
					if (morphTargetsRelative) {
						_offset.fromBufferAttribute(position, j);
						_vector$8.add(_offset);
					}
					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
				}
			}
			this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
			if (isNaN(this.boundingSphere.radius)) error("BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.", this);
		}
	}
	/**
	* Calculates and adds a tangent attribute to this geometry.
	*
	* The computation is only supported for indexed geometries and if position, normal, and uv attributes
	* are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
	* {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
	*/
	computeTangents() {
		const index = this.index;
		const attributes = this.attributes;
		if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
			error("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
			return;
		}
		const positionAttribute = attributes.position;
		const normalAttribute = attributes.normal;
		const uvAttribute = attributes.uv;
		if (this.hasAttribute("tangent") === false) this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
		const tangentAttribute = this.getAttribute("tangent");
		const tan1 = [], tan2 = [];
		for (let i = 0; i < positionAttribute.count; i++) {
			tan1[i] = new Vector3();
			tan2[i] = new Vector3();
		}
		const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
		function handleTriangle(a$1, b$2, c$1) {
			vA.fromBufferAttribute(positionAttribute, a$1);
			vB.fromBufferAttribute(positionAttribute, b$2);
			vC.fromBufferAttribute(positionAttribute, c$1);
			uvA.fromBufferAttribute(uvAttribute, a$1);
			uvB.fromBufferAttribute(uvAttribute, b$2);
			uvC.fromBufferAttribute(uvAttribute, c$1);
			vB.sub(vA);
			vC.sub(vA);
			uvB.sub(uvA);
			uvC.sub(uvA);
			const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
			if (!isFinite(r)) return;
			sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
			tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
			tan1[a$1].add(sdir);
			tan1[b$2].add(sdir);
			tan1[c$1].add(sdir);
			tan2[a$1].add(tdir);
			tan2[b$2].add(tdir);
			tan2[c$1].add(tdir);
		}
		let groups = this.groups;
		if (groups.length === 0) groups = [{
			start: 0,
			count: index.count
		}];
		for (let i = 0, il = groups.length; i < il; ++i) {
			const group = groups[i];
			const start = group.start;
			const count = group.count;
			for (let j = start, jl = start + count; j < jl; j += 3) handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));
		}
		const tmp = new Vector3(), tmp2 = new Vector3();
		const n$2 = new Vector3(), n2 = new Vector3();
		function handleVertex(v) {
			n$2.fromBufferAttribute(normalAttribute, v);
			n2.copy(n$2);
			const t = tan1[v];
			tmp.copy(t);
			tmp.sub(n$2.multiplyScalar(n$2.dot(t))).normalize();
			tmp2.crossVectors(n2, t);
			const w = tmp2.dot(tan2[v]) < 0 ? -1 : 1;
			tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
		}
		for (let i = 0, il = groups.length; i < il; ++i) {
			const group = groups[i];
			const start = group.start;
			const count = group.count;
			for (let j = start, jl = start + count; j < jl; j += 3) {
				handleVertex(index.getX(j + 0));
				handleVertex(index.getX(j + 1));
				handleVertex(index.getX(j + 2));
			}
		}
	}
	/**
	* Computes vertex normals for the given vertex data. For indexed geometries, the method sets
	* each vertex normal to be the average of the face normals of the faces that share that vertex.
	* For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
	* to be the same as the face normal.
	*/
	computeVertexNormals() {
		const index = this.index;
		const positionAttribute = this.getAttribute("position");
		if (positionAttribute !== void 0) {
			let normalAttribute = this.getAttribute("normal");
			if (normalAttribute === void 0) {
				normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
				this.setAttribute("normal", normalAttribute);
			} else for (let i = 0, il = normalAttribute.count; i < il; i++) normalAttribute.setXYZ(i, 0, 0, 0);
			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();
			if (index) for (let i = 0, il = index.count; i < il; i += 3) {
				const vA = index.getX(i + 0);
				const vB = index.getX(i + 1);
				const vC = index.getX(i + 2);
				pA.fromBufferAttribute(positionAttribute, vA);
				pB.fromBufferAttribute(positionAttribute, vB);
				pC.fromBufferAttribute(positionAttribute, vC);
				cb.subVectors(pC, pB);
				ab.subVectors(pA, pB);
				cb.cross(ab);
				nA.fromBufferAttribute(normalAttribute, vA);
				nB.fromBufferAttribute(normalAttribute, vB);
				nC.fromBufferAttribute(normalAttribute, vC);
				nA.add(cb);
				nB.add(cb);
				nC.add(cb);
				normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
				normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
				normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
			}
			else for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
				pA.fromBufferAttribute(positionAttribute, i + 0);
				pB.fromBufferAttribute(positionAttribute, i + 1);
				pC.fromBufferAttribute(positionAttribute, i + 2);
				cb.subVectors(pC, pB);
				ab.subVectors(pA, pB);
				cb.cross(ab);
				normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
				normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
				normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
			}
			this.normalizeNormals();
			normalAttribute.needsUpdate = true;
		}
	}
	/**
	* Ensures every normal vector in a geometry will have a magnitude of `1`. This will
	* correct lighting on the geometry surfaces.
	*/
	normalizeNormals() {
		const normals = this.attributes.normal;
		for (let i = 0, il = normals.count; i < il; i++) {
			_vector$8.fromBufferAttribute(normals, i);
			_vector$8.normalize();
			normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
		}
	}
	/**
	* Return a new non-index version of this indexed geometry. If the geometry
	* is already non-indexed, the method is a NOOP.
	*
	* @return {BufferGeometry} The non-indexed version of this indexed geometry.
	*/
	toNonIndexed() {
		function convertBufferAttribute(attribute$2, indices$1) {
			const array$2 = attribute$2.array;
			const itemSize = attribute$2.itemSize;
			const normalized = attribute$2.normalized;
			const array2 = new array$2.constructor(indices$1.length * itemSize);
			let index = 0, index2 = 0;
			for (let i = 0, l = indices$1.length; i < l; i++) {
				if (attribute$2.isInterleavedBufferAttribute) index = indices$1[i] * attribute$2.data.stride + attribute$2.offset;
				else index = indices$1[i] * itemSize;
				for (let j = 0; j < itemSize; j++) array2[index2++] = array$2[index++];
			}
			return new BufferAttribute(array2, itemSize, normalized);
		}
		if (this.index === null) {
			warn("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
			return this;
		}
		const geometry2 = new BufferGeometry();
		const indices = this.index.array;
		const attributes = this.attributes;
		for (const name in attributes) {
			const attribute$2 = attributes[name];
			const newAttribute = convertBufferAttribute(attribute$2, indices);
			geometry2.setAttribute(name, newAttribute);
		}
		const morphAttributes = this.morphAttributes;
		for (const name in morphAttributes) {
			const morphArray = [];
			const morphAttribute = morphAttributes[name];
			for (let i = 0, il = morphAttribute.length; i < il; i++) {
				const attribute$2 = morphAttribute[i];
				const newAttribute = convertBufferAttribute(attribute$2, indices);
				morphArray.push(newAttribute);
			}
			geometry2.morphAttributes[name] = morphArray;
		}
		geometry2.morphTargetsRelative = this.morphTargetsRelative;
		const groups = this.groups;
		for (let i = 0, l = groups.length; i < l; i++) {
			const group = groups[i];
			geometry2.addGroup(group.start, group.count, group.materialIndex);
		}
		return geometry2;
	}
	/**
	* Serializes the geometry into JSON.
	*
	* @return {Object} A JSON object representing the serialized geometry.
	*/
	toJSON() {
		const data = { metadata: {
			version: 4.7,
			type: "BufferGeometry",
			generator: "BufferGeometry.toJSON"
		} };
		data.uuid = this.uuid;
		data.type = this.type;
		if (this.name !== "") data.name = this.name;
		if (Object.keys(this.userData).length > 0) data.userData = this.userData;
		if (this.parameters !== void 0) {
			const parameters = this.parameters;
			for (const key in parameters) if (parameters[key] !== void 0) data[key] = parameters[key];
			return data;
		}
		data.data = { attributes: {} };
		const index = this.index;
		if (index !== null) data.data.index = {
			type: index.array.constructor.name,
			array: Array.prototype.slice.call(index.array)
		};
		const attributes = this.attributes;
		for (const key in attributes) {
			const attribute$2 = attributes[key];
			data.data.attributes[key] = attribute$2.toJSON(data.data);
		}
		const morphAttributes = {};
		let hasMorphAttributes = false;
		for (const key in this.morphAttributes) {
			const attributeArray$2 = this.morphAttributes[key];
			const array$2 = [];
			for (let i = 0, il = attributeArray$2.length; i < il; i++) {
				const attribute$2 = attributeArray$2[i];
				array$2.push(attribute$2.toJSON(data.data));
			}
			if (array$2.length > 0) {
				morphAttributes[key] = array$2;
				hasMorphAttributes = true;
			}
		}
		if (hasMorphAttributes) {
			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;
		}
		const groups = this.groups;
		if (groups.length > 0) data.data.groups = JSON.parse(JSON.stringify(groups));
		const boundingSphere = this.boundingSphere;
		if (boundingSphere !== null) data.data.boundingSphere = boundingSphere.toJSON();
		return data;
	}
	/**
	* Returns a new geometry with copied values from this instance.
	*
	* @return {BufferGeometry} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	/**
	* Copies the values of the given geometry to this instance.
	*
	* @param {BufferGeometry} source - The geometry to copy.
	* @return {BufferGeometry} A reference to this instance.
	*/
	copy(source) {
		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;
		const data = {};
		this.name = source.name;
		const index = source.index;
		if (index !== null) this.setIndex(index.clone());
		const attributes = source.attributes;
		for (const name in attributes) {
			const attribute$2 = attributes[name];
			this.setAttribute(name, attribute$2.clone(data));
		}
		const morphAttributes = source.morphAttributes;
		for (const name in morphAttributes) {
			const array$2 = [];
			const morphAttribute = morphAttributes[name];
			for (let i = 0, l = morphAttribute.length; i < l; i++) array$2.push(morphAttribute[i].clone(data));
			this.morphAttributes[name] = array$2;
		}
		this.morphTargetsRelative = source.morphTargetsRelative;
		const groups = source.groups;
		for (let i = 0, l = groups.length; i < l; i++) {
			const group = groups[i];
			this.addGroup(group.start, group.count, group.materialIndex);
		}
		const boundingBox = source.boundingBox;
		if (boundingBox !== null) this.boundingBox = boundingBox.clone();
		const boundingSphere = source.boundingSphere;
		if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;
		this.userData = source.userData;
		return this;
	}
	/**
	* Frees the GPU-related resources allocated by this instance. Call this
	* method whenever this instance is no longer used in your app.
	*
	* @fires BufferGeometry#dispose
	*/
	dispose() {
		this.dispatchEvent({ type: "dispose" });
	}
};
var _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
var _ray$3 = /* @__PURE__ */ new Ray();
var _sphere$6 = /* @__PURE__ */ new Sphere();
var _sphereHitAt = /* @__PURE__ */ new Vector3();
var _vA$1 = /* @__PURE__ */ new Vector3();
var _vB$1 = /* @__PURE__ */ new Vector3();
var _vC$1 = /* @__PURE__ */ new Vector3();
var _tempA = /* @__PURE__ */ new Vector3();
var _morphA = /* @__PURE__ */ new Vector3();
var _intersectionPoint = /* @__PURE__ */ new Vector3();
var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
/**
* Class representing triangular polygon mesh based objects.
*
* ```js
* const geometry = new THREE.BoxGeometry( 1, 1, 1 );
* const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
* const mesh = new THREE.Mesh( geometry, material );
* scene.add( mesh );
* ```
*
* @augments Object3D
*/
var Mesh = class extends Object3D {
	/**
	* Constructs a new mesh.
	*
	* @param {BufferGeometry} [geometry] - The mesh geometry.
	* @param {Material|Array<Material>} [material] - The mesh material.
	*/
	constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMesh = true;
		this.type = "Mesh";
		/**
		* The mesh geometry.
		*
		* @type {BufferGeometry}
		*/
		this.geometry = geometry;
		/**
		* The mesh material.
		*
		* @type {Material|Array<Material>}
		* @default MeshBasicMaterial
		*/
		this.material = material;
		/**
		* A dictionary representing the morph targets in the geometry. The key is the
		* morph targets name, the value its attribute index. This member is `undefined`
		* by default and only set when morph targets are detected in the geometry.
		*
		* @type {Object<String,number>|undefined}
		* @default undefined
		*/
		this.morphTargetDictionary = void 0;
		/**
		* An array of weights typically in the range `[0,1]` that specify how much of the morph
		* is applied. This member is `undefined` by default and only set when morph targets are
		* detected in the geometry.
		*
		* @type {Array<number>|undefined}
		* @default undefined
		*/
		this.morphTargetInfluences = void 0;
		/**
		* The number of instances of this mesh.
		* Can only be used with {@link WebGPURenderer}.
		*
		* @type {number}
		* @default 1
		*/
		this.count = 1;
		this.updateMorphTargets();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		if (source.morphTargetInfluences !== void 0) this.morphTargetInfluences = source.morphTargetInfluences.slice();
		if (source.morphTargetDictionary !== void 0) this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
		this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
		this.geometry = source.geometry;
		return this;
	}
	/**
	* Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
	* to make sure existing morph targets can influence this 3D object.
	*/
	updateMorphTargets() {
		const morphAttributes = this.geometry.morphAttributes;
		const keys = Object.keys(morphAttributes);
		if (keys.length > 0) {
			const morphAttribute = morphAttributes[keys[0]];
			if (morphAttribute !== void 0) {
				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};
				for (let m$1 = 0, ml = morphAttribute.length; m$1 < ml; m$1++) {
					const name = morphAttribute[m$1].name || String(m$1);
					this.morphTargetInfluences.push(0);
					this.morphTargetDictionary[name] = m$1;
				}
			}
		}
	}
	/**
	* Returns the local-space position of the vertex at the given index, taking into
	* account the current animation state of both morph targets and skinning.
	*
	* @param {number} index - The vertex index.
	* @param {Vector3} target - The target object that is used to store the method's result.
	* @return {Vector3} The vertex position in local space.
	*/
	getVertexPosition(index, target) {
		const geometry = this.geometry;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;
		target.fromBufferAttribute(position, index);
		const morphInfluences = this.morphTargetInfluences;
		if (morphPosition && morphInfluences) {
			_morphA.set(0, 0, 0);
			for (let i = 0, il = morphPosition.length; i < il; i++) {
				const influence = morphInfluences[i];
				const morphAttribute = morphPosition[i];
				if (influence === 0) continue;
				_tempA.fromBufferAttribute(morphAttribute, index);
				if (morphTargetsRelative) _morphA.addScaledVector(_tempA, influence);
				else _morphA.addScaledVector(_tempA.sub(target), influence);
			}
			target.add(_morphA);
		}
		return target;
	}
	/**
	* Computes intersection points between a casted ray and this line.
	*
	* @param {Raycaster} raycaster - The raycaster.
	* @param {Array<Object>} intersects - The target array that holds the intersection points.
	*/
	raycast(raycaster, intersects) {
		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;
		if (material === void 0) return;
		if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
		_sphere$6.copy(geometry.boundingSphere);
		_sphere$6.applyMatrix4(matrixWorld);
		_ray$3.copy(raycaster.ray).recast(raycaster.near);
		if (_sphere$6.containsPoint(_ray$3.origin) === false) {
			if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
			if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
		}
		_inverseMatrix$3.copy(matrixWorld).invert();
		_ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
		if (geometry.boundingBox !== null) {
			if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
		}
		this._computeIntersections(raycaster, intersects, _ray$3);
	}
	_computeIntersections(raycaster, intersects, rayLocalSpace) {
		let intersection;
		const geometry = this.geometry;
		const material = this.material;
		const index = geometry.index;
		const position = geometry.attributes.position;
		const uv$3 = geometry.attributes.uv;
		const uv1 = geometry.attributes.uv1;
		const normal$1 = geometry.attributes.normal;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;
		if (index !== null) if (Array.isArray(material)) for (let i = 0, il = groups.length; i < il; i++) {
			const group = groups[i];
			const groupMaterial = material[group.materialIndex];
			const start = Math.max(group.start, drawRange.start);
			const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
			for (let j = start, jl = end; j < jl; j += 3) {
				const a$1 = index.getX(j);
				const b$2 = index.getX(j + 1);
				const c$1 = index.getX(j + 2);
				intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv$3, uv1, normal$1, a$1, b$2, c$1);
				if (intersection) {
					intersection.faceIndex = Math.floor(j / 3);
					intersection.face.materialIndex = group.materialIndex;
					intersects.push(intersection);
				}
			}
		}
		else {
			const start = Math.max(0, drawRange.start);
			const end = Math.min(index.count, drawRange.start + drawRange.count);
			for (let i = start, il = end; i < il; i += 3) {
				const a$1 = index.getX(i);
				const b$2 = index.getX(i + 1);
				const c$1 = index.getX(i + 2);
				intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv$3, uv1, normal$1, a$1, b$2, c$1);
				if (intersection) {
					intersection.faceIndex = Math.floor(i / 3);
					intersects.push(intersection);
				}
			}
		}
		else if (position !== void 0) if (Array.isArray(material)) for (let i = 0, il = groups.length; i < il; i++) {
			const group = groups[i];
			const groupMaterial = material[group.materialIndex];
			const start = Math.max(group.start, drawRange.start);
			const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
			for (let j = start, jl = end; j < jl; j += 3) {
				const a$1 = j;
				const b$2 = j + 1;
				const c$1 = j + 2;
				intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv$3, uv1, normal$1, a$1, b$2, c$1);
				if (intersection) {
					intersection.faceIndex = Math.floor(j / 3);
					intersection.face.materialIndex = group.materialIndex;
					intersects.push(intersection);
				}
			}
		}
		else {
			const start = Math.max(0, drawRange.start);
			const end = Math.min(position.count, drawRange.start + drawRange.count);
			for (let i = start, il = end; i < il; i += 3) {
				const a$1 = i;
				const b$2 = i + 1;
				const c$1 = i + 2;
				intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv$3, uv1, normal$1, a$1, b$2, c$1);
				if (intersection) {
					intersection.faceIndex = Math.floor(i / 3);
					intersects.push(intersection);
				}
			}
		}
	}
};
function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
	let intersect;
	if (material.side === BackSide) intersect = ray.intersectTriangle(pC, pB, pA, true, point);
	else intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
	if (intersect === null) return null;
	_intersectionPointWorld.copy(point);
	_intersectionPointWorld.applyMatrix4(object.matrixWorld);
	const distance$3 = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
	if (distance$3 < raycaster.near || distance$3 > raycaster.far) return null;
	return {
		distance: distance$3,
		point: _intersectionPointWorld.clone(),
		object
	};
}
function checkGeometryIntersection(object, material, raycaster, ray, uv$3, uv1, normal$1, a$1, b$2, c$1) {
	object.getVertexPosition(a$1, _vA$1);
	object.getVertexPosition(b$2, _vB$1);
	object.getVertexPosition(c$1, _vC$1);
	const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
	if (intersection) {
		const barycoord = new Vector3();
		Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
		if (uv$3) intersection.uv = Triangle.getInterpolatedAttribute(uv$3, a$1, b$2, c$1, barycoord, new Vector2());
		if (uv1) intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a$1, b$2, c$1, barycoord, new Vector2());
		if (normal$1) {
			intersection.normal = Triangle.getInterpolatedAttribute(normal$1, a$1, b$2, c$1, barycoord, new Vector3());
			if (intersection.normal.dot(ray.direction) > 0) intersection.normal.multiplyScalar(-1);
		}
		const face = {
			a: a$1,
			b: b$2,
			c: c$1,
			normal: new Vector3(),
			materialIndex: 0
		};
		Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
		intersection.face = face;
		intersection.barycoord = barycoord;
	}
	return intersection;
}
/**
* A geometry class for a rectangular cuboid with a given width, height, and depth.
* On creation, the cuboid is centred on the origin, with each edge parallel to one
* of the axes.
*
* ```js
* const geometry = new THREE.BoxGeometry( 1, 1, 1 );
* const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
* const cube = new THREE.Mesh( geometry, material );
* scene.add( cube );
* ```
*
* @augments BufferGeometry
* @demo scenes/geometry-browser.html#BoxGeometry
*/
var BoxGeometry = class BoxGeometry extends BufferGeometry {
	/**
	* Constructs a new box geometry.
	*
	* @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
	* @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
	* @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
	* @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
	* @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
	* @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
	*/
	constructor(width = 1, height = 1, depth$2 = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
		super();
		this.type = "BoxGeometry";
		/**
		* Holds the constructor parameters that have been
		* used to generate the geometry. Any modification
		* after instantiation does not change the geometry.
		*
		* @type {Object}
		*/
		this.parameters = {
			width,
			height,
			depth: depth$2,
			widthSegments,
			heightSegments,
			depthSegments
		};
		const scope = this;
		widthSegments = Math.floor(widthSegments);
		heightSegments = Math.floor(heightSegments);
		depthSegments = Math.floor(depthSegments);
		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];
		let numberOfVertices = 0;
		let groupStart = 0;
		buildPlane("z", "y", "x", -1, -1, depth$2, height, width, depthSegments, heightSegments, 0);
		buildPlane("z", "y", "x", 1, -1, depth$2, height, -width, depthSegments, heightSegments, 1);
		buildPlane("x", "z", "y", 1, 1, width, depth$2, height, widthSegments, depthSegments, 2);
		buildPlane("x", "z", "y", 1, -1, width, depth$2, -height, widthSegments, depthSegments, 3);
		buildPlane("x", "y", "z", 1, -1, width, height, depth$2, widthSegments, heightSegments, 4);
		buildPlane("x", "y", "z", -1, -1, width, height, -depth$2, widthSegments, heightSegments, 5);
		this.setIndex(indices);
		this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
		this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
		this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
		function buildPlane(u, v, w, udir, vdir, width$1, height$1, depth$3, gridX, gridY, materialIndex) {
			const segmentWidth = width$1 / gridX;
			const segmentHeight = height$1 / gridY;
			const widthHalf = width$1 / 2;
			const heightHalf = height$1 / 2;
			const depthHalf = depth$3 / 2;
			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;
			let vertexCounter = 0;
			let groupCount = 0;
			const vector = new Vector3();
			for (let iy = 0; iy < gridY1; iy++) {
				const y = iy * segmentHeight - heightHalf;
				for (let ix = 0; ix < gridX1; ix++) {
					vector[u] = (ix * segmentWidth - widthHalf) * udir;
					vector[v] = y * vdir;
					vector[w] = depthHalf;
					vertices.push(vector.x, vector.y, vector.z);
					vector[u] = 0;
					vector[v] = 0;
					vector[w] = depth$3 > 0 ? 1 : -1;
					normals.push(vector.x, vector.y, vector.z);
					uvs.push(ix / gridX);
					uvs.push(1 - iy / gridY);
					vertexCounter += 1;
				}
			}
			for (let iy = 0; iy < gridY; iy++) for (let ix = 0; ix < gridX; ix++) {
				const a$1 = numberOfVertices + ix + gridX1 * iy;
				const b$2 = numberOfVertices + ix + gridX1 * (iy + 1);
				const c$1 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
				const d$1 = numberOfVertices + (ix + 1) + gridX1 * iy;
				indices.push(a$1, b$2, d$1);
				indices.push(b$2, c$1, d$1);
				groupCount += 6;
			}
			scope.addGroup(groupStart, groupCount, materialIndex);
			groupStart += groupCount;
			numberOfVertices += vertexCounter;
		}
	}
	copy(source) {
		super.copy(source);
		this.parameters = Object.assign({}, source.parameters);
		return this;
	}
	/**
	* Factory method for creating an instance of this class from the given
	* JSON object.
	*
	* @param {Object} data - A JSON object representing the serialized geometry.
	* @return {BoxGeometry} A new instance.
	*/
	static fromJSON(data) {
		return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
	}
};
/**
* Provides utility functions for managing uniforms.
*
* @module UniformsUtils
*/
/**
* Clones the given uniform definitions by performing a deep-copy. That means
* if the value of a uniform refers to an object like a Vector3 or Texture,
* the cloned uniform will refer to a new object reference.
*
* @param {Object} src - An object representing uniform definitions.
* @return {Object} The cloned uniforms.
*/
function cloneUniforms(src) {
	const dst = {};
	for (const u in src) {
		dst[u] = {};
		for (const p$1 in src[u]) {
			const property$2 = src[u][p$1];
			if (property$2 && (property$2.isColor || property$2.isMatrix3 || property$2.isMatrix4 || property$2.isVector2 || property$2.isVector3 || property$2.isVector4 || property$2.isTexture || property$2.isQuaternion)) if (property$2.isRenderTargetTexture) {
				warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
				dst[u][p$1] = null;
			} else dst[u][p$1] = property$2.clone();
			else if (Array.isArray(property$2)) dst[u][p$1] = property$2.slice();
			else dst[u][p$1] = property$2;
		}
	}
	return dst;
}
/**
* Merges the given uniform definitions into a single object. Since the
* method internally uses cloneUniforms(), it performs a deep-copy when
* producing the merged uniform definitions.
*
* @param {Array} uniforms - An array of objects containing uniform definitions.
* @return {Object} The merged uniforms.
*/
function mergeUniforms(uniforms) {
	const merged = {};
	for (let u = 0; u < uniforms.length; u++) {
		const tmp = cloneUniforms(uniforms[u]);
		for (const p$1 in tmp) merged[p$1] = tmp[p$1];
	}
	return merged;
}
function cloneUniformsGroups(src) {
	const dst = [];
	for (let u = 0; u < src.length; u++) dst.push(src[u].clone());
	return dst;
}
function getUnlitUniformColorSpace(renderer) {
	const currentRenderTarget = renderer.getRenderTarget();
	if (currentRenderTarget === null) return renderer.outputColorSpace;
	if (currentRenderTarget.isXRRenderTarget === true) return currentRenderTarget.texture.colorSpace;
	return ColorManagement.workingColorSpace;
}
var UniformsUtils = {
	clone: cloneUniforms,
	merge: mergeUniforms
};
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
/**
* A material rendered with custom shaders. A shader is a small program written in GLSL.
* that runs on the GPU. You may want to use a custom shader if you need to implement an
* effect not included with any of the built-in materials.
*
* There are the following notes to bear in mind when using a `ShaderMaterial`:
*
* - `ShaderMaterial` can only be used with {@link WebGLRenderer}.
* - Built in attributes and uniforms are passed to the shaders along with your code. If
* you don't want that, use {@link RawShaderMaterial} instead.
* - You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`
* in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has
* to be placed right above the loop. The loop formatting has to correspond to a defined standard.
*   - The loop has to be [normalized](https://en.wikipedia.org/wiki/Normalized_loop).
*   - The loop variable has to be *i*.
*   - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly
* value of *i* for the given iteration and can be used in preprocessor
* statements.
*
* ```js
* const material = new THREE.ShaderMaterial( {
* 	uniforms: {
* 		time: { value: 1.0 },
* 		resolution: { value: new THREE.Vector2() }
* 	},
* 	vertexShader: document.getElementById( 'vertexShader' ).textContent,
* 	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
* } );
* ```
*
* @augments Material
*/
var ShaderMaterial = class extends Material {
	/**
	* Constructs a new shader material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isShaderMaterial = true;
		this.type = "ShaderMaterial";
		/**
		* Defines custom constants using `#define` directives within the GLSL code
		* for both the vertex shader and the fragment shader; each key/value pair
		* yields another directive.
		* ```js
		* defines: {
		* 	FOO: 15,
		* 	BAR: true
		* }
		* ```
		* Yields the lines:
		* ```
		* #define FOO 15
		* #define BAR true
		* ```
		*
		* @type {Object}
		*/
		this.defines = {};
		/**
		* An object of the form:
		* ```js
		* {
		* 	"uniform1": { value: 1.0 },
		* 	"uniform2": { value: 2 }
		* }
		* ```
		* specifying the uniforms to be passed to the shader code; keys are uniform
		* names, values are definitions of the form
		* ```
		* {
		* 	value: 1.0
		* }
		* ```
		* where `value` is the value of the uniform. Names must match the name of
		* the uniform, as defined in the GLSL code. Note that uniforms are refreshed
		* on every frame, so updating the value of the uniform will immediately
		* update the value available to the GLSL code.
		*
		* @type {Object}
		*/
		this.uniforms = {};
		/**
		* An array holding uniforms groups for configuring UBOs.
		*
		* @type {Array<UniformsGroup>}
		*/
		this.uniformsGroups = [];
		/**
		* Vertex shader GLSL code. This is the actual code for the shader.
		*
		* @type {string}
		*/
		this.vertexShader = default_vertex;
		/**
		* Fragment shader GLSL code. This is the actual code for the shader.
		*
		* @type {string}
		*/
		this.fragmentShader = default_fragment;
		/**
		* Controls line thickness or lines.
		*
		* WebGL and WebGPU ignore this setting and always render line primitives with a
		* width of one pixel.
		*
		* @type {number}
		* @default 1
		*/
		this.linewidth = 1;
		/**
		* Renders the geometry as a wireframe.
		*
		* @type {boolean}
		* @default false
		*/
		this.wireframe = false;
		/**
		* Controls the thickness of the wireframe.
		*
		* WebGL and WebGPU ignore this property and always render
		* 1 pixel wide lines.
		*
		* @type {number}
		* @default 1
		*/
		this.wireframeLinewidth = 1;
		/**
		* Define whether the material color is affected by global fog settings; `true`
		* to pass fog uniforms to the shader.
		*
		* @type {boolean}
		* @default false
		*/
		this.fog = false;
		/**
		* Defines whether this material uses lighting; `true` to pass uniform data
		* related to lighting to this shader.
		*
		* @type {boolean}
		* @default false
		*/
		this.lights = false;
		/**
		* Defines whether this material supports clipping; `true` to let the renderer
		* pass the clippingPlanes uniform.
		*
		* @type {boolean}
		* @default false
		*/
		this.clipping = false;
		/**
		* Overwritten and set to `true` by default.
		*
		* @type {boolean}
		* @default true
		*/
		this.forceSinglePass = true;
		/**
		* This object allows to enable certain WebGL 2 extensions.
		*
		* - clipCullDistance: set to `true` to use vertex shader clipping
		* - multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID
		*
		* @type {{clipCullDistance:false,multiDraw:false}}
		*/
		this.extensions = {
			clipCullDistance: false,
			multiDraw: false
		};
		/**
		* When the rendered geometry doesn't include these attributes but the
		* material does, these default values will be passed to the shaders. This
		* avoids errors when buffer data is missing.
		*
		* - color: [ 1, 1, 1 ]
		* - uv: [ 0, 0 ]
		* - uv1: [ 0, 0 ]
		*
		* @type {Object}
		*/
		this.defaultAttributeValues = {
			"color": [
				1,
				1,
				1
			],
			"uv": [0, 0],
			"uv1": [0, 0]
		};
		/**
		* If set, this calls [gl.bindAttribLocation](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation)
		* to bind a generic vertex index to an attribute variable.
		*
		* @type {string|undefined}
		* @default undefined
		*/
		this.index0AttributeName = void 0;
		/**
		* Can be used to force a uniform update while changing uniforms in
		* {@link Object3D#onBeforeRender}.
		*
		* @type {boolean}
		* @default false
		*/
		this.uniformsNeedUpdate = false;
		/**
		* Defines the GLSL version of custom shader code.
		*
		* @type {?(GLSL1|GLSL3)}
		* @default null
		*/
		this.glslVersion = null;
		if (parameters !== void 0) this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;
		this.uniforms = cloneUniforms(source.uniforms);
		this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
		this.defines = Object.assign({}, source.defines);
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;
		this.extensions = Object.assign({}, source.extensions);
		this.glslVersion = source.glslVersion;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.glslVersion = this.glslVersion;
		data.uniforms = {};
		for (const name in this.uniforms) {
			const value = this.uniforms[name].value;
			if (value && value.isTexture) data.uniforms[name] = {
				type: "t",
				value: value.toJSON(meta).uuid
			};
			else if (value && value.isColor) data.uniforms[name] = {
				type: "c",
				value: value.getHex()
			};
			else if (value && value.isVector2) data.uniforms[name] = {
				type: "v2",
				value: value.toArray()
			};
			else if (value && value.isVector3) data.uniforms[name] = {
				type: "v3",
				value: value.toArray()
			};
			else if (value && value.isVector4) data.uniforms[name] = {
				type: "v4",
				value: value.toArray()
			};
			else if (value && value.isMatrix3) data.uniforms[name] = {
				type: "m3",
				value: value.toArray()
			};
			else if (value && value.isMatrix4) data.uniforms[name] = {
				type: "m4",
				value: value.toArray()
			};
			else data.uniforms[name] = { value };
		}
		if (Object.keys(this.defines).length > 0) data.defines = this.defines;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;
		data.lights = this.lights;
		data.clipping = this.clipping;
		const extensions = {};
		for (const key in this.extensions) if (this.extensions[key] === true) extensions[key] = true;
		if (Object.keys(extensions).length > 0) data.extensions = extensions;
		return data;
	}
};
/**
* Abstract base class for cameras. This class should always be inherited
* when you build a new camera.
*
* @abstract
* @augments Object3D
*/
var Camera = class extends Object3D {
	/**
	* Constructs a new camera.
	*/
	constructor() {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isCamera = true;
		this.type = "Camera";
		/**
		* The inverse of the camera's world matrix.
		*
		* @type {Matrix4}
		*/
		this.matrixWorldInverse = new Matrix4();
		/**
		* The camera's projection matrix.
		*
		* @type {Matrix4}
		*/
		this.projectionMatrix = new Matrix4();
		/**
		* The inverse of the camera's projection matrix.
		*
		* @type {Matrix4}
		*/
		this.projectionMatrixInverse = new Matrix4();
		/**
		* The coordinate system in which the camera is used.
		*
		* @type {(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
		*/
		this.coordinateSystem = WebGLCoordinateSystem;
		this._reversedDepth = false;
	}
	/**
	* The flag that indicates whether the camera uses a reversed depth buffer.
	*
	* @type {boolean}
	* @default false
	*/
	get reversedDepth() {
		return this._reversedDepth;
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.matrixWorldInverse.copy(source.matrixWorldInverse);
		this.projectionMatrix.copy(source.projectionMatrix);
		this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
		this.coordinateSystem = source.coordinateSystem;
		return this;
	}
	/**
	* Returns a vector representing the ("look") direction of the 3D object in world space.
	*
	* This method is overwritten since cameras have a different forward vector compared to other
	* 3D objects. A camera looks down its local, negative z-axis by default.
	*
	* @param {Vector3} target - The target vector the result is stored to.
	* @return {Vector3} The 3D object's direction in world space.
	*/
	getWorldDirection(target) {
		return super.getWorldDirection(target).negate();
	}
	updateMatrixWorld(force) {
		super.updateMatrixWorld(force);
		this.matrixWorldInverse.copy(this.matrixWorld).invert();
	}
	updateWorldMatrix(updateParents, updateChildren) {
		super.updateWorldMatrix(updateParents, updateChildren);
		this.matrixWorldInverse.copy(this.matrixWorld).invert();
	}
	clone() {
		return new this.constructor().copy(this);
	}
};
var _v3$1 = /* @__PURE__ */ new Vector3();
var _minTarget = /* @__PURE__ */ new Vector2();
var _maxTarget = /* @__PURE__ */ new Vector2();
/**
* Camera that uses [perspective projection](https://en.wikipedia.org/wiki/Perspective_(graphical)).
*
* This projection mode is designed to mimic the way the human eye sees. It
* is the most common projection mode used for rendering a 3D scene.
*
* ```js
* const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
* scene.add( camera );
* ```
*
* @augments Camera
*/
var PerspectiveCamera = class extends Camera {
	/**
	* Constructs a new perspective camera.
	*
	* @param {number} [fov=50] - The vertical field of view.
	* @param {number} [aspect=1] - The aspect ratio.
	* @param {number} [near=0.1] - The camera's near plane.
	* @param {number} [far=2000] - The camera's far plane.
	*/
	constructor(fov$1 = 50, aspect$1 = 1, near = .1, far = 2e3) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isPerspectiveCamera = true;
		this.type = "PerspectiveCamera";
		/**
		* The vertical field of view, from bottom to top of view,
		* in degrees.
		*
		* @type {number}
		* @default 50
		*/
		this.fov = fov$1;
		/**
		* The zoom factor of the camera.
		*
		* @type {number}
		* @default 1
		*/
		this.zoom = 1;
		/**
		* The camera's near plane. The valid range is greater than `0`
		* and less than the current value of {@link PerspectiveCamera#far}.
		*
		* Note that, unlike for the {@link OrthographicCamera}, `0` is <em>not</em> a
		* valid value for a perspective camera's near plane.
		*
		* @type {number}
		* @default 0.1
		*/
		this.near = near;
		/**
		* The camera's far plane. Must be greater than the
		* current value of {@link PerspectiveCamera#near}.
		*
		* @type {number}
		* @default 2000
		*/
		this.far = far;
		/**
		* Object distance used for stereoscopy and depth-of-field effects. This
		* parameter does not influence the projection matrix unless a
		* {@link StereoCamera} is being used.
		*
		* @type {number}
		* @default 10
		*/
		this.focus = 10;
		/**
		* The aspect ratio, usually the canvas width / canvas height.
		*
		* @type {number}
		* @default 1
		*/
		this.aspect = aspect$1;
		/**
		* Represents the frustum window specification. This property should not be edited
		* directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
		*
		* @type {?Object}
		* @default null
		*/
		this.view = null;
		/**
		* Film size used for the larger axis. Default is `35` (millimeters). This
		* parameter does not influence the projection matrix unless {@link PerspectiveCamera#filmOffset}
		* is set to a nonzero value.
		*
		* @type {number}
		* @default 35
		*/
		this.filmGauge = 35;
		/**
		* Horizontal off-center offset in the same unit as {@link PerspectiveCamera#filmGauge}.
		*
		* @type {number}
		* @default 0
		*/
		this.filmOffset = 0;
		this.updateProjectionMatrix();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.fov = source.fov;
		this.zoom = source.zoom;
		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;
		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign({}, source.view);
		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;
		return this;
	}
	/**
	* Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
	*
	* The default film gauge is 35, so that the focal length can be specified for
	* a 35mm (full frame) camera.
	*
	* @param {number} focalLength - Values for focal length and film gauge must have the same unit.
	*/
	setFocalLength(focalLength) {
		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = .5 * this.getFilmHeight() / focalLength;
		this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
		this.updateProjectionMatrix();
	}
	/**
	* Returns the focal length from the current {@link PerspectiveCamera#fov} and
	* {@link PerspectiveCamera#filmGauge}.
	*
	* @return {number} The computed focal length.
	*/
	getFocalLength() {
		const vExtentSlope = Math.tan(DEG2RAD * .5 * this.fov);
		return .5 * this.getFilmHeight() / vExtentSlope;
	}
	/**
	* Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
	*
	* @return {number} The effective FOV.
	*/
	getEffectiveFOV() {
		return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * .5 * this.fov) / this.zoom);
	}
	/**
	* Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
	* equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
	*
	* @return {number} The film width.
	*/
	getFilmWidth() {
		return this.filmGauge * Math.min(this.aspect, 1);
	}
	/**
	* Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
	* equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
	*
	* @return {number} The film width.
	*/
	getFilmHeight() {
		return this.filmGauge / Math.max(this.aspect, 1);
	}
	/**
	* Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
	* Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
	*
	* @param {number} distance - The viewing distance.
	* @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
	* @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
	*/
	getViewBounds(distance$3, minTarget, maxTarget) {
		_v3$1.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse);
		minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance$3 / _v3$1.z);
		_v3$1.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse);
		maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance$3 / _v3$1.z);
	}
	/**
	* Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
	*
	* @param {number} distance - The viewing distance.
	* @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
	* @returns {Vector2} The view size.
	*/
	getViewSize(distance$3, target) {
		this.getViewBounds(distance$3, _minTarget, _maxTarget);
		return target.subVectors(_maxTarget, _minTarget);
	}
	/**
	* Sets an offset in a larger frustum. This is useful for multi-window or
	* multi-monitor/multi-machine setups.
	*
	* For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	* the monitors are in grid like this
	*```
	*   +---+---+---+
	*   | A | B | C |
	*   +---+---+---+
	*   | D | E | F |
	*   +---+---+---+
	*```
	* then for each monitor you would call it like this:
	*```js
	* const w = 1920;
	* const h = 1080;
	* const fullWidth = w * 3;
	* const fullHeight = h * 2;
	*
	* // --A--
	* camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	* // --B--
	* camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	* // --C--
	* camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	* // --D--
	* camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	* // --E--
	* camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	* // --F--
	* camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	* ```
	*
	* Note there is no reason monitors have to be the same size or in a grid.
	*
	* @param {number} fullWidth - The full width of multiview setup.
	* @param {number} fullHeight - The full height of multiview setup.
	* @param {number} x - The horizontal offset of the subcamera.
	* @param {number} y - The vertical offset of the subcamera.
	* @param {number} width - The width of subcamera.
	* @param {number} height - The height of subcamera.
	*/
	setViewOffset(fullWidth, fullHeight, x, y, width, height) {
		this.aspect = fullWidth / fullHeight;
		if (this.view === null) this.view = {
			enabled: true,
			fullWidth: 1,
			fullHeight: 1,
			offsetX: 0,
			offsetY: 0,
			width: 1,
			height: 1
		};
		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;
		this.updateProjectionMatrix();
	}
	/**
	* Removes the view offset from the projection matrix.
	*/
	clearViewOffset() {
		if (this.view !== null) this.view.enabled = false;
		this.updateProjectionMatrix();
	}
	/**
	* Updates the camera's projection matrix. Must be called after any change of
	* camera properties.
	*/
	updateProjectionMatrix() {
		const near = this.near;
		let top = near * Math.tan(DEG2RAD * .5 * this.fov) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = -.5 * width;
		const view = this.view;
		if (this.view !== null && this.view.enabled) {
			const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;
		}
		const skew = this.filmOffset;
		if (skew !== 0) left += near * skew / this.getFilmWidth();
		this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem, this.reversedDepth);
		this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.fov = this.fov;
		data.object.zoom = this.zoom;
		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;
		data.object.aspect = this.aspect;
		if (this.view !== null) data.object.view = Object.assign({}, this.view);
		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;
		return data;
	}
};
var fov = -90;
var aspect = 1;
/**
* A special type of camera that is positioned in 3D space to render its surroundings into a
* cube render target. The render target can then be used as an environment map for rendering
* realtime reflections in your scene.
*
* ```js
* // Create cube render target
* const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );
*
* // Create cube camera
* const cubeCamera = new THREE.CubeCamera( 1, 100000, cubeRenderTarget );
* scene.add( cubeCamera );
*
* // Create car
* const chromeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: cubeRenderTarget.texture } );
* const car = new THREE.Mesh( carGeometry, chromeMaterial );
* scene.add( car );
*
* // Update the render target cube
* car.visible = false;
* cubeCamera.position.copy( car.position );
* cubeCamera.update( renderer, scene );
*
* // Render the scene
* car.visible = true;
* renderer.render( scene, camera );
* ```
*
* @augments Object3D
*/
var CubeCamera = class extends Object3D {
	/**
	* Constructs a new cube camera.
	*
	* @param {number} near - The camera's near plane.
	* @param {number} far - The camera's far plane.
	* @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
	*/
	constructor(near, far, renderTarget) {
		super();
		this.type = "CubeCamera";
		/**
		* A reference to the cube render target.
		*
		* @type {WebGLCubeRenderTarget}
		*/
		this.renderTarget = renderTarget;
		/**
		* The current active coordinate system.
		*
		* @type {?(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
		* @default null
		*/
		this.coordinateSystem = null;
		/**
		* The current active mipmap level
		*
		* @type {number}
		* @default 0
		*/
		this.activeMipmapLevel = 0;
		const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
		cameraPX.layers = this.layers;
		this.add(cameraPX);
		const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
		cameraNX.layers = this.layers;
		this.add(cameraNX);
		const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
		cameraPY.layers = this.layers;
		this.add(cameraPY);
		const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
		cameraNY.layers = this.layers;
		this.add(cameraNY);
		const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
		cameraPZ.layers = this.layers;
		this.add(cameraPZ);
		const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
		cameraNZ.layers = this.layers;
		this.add(cameraNZ);
	}
	/**
	* Must be called when the coordinate system of the cube camera is changed.
	*/
	updateCoordinateSystem() {
		const coordinateSystem = this.coordinateSystem;
		const cameras = this.children.concat();
		const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
		for (const camera of cameras) this.remove(camera);
		if (coordinateSystem === WebGLCoordinateSystem) {
			cameraPX.up.set(0, 1, 0);
			cameraPX.lookAt(1, 0, 0);
			cameraNX.up.set(0, 1, 0);
			cameraNX.lookAt(-1, 0, 0);
			cameraPY.up.set(0, 0, -1);
			cameraPY.lookAt(0, 1, 0);
			cameraNY.up.set(0, 0, 1);
			cameraNY.lookAt(0, -1, 0);
			cameraPZ.up.set(0, 1, 0);
			cameraPZ.lookAt(0, 0, 1);
			cameraNZ.up.set(0, 1, 0);
			cameraNZ.lookAt(0, 0, -1);
		} else if (coordinateSystem === WebGPUCoordinateSystem) {
			cameraPX.up.set(0, -1, 0);
			cameraPX.lookAt(-1, 0, 0);
			cameraNX.up.set(0, -1, 0);
			cameraNX.lookAt(1, 0, 0);
			cameraPY.up.set(0, 0, 1);
			cameraPY.lookAt(0, 1, 0);
			cameraNY.up.set(0, 0, -1);
			cameraNY.lookAt(0, -1, 0);
			cameraPZ.up.set(0, -1, 0);
			cameraPZ.lookAt(0, 0, 1);
			cameraNZ.up.set(0, -1, 0);
			cameraNZ.lookAt(0, 0, -1);
		} else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
		for (const camera of cameras) {
			this.add(camera);
			camera.updateMatrixWorld();
		}
	}
	/**
	* Calling this method will render the given scene with the given renderer
	* into the cube render target of the camera.
	*
	* @param {(Renderer|WebGLRenderer)} renderer - The renderer.
	* @param {Scene} scene - The scene to render.
	*/
	update(renderer, scene) {
		if (this.parent === null) this.updateMatrixWorld();
		const { renderTarget, activeMipmapLevel } = this;
		if (this.coordinateSystem !== renderer.coordinateSystem) {
			this.coordinateSystem = renderer.coordinateSystem;
			this.updateCoordinateSystem();
		}
		const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
		const currentRenderTarget = renderer.getRenderTarget();
		const currentActiveCubeFace = renderer.getActiveCubeFace();
		const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
		const currentXrEnabled = renderer.xr.enabled;
		renderer.xr.enabled = false;
		const generateMipmaps = renderTarget.texture.generateMipmaps;
		renderTarget.texture.generateMipmaps = false;
		renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
		renderer.render(scene, cameraPX);
		renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
		renderer.render(scene, cameraNX);
		renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
		renderer.render(scene, cameraPY);
		renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
		renderer.render(scene, cameraNY);
		renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
		renderer.render(scene, cameraPZ);
		renderTarget.texture.generateMipmaps = generateMipmaps;
		renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
		renderer.render(scene, cameraNZ);
		renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
		renderer.xr.enabled = currentXrEnabled;
		renderTarget.texture.needsPMREMUpdate = true;
	}
};
/**
* Creates a cube texture made up of six images.
*
* ```js
* const loader = new THREE.CubeTextureLoader();
* loader.setPath( 'textures/cube/pisa/' );
*
* const textureCube = loader.load( [
* 	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
* ] );
*
* const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
* ```
*
* @augments Texture
*/
var CubeTexture = class extends Texture {
	/**
	* Constructs a new cube texture.
	*
	* @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
	* @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
	* @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	* @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	* @param {number} [magFilter=LinearFilter] - The mag filter value.
	* @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
	* @param {number} [format=RGBAFormat] - The texture format.
	* @param {number} [type=UnsignedByteType] - The texture type.
	* @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	* @param {string} [colorSpace=NoColorSpace] - The color space value.
	*/
	constructor(images = [], mapping = CubeReflectionMapping, wrapS, wrapT, magFilter, minFilter, format, type$1, anisotropy$2, colorSpace) {
		super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type$1, anisotropy$2, colorSpace);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isCubeTexture = true;
		/**
		* If set to `true`, the texture is flipped along the vertical axis when
		* uploaded to the GPU.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.flipY = false;
	}
	/**
	* Alias for {@link CubeTexture#image}.
	*
	* @type {Array<Image>}
	*/
	get images() {
		return this.image;
	}
	set images(value) {
		this.image = value;
	}
};
/**
* A cube render target used in context of {@link WebGLRenderer}.
*
* @augments WebGLRenderTarget
*/
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
	/**
	* Constructs a new cube render target.
	*
	* @param {number} [size=1] - The size of the render target.
	* @param {RenderTarget~Options} [options] - The configuration object.
	*/
	constructor(size = 1, options = {}) {
		super(size, size, options);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isWebGLCubeRenderTarget = true;
		const image = {
			width: size,
			height: size,
			depth: 1
		};
		/**
		* Overwritten with a different texture type.
		*
		* @type {DataArrayTexture}
		*/
		this.texture = new CubeTexture([
			image,
			image,
			image,
			image,
			image,
			image
		]);
		this._setTextureOptions(options);
		this.texture.isRenderTargetTexture = true;
	}
	/**
	* Converts the given equirectangular texture to a cube map.
	*
	* @param {WebGLRenderer} renderer - The renderer.
	* @param {Texture} texture - The equirectangular texture.
	* @return {WebGLCubeRenderTarget} A reference to this cube render target.
	*/
	fromEquirectangularTexture(renderer, texture$2) {
		this.texture.type = texture$2.type;
		this.texture.colorSpace = texture$2.colorSpace;
		this.texture.generateMipmaps = texture$2.generateMipmaps;
		this.texture.minFilter = texture$2.minFilter;
		this.texture.magFilter = texture$2.magFilter;
		const shader = {
			uniforms: { tEquirect: { value: null } },
			vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
			fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};
		const geometry = new BoxGeometry(5, 5, 5);
		const material = new ShaderMaterial({
			name: "CubemapFromEquirect",
			uniforms: cloneUniforms(shader.uniforms),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending
		});
		material.uniforms.tEquirect.value = texture$2;
		const mesh = new Mesh(geometry, material);
		const currentMinFilter = texture$2.minFilter;
		if (texture$2.minFilter === LinearMipmapLinearFilter) texture$2.minFilter = LinearFilter;
		new CubeCamera(1, 10, this).update(renderer, mesh);
		texture$2.minFilter = currentMinFilter;
		mesh.geometry.dispose();
		mesh.material.dispose();
		return this;
	}
	/**
	* Clears this cube render target.
	*
	* @param {WebGLRenderer} renderer - The renderer.
	* @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
	* @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
	* @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
	*/
	clear(renderer, color$2 = true, depth$2 = true, stencil = true) {
		const currentRenderTarget = renderer.getRenderTarget();
		for (let i = 0; i < 6; i++) {
			renderer.setRenderTarget(this, i);
			renderer.clear(color$2, depth$2, stencil);
		}
		renderer.setRenderTarget(currentRenderTarget);
	}
};
/**
* This is almost identical to an {@link Object3D}. Its purpose is to
* make working with groups of objects syntactically clearer.
*
* ```js
* // Create a group and add the two cubes.
* // These cubes can now be rotated / scaled etc as a group.
* const group = new THREE.Group();
*
* group.add( meshA );
* group.add( meshB );
*
* scene.add( group );
* ```
*
* @augments Object3D
*/
var Group = class extends Object3D {
	constructor() {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isGroup = true;
		this.type = "Group";
	}
};
var _moveEvent = { type: "move" };
/**
* Class for representing a XR controller with its
* different coordinate systems.
*
* @private
*/
var WebXRController = class {
	/**
	* Constructs a new XR controller.
	*/
	constructor() {
		/**
		* A group representing the target ray space
		* of the XR controller.
		*
		* @private
		* @type {?Group}
		* @default null
		*/
		this._targetRay = null;
		/**
		* A group representing the grip space
		* of the XR controller.
		*
		* @private
		* @type {?Group}
		* @default null
		*/
		this._grip = null;
		/**
		* A group representing the hand space
		* of the XR controller.
		*
		* @private
		* @type {?Group}
		* @default null
		*/
		this._hand = null;
	}
	/**
	* Returns a group representing the hand space of the XR controller.
	*
	* @return {Group} A group representing the hand space of the XR controller.
	*/
	getHandSpace() {
		if (this._hand === null) {
			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;
			this._hand.joints = {};
			this._hand.inputState = { pinching: false };
		}
		return this._hand;
	}
	/**
	* Returns a group representing the target ray space of the XR controller.
	*
	* @return {Group} A group representing the target ray space of the XR controller.
	*/
	getTargetRaySpace() {
		if (this._targetRay === null) {
			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();
		}
		return this._targetRay;
	}
	/**
	* Returns a group representing the grip space of the XR controller.
	*
	* @return {Group} A group representing the grip space of the XR controller.
	*/
	getGripSpace() {
		if (this._grip === null) {
			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();
		}
		return this._grip;
	}
	/**
	* Dispatches the given event to the groups representing
	* the different coordinate spaces of the XR controller.
	*
	* @param {Object} event - The event to dispatch.
	* @return {WebXRController} A reference to this instance.
	*/
	dispatchEvent(event) {
		if (this._targetRay !== null) this._targetRay.dispatchEvent(event);
		if (this._grip !== null) this._grip.dispatchEvent(event);
		if (this._hand !== null) this._hand.dispatchEvent(event);
		return this;
	}
	/**
	* Connects the controller with the given XR input source.
	*
	* @param {XRInputSource} inputSource - The input source.
	* @return {WebXRController} A reference to this instance.
	*/
	connect(inputSource) {
		if (inputSource && inputSource.hand) {
			const hand = this._hand;
			if (hand) for (const inputjoint of inputSource.hand.values()) this._getHandJoint(hand, inputjoint);
		}
		this.dispatchEvent({
			type: "connected",
			data: inputSource
		});
		return this;
	}
	/**
	* Disconnects the controller from the given XR input source.
	*
	* @param {XRInputSource} inputSource - The input source.
	* @return {WebXRController} A reference to this instance.
	*/
	disconnect(inputSource) {
		this.dispatchEvent({
			type: "disconnected",
			data: inputSource
		});
		if (this._targetRay !== null) this._targetRay.visible = false;
		if (this._grip !== null) this._grip.visible = false;
		if (this._hand !== null) this._hand.visible = false;
		return this;
	}
	/**
	* Updates the controller with the given input source, XR frame and reference space.
	* This updates the transformations of the groups that represent the different
	* coordinate systems of the controller.
	*
	* @param {XRInputSource} inputSource - The input source.
	* @param {XRFrame} frame - The XR frame.
	* @param {XRReferenceSpace} referenceSpace - The reference space.
	* @return {WebXRController} A reference to this instance.
	*/
	update(inputSource, frame, referenceSpace) {
		let inputPose = null;
		let gripPose = null;
		let handPose = null;
		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;
		if (inputSource && frame.session.visibilityState !== "visible-blurred") {
			if (hand && inputSource.hand) {
				handPose = true;
				for (const inputjoint of inputSource.hand.values()) {
					const jointPose = frame.getJointPose(inputjoint, referenceSpace);
					const joint = this._getHandJoint(hand, inputjoint);
					if (jointPose !== null) {
						joint.matrix.fromArray(jointPose.transform.matrix);
						joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
						joint.matrixWorldNeedsUpdate = true;
						joint.jointRadius = jointPose.radius;
					}
					joint.visible = jointPose !== null;
				}
				const indexTip = hand.joints["index-finger-tip"];
				const thumbTip = hand.joints["thumb-tip"];
				const distance$3 = indexTip.position.distanceTo(thumbTip.position);
				const distanceToPinch = .02;
				const threshold = .005;
				if (hand.inputState.pinching && distance$3 > distanceToPinch + threshold) {
					hand.inputState.pinching = false;
					this.dispatchEvent({
						type: "pinchend",
						handedness: inputSource.handedness,
						target: this
					});
				} else if (!hand.inputState.pinching && distance$3 <= distanceToPinch - threshold) {
					hand.inputState.pinching = true;
					this.dispatchEvent({
						type: "pinchstart",
						handedness: inputSource.handedness,
						target: this
					});
				}
			} else if (grip !== null && inputSource.gripSpace) {
				gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
				if (gripPose !== null) {
					grip.matrix.fromArray(gripPose.transform.matrix);
					grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
					grip.matrixWorldNeedsUpdate = true;
					if (gripPose.linearVelocity) {
						grip.hasLinearVelocity = true;
						grip.linearVelocity.copy(gripPose.linearVelocity);
					} else grip.hasLinearVelocity = false;
					if (gripPose.angularVelocity) {
						grip.hasAngularVelocity = true;
						grip.angularVelocity.copy(gripPose.angularVelocity);
					} else grip.hasAngularVelocity = false;
				}
			}
			if (targetRay !== null) {
				inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
				if (inputPose === null && gripPose !== null) inputPose = gripPose;
				if (inputPose !== null) {
					targetRay.matrix.fromArray(inputPose.transform.matrix);
					targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
					targetRay.matrixWorldNeedsUpdate = true;
					if (inputPose.linearVelocity) {
						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy(inputPose.linearVelocity);
					} else targetRay.hasLinearVelocity = false;
					if (inputPose.angularVelocity) {
						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy(inputPose.angularVelocity);
					} else targetRay.hasAngularVelocity = false;
					this.dispatchEvent(_moveEvent);
				}
			}
		}
		if (targetRay !== null) targetRay.visible = inputPose !== null;
		if (grip !== null) grip.visible = gripPose !== null;
		if (hand !== null) hand.visible = handPose !== null;
		return this;
	}
	/**
	* Returns a group representing the hand joint for the given input joint.
	*
	* @private
	* @param {Group} hand - The group representing the hand space.
	* @param {XRJointSpace} inputjoint - The hand joint data.
	* @return {Group} A group representing the hand joint for the given input joint.
	*/
	_getHandJoint(hand, inputjoint) {
		if (hand.joints[inputjoint.jointName] === void 0) {
			const joint = new Group();
			joint.matrixAutoUpdate = false;
			joint.visible = false;
			hand.joints[inputjoint.jointName] = joint;
			hand.add(joint);
		}
		return hand.joints[inputjoint.jointName];
	}
};
/**
* Scenes allow you to set up what is to be rendered and where by three.js.
* This is where you place 3D objects like meshes, lines or lights.
*
* @augments Object3D
*/
var Scene = class extends Object3D {
	/**
	* Constructs a new scene.
	*/
	constructor() {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isScene = true;
		this.type = "Scene";
		/**
		* Defines the background of the scene. Valid inputs are:
		*
		* - A color for defining a uniform colored background.
		* - A texture for defining a (flat) textured background.
		* - Cube textures or equirectangular textures for defining a skybox.
		*
		* @type {?(Color|Texture)}
		* @default null
		*/
		this.background = null;
		/**
		* Sets the environment map for all physical materials in the scene. However,
		* it's not possible to overwrite an existing texture assigned to the `envMap`
		* material property.
		*
		* @type {?Texture}
		* @default null
		*/
		this.environment = null;
		/**
		* A fog instance defining the type of fog that affects everything
		* rendered in the scene.
		*
		* @type {?(Fog|FogExp2)}
		* @default null
		*/
		this.fog = null;
		/**
		* Sets the blurriness of the background. Only influences environment maps
		* assigned to {@link Scene#background}. Valid input is a float between `0`
		* and `1`.
		*
		* @type {number}
		* @default 0
		*/
		this.backgroundBlurriness = 0;
		/**
		* Attenuates the color of the background. Only applies to background textures.
		*
		* @type {number}
		* @default 1
		*/
		this.backgroundIntensity = 1;
		/**
		* The rotation of the background in radians. Only influences environment maps
		* assigned to {@link Scene#background}.
		*
		* @type {Euler}
		* @default (0,0,0)
		*/
		this.backgroundRotation = new Euler();
		/**
		* Attenuates the color of the environment. Only influences environment maps
		* assigned to {@link Scene#environment}.
		*
		* @type {number}
		* @default 1
		*/
		this.environmentIntensity = 1;
		/**
		* The rotation of the environment map in radians. Only influences physical materials
		* in the scene when {@link Scene#environment} is used.
		*
		* @type {Euler}
		* @default (0,0,0)
		*/
		this.environmentRotation = new Euler();
		/**
		* Forces everything in the scene to be rendered with the defined material. It is possible
		* to exclude materials from override by setting {@link Material#allowOverride} to `false`.
		*
		* @type {?Material}
		* @default null
		*/
		this.overrideMaterial = null;
		if (typeof __THREE_DEVTOOLS__ !== "undefined") __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		if (source.background !== null) this.background = source.background.clone();
		if (source.environment !== null) this.environment = source.environment.clone();
		if (source.fog !== null) this.fog = source.fog.clone();
		this.backgroundBlurriness = source.backgroundBlurriness;
		this.backgroundIntensity = source.backgroundIntensity;
		this.backgroundRotation.copy(source.backgroundRotation);
		this.environmentIntensity = source.environmentIntensity;
		this.environmentRotation.copy(source.environmentRotation);
		if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		if (this.fog !== null) data.object.fog = this.fog.toJSON();
		if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
		if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
		data.object.backgroundRotation = this.backgroundRotation.toArray();
		if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
		data.object.environmentRotation = this.environmentRotation.toArray();
		return data;
	}
};
/**
* "Interleaved" means that multiple attributes, possibly of different types,
* (e.g., position, normal, uv, color) are packed into a single array buffer.
*
* An introduction into interleaved arrays can be found here: [Interleaved array basics](https://blog.tojicode.com/2011/05/interleaved-array-basics.html)
*/
var InterleavedBuffer = class {
	/**
	* Constructs a new interleaved buffer.
	*
	* @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
	* @param {number} stride - The number of typed-array elements per vertex.
	*/
	constructor(array$2, stride) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isInterleavedBuffer = true;
		/**
		* A typed array with a shared buffer storing attribute data.
		*
		* @type {TypedArray}
		*/
		this.array = array$2;
		/**
		* The number of typed-array elements per vertex.
		*
		* @type {number}
		*/
		this.stride = stride;
		/**
		* The total number of elements in the array
		*
		* @type {number}
		* @readonly
		*/
		this.count = array$2 !== void 0 ? array$2.length / stride : 0;
		/**
		* Defines the intended usage pattern of the data store for optimization purposes.
		*
		* Note: After the initial use of a buffer, its usage cannot be changed. Instead,
		* instantiate a new one and set the desired usage before the next render.
		*
		* @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
		* @default StaticDrawUsage
		*/
		this.usage = StaticDrawUsage;
		/**
		* This can be used to only update some components of stored vectors (for example, just the
		* component related to color). Use the `addUpdateRange()` function to add ranges to this array.
		*
		* @type {Array<Object>}
		*/
		this.updateRanges = [];
		/**
		* A version number, incremented every time the `needsUpdate` is set to `true`.
		*
		* @type {number}
		*/
		this.version = 0;
		/**
		* The UUID of the interleaved buffer.
		*
		* @type {string}
		* @readonly
		*/
		this.uuid = generateUUID();
	}
	/**
	* A callback function that is executed after the renderer has transferred the attribute array
	* data to the GPU.
	*/
	onUploadCallback() {}
	/**
	* Flag to indicate that this attribute has changed and should be re-sent to
	* the GPU. Set this to `true` when you modify the value of the array.
	*
	* @type {number}
	* @default false
	* @param {boolean} value
	*/
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
	/**
	* Sets the usage of this interleaved buffer.
	*
	* @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
	* @return {InterleavedBuffer} A reference to this interleaved buffer.
	*/
	setUsage(value) {
		this.usage = value;
		return this;
	}
	/**
	* Adds a range of data in the data array to be updated on the GPU.
	*
	* @param {number} start - Position at which to start update.
	* @param {number} count - The number of components to update.
	*/
	addUpdateRange(start, count) {
		this.updateRanges.push({
			start,
			count
		});
	}
	/**
	* Clears the update ranges.
	*/
	clearUpdateRanges() {
		this.updateRanges.length = 0;
	}
	/**
	* Copies the values of the given interleaved buffer to this instance.
	*
	* @param {InterleavedBuffer} source - The interleaved buffer to copy.
	* @return {InterleavedBuffer} A reference to this instance.
	*/
	copy(source) {
		this.array = new source.array.constructor(source.array);
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;
		return this;
	}
	/**
	* Copies a vector from the given interleaved buffer to this one. The start
	* and destination position in the attribute buffers are represented by the
	* given indices.
	*
	* @param {number} index1 - The destination index into this interleaved buffer.
	* @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
	* @param {number} index2 - The source index into the given interleaved buffer.
	* @return {InterleavedBuffer} A reference to this instance.
	*/
	copyAt(index1, interleavedBuffer, index2) {
		index1 *= this.stride;
		index2 *= interleavedBuffer.stride;
		for (let i = 0, l = this.stride; i < l; i++) this.array[index1 + i] = interleavedBuffer.array[index2 + i];
		return this;
	}
	/**
	* Sets the given array data in the interleaved buffer.
	*
	* @param {(TypedArray|Array)} value - The array data to set.
	* @param {number} [offset=0] - The offset in this interleaved buffer's array.
	* @return {InterleavedBuffer} A reference to this instance.
	*/
	set(value, offset = 0) {
		this.array.set(value, offset);
		return this;
	}
	/**
	* Returns a new interleaved buffer with copied values from this instance.
	*
	* @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
	* @return {InterleavedBuffer} A clone of this instance.
	*/
	clone(data) {
		if (data.arrayBuffers === void 0) data.arrayBuffers = {};
		if (this.array.buffer._uuid === void 0) this.array.buffer._uuid = generateUUID();
		if (data.arrayBuffers[this.array.buffer._uuid] === void 0) data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
		const array$2 = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
		const ib = new this.constructor(array$2, this.stride);
		ib.setUsage(this.usage);
		return ib;
	}
	/**
	* Sets the given callback function that is executed after the Renderer has transferred
	* the array data to the GPU. Can be used to perform clean-up operations after
	* the upload when data are not needed anymore on the CPU side.
	*
	* @param {Function} callback - The `onUpload()` callback.
	* @return {InterleavedBuffer} A reference to this instance.
	*/
	onUpload(callback) {
		this.onUploadCallback = callback;
		return this;
	}
	/**
	* Serializes the interleaved buffer into JSON.
	*
	* @param {Object} [data] - An optional value holding meta information about the serialization.
	* @return {Object} A JSON object representing the serialized interleaved buffer.
	*/
	toJSON(data) {
		if (data.arrayBuffers === void 0) data.arrayBuffers = {};
		if (this.array.buffer._uuid === void 0) this.array.buffer._uuid = generateUUID();
		if (data.arrayBuffers[this.array.buffer._uuid] === void 0) data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};
	}
};
var _vector$7 = /* @__PURE__ */ new Vector3();
/**
* An alternative version of a buffer attribute with interleaved data. Interleaved
* attributes share a common interleaved data storage ({@link InterleavedBuffer}) and refer with
* different offsets into the buffer.
*/
var InterleavedBufferAttribute = class InterleavedBufferAttribute {
	/**
	* Constructs a new interleaved buffer attribute.
	*
	* @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
	* @param {number} itemSize - The item size.
	* @param {number} offset - The attribute offset into the buffer.
	* @param {boolean} [normalized=false] - Whether the data are normalized or not.
	*/
	constructor(interleavedBuffer, itemSize, offset, normalized = false) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isInterleavedBufferAttribute = true;
		/**
		* The name of the buffer attribute.
		*
		* @type {string}
		*/
		this.name = "";
		/**
		* The buffer holding the interleaved data.
		*
		* @type {InterleavedBuffer}
		*/
		this.data = interleavedBuffer;
		/**
		* The item size, see {@link BufferAttribute#itemSize}.
		*
		* @type {number}
		*/
		this.itemSize = itemSize;
		/**
		* The attribute offset into the buffer.
		*
		* @type {number}
		*/
		this.offset = offset;
		/**
		* Whether the data are normalized or not, see {@link BufferAttribute#normalized}
		*
		* @type {InterleavedBuffer}
		*/
		this.normalized = normalized;
	}
	/**
	* The item count of this buffer attribute.
	*
	* @type {number}
	* @readonly
	*/
	get count() {
		return this.data.count;
	}
	/**
	* The array holding the interleaved buffer attribute data.
	*
	* @type {TypedArray}
	*/
	get array() {
		return this.data.array;
	}
	/**
	* Flag to indicate that this attribute has changed and should be re-sent to
	* the GPU. Set this to `true` when you modify the value of the array.
	*
	* @type {number}
	* @default false
	* @param {boolean} value
	*/
	set needsUpdate(value) {
		this.data.needsUpdate = value;
	}
	/**
	* Applies the given 4x4 matrix to the given attribute. Only works with
	* item size `3`.
	*
	* @param {Matrix4} m - The matrix to apply.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	applyMatrix4(m$1) {
		for (let i = 0, l = this.data.count; i < l; i++) {
			_vector$7.fromBufferAttribute(this, i);
			_vector$7.applyMatrix4(m$1);
			this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
		}
		return this;
	}
	/**
	* Applies the given 3x3 normal matrix to the given attribute. Only works with
	* item size `3`.
	*
	* @param {Matrix3} m - The normal matrix to apply.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	applyNormalMatrix(m$1) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$7.fromBufferAttribute(this, i);
			_vector$7.applyNormalMatrix(m$1);
			this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
		}
		return this;
	}
	/**
	* Applies the given 4x4 matrix to the given attribute. Only works with
	* item size `3` and with direction vectors.
	*
	* @param {Matrix4} m - The matrix to apply.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	transformDirection(m$1) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$7.fromBufferAttribute(this, i);
			_vector$7.transformDirection(m$1);
			this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
		}
		return this;
	}
	/**
	* Returns the given component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} component - The component index.
	* @return {number} The returned value.
	*/
	getComponent(index, component) {
		let value = this.array[index * this.data.stride + this.offset + component];
		if (this.normalized) value = denormalize(value, this.array);
		return value;
	}
	/**
	* Sets the given value to the given component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} component - The component index.
	* @param {number} value - The value to set.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	setComponent(index, component, value) {
		if (this.normalized) value = normalize$2(value, this.array);
		this.data.array[index * this.data.stride + this.offset + component] = value;
		return this;
	}
	/**
	* Sets the x component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} x - The value to set.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	setX(index, x) {
		if (this.normalized) x = normalize$2(x, this.array);
		this.data.array[index * this.data.stride + this.offset] = x;
		return this;
	}
	/**
	* Sets the y component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} y - The value to set.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	setY(index, y) {
		if (this.normalized) y = normalize$2(y, this.array);
		this.data.array[index * this.data.stride + this.offset + 1] = y;
		return this;
	}
	/**
	* Sets the z component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} z - The value to set.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	setZ(index, z) {
		if (this.normalized) z = normalize$2(z, this.array);
		this.data.array[index * this.data.stride + this.offset + 2] = z;
		return this;
	}
	/**
	* Sets the w component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} w - The value to set.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	setW(index, w) {
		if (this.normalized) w = normalize$2(w, this.array);
		this.data.array[index * this.data.stride + this.offset + 3] = w;
		return this;
	}
	/**
	* Returns the x component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @return {number} The x component.
	*/
	getX(index) {
		let x = this.data.array[index * this.data.stride + this.offset];
		if (this.normalized) x = denormalize(x, this.array);
		return x;
	}
	/**
	* Returns the y component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @return {number} The y component.
	*/
	getY(index) {
		let y = this.data.array[index * this.data.stride + this.offset + 1];
		if (this.normalized) y = denormalize(y, this.array);
		return y;
	}
	/**
	* Returns the z component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @return {number} The z component.
	*/
	getZ(index) {
		let z = this.data.array[index * this.data.stride + this.offset + 2];
		if (this.normalized) z = denormalize(z, this.array);
		return z;
	}
	/**
	* Returns the w component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @return {number} The w component.
	*/
	getW(index) {
		let w = this.data.array[index * this.data.stride + this.offset + 3];
		if (this.normalized) w = denormalize(w, this.array);
		return w;
	}
	/**
	* Sets the x and y component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} x - The value for the x component to set.
	* @param {number} y - The value for the y component to set.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	setXY(index, x, y) {
		index = index * this.data.stride + this.offset;
		if (this.normalized) {
			x = normalize$2(x, this.array);
			y = normalize$2(y, this.array);
		}
		this.data.array[index + 0] = x;
		this.data.array[index + 1] = y;
		return this;
	}
	/**
	* Sets the x, y and z component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} x - The value for the x component to set.
	* @param {number} y - The value for the y component to set.
	* @param {number} z - The value for the z component to set.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	setXYZ(index, x, y, z) {
		index = index * this.data.stride + this.offset;
		if (this.normalized) {
			x = normalize$2(x, this.array);
			y = normalize$2(y, this.array);
			z = normalize$2(z, this.array);
		}
		this.data.array[index + 0] = x;
		this.data.array[index + 1] = y;
		this.data.array[index + 2] = z;
		return this;
	}
	/**
	* Sets the x, y, z and w component of the vector at the given index.
	*
	* @param {number} index - The index into the buffer attribute.
	* @param {number} x - The value for the x component to set.
	* @param {number} y - The value for the y component to set.
	* @param {number} z - The value for the z component to set.
	* @param {number} w - The value for the w component to set.
	* @return {InterleavedBufferAttribute} A reference to this instance.
	*/
	setXYZW(index, x, y, z, w) {
		index = index * this.data.stride + this.offset;
		if (this.normalized) {
			x = normalize$2(x, this.array);
			y = normalize$2(y, this.array);
			z = normalize$2(z, this.array);
			w = normalize$2(w, this.array);
		}
		this.data.array[index + 0] = x;
		this.data.array[index + 1] = y;
		this.data.array[index + 2] = z;
		this.data.array[index + 3] = w;
		return this;
	}
	/**
	* Returns a new buffer attribute with copied values from this instance.
	*
	* If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
	*
	* @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
	* @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
	*/
	clone(data) {
		if (data === void 0) {
			log("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
			const array$2 = [];
			for (let i = 0; i < this.count; i++) {
				const index = i * this.data.stride + this.offset;
				for (let j = 0; j < this.itemSize; j++) array$2.push(this.data.array[index + j]);
			}
			return new BufferAttribute(new this.array.constructor(array$2), this.itemSize, this.normalized);
		} else {
			if (data.interleavedBuffers === void 0) data.interleavedBuffers = {};
			if (data.interleavedBuffers[this.data.uuid] === void 0) data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
			return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
		}
	}
	/**
	* Serializes the buffer attribute into JSON.
	*
	* If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
	*
	* @param {Object} [data] - An optional value holding meta information about the serialization.
	* @return {Object} A JSON object representing the serialized buffer attribute.
	*/
	toJSON(data) {
		if (data === void 0) {
			log("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
			const array$2 = [];
			for (let i = 0; i < this.count; i++) {
				const index = i * this.data.stride + this.offset;
				for (let j = 0; j < this.itemSize; j++) array$2.push(this.data.array[index + j]);
			}
			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array$2,
				normalized: this.normalized
			};
		} else {
			if (data.interleavedBuffers === void 0) data.interleavedBuffers = {};
			if (data.interleavedBuffers[this.data.uuid] === void 0) data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};
		}
	}
};
/**
* A material for rendering instances of {@link Sprite}.
*
* ```js
* const map = new THREE.TextureLoader().load( 'textures/sprite.png' );
* const material = new THREE.SpriteMaterial( { map: map, color: 0xffffff } );
*
* const sprite = new THREE.Sprite( material );
* sprite.scale.set(200, 200, 1)
* scene.add( sprite );
* ```
*
* @augments Material
*/
var SpriteMaterial = class extends Material {
	/**
	* Constructs a new sprite material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSpriteMaterial = true;
		this.type = "SpriteMaterial";
		/**
		* Color of the material.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.color = new Color$1(16777215);
		/**
		* The color map. May optionally include an alpha channel, typically combined
		* with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		* color is modulated by the diffuse `color`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* The alpha map is a grayscale texture that controls the opacity across the
		* surface (black: fully transparent; white: fully opaque).
		*
		* Only the color of the texture is used, ignoring the alpha channel if one
		* exists. For RGB and RGBA textures, the renderer will use the green channel
		* when sampling this texture due to the extra bit of precision provided for
		* green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		* luminance/alpha textures will also still work as expected.
		*
		* @type {?Texture}
		* @default null
		*/
		this.alphaMap = null;
		/**
		* The rotation of the sprite in radians.
		*
		* @type {number}
		* @default 0
		*/
		this.rotation = 0;
		/**
		* Specifies whether size of the sprite is attenuated by the camera depth (perspective camera only).
		*
		* @type {boolean}
		* @default true
		*/
		this.sizeAttenuation = true;
		/**
		* Overwritten since sprite materials are transparent
		* by default.
		*
		* @type {boolean}
		* @default true
		*/
		this.transparent = true;
		/**
		* Whether the material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.rotation = source.rotation;
		this.sizeAttenuation = source.sizeAttenuation;
		this.fog = source.fog;
		return this;
	}
};
/**
* Creates a texture directly from raw buffer data.
*
* The interpretation of the data depends on type and format: If the type is
* `UnsignedByteType`, a `Uint8Array` will be useful for addressing the
* texel data. If the format is `RGBAFormat`, data needs four values for
* one texel; Red, Green, Blue and Alpha (typically the opacity).
*
* @augments Texture
*/
var DataTexture = class extends Texture {
	/**
	* Constructs a new data texture.
	*
	* @param {?TypedArray} [data=null] - The buffer data.
	* @param {number} [width=1] - The width of the texture.
	* @param {number} [height=1] - The height of the texture.
	* @param {number} [format=RGBAFormat] - The texture format.
	* @param {number} [type=UnsignedByteType] - The texture type.
	* @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	* @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	* @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	* @param {number} [magFilter=NearestFilter] - The mag filter value.
	* @param {number} [minFilter=NearestFilter] - The min filter value.
	* @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	* @param {string} [colorSpace=NoColorSpace] - The color space.
	*/
	constructor(data = null, width = 1, height = 1, format, type$1, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy$2, colorSpace) {
		super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type$1, anisotropy$2, colorSpace);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isDataTexture = true;
		/**
		* The image definition of a data texture.
		*
		* @type {{data:TypedArray,width:number,height:number}}
		*/
		this.image = {
			data,
			width,
			height
		};
		/**
		* Whether to generate mipmaps (if possible) for a texture.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.generateMipmaps = false;
		/**
		* If set to `true`, the texture is flipped along the vertical axis when
		* uploaded to the GPU.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.flipY = false;
		/**
		* Specifies the alignment requirements for the start of each pixel row in memory.
		*
		* Overwritten and set to `1` by default.
		*
		* @type {boolean}
		* @default 1
		*/
		this.unpackAlignment = 1;
	}
};
/**
* An instanced version of a buffer attribute.
*
* @augments BufferAttribute
*/
var InstancedBufferAttribute = class extends BufferAttribute {
	/**
	* Constructs a new instanced buffer attribute.
	*
	* @param {TypedArray} array - The array holding the attribute data.
	* @param {number} itemSize - The item size.
	* @param {boolean} [normalized=false] - Whether the data are normalized or not.
	* @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
	*/
	constructor(array$2, itemSize, normalized, meshPerAttribute = 1) {
		super(array$2, itemSize, normalized);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isInstancedBufferAttribute = true;
		/**
		* Defines how often a value of this buffer attribute should be repeated. A
		* value of one means that each value of the instanced attribute is used for
		* a single instance. A value of two means that each value is used for two
		* consecutive instances (and so on).
		*
		* @type {number}
		* @default 1
		*/
		this.meshPerAttribute = meshPerAttribute;
	}
	copy(source) {
		super.copy(source);
		this.meshPerAttribute = source.meshPerAttribute;
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.meshPerAttribute = this.meshPerAttribute;
		data.isInstancedBufferAttribute = true;
		return data;
	}
};
var _vector1 = /* @__PURE__ */ new Vector3();
var _vector2$2 = /* @__PURE__ */ new Vector3();
var _normalMatrix = /* @__PURE__ */ new Matrix3();
/**
* A two dimensional surface that extends infinitely in 3D space, represented
* in [Hessian normal form](http://mathworld.wolfram.com/HessianNormalForm.html)
* by a unit length normal vector and a constant.
*/
var Plane = class {
	/**
	* Constructs a new plane.
	*
	* @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
	* @param {number} [constant=0] - The signed distance from the origin to the plane.
	*/
	constructor(normal$1 = new Vector3(1, 0, 0), constant = 0) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isPlane = true;
		/**
		* A unit length vector defining the normal of the plane.
		*
		* @type {Vector3}
		*/
		this.normal = normal$1;
		/**
		* The signed distance from the origin to the plane.
		*
		* @type {number}
		* @default 0
		*/
		this.constant = constant;
	}
	/**
	* Sets the plane components by copying the given values.
	*
	* @param {Vector3} normal - The normal.
	* @param {number} constant - The constant.
	* @return {Plane} A reference to this plane.
	*/
	set(normal$1, constant) {
		this.normal.copy(normal$1);
		this.constant = constant;
		return this;
	}
	/**
	* Sets the plane components by defining `x`, `y`, `z` as the
	* plane normal and `w` as the constant.
	*
	* @param {number} x - The value for the normal's x component.
	* @param {number} y - The value for the normal's y component.
	* @param {number} z - The value for the normal's z component.
	* @param {number} w - The constant value.
	* @return {Plane} A reference to this plane.
	*/
	setComponents(x, y, z, w) {
		this.normal.set(x, y, z);
		this.constant = w;
		return this;
	}
	/**
	* Sets the plane from the given normal and coplanar point (that is a point
	* that lies onto the plane).
	*
	* @param {Vector3} normal - The normal.
	* @param {Vector3} point - A coplanar point.
	* @return {Plane} A reference to this plane.
	*/
	setFromNormalAndCoplanarPoint(normal$1, point) {
		this.normal.copy(normal$1);
		this.constant = -point.dot(this.normal);
		return this;
	}
	/**
	* Sets the plane from three coplanar points. The winding order is
	* assumed to be counter-clockwise, and determines the direction of
	* the plane normal.
	*
	* @param {Vector3} a - The first coplanar point.
	* @param {Vector3} b - The second coplanar point.
	* @param {Vector3} c - The third coplanar point.
	* @return {Plane} A reference to this plane.
	*/
	setFromCoplanarPoints(a$1, b$2, c$1) {
		const normal$1 = _vector1.subVectors(c$1, b$2).cross(_vector2$2.subVectors(a$1, b$2)).normalize();
		this.setFromNormalAndCoplanarPoint(normal$1, a$1);
		return this;
	}
	/**
	* Copies the values of the given plane to this instance.
	*
	* @param {Plane} plane - The plane to copy.
	* @return {Plane} A reference to this plane.
	*/
	copy(plane) {
		this.normal.copy(plane.normal);
		this.constant = plane.constant;
		return this;
	}
	/**
	* Normalizes the plane normal and adjusts the constant accordingly.
	*
	* @return {Plane} A reference to this plane.
	*/
	normalize() {
		const inverseNormalLength = 1 / this.normal.length();
		this.normal.multiplyScalar(inverseNormalLength);
		this.constant *= inverseNormalLength;
		return this;
	}
	/**
	* Negates both the plane normal and the constant.
	*
	* @return {Plane} A reference to this plane.
	*/
	negate() {
		this.constant *= -1;
		this.normal.negate();
		return this;
	}
	/**
	* Returns the signed distance from the given point to this plane.
	*
	* @param {Vector3} point - The point to compute the distance for.
	* @return {number} The signed distance.
	*/
	distanceToPoint(point) {
		return this.normal.dot(point) + this.constant;
	}
	/**
	* Returns the signed distance from the given sphere to this plane.
	*
	* @param {Sphere} sphere - The sphere to compute the distance for.
	* @return {number} The signed distance.
	*/
	distanceToSphere(sphere) {
		return this.distanceToPoint(sphere.center) - sphere.radius;
	}
	/**
	* Projects a the given point onto the plane.
	*
	* @param {Vector3} point - The point to project.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The projected point on the plane.
	*/
	projectPoint(point, target) {
		return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
	}
	/**
	* Returns the intersection point of the passed line and the plane. Returns
	* `null` if the line does not intersect. Returns the line's starting point if
	* the line is coplanar with the plane.
	*
	* @param {Line3} line - The line to compute the intersection for.
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {?Vector3} The intersection point.
	*/
	intersectLine(line, target) {
		const direction = line.delta(_vector1);
		const denominator = this.normal.dot(direction);
		if (denominator === 0) {
			if (this.distanceToPoint(line.start) === 0) return target.copy(line.start);
			return null;
		}
		const t = -(line.start.dot(this.normal) + this.constant) / denominator;
		if (t < 0 || t > 1) return null;
		return target.copy(line.start).addScaledVector(direction, t);
	}
	/**
	* Returns `true` if the given line segment intersects with (passes through) the plane.
	*
	* @param {Line3} line - The line to test.
	* @return {boolean} Whether the given line segment intersects with the plane or not.
	*/
	intersectsLine(line) {
		const startSign = this.distanceToPoint(line.start);
		const endSign = this.distanceToPoint(line.end);
		return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
	}
	/**
	* Returns `true` if the given bounding box intersects with the plane.
	*
	* @param {Box3} box - The bounding box to test.
	* @return {boolean} Whether the given bounding box intersects with the plane or not.
	*/
	intersectsBox(box) {
		return box.intersectsPlane(this);
	}
	/**
	* Returns `true` if the given bounding sphere intersects with the plane.
	*
	* @param {Sphere} sphere - The bounding sphere to test.
	* @return {boolean} Whether the given bounding sphere intersects with the plane or not.
	*/
	intersectsSphere(sphere) {
		return sphere.intersectsPlane(this);
	}
	/**
	* Returns a coplanar vector to the plane, by calculating the
	* projection of the normal at the origin onto the plane.
	*
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The coplanar point.
	*/
	coplanarPoint(target) {
		return target.copy(this.normal).multiplyScalar(-this.constant);
	}
	/**
	* Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
	*
	* The optional normal matrix can be pre-computed like so:
	* ```js
	* const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	* ```
	*
	* @param {Matrix4} matrix - The transformation matrix.
	* @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
	* @return {Plane} A reference to this plane.
	*/
	applyMatrix4(matrix, optionalNormalMatrix) {
		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
		const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
		const normal$1 = this.normal.applyMatrix3(normalMatrix).normalize();
		this.constant = -referencePoint.dot(normal$1);
		return this;
	}
	/**
	* Translates the plane by the distance defined by the given offset vector.
	* Note that this only affects the plane constant and will not affect the normal vector.
	*
	* @param {Vector3} offset - The offset vector.
	* @return {Plane} A reference to this plane.
	*/
	translate(offset) {
		this.constant -= offset.dot(this.normal);
		return this;
	}
	/**
	* Returns `true` if this plane is equal with the given one.
	*
	* @param {Plane} plane - The plane to test for equality.
	* @return {boolean} Whether this plane is equal with the given one.
	*/
	equals(plane) {
		return plane.normal.equals(this.normal) && plane.constant === this.constant;
	}
	/**
	* Returns a new plane with copied values from this instance.
	*
	* @return {Plane} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
};
var _sphere$3 = /* @__PURE__ */ new Sphere();
var _defaultSpriteCenter = /* @__PURE__ */ new Vector2(.5, .5);
var _vector$6 = /* @__PURE__ */ new Vector3();
/**
* Frustums are used to determine what is inside the camera's field of view.
* They help speed up the rendering process - objects which lie outside a camera's
* frustum can safely be excluded from rendering.
*
* This class is mainly intended for use internally by a renderer.
*/
var Frustum = class {
	/**
	* Constructs a new frustum.
	*
	* @param {Plane} [p0] - The first plane that encloses the frustum.
	* @param {Plane} [p1] - The second plane that encloses the frustum.
	* @param {Plane} [p2] - The third plane that encloses the frustum.
	* @param {Plane} [p3] - The fourth plane that encloses the frustum.
	* @param {Plane} [p4] - The fifth plane that encloses the frustum.
	* @param {Plane} [p5] - The sixth plane that encloses the frustum.
	*/
	constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
		/**
		* This array holds the planes that enclose the frustum.
		*
		* @type {Array<Plane>}
		*/
		this.planes = [
			p0,
			p1,
			p2,
			p3,
			p4,
			p5
		];
	}
	/**
	* Sets the frustum planes by copying the given planes.
	*
	* @param {Plane} [p0] - The first plane that encloses the frustum.
	* @param {Plane} [p1] - The second plane that encloses the frustum.
	* @param {Plane} [p2] - The third plane that encloses the frustum.
	* @param {Plane} [p3] - The fourth plane that encloses the frustum.
	* @param {Plane} [p4] - The fifth plane that encloses the frustum.
	* @param {Plane} [p5] - The sixth plane that encloses the frustum.
	* @return {Frustum} A reference to this frustum.
	*/
	set(p0, p1, p2, p3, p4, p5) {
		const planes = this.planes;
		planes[0].copy(p0);
		planes[1].copy(p1);
		planes[2].copy(p2);
		planes[3].copy(p3);
		planes[4].copy(p4);
		planes[5].copy(p5);
		return this;
	}
	/**
	* Copies the values of the given frustum to this instance.
	*
	* @param {Frustum} frustum - The frustum to copy.
	* @return {Frustum} A reference to this frustum.
	*/
	copy(frustum) {
		const planes = this.planes;
		for (let i = 0; i < 6; i++) planes[i].copy(frustum.planes[i]);
		return this;
	}
	/**
	* Sets the frustum planes from the given projection matrix.
	*
	* @param {Matrix4} m - The projection matrix.
	* @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
	* @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
	* @return {Frustum} A reference to this frustum.
	*/
	setFromProjectionMatrix(m$1, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
		const planes = this.planes;
		const me = m$1.elements;
		const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
		const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
		const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
		const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
		planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
		planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
		planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
		planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
		if (reversedDepth) {
			planes[4].setComponents(me2, me6, me10, me14).normalize();
			planes[5].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
		} else {
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
			if (coordinateSystem === WebGLCoordinateSystem) planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
			else if (coordinateSystem === WebGPUCoordinateSystem) planes[5].setComponents(me2, me6, me10, me14).normalize();
			else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
		}
		return this;
	}
	/**
	* Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
	*
	* Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
	*
	* @param {Object3D} object - The 3D object to test.
	* @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
	*/
	intersectsObject(object) {
		if (object.boundingSphere !== void 0) {
			if (object.boundingSphere === null) object.computeBoundingSphere();
			_sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
		} else {
			const geometry = object.geometry;
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
			_sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
		}
		return this.intersectsSphere(_sphere$3);
	}
	/**
	* Returns `true` if the given sprite is intersecting this frustum.
	*
	* @param {Sprite} sprite - The sprite to test.
	* @return {boolean} Whether the sprite is intersecting this frustum or not.
	*/
	intersectsSprite(sprite) {
		_sphere$3.center.set(0, 0, 0);
		_sphere$3.radius = .7071067811865476 + _defaultSpriteCenter.distanceTo(sprite.center);
		_sphere$3.applyMatrix4(sprite.matrixWorld);
		return this.intersectsSphere(_sphere$3);
	}
	/**
	* Returns `true` if the given bounding sphere is intersecting this frustum.
	*
	* @param {Sphere} sphere - The bounding sphere to test.
	* @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
	*/
	intersectsSphere(sphere) {
		const planes = this.planes;
		const center = sphere.center;
		const negRadius = -sphere.radius;
		for (let i = 0; i < 6; i++) if (planes[i].distanceToPoint(center) < negRadius) return false;
		return true;
	}
	/**
	* Returns `true` if the given bounding box is intersecting this frustum.
	*
	* @param {Box3} box - The bounding box to test.
	* @return {boolean} Whether the bounding box is intersecting this frustum or not.
	*/
	intersectsBox(box) {
		const planes = this.planes;
		for (let i = 0; i < 6; i++) {
			const plane = planes[i];
			_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
			if (plane.distanceToPoint(_vector$6) < 0) return false;
		}
		return true;
	}
	/**
	* Returns `true` if the given point lies within the frustum.
	*
	* @param {Vector3} point - The point to test.
	* @return {boolean} Whether the point lies within this frustum or not.
	*/
	containsPoint(point) {
		const planes = this.planes;
		for (let i = 0; i < 6; i++) if (planes[i].distanceToPoint(point) < 0) return false;
		return true;
	}
	/**
	* Returns a new frustum with copied values from this instance.
	*
	* @return {Frustum} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
};
var _projScreenMatrix$2 = /* @__PURE__ */ new Matrix4();
var _frustum$1 = /* @__PURE__ */ new Frustum();
/**
* FrustumArray is used to determine if an object is visible in at least one camera
* from an array of cameras. This is particularly useful for multi-view renderers.
*/
var FrustumArray = class FrustumArray {
	/**
	* Constructs a new frustum array.
	*
	*/
	constructor() {
		/**
		* The coordinate system to use.
		*
		* @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
		* @default WebGLCoordinateSystem
		*/
		this.coordinateSystem = WebGLCoordinateSystem;
	}
	/**
	* Returns `true` if the 3D object's bounding sphere is intersecting any frustum
	* from the camera array.
	*
	* @param {Object3D} object - The 3D object to test.
	* @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
	* @return {boolean} Whether the 3D object is visible in any camera.
	*/
	intersectsObject(object, cameraArray) {
		if (!cameraArray.isArrayCamera || cameraArray.cameras.length === 0) return false;
		for (let i = 0; i < cameraArray.cameras.length; i++) {
			const camera = cameraArray.cameras[i];
			_projScreenMatrix$2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			_frustum$1.setFromProjectionMatrix(_projScreenMatrix$2, camera.coordinateSystem, camera.reversedDepth);
			if (_frustum$1.intersectsObject(object)) return true;
		}
		return false;
	}
	/**
	* Returns `true` if the given sprite is intersecting any frustum
	* from the camera array.
	*
	* @param {Sprite} sprite - The sprite to test.
	* @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
	* @return {boolean} Whether the sprite is visible in any camera.
	*/
	intersectsSprite(sprite, cameraArray) {
		if (!cameraArray || !cameraArray.cameras || cameraArray.cameras.length === 0) return false;
		for (let i = 0; i < cameraArray.cameras.length; i++) {
			const camera = cameraArray.cameras[i];
			_projScreenMatrix$2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			_frustum$1.setFromProjectionMatrix(_projScreenMatrix$2, camera.coordinateSystem, camera.reversedDepth);
			if (_frustum$1.intersectsSprite(sprite)) return true;
		}
		return false;
	}
	/**
	* Returns `true` if the given bounding sphere is intersecting any frustum
	* from the camera array.
	*
	* @param {Sphere} sphere - The bounding sphere to test.
	* @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
	* @return {boolean} Whether the sphere is visible in any camera.
	*/
	intersectsSphere(sphere, cameraArray) {
		if (!cameraArray || !cameraArray.cameras || cameraArray.cameras.length === 0) return false;
		for (let i = 0; i < cameraArray.cameras.length; i++) {
			const camera = cameraArray.cameras[i];
			_projScreenMatrix$2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			_frustum$1.setFromProjectionMatrix(_projScreenMatrix$2, camera.coordinateSystem, camera.reversedDepth);
			if (_frustum$1.intersectsSphere(sphere)) return true;
		}
		return false;
	}
	/**
	* Returns `true` if the given bounding box is intersecting any frustum
	* from the camera array.
	*
	* @param {Box3} box - The bounding box to test.
	* @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
	* @return {boolean} Whether the box is visible in any camera.
	*/
	intersectsBox(box, cameraArray) {
		if (!cameraArray || !cameraArray.cameras || cameraArray.cameras.length === 0) return false;
		for (let i = 0; i < cameraArray.cameras.length; i++) {
			const camera = cameraArray.cameras[i];
			_projScreenMatrix$2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			_frustum$1.setFromProjectionMatrix(_projScreenMatrix$2, camera.coordinateSystem, camera.reversedDepth);
			if (_frustum$1.intersectsBox(box)) return true;
		}
		return false;
	}
	/**
	* Returns `true` if the given point lies within any frustum
	* from the camera array.
	*
	* @param {Vector3} point - The point to test.
	* @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
	* @return {boolean} Whether the point is visible in any camera.
	*/
	containsPoint(point, cameraArray) {
		if (!cameraArray || !cameraArray.cameras || cameraArray.cameras.length === 0) return false;
		for (let i = 0; i < cameraArray.cameras.length; i++) {
			const camera = cameraArray.cameras[i];
			_projScreenMatrix$2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			_frustum$1.setFromProjectionMatrix(_projScreenMatrix$2, camera.coordinateSystem, camera.reversedDepth);
			if (_frustum$1.containsPoint(point)) return true;
		}
		return false;
	}
	/**
	* Returns a new frustum array with copied values from this instance.
	*
	* @return {FrustumArray} A clone of this instance.
	*/
	clone() {
		return new FrustumArray();
	}
};
/**
* A material for rendering line primitives.
*
* Materials define the appearance of renderable 3D objects.
*
* ```js
* const material = new THREE.LineBasicMaterial( { color: 0xffffff } );
* ```
*
* @augments Material
*/
var LineBasicMaterial = class extends Material {
	/**
	* Constructs a new line basic material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isLineBasicMaterial = true;
		this.type = "LineBasicMaterial";
		/**
		* Color of the material.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.color = new Color$1(16777215);
		/**
		* Sets the color of the lines using data from a texture. The texture map
		* color is modulated by the diffuse `color`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* Controls line thickness or lines.
		*
		* Can only be used with {@link SVGRenderer}. WebGL and WebGPU
		* ignore this setting and always render line primitives with a
		* width of one pixel.
		*
		* @type {number}
		* @default 1
		*/
		this.linewidth = 1;
		/**
		* Defines appearance of line ends.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('butt'|'round'|'square')}
		* @default 'round'
		*/
		this.linecap = "round";
		/**
		* Defines appearance of line joints.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.linejoin = "round";
		/**
		* Whether the material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;
		this.fog = source.fog;
		return this;
	}
};
/**
* A material for rendering point primitives.
*
* Materials define the appearance of renderable 3D objects.
*
* ```js
* const vertices = [];
*
* for ( let i = 0; i < 10000; i ++ ) {
* 	const x = THREE.MathUtils.randFloatSpread( 2000 );
* 	const y = THREE.MathUtils.randFloatSpread( 2000 );
* 	const z = THREE.MathUtils.randFloatSpread( 2000 );
*
* 	vertices.push( x, y, z );
* }
*
* const geometry = new THREE.BufferGeometry();
* geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
* const material = new THREE.PointsMaterial( { color: 0x888888 } );
* const points = new THREE.Points( geometry, material );
* scene.add( points );
* ```
*
* @augments Material
*/
var PointsMaterial = class extends Material {
	/**
	* Constructs a new points material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isPointsMaterial = true;
		this.type = "PointsMaterial";
		/**
		* Color of the material.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.color = new Color$1(16777215);
		/**
		* The color map. May optionally include an alpha channel, typically combined
		* with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		* color is modulated by the diffuse `color`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* The alpha map is a grayscale texture that controls the opacity across the
		* surface (black: fully transparent; white: fully opaque).
		*
		* Only the color of the texture is used, ignoring the alpha channel if one
		* exists. For RGB and RGBA textures, the renderer will use the green channel
		* when sampling this texture due to the extra bit of precision provided for
		* green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		* luminance/alpha textures will also still work as expected.
		*
		* @type {?Texture}
		* @default null
		*/
		this.alphaMap = null;
		/**
		* Defines the size of the points in pixels.
		*
		* Might be capped if the value exceeds hardware dependent parameters like [gl.ALIASED_POINT_SIZE_RANGE](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getParamete).
		*
		* @type {number}
		* @default 1
		*/
		this.size = 1;
		/**
		* Specifies whether size of individual points is attenuated by the camera depth (perspective camera only).
		*
		* @type {boolean}
		* @default true
		*/
		this.sizeAttenuation = true;
		/**
		* Whether the material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;
		this.fog = source.fog;
		return this;
	}
};
/**
* A texture for use with a video.
*
* ```js
* // assuming you have created a HTML video element with id="video"
* const video = document.getElementById( 'video' );
* const texture = new THREE.VideoTexture( video );
* ```
*
* Note: When using video textures with {@link WebGPURenderer}, {@link Texture#colorSpace} must be
* set to THREE.SRGBColorSpace.
*
* Note: After the initial use of a texture, its dimensions, format, and type
* cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.
*
* @augments Texture
*/
var VideoTexture = class extends Texture {
	/**
	* Constructs a new video texture.
	*
	* @param {HTMLVideoElement} video - The video element to use as a data source for the texture.
	* @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	* @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	* @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	* @param {number} [magFilter=LinearFilter] - The mag filter value.
	* @param {number} [minFilter=LinearFilter] - The min filter value.
	* @param {number} [format=RGBAFormat] - The texture format.
	* @param {number} [type=UnsignedByteType] - The texture type.
	* @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	*/
	constructor(video, mapping, wrapS, wrapT, magFilter = LinearFilter, minFilter = LinearFilter, format, type$1, anisotropy$2) {
		super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type$1, anisotropy$2);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isVideoTexture = true;
		/**
		* Whether to generate mipmaps (if possible) for a texture.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.generateMipmaps = false;
		/**
		* The video frame request callback identifier, which is a positive integer.
		*
		* Value of 0 represents no scheduled rVFC.
		*
		* @private
		* @type {number}
		*/
		this._requestVideoFrameCallbackId = 0;
		const scope = this;
		function updateVideo() {
			scope.needsUpdate = true;
			scope._requestVideoFrameCallbackId = video.requestVideoFrameCallback(updateVideo);
		}
		if ("requestVideoFrameCallback" in video) this._requestVideoFrameCallbackId = video.requestVideoFrameCallback(updateVideo);
	}
	clone() {
		return new this.constructor(this.image).copy(this);
	}
	/**
	* This method is called automatically by the renderer and sets {@link Texture#needsUpdate}
	* to `true` every time a new frame is available.
	*
	* Only relevant if `requestVideoFrameCallback` is not supported in the browser.
	*/
	update() {
		const video = this.image;
		if ("requestVideoFrameCallback" in video === false && video.readyState >= video.HAVE_CURRENT_DATA) this.needsUpdate = true;
	}
	dispose() {
		if (this._requestVideoFrameCallbackId !== 0) {
			this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId);
			this._requestVideoFrameCallbackId = 0;
		}
		super.dispose();
	}
};
/**
* This class can only be used in combination with `copyFramebufferToTexture()` methods
* of renderers. It extracts the contents of the current bound framebuffer and provides it
* as a texture for further usage.
*
* ```js
* const pixelRatio = window.devicePixelRatio;
* const textureSize = 128 * pixelRatio;
*
* const frameTexture = new FramebufferTexture( textureSize, textureSize );
*
* // calculate start position for copying part of the frame data
* const vector = new Vector2();
* vector.x = ( window.innerWidth * pixelRatio / 2 ) - ( textureSize / 2 );
* vector.y = ( window.innerHeight * pixelRatio / 2 ) - ( textureSize / 2 );
*
* renderer.render( scene, camera );
*
* // copy part of the rendered frame into the framebuffer texture
* renderer.copyFramebufferToTexture( frameTexture, vector );
* ```
*
* @augments Texture
*/
var FramebufferTexture = class extends Texture {
	/**
	* Constructs a new framebuffer texture.
	*
	* @param {number} [width] - The width of the texture.
	* @param {number} [height] - The height of the texture.
	*/
	constructor(width, height) {
		super({
			width,
			height
		});
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isFramebufferTexture = true;
		/**
		* How the texture is sampled when a texel covers more than one pixel.
		*
		* Overwritten and set to `NearestFilter` by default to disable filtering.
		*
		* @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		* @default NearestFilter
		*/
		this.magFilter = NearestFilter;
		/**
		* How the texture is sampled when a texel covers less than one pixel.
		*
		* Overwritten and set to `NearestFilter` by default to disable filtering.
		*
		* @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		* @default NearestFilter
		*/
		this.minFilter = NearestFilter;
		/**
		* Whether to generate mipmaps (if possible) for a texture.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.generateMipmaps = false;
		this.needsUpdate = true;
	}
};
/**
* This class can be used to automatically save the depth information of a
* rendering into a texture.
*
* @augments Texture
*/
var DepthTexture = class extends Texture {
	/**
	* Constructs a new depth texture.
	*
	* @param {number} width - The width of the texture.
	* @param {number} height - The height of the texture.
	* @param {number} [type=UnsignedIntType] - The texture type.
	* @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	* @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	* @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	* @param {number} [magFilter=LinearFilter] - The mag filter value.
	* @param {number} [minFilter=LinearFilter] - The min filter value.
	* @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	* @param {number} [format=DepthFormat] - The texture format.
	* @param {number} [depth=1] - The depth of the texture.
	*/
	constructor(width, height, type$1 = UnsignedIntType, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy$2, format = DepthFormat, depth$2 = 1) {
		if (format !== DepthFormat && format !== DepthStencilFormat) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
		super({
			width,
			height,
			depth: depth$2
		}, mapping, wrapS, wrapT, magFilter, minFilter, format, type$1, anisotropy$2);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isDepthTexture = true;
		/**
		* If set to `true`, the texture is flipped along the vertical axis when
		* uploaded to the GPU.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.flipY = false;
		/**
		* Whether to generate mipmaps (if possible) for a texture.
		*
		* Overwritten and set to `false` by default.
		*
		* @type {boolean}
		* @default false
		*/
		this.generateMipmaps = false;
		/**
		* Code corresponding to the depth compare function.
		*
		* @type {?(NeverCompare|LessCompare|EqualCompare|LessEqualCompare|GreaterCompare|NotEqualCompare|GreaterEqualCompare|AlwaysCompare)}
		* @default null
		*/
		this.compareFunction = null;
	}
	copy(source) {
		super.copy(source);
		this.source = new Source(Object.assign({}, source.image));
		this.compareFunction = source.compareFunction;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
		return data;
	}
};
/**
* Represents a texture created externally with the same renderer context.
*
* This may be a texture from a protected media stream, device camera feed,
* or other data feeds like a depth sensor.
*
* Note that this class is only supported in {@link WebGLRenderer}, and in
* the {@link WebGPURenderer} WebGPU backend.
*
* @augments Texture
*/
var ExternalTexture = class extends Texture {
	/**
	* Creates a new raw texture.
	*
	* @param {?(WebGLTexture|GPUTexture)} [sourceTexture=null] - The external texture.
	*/
	constructor(sourceTexture = null) {
		super();
		/**
		* The external source texture.
		*
		* @type {?(WebGLTexture|GPUTexture)}
		* @default null
		*/
		this.sourceTexture = sourceTexture;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isExternalTexture = true;
	}
	copy(source) {
		super.copy(source);
		this.sourceTexture = source.sourceTexture;
		return this;
	}
};
/**
* A geometry class for representing a cylinder.
*
* ```js
* const geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
* const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
* const cylinder = new THREE.Mesh( geometry, material );
* scene.add( cylinder );
* ```
*
* @augments BufferGeometry
* @demo scenes/geometry-browser.html#CylinderGeometry
*/
var CylinderGeometry = class CylinderGeometry extends BufferGeometry {
	/**
	* Constructs a new cylinder geometry.
	*
	* @param {number} [radiusTop=1] - Radius of the cylinder at the top.
	* @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
	* @param {number} [height=1] - Height of the cylinder.
	* @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
	* @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
	* @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
	* @param {number} [thetaStart=0] - Start angle for first segment, in radians.
	* @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
	* The default value results in a complete cylinder.
	*/
	constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
		super();
		this.type = "CylinderGeometry";
		/**
		* Holds the constructor parameters that have been
		* used to generate the geometry. Any modification
		* after instantiation does not change the geometry.
		*
		* @type {Object}
		*/
		this.parameters = {
			radiusTop,
			radiusBottom,
			height,
			radialSegments,
			heightSegments,
			openEnded,
			thetaStart,
			thetaLength
		};
		const scope = this;
		radialSegments = Math.floor(radialSegments);
		heightSegments = Math.floor(heightSegments);
		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];
		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;
		generateTorso();
		if (openEnded === false) {
			if (radiusTop > 0) generateCap(true);
			if (radiusBottom > 0) generateCap(false);
		}
		this.setIndex(indices);
		this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
		this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
		this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
		function generateTorso() {
			const normal$1 = new Vector3();
			const vertex$1 = new Vector3();
			let groupCount = 0;
			const slope = (radiusBottom - radiusTop) / height;
			for (let y = 0; y <= heightSegments; y++) {
				const indexRow = [];
				const v = y / heightSegments;
				const radius = v * (radiusBottom - radiusTop) + radiusTop;
				for (let x = 0; x <= radialSegments; x++) {
					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;
					const sinTheta = Math.sin(theta);
					const cosTheta = Math.cos(theta);
					vertex$1.x = radius * sinTheta;
					vertex$1.y = -v * height + halfHeight;
					vertex$1.z = radius * cosTheta;
					vertices.push(vertex$1.x, vertex$1.y, vertex$1.z);
					normal$1.set(sinTheta, slope, cosTheta).normalize();
					normals.push(normal$1.x, normal$1.y, normal$1.z);
					uvs.push(u, 1 - v);
					indexRow.push(index++);
				}
				indexArray.push(indexRow);
			}
			for (let x = 0; x < radialSegments; x++) for (let y = 0; y < heightSegments; y++) {
				const a$1 = indexArray[y][x];
				const b$2 = indexArray[y + 1][x];
				const c$1 = indexArray[y + 1][x + 1];
				const d$1 = indexArray[y][x + 1];
				if (radiusTop > 0 || y !== 0) {
					indices.push(a$1, b$2, d$1);
					groupCount += 3;
				}
				if (radiusBottom > 0 || y !== heightSegments - 1) {
					indices.push(b$2, c$1, d$1);
					groupCount += 3;
				}
			}
			scope.addGroup(groupStart, groupCount, 0);
			groupStart += groupCount;
		}
		function generateCap(top) {
			const centerIndexStart = index;
			const uv$3 = new Vector2();
			const vertex$1 = new Vector3();
			let groupCount = 0;
			const radius = top === true ? radiusTop : radiusBottom;
			const sign$2 = top === true ? 1 : -1;
			for (let x = 1; x <= radialSegments; x++) {
				vertices.push(0, halfHeight * sign$2, 0);
				normals.push(0, sign$2, 0);
				uvs.push(.5, .5);
				index++;
			}
			const centerIndexEnd = index;
			for (let x = 0; x <= radialSegments; x++) {
				const theta = x / radialSegments * thetaLength + thetaStart;
				const cosTheta = Math.cos(theta);
				const sinTheta = Math.sin(theta);
				vertex$1.x = radius * sinTheta;
				vertex$1.y = halfHeight * sign$2;
				vertex$1.z = radius * cosTheta;
				vertices.push(vertex$1.x, vertex$1.y, vertex$1.z);
				normals.push(0, sign$2, 0);
				uv$3.x = cosTheta * .5 + .5;
				uv$3.y = sinTheta * .5 * sign$2 + .5;
				uvs.push(uv$3.x, uv$3.y);
				index++;
			}
			for (let x = 0; x < radialSegments; x++) {
				const c$1 = centerIndexStart + x;
				const i = centerIndexEnd + x;
				if (top === true) indices.push(i, i + 1, c$1);
				else indices.push(i + 1, i, c$1);
				groupCount += 3;
			}
			scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
			groupStart += groupCount;
		}
	}
	copy(source) {
		super.copy(source);
		this.parameters = Object.assign({}, source.parameters);
		return this;
	}
	/**
	* Factory method for creating an instance of this class from the given
	* JSON object.
	*
	* @param {Object} data - A JSON object representing the serialized geometry.
	* @return {CylinderGeometry} A new instance.
	*/
	static fromJSON(data) {
		return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
	}
};
/**
* A geometry class for representing a plane.
*
* ```js
* const geometry = new THREE.PlaneGeometry( 1, 1 );
* const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
* const plane = new THREE.Mesh( geometry, material );
* scene.add( plane );
* ```
*
* @augments BufferGeometry
* @demo scenes/geometry-browser.html#PlaneGeometry
*/
var PlaneGeometry = class PlaneGeometry extends BufferGeometry {
	/**
	* Constructs a new plane geometry.
	*
	* @param {number} [width=1] - The width along the X axis.
	* @param {number} [height=1] - The height along the Y axis
	* @param {number} [widthSegments=1] - The number of segments along the X axis.
	* @param {number} [heightSegments=1] - The number of segments along the Y axis.
	*/
	constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
		super();
		this.type = "PlaneGeometry";
		/**
		* Holds the constructor parameters that have been
		* used to generate the geometry. Any modification
		* after instantiation does not change the geometry.
		*
		* @type {Object}
		*/
		this.parameters = {
			width,
			height,
			widthSegments,
			heightSegments
		};
		const width_half = width / 2;
		const height_half = height / 2;
		const gridX = Math.floor(widthSegments);
		const gridY = Math.floor(heightSegments);
		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;
		const segment_width = width / gridX;
		const segment_height = height / gridY;
		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];
		for (let iy = 0; iy < gridY1; iy++) {
			const y = iy * segment_height - height_half;
			for (let ix = 0; ix < gridX1; ix++) {
				const x = ix * segment_width - width_half;
				vertices.push(x, -y, 0);
				normals.push(0, 0, 1);
				uvs.push(ix / gridX);
				uvs.push(1 - iy / gridY);
			}
		}
		for (let iy = 0; iy < gridY; iy++) for (let ix = 0; ix < gridX; ix++) {
			const a$1 = ix + gridX1 * iy;
			const b$2 = ix + gridX1 * (iy + 1);
			const c$1 = ix + 1 + gridX1 * (iy + 1);
			const d$1 = ix + 1 + gridX1 * iy;
			indices.push(a$1, b$2, d$1);
			indices.push(b$2, c$1, d$1);
		}
		this.setIndex(indices);
		this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
		this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
		this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	}
	copy(source) {
		super.copy(source);
		this.parameters = Object.assign({}, source.parameters);
		return this;
	}
	/**
	* Factory method for creating an instance of this class from the given
	* JSON object.
	*
	* @param {Object} data - A JSON object representing the serialized geometry.
	* @return {PlaneGeometry} A new instance.
	*/
	static fromJSON(data) {
		return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
	}
};
/**
* A class for generating a sphere geometry.
*
* ```js
* const geometry = new THREE.SphereGeometry( 15, 32, 16 );
* const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
* const sphere = new THREE.Mesh( geometry, material );
* scene.add( sphere );
* ```
*
* @augments BufferGeometry
* @demo scenes/geometry-browser.html#SphereGeometry
*/
var SphereGeometry = class SphereGeometry extends BufferGeometry {
	/**
	* Constructs a new sphere geometry.
	*
	* @param {number} [radius=1] - The sphere radius.
	* @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
	* @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
	* @param {number} [phiStart=0] - The horizontal starting angle in radians.
	* @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
	* @param {number} [thetaStart=0] - The vertical starting angle in radians.
	* @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
	*/
	constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
		super();
		this.type = "SphereGeometry";
		/**
		* Holds the constructor parameters that have been
		* used to generate the geometry. Any modification
		* after instantiation does not change the geometry.
		*
		* @type {Object}
		*/
		this.parameters = {
			radius,
			widthSegments,
			heightSegments,
			phiStart,
			phiLength,
			thetaStart,
			thetaLength
		};
		widthSegments = Math.max(3, Math.floor(widthSegments));
		heightSegments = Math.max(2, Math.floor(heightSegments));
		const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
		let index = 0;
		const grid = [];
		const vertex$1 = new Vector3();
		const normal$1 = new Vector3();
		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];
		for (let iy = 0; iy <= heightSegments; iy++) {
			const verticesRow = [];
			const v = iy / heightSegments;
			let uOffset = 0;
			if (iy === 0 && thetaStart === 0) uOffset = .5 / widthSegments;
			else if (iy === heightSegments && thetaEnd === Math.PI) uOffset = -.5 / widthSegments;
			for (let ix = 0; ix <= widthSegments; ix++) {
				const u = ix / widthSegments;
				vertex$1.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
				vertex$1.y = radius * Math.cos(thetaStart + v * thetaLength);
				vertex$1.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
				vertices.push(vertex$1.x, vertex$1.y, vertex$1.z);
				normal$1.copy(vertex$1).normalize();
				normals.push(normal$1.x, normal$1.y, normal$1.z);
				uvs.push(u + uOffset, 1 - v);
				verticesRow.push(index++);
			}
			grid.push(verticesRow);
		}
		for (let iy = 0; iy < heightSegments; iy++) for (let ix = 0; ix < widthSegments; ix++) {
			const a$1 = grid[iy][ix + 1];
			const b$2 = grid[iy][ix];
			const c$1 = grid[iy + 1][ix];
			const d$1 = grid[iy + 1][ix + 1];
			if (iy !== 0 || thetaStart > 0) indices.push(a$1, b$2, d$1);
			if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b$2, c$1, d$1);
		}
		this.setIndex(indices);
		this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
		this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
		this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	}
	copy(source) {
		super.copy(source);
		this.parameters = Object.assign({}, source.parameters);
		return this;
	}
	/**
	* Factory method for creating an instance of this class from the given
	* JSON object.
	*
	* @param {Object} data - A JSON object representing the serialized geometry.
	* @return {SphereGeometry} A new instance.
	*/
	static fromJSON(data) {
		return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
	}
};
/**
* This material can receive shadows, but otherwise is completely transparent.
*
* ```js
* const geometry = new THREE.PlaneGeometry( 2000, 2000 );
* geometry.rotateX( - Math.PI / 2 );
*
* const material = new THREE.ShadowMaterial();
* material.opacity = 0.2;
*
* const plane = new THREE.Mesh( geometry, material );
* plane.position.y = -200;
* plane.receiveShadow = true;
* scene.add( plane );
* ```
*
* @augments Material
*/
var ShadowMaterial = class extends Material {
	/**
	* Constructs a new shadow material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isShadowMaterial = true;
		this.type = "ShadowMaterial";
		/**
		* Color of the material.
		*
		* @type {Color}
		* @default (0,0,0)
		*/
		this.color = new Color$1(0);
		/**
		* Overwritten since shadow materials are transparent
		* by default.
		*
		* @type {boolean}
		* @default true
		*/
		this.transparent = true;
		/**
		* Whether the material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.fog = source.fog;
		return this;
	}
};
/**
* A standard physically based material, using Metallic-Roughness workflow.
*
* Physically based rendering (PBR) has recently become the standard in many
* 3D applications, such as [Unity](https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/),
* [Unreal](https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/PhysicallyBased/) and
* [3D Studio Max](http://area.autodesk.com/blogs/the-3ds-max-blog/what039s-new-for-rendering-in-3ds-max-2017).
*
* This approach differs from older approaches in that instead of using
* approximations for the way in which light interacts with a surface, a
* physically correct model is used. The idea is that, instead of tweaking
* materials to look good under specific lighting, a material can be created
* that will react 'correctly' under all lighting scenarios.
*
* In practice this gives a more accurate and realistic looking result than
* the {@link MeshLambertMaterial} or {@link MeshPhongMaterial}, at the cost of
* being somewhat more computationally expensive. `MeshStandardMaterial` uses per-fragment
* shading.
*
* Note that for best results you should always specify an environment map when using this material.
*
* For a non-technical introduction to the concept of PBR and how to set up a
* PBR material, check out these articles by the people at [marmoset](https://www.marmoset.co):
*
* - [Basic Theory of Physically Based Rendering](https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/)
* - [Physically Based Rendering and You Can Too](https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/)
*
* Technical details of the approach used in three.js (and most other PBR systems) can be found is this
* [paper from Disney](https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf)
* (pdf), by Brent Burley.
*
* @augments Material
* @demo scenes/material-browser.html#MeshStandardMaterial
*/
var MeshStandardMaterial = class extends Material {
	/**
	* Constructs a new mesh standard material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshStandardMaterial = true;
		this.type = "MeshStandardMaterial";
		this.defines = { "STANDARD": "" };
		/**
		* Color of the material.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.color = new Color$1(16777215);
		/**
		* How rough the material appears. `0.0` means a smooth mirror reflection, `1.0`
		* means fully diffuse. If `roughnessMap` is also provided,
		* both values are multiplied.
		*
		* @type {number}
		* @default 1
		*/
		this.roughness = 1;
		/**
		* How much the material is like a metal. Non-metallic materials such as wood
		* or stone use `0.0`, metallic use `1.0`, with nothing (usually) in between.
		* A value between `0.0` and `1.0` could be used for a rusty metal look.
		* If `metalnessMap` is also provided, both values are multiplied.
		*
		* @type {number}
		* @default 0
		*/
		this.metalness = 0;
		/**
		* The color map. May optionally include an alpha channel, typically combined
		* with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		* color is modulated by the diffuse `color`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* The light map. Requires a second set of UVs.
		*
		* @type {?Texture}
		* @default null
		*/
		this.lightMap = null;
		/**
		* Intensity of the baked light.
		*
		* @type {number}
		* @default 1
		*/
		this.lightMapIntensity = 1;
		/**
		* The red channel of this texture is used as the ambient occlusion map.
		* Requires a second set of UVs.
		*
		* @type {?Texture}
		* @default null
		*/
		this.aoMap = null;
		/**
		* Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		* disables ambient occlusion. Where intensity is `1` and the AO map's
		* red channel is also `1`, ambient light is fully occluded on a surface.
		*
		* @type {number}
		* @default 1
		*/
		this.aoMapIntensity = 1;
		/**
		* Emissive (light) color of the material, essentially a solid color
		* unaffected by other lighting.
		*
		* @type {Color}
		* @default (0,0,0)
		*/
		this.emissive = new Color$1(0);
		/**
		* Intensity of the emissive light. Modulates the emissive color.
		*
		* @type {number}
		* @default 1
		*/
		this.emissiveIntensity = 1;
		/**
		* Set emissive (glow) map. The emissive map color is modulated by the
		* emissive color and the emissive intensity. If you have an emissive map,
		* be sure to set the emissive color to something other than black.
		*
		* @type {?Texture}
		* @default null
		*/
		this.emissiveMap = null;
		/**
		* The texture to create a bump map. The black and white values map to the
		* perceived depth in relation to the lights. Bump doesn't actually affect
		* the geometry of the object, only the lighting. If a normal map is defined
		* this will be ignored.
		*
		* @type {?Texture}
		* @default null
		*/
		this.bumpMap = null;
		/**
		* How much the bump map affects the material. Typical range is `[0,1]`.
		*
		* @type {number}
		* @default 1
		*/
		this.bumpScale = 1;
		/**
		* The texture to create a normal map. The RGB values affect the surface
		* normal for each pixel fragment and change the way the color is lit. Normal
		* maps do not change the actual shape of the surface, only the lighting. In
		* case the material has a normal map authored using the left handed
		* convention, the `y` component of `normalScale` should be negated to compensate
		* for the different handedness.
		*
		* @type {?Texture}
		* @default null
		*/
		this.normalMap = null;
		/**
		* The type of normal map.
		*
		* @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		* @default TangentSpaceNormalMap
		*/
		this.normalMapType = TangentSpaceNormalMap;
		/**
		* How much the normal map affects the material. Typical value range is `[0,1]`.
		*
		* @type {Vector2}
		* @default (1,1)
		*/
		this.normalScale = new Vector2(1, 1);
		/**
		* The displacement map affects the position of the mesh's vertices. Unlike
		* other maps which only affect the light and shade of the material the
		* displaced vertices can cast shadows, block other objects, and otherwise
		* act as real geometry. The displacement texture is an image where the value
		* of each pixel (white being the highest) is mapped against, and
		* repositions, the vertices of the mesh.
		*
		* @type {?Texture}
		* @default null
		*/
		this.displacementMap = null;
		/**
		* How much the displacement map affects the mesh (where black is no
		* displacement, and white is maximum displacement). Without a displacement
		* map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementScale = 1;
		/**
		* The offset of the displacement map's values on the mesh's vertices.
		* The bias is added to the scaled sample of the displacement map.
		* Without a displacement map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementBias = 0;
		/**
		* The green channel of this texture is used to alter the roughness of the
		* material.
		*
		* @type {?Texture}
		* @default null
		*/
		this.roughnessMap = null;
		/**
		* The blue channel of this texture is used to alter the metalness of the
		* material.
		*
		* @type {?Texture}
		* @default null
		*/
		this.metalnessMap = null;
		/**
		* The alpha map is a grayscale texture that controls the opacity across the
		* surface (black: fully transparent; white: fully opaque).
		*
		* Only the color of the texture is used, ignoring the alpha channel if one
		* exists. For RGB and RGBA textures, the renderer will use the green channel
		* when sampling this texture due to the extra bit of precision provided for
		* green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		* luminance/alpha textures will also still work as expected.
		*
		* @type {?Texture}
		* @default null
		*/
		this.alphaMap = null;
		/**
		* The environment map. To ensure a physically correct rendering, environment maps
		* are internally pre-processed with {@link PMREMGenerator}.
		*
		* @type {?Texture}
		* @default null
		*/
		this.envMap = null;
		/**
		* The rotation of the environment map in radians.
		*
		* @type {Euler}
		* @default (0,0,0)
		*/
		this.envMapRotation = new Euler();
		/**
		* Scales the effect of the environment map by multiplying its color.
		*
		* @type {number}
		* @default 1
		*/
		this.envMapIntensity = 1;
		/**
		* Renders the geometry as a wireframe.
		*
		* @type {boolean}
		* @default false
		*/
		this.wireframe = false;
		/**
		* Controls the thickness of the wireframe.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {number}
		* @default 1
		*/
		this.wireframeLinewidth = 1;
		/**
		* Defines appearance of wireframe ends.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.wireframeLinecap = "round";
		/**
		* Defines appearance of wireframe joints.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.wireframeLinejoin = "round";
		/**
		* Whether the material is rendered with flat shading or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.flatShading = false;
		/**
		* Whether the material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.defines = { "STANDARD": "" };
		this.color.copy(source.color);
		this.roughness = source.roughness;
		this.metalness = source.metalness;
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.roughnessMap = source.roughnessMap;
		this.metalnessMap = source.metalnessMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.envMapRotation.copy(source.envMapRotation);
		this.envMapIntensity = source.envMapIntensity;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.flatShading = source.flatShading;
		this.fog = source.fog;
		return this;
	}
};
/**
* An extension of the {@link MeshStandardMaterial}, providing more advanced
* physically-based rendering properties:
*
* - Anisotropy: Ability to represent the anisotropic property of materials
* as observable with brushed metals.
* - Clearcoat: Some materials — like car paints, carbon fiber, and wet surfaces — require
* a clear, reflective layer on top of another layer that may be irregular or rough.
* Clearcoat approximates this effect, without the need for a separate transparent surface.
* - Iridescence: Allows to render the effect where hue varies  depending on the viewing
* angle and illumination angle. This can be seen on soap bubbles, oil films, or on the
* wings of many insects.
* - Physically-based transparency: One limitation of {@link Material#opacity} is that highly
* transparent materials are less reflective. Physically-based transmission provides a more
* realistic option for thin, transparent surfaces like glass.
* - Advanced reflectivity: More flexible reflectivity for non-metallic materials.
* - Sheen: Can be used for representing cloth and fabric materials.
*
* As a result of these complex shading features, `MeshPhysicalMaterial` has a
* higher performance cost, per pixel, than other three.js materials. Most
* effects are disabled by default, and add cost as they are enabled. For
* best results, always specify an environment map when using this material.
*
* @augments MeshStandardMaterial
* @demo scenes/material-browser.html#MeshPhysicalMaterial
*/
var MeshPhysicalMaterial = class extends MeshStandardMaterial {
	/**
	* Constructs a new mesh physical material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshPhysicalMaterial = true;
		this.defines = {
			"STANDARD": "",
			"PHYSICAL": ""
		};
		this.type = "MeshPhysicalMaterial";
		/**
		* The rotation of the anisotropy in tangent, bitangent space, measured in radians
		* counter-clockwise from the tangent. When `anisotropyMap` is present, this
		* property provides additional rotation to the vectors in the texture.
		*
		* @type {number}
		* @default 1
		*/
		this.anisotropyRotation = 0;
		/**
		* Red and green channels represent the anisotropy direction in `[-1, 1]` tangent,
		* bitangent space, to be rotated by `anisotropyRotation`. The blue channel
		* contains strength as `[0, 1]` to be multiplied by `anisotropy`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.anisotropyMap = null;
		/**
		* The red channel of this texture is multiplied against `clearcoat`,
		* for per-pixel control over a coating's intensity.
		*
		* @type {?Texture}
		* @default null
		*/
		this.clearcoatMap = null;
		/**
		* Roughness of the clear coat layer, from `0.0` to `1.0`.
		*
		* @type {number}
		* @default 0
		*/
		this.clearcoatRoughness = 0;
		/**
		* The green channel of this texture is multiplied against
		* `clearcoatRoughness`, for per-pixel control over a coating's roughness.
		*
		* @type {?Texture}
		* @default null
		*/
		this.clearcoatRoughnessMap = null;
		/**
		* How much `clearcoatNormalMap` affects the clear coat layer, from
		* `(0,0)` to `(1,1)`.
		*
		* @type {Vector2}
		* @default (1,1)
		*/
		this.clearcoatNormalScale = new Vector2(1, 1);
		/**
		* Can be used to enable independent normals for the clear coat layer.
		*
		* @type {?Texture}
		* @default null
		*/
		this.clearcoatNormalMap = null;
		/**
		* Index-of-refraction for non-metallic materials, from `1.0` to `2.333`.
		*
		* @type {number}
		* @default 1.5
		*/
		this.ior = 1.5;
		/**
		* Degree of reflectivity, from `0.0` to `1.0`. Default is `0.5`, which
		* corresponds to an index-of-refraction of `1.5`.
		*
		* This models the reflectivity of non-metallic materials. It has no effect
		* when `metalness` is `1.0`
		*
		* @name MeshPhysicalMaterial#reflectivity
		* @type {number}
		* @default 0.5
		*/
		Object.defineProperty(this, "reflectivity", {
			get: function() {
				return clamp$3(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
			},
			set: function(reflectivity) {
				this.ior = (1 + .4 * reflectivity) / (1 - .4 * reflectivity);
			}
		});
		/**
		* The red channel of this texture is multiplied against `iridescence`, for per-pixel
		* control over iridescence.
		*
		* @type {?Texture}
		* @default null
		*/
		this.iridescenceMap = null;
		/**
		* Strength of the iridescence RGB color shift effect, represented by an index-of-refraction.
		* Between `1.0` to `2.333`.
		*
		* @type {number}
		* @default 1.3
		*/
		this.iridescenceIOR = 1.3;
		/**
		*Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence layer.
		Thickness of iridescence layer has an equivalent effect of the one `thickness` has on `ior`.
		*
		* @type {Array<number,number>}
		* @default [100,400]
		*/
		this.iridescenceThicknessRange = [100, 400];
		/**
		* A texture that defines the thickness of the iridescence layer, stored in the green channel.
		* Minimum and maximum values of thickness are defined by `iridescenceThicknessRange` array:
		* - `0.0` in the green channel will result in thickness equal to first element of the array.
		* - `1.0` in the green channel will result in thickness equal to second element of the array.
		* - Values in-between will linearly interpolate between the elements of the array.
		*
		* @type {?Texture}
		* @default null
		*/
		this.iridescenceThicknessMap = null;
		/**
		* The sheen tint.
		*
		* @type {Color}
		* @default (0,0,0)
		*/
		this.sheenColor = new Color$1(0);
		/**
		* The RGB channels of this texture are multiplied against  `sheenColor`, for per-pixel control
		* over sheen tint.
		*
		* @type {?Texture}
		* @default null
		*/
		this.sheenColorMap = null;
		/**
		* Roughness of the sheen layer, from `0.0` to `1.0`.
		*
		* @type {number}
		* @default 1
		*/
		this.sheenRoughness = 1;
		/**
		* The alpha channel of this texture is multiplied against `sheenRoughness`, for per-pixel control
		* over sheen roughness.
		*
		* @type {?Texture}
		* @default null
		*/
		this.sheenRoughnessMap = null;
		/**
		* The red channel of this texture is multiplied against `transmission`, for per-pixel control over
		* optical transparency.
		*
		* @type {?Texture}
		* @default null
		*/
		this.transmissionMap = null;
		/**
		* The thickness of the volume beneath the surface. The value is given in the
		* coordinate space of the mesh. If the value is `0` the material is
		* thin-walled. Otherwise the material is a volume boundary.
		*
		* @type {number}
		* @default 0
		*/
		this.thickness = 0;
		/**
		* A texture that defines the thickness, stored in the green channel. This will
		* be multiplied by `thickness`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.thicknessMap = null;
		/**
		* Density of the medium given as the average distance that light travels in
		* the medium before interacting with a particle. The value is given in world
		* space units, and must be greater than zero.
		*
		* @type {number}
		* @default Infinity
		*/
		this.attenuationDistance = Infinity;
		/**
		* The color that white light turns into due to absorption when reaching the
		* attenuation distance.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.attenuationColor = new Color$1(1, 1, 1);
		/**
		* A float that scales the amount of specular reflection for non-metals only.
		* When set to zero, the model is effectively Lambertian. From `0.0` to `1.0`.
		*
		* @type {number}
		* @default 1
		*/
		this.specularIntensity = 1;
		/**
		* The alpha channel of this texture is multiplied against `specularIntensity`,
		* for per-pixel control over specular intensity.
		*
		* @type {?Texture}
		* @default null
		*/
		this.specularIntensityMap = null;
		/**
		* Tints the specular reflection at normal incidence for non-metals only.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.specularColor = new Color$1(1, 1, 1);
		/**
		* The RGB channels of this texture are multiplied against `specularColor`,
		* for per-pixel control over specular color.
		*
		* @type {?Texture}
		* @default null
		*/
		this.specularColorMap = null;
		this._anisotropy = 0;
		this._clearcoat = 0;
		this._dispersion = 0;
		this._iridescence = 0;
		this._sheen = 0;
		this._transmission = 0;
		this.setValues(parameters);
	}
	/**
	* The anisotropy strength, from `0.0` to `1.0`.
	*
	* @type {number}
	* @default 0
	*/
	get anisotropy() {
		return this._anisotropy;
	}
	set anisotropy(value) {
		if (this._anisotropy > 0 !== value > 0) this.version++;
		this._anisotropy = value;
	}
	/**
	* Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
	* clear coat related properties to enable multilayer materials that have a
	* thin translucent layer over the base layer.
	*
	* @type {number}
	* @default 0
	*/
	get clearcoat() {
		return this._clearcoat;
	}
	set clearcoat(value) {
		if (this._clearcoat > 0 !== value > 0) this.version++;
		this._clearcoat = value;
	}
	/**
	* The intensity of the iridescence layer, simulating RGB color shift based on the angle between
	* the surface and the viewer, from `0.0` to `1.0`.
	*
	* @type {number}
	* @default 0
	*/
	get iridescence() {
		return this._iridescence;
	}
	set iridescence(value) {
		if (this._iridescence > 0 !== value > 0) this.version++;
		this._iridescence = value;
	}
	/**
	* Defines the strength of the angular separation of colors (chromatic aberration) transmitting
	* through a relatively clear volume. Any value zero or larger is valid, the typical range of
	* realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
	*
	* @type {number}
	* @default 0
	*/
	get dispersion() {
		return this._dispersion;
	}
	set dispersion(value) {
		if (this._dispersion > 0 !== value > 0) this.version++;
		this._dispersion = value;
	}
	/**
	* The intensity of the sheen layer, from `0.0` to `1.0`.
	*
	* @type {number}
	* @default 0
	*/
	get sheen() {
		return this._sheen;
	}
	set sheen(value) {
		if (this._sheen > 0 !== value > 0) this.version++;
		this._sheen = value;
	}
	/**
	* Degree of transmission (or optical transparency), from `0.0` to `1.0`.
	*
	* Thin, transparent or semitransparent, plastic or glass materials remain
	* largely reflective even if they are fully transmissive. The transmission
	* property can be used to model these materials.
	*
	* When transmission is non-zero, `opacity` should be  set to `1`.
	*
	* @type {number}
	* @default 0
	*/
	get transmission() {
		return this._transmission;
	}
	set transmission(value) {
		if (this._transmission > 0 !== value > 0) this.version++;
		this._transmission = value;
	}
	copy(source) {
		super.copy(source);
		this.defines = {
			"STANDARD": "",
			"PHYSICAL": ""
		};
		this.anisotropy = source.anisotropy;
		this.anisotropyRotation = source.anisotropyRotation;
		this.anisotropyMap = source.anisotropyMap;
		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
		this.dispersion = source.dispersion;
		this.ior = source.ior;
		this.iridescence = source.iridescence;
		this.iridescenceMap = source.iridescenceMap;
		this.iridescenceIOR = source.iridescenceIOR;
		this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
		this.iridescenceThicknessMap = source.iridescenceThicknessMap;
		this.sheen = source.sheen;
		this.sheenColor.copy(source.sheenColor);
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;
		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;
		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy(source.attenuationColor);
		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy(source.specularColor);
		this.specularColorMap = source.specularColorMap;
		return this;
	}
};
/**
* A material for shiny surfaces with specular highlights.
*
* The material uses a non-physically based [Blinn-Phong](https://en.wikipedia.org/wiki/Blinn-Phong_shading_model)
* model for calculating reflectance. Unlike the Lambertian model used in the
* {@link MeshLambertMaterial} this can simulate shiny surfaces with specular
* highlights (such as varnished wood). `MeshPhongMaterial` uses per-fragment shading.
*
* Performance will generally be greater when using this material over the
* {@link MeshStandardMaterial} or {@link MeshPhysicalMaterial}, at the cost of
* some graphical accuracy.
*
* @augments Material
* @demo scenes/material-browser.html#MeshPhongMaterial
*/
var MeshPhongMaterial = class extends Material {
	/**
	* Constructs a new mesh phong material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshPhongMaterial = true;
		this.type = "MeshPhongMaterial";
		/**
		* Color of the material.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.color = new Color$1(16777215);
		/**
		* Specular color of the material. The default color is set to `0x111111` (very dark grey)
		*
		* This defines how shiny the material is and the color of its shine.
		*
		* @type {Color}
		*/
		this.specular = new Color$1(1118481);
		/**
		* How shiny the specular highlight is; a higher value gives a sharper highlight.
		*
		* @type {number}
		* @default 30
		*/
		this.shininess = 30;
		/**
		* The color map. May optionally include an alpha channel, typically combined
		* with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		* color is modulated by the diffuse `color`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* The light map. Requires a second set of UVs.
		*
		* @type {?Texture}
		* @default null
		*/
		this.lightMap = null;
		/**
		* Intensity of the baked light.
		*
		* @type {number}
		* @default 1
		*/
		this.lightMapIntensity = 1;
		/**
		* The red channel of this texture is used as the ambient occlusion map.
		* Requires a second set of UVs.
		*
		* @type {?Texture}
		* @default null
		*/
		this.aoMap = null;
		/**
		* Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		* disables ambient occlusion. Where intensity is `1` and the AO map's
		* red channel is also `1`, ambient light is fully occluded on a surface.
		*
		* @type {number}
		* @default 1
		*/
		this.aoMapIntensity = 1;
		/**
		* Emissive (light) color of the material, essentially a solid color
		* unaffected by other lighting.
		*
		* @type {Color}
		* @default (0,0,0)
		*/
		this.emissive = new Color$1(0);
		/**
		* Intensity of the emissive light. Modulates the emissive color.
		*
		* @type {number}
		* @default 1
		*/
		this.emissiveIntensity = 1;
		/**
		* Set emissive (glow) map. The emissive map color is modulated by the
		* emissive color and the emissive intensity. If you have an emissive map,
		* be sure to set the emissive color to something other than black.
		*
		* @type {?Texture}
		* @default null
		*/
		this.emissiveMap = null;
		/**
		* The texture to create a bump map. The black and white values map to the
		* perceived depth in relation to the lights. Bump doesn't actually affect
		* the geometry of the object, only the lighting. If a normal map is defined
		* this will be ignored.
		*
		* @type {?Texture}
		* @default null
		*/
		this.bumpMap = null;
		/**
		* How much the bump map affects the material. Typical range is `[0,1]`.
		*
		* @type {number}
		* @default 1
		*/
		this.bumpScale = 1;
		/**
		* The texture to create a normal map. The RGB values affect the surface
		* normal for each pixel fragment and change the way the color is lit. Normal
		* maps do not change the actual shape of the surface, only the lighting. In
		* case the material has a normal map authored using the left handed
		* convention, the `y` component of `normalScale` should be negated to compensate
		* for the different handedness.
		*
		* @type {?Texture}
		* @default null
		*/
		this.normalMap = null;
		/**
		* The type of normal map.
		*
		* @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		* @default TangentSpaceNormalMap
		*/
		this.normalMapType = TangentSpaceNormalMap;
		/**
		* How much the normal map affects the material. Typical value range is `[0,1]`.
		*
		* @type {Vector2}
		* @default (1,1)
		*/
		this.normalScale = new Vector2(1, 1);
		/**
		* The displacement map affects the position of the mesh's vertices. Unlike
		* other maps which only affect the light and shade of the material the
		* displaced vertices can cast shadows, block other objects, and otherwise
		* act as real geometry. The displacement texture is an image where the value
		* of each pixel (white being the highest) is mapped against, and
		* repositions, the vertices of the mesh.
		*
		* @type {?Texture}
		* @default null
		*/
		this.displacementMap = null;
		/**
		* How much the displacement map affects the mesh (where black is no
		* displacement, and white is maximum displacement). Without a displacement
		* map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementScale = 1;
		/**
		* The offset of the displacement map's values on the mesh's vertices.
		* The bias is added to the scaled sample of the displacement map.
		* Without a displacement map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementBias = 0;
		/**
		* The specular map value affects both how much the specular surface
		* highlight contributes and how much of the environment map affects the
		* surface.
		*
		* @type {?Texture}
		* @default null
		*/
		this.specularMap = null;
		/**
		* The alpha map is a grayscale texture that controls the opacity across the
		* surface (black: fully transparent; white: fully opaque).
		*
		* Only the color of the texture is used, ignoring the alpha channel if one
		* exists. For RGB and RGBA textures, the renderer will use the green channel
		* when sampling this texture due to the extra bit of precision provided for
		* green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		* luminance/alpha textures will also still work as expected.
		*
		* @type {?Texture}
		* @default null
		*/
		this.alphaMap = null;
		/**
		* The environment map.
		*
		* @type {?Texture}
		* @default null
		*/
		this.envMap = null;
		/**
		* The rotation of the environment map in radians.
		*
		* @type {Euler}
		* @default (0,0,0)
		*/
		this.envMapRotation = new Euler();
		/**
		* How to combine the result of the surface's color with the environment map, if any.
		*
		* When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
		* blend between the two colors.
		*
		* @type {(MultiplyOperation|MixOperation|AddOperation)}
		* @default MultiplyOperation
		*/
		this.combine = MultiplyOperation;
		/**
		* How much the environment map affects the surface.
		* The valid range is between `0` (no reflections) and `1` (full reflections).
		*
		* @type {number}
		* @default 1
		*/
		this.reflectivity = 1;
		/**
		* The index of refraction (IOR) of air (approximately 1) divided by the
		* index of refraction of the material. It is used with environment mapping
		* modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
		* The refraction ratio should not exceed `1`.
		*
		* @type {number}
		* @default 0.98
		*/
		this.refractionRatio = .98;
		/**
		* Renders the geometry as a wireframe.
		*
		* @type {boolean}
		* @default false
		*/
		this.wireframe = false;
		/**
		* Controls the thickness of the wireframe.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {number}
		* @default 1
		*/
		this.wireframeLinewidth = 1;
		/**
		* Defines appearance of wireframe ends.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.wireframeLinecap = "round";
		/**
		* Defines appearance of wireframe joints.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.wireframeLinejoin = "round";
		/**
		* Whether the material is rendered with flat shading or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.flatShading = false;
		/**
		* Whether the material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.specular.copy(source.specular);
		this.shininess = source.shininess;
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.envMapRotation.copy(source.envMapRotation);
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.flatShading = source.flatShading;
		this.fog = source.fog;
		return this;
	}
};
/**
* A material implementing toon shading.
*
* @augments Material
* @demo scenes/material-browser.html#MeshToonMaterial
*/
var MeshToonMaterial = class extends Material {
	/**
	* Constructs a new mesh toon material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshToonMaterial = true;
		this.defines = { "TOON": "" };
		this.type = "MeshToonMaterial";
		/**
		* Color of the material.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.color = new Color$1(16777215);
		/**
		* The color map. May optionally include an alpha channel, typically combined
		* with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		* color is modulated by the diffuse `color`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* Gradient map for toon shading. It's required to set
		* {@link Texture#minFilter} and {@link Texture#magFilter} to {@linkNearestFilter}
		* when using this type of texture.
		*
		* @type {?Texture}
		* @default null
		*/
		this.gradientMap = null;
		/**
		* The light map. Requires a second set of UVs.
		*
		* @type {?Texture}
		* @default null
		*/
		this.lightMap = null;
		/**
		* Intensity of the baked light.
		*
		* @type {number}
		* @default 1
		*/
		this.lightMapIntensity = 1;
		/**
		* The red channel of this texture is used as the ambient occlusion map.
		* Requires a second set of UVs.
		*
		* @type {?Texture}
		* @default null
		*/
		this.aoMap = null;
		/**
		* Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		* disables ambient occlusion. Where intensity is `1` and the AO map's
		* red channel is also `1`, ambient light is fully occluded on a surface.
		*
		* @type {number}
		* @default 1
		*/
		this.aoMapIntensity = 1;
		/**
		* Emissive (light) color of the material, essentially a solid color
		* unaffected by other lighting.
		*
		* @type {Color}
		* @default (0,0,0)
		*/
		this.emissive = new Color$1(0);
		/**
		* Intensity of the emissive light. Modulates the emissive color.
		*
		* @type {number}
		* @default 1
		*/
		this.emissiveIntensity = 1;
		/**
		* Set emissive (glow) map. The emissive map color is modulated by the
		* emissive color and the emissive intensity. If you have an emissive map,
		* be sure to set the emissive color to something other than black.
		*
		* @type {?Texture}
		* @default null
		*/
		this.emissiveMap = null;
		/**
		* The texture to create a bump map. The black and white values map to the
		* perceived depth in relation to the lights. Bump doesn't actually affect
		* the geometry of the object, only the lighting. If a normal map is defined
		* this will be ignored.
		*
		* @type {?Texture}
		* @default null
		*/
		this.bumpMap = null;
		/**
		* How much the bump map affects the material. Typical range is `[0,1]`.
		*
		* @type {number}
		* @default 1
		*/
		this.bumpScale = 1;
		/**
		* The texture to create a normal map. The RGB values affect the surface
		* normal for each pixel fragment and change the way the color is lit. Normal
		* maps do not change the actual shape of the surface, only the lighting. In
		* case the material has a normal map authored using the left handed
		* convention, the `y` component of `normalScale` should be negated to compensate
		* for the different handedness.
		*
		* @type {?Texture}
		* @default null
		*/
		this.normalMap = null;
		/**
		* The type of normal map.
		*
		* @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		* @default TangentSpaceNormalMap
		*/
		this.normalMapType = TangentSpaceNormalMap;
		/**
		* How much the normal map affects the material. Typical value range is `[0,1]`.
		*
		* @type {Vector2}
		* @default (1,1)
		*/
		this.normalScale = new Vector2(1, 1);
		/**
		* The displacement map affects the position of the mesh's vertices. Unlike
		* other maps which only affect the light and shade of the material the
		* displaced vertices can cast shadows, block other objects, and otherwise
		* act as real geometry. The displacement texture is an image where the value
		* of each pixel (white being the highest) is mapped against, and
		* repositions, the vertices of the mesh.
		*
		* @type {?Texture}
		* @default null
		*/
		this.displacementMap = null;
		/**
		* How much the displacement map affects the mesh (where black is no
		* displacement, and white is maximum displacement). Without a displacement
		* map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementScale = 1;
		/**
		* The offset of the displacement map's values on the mesh's vertices.
		* The bias is added to the scaled sample of the displacement map.
		* Without a displacement map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementBias = 0;
		/**
		* The alpha map is a grayscale texture that controls the opacity across the
		* surface (black: fully transparent; white: fully opaque).
		*
		* Only the color of the texture is used, ignoring the alpha channel if one
		* exists. For RGB and RGBA textures, the renderer will use the green channel
		* when sampling this texture due to the extra bit of precision provided for
		* green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		* luminance/alpha textures will also still work as expected.
		*
		* @type {?Texture}
		* @default null
		*/
		this.alphaMap = null;
		/**
		* Renders the geometry as a wireframe.
		*
		* @type {boolean}
		* @default false
		*/
		this.wireframe = false;
		/**
		* Controls the thickness of the wireframe.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {number}
		* @default 1
		*/
		this.wireframeLinewidth = 1;
		/**
		* Defines appearance of wireframe ends.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.wireframeLinecap = "round";
		/**
		* Defines appearance of wireframe joints.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.wireframeLinejoin = "round";
		/**
		* Whether the material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.gradientMap = source.gradientMap;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.alphaMap = source.alphaMap;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.fog = source.fog;
		return this;
	}
};
/**
* A material that maps the normal vectors to RGB colors.
*
* @augments Material
* @demo scenes/material-browser.html#MeshNormalMaterial
*/
var MeshNormalMaterial = class extends Material {
	/**
	* Constructs a new mesh normal material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshNormalMaterial = true;
		this.type = "MeshNormalMaterial";
		/**
		* The texture to create a bump map. The black and white values map to the
		* perceived depth in relation to the lights. Bump doesn't actually affect
		* the geometry of the object, only the lighting. If a normal map is defined
		* this will be ignored.
		*
		* @type {?Texture}
		* @default null
		*/
		this.bumpMap = null;
		/**
		* How much the bump map affects the material. Typical range is `[0,1]`.
		*
		* @type {number}
		* @default 1
		*/
		this.bumpScale = 1;
		/**
		* The texture to create a normal map. The RGB values affect the surface
		* normal for each pixel fragment and change the way the color is lit. Normal
		* maps do not change the actual shape of the surface, only the lighting. In
		* case the material has a normal map authored using the left handed
		* convention, the `y` component of `normalScale` should be negated to compensate
		* for the different handedness.
		*
		* @type {?Texture}
		* @default null
		*/
		this.normalMap = null;
		/**
		* The type of normal map.
		*
		* @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		* @default TangentSpaceNormalMap
		*/
		this.normalMapType = TangentSpaceNormalMap;
		/**
		* How much the normal map affects the material. Typical value range is `[0,1]`.
		*
		* @type {Vector2}
		* @default (1,1)
		*/
		this.normalScale = new Vector2(1, 1);
		/**
		* The displacement map affects the position of the mesh's vertices. Unlike
		* other maps which only affect the light and shade of the material the
		* displaced vertices can cast shadows, block other objects, and otherwise
		* act as real geometry. The displacement texture is an image where the value
		* of each pixel (white being the highest) is mapped against, and
		* repositions, the vertices of the mesh.
		*
		* @type {?Texture}
		* @default null
		*/
		this.displacementMap = null;
		/**
		* How much the displacement map affects the mesh (where black is no
		* displacement, and white is maximum displacement). Without a displacement
		* map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementScale = 1;
		/**
		* The offset of the displacement map's values on the mesh's vertices.
		* The bias is added to the scaled sample of the displacement map.
		* Without a displacement map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementBias = 0;
		/**
		* Renders the geometry as a wireframe.
		*
		* @type {boolean}
		* @default false
		*/
		this.wireframe = false;
		/**
		* Controls the thickness of the wireframe.
		*
		* WebGL and WebGPU ignore this property and always render
		* 1 pixel wide lines.
		*
		* @type {number}
		* @default 1
		*/
		this.wireframeLinewidth = 1;
		/**
		* Whether the material is rendered with flat shading or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.flatShading = false;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.flatShading = source.flatShading;
		return this;
	}
};
/**
* A material for non-shiny surfaces, without specular highlights.
*
* The material uses a non-physically based [Lambertian](https://en.wikipedia.org/wiki/Lambertian_reflectance)
* model for calculating reflectance. This can simulate some surfaces (such
* as untreated wood or stone) well, but cannot simulate shiny surfaces with
* specular highlights (such as varnished wood). `MeshLambertMaterial` uses per-fragment
* shading.
*
* Due to the simplicity of the reflectance and illumination models,
* performance will be greater when using this material over the
* {@link MeshPhongMaterial}, {@link MeshStandardMaterial} or
* {@link MeshPhysicalMaterial}, at the cost of some graphical accuracy.
*
* @augments Material
* @demo scenes/material-browser.html#MeshLambertMaterial
*/
var MeshLambertMaterial = class extends Material {
	/**
	* Constructs a new mesh lambert material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshLambertMaterial = true;
		this.type = "MeshLambertMaterial";
		/**
		* Color of the material.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.color = new Color$1(16777215);
		/**
		* The color map. May optionally include an alpha channel, typically combined
		* with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		* color is modulated by the diffuse `color`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* The light map. Requires a second set of UVs.
		*
		* @type {?Texture}
		* @default null
		*/
		this.lightMap = null;
		/**
		* Intensity of the baked light.
		*
		* @type {number}
		* @default 1
		*/
		this.lightMapIntensity = 1;
		/**
		* The red channel of this texture is used as the ambient occlusion map.
		* Requires a second set of UVs.
		*
		* @type {?Texture}
		* @default null
		*/
		this.aoMap = null;
		/**
		* Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		* disables ambient occlusion. Where intensity is `1` and the AO map's
		* red channel is also `1`, ambient light is fully occluded on a surface.
		*
		* @type {number}
		* @default 1
		*/
		this.aoMapIntensity = 1;
		/**
		* Emissive (light) color of the material, essentially a solid color
		* unaffected by other lighting.
		*
		* @type {Color}
		* @default (0,0,0)
		*/
		this.emissive = new Color$1(0);
		/**
		* Intensity of the emissive light. Modulates the emissive color.
		*
		* @type {number}
		* @default 1
		*/
		this.emissiveIntensity = 1;
		/**
		* Set emissive (glow) map. The emissive map color is modulated by the
		* emissive color and the emissive intensity. If you have an emissive map,
		* be sure to set the emissive color to something other than black.
		*
		* @type {?Texture}
		* @default null
		*/
		this.emissiveMap = null;
		/**
		* The texture to create a bump map. The black and white values map to the
		* perceived depth in relation to the lights. Bump doesn't actually affect
		* the geometry of the object, only the lighting. If a normal map is defined
		* this will be ignored.
		*
		* @type {?Texture}
		* @default null
		*/
		this.bumpMap = null;
		/**
		* How much the bump map affects the material. Typical range is `[0,1]`.
		*
		* @type {number}
		* @default 1
		*/
		this.bumpScale = 1;
		/**
		* The texture to create a normal map. The RGB values affect the surface
		* normal for each pixel fragment and change the way the color is lit. Normal
		* maps do not change the actual shape of the surface, only the lighting. In
		* case the material has a normal map authored using the left handed
		* convention, the `y` component of `normalScale` should be negated to compensate
		* for the different handedness.
		*
		* @type {?Texture}
		* @default null
		*/
		this.normalMap = null;
		/**
		* The type of normal map.
		*
		* @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		* @default TangentSpaceNormalMap
		*/
		this.normalMapType = TangentSpaceNormalMap;
		/**
		* How much the normal map affects the material. Typical value range is `[0,1]`.
		*
		* @type {Vector2}
		* @default (1,1)
		*/
		this.normalScale = new Vector2(1, 1);
		/**
		* The displacement map affects the position of the mesh's vertices. Unlike
		* other maps which only affect the light and shade of the material the
		* displaced vertices can cast shadows, block other objects, and otherwise
		* act as real geometry. The displacement texture is an image where the value
		* of each pixel (white being the highest) is mapped against, and
		* repositions, the vertices of the mesh.
		*
		* @type {?Texture}
		* @default null
		*/
		this.displacementMap = null;
		/**
		* How much the displacement map affects the mesh (where black is no
		* displacement, and white is maximum displacement). Without a displacement
		* map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementScale = 1;
		/**
		* The offset of the displacement map's values on the mesh's vertices.
		* The bias is added to the scaled sample of the displacement map.
		* Without a displacement map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementBias = 0;
		/**
		* Specular map used by the material.
		*
		* @type {?Texture}
		* @default null
		*/
		this.specularMap = null;
		/**
		* The alpha map is a grayscale texture that controls the opacity across the
		* surface (black: fully transparent; white: fully opaque).
		*
		* Only the color of the texture is used, ignoring the alpha channel if one
		* exists. For RGB and RGBA textures, the renderer will use the green channel
		* when sampling this texture due to the extra bit of precision provided for
		* green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		* luminance/alpha textures will also still work as expected.
		*
		* @type {?Texture}
		* @default null
		*/
		this.alphaMap = null;
		/**
		* The environment map.
		*
		* @type {?Texture}
		* @default null
		*/
		this.envMap = null;
		/**
		* The rotation of the environment map in radians.
		*
		* @type {Euler}
		* @default (0,0,0)
		*/
		this.envMapRotation = new Euler();
		/**
		* How to combine the result of the surface's color with the environment map, if any.
		*
		* When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
		* blend between the two colors.
		*
		* @type {(MultiplyOperation|MixOperation|AddOperation)}
		* @default MultiplyOperation
		*/
		this.combine = MultiplyOperation;
		/**
		* How much the environment map affects the surface.
		* The valid range is between `0` (no reflections) and `1` (full reflections).
		*
		* @type {number}
		* @default 1
		*/
		this.reflectivity = 1;
		/**
		* The index of refraction (IOR) of air (approximately 1) divided by the
		* index of refraction of the material. It is used with environment mapping
		* modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
		* The refraction ratio should not exceed `1`.
		*
		* @type {number}
		* @default 0.98
		*/
		this.refractionRatio = .98;
		/**
		* Renders the geometry as a wireframe.
		*
		* @type {boolean}
		* @default false
		*/
		this.wireframe = false;
		/**
		* Controls the thickness of the wireframe.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {number}
		* @default 1
		*/
		this.wireframeLinewidth = 1;
		/**
		* Defines appearance of wireframe ends.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.wireframeLinecap = "round";
		/**
		* Defines appearance of wireframe joints.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {('round'|'bevel'|'miter')}
		* @default 'round'
		*/
		this.wireframeLinejoin = "round";
		/**
		* Whether the material is rendered with flat shading or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.flatShading = false;
		/**
		* Whether the material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.envMapRotation.copy(source.envMapRotation);
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.flatShading = source.flatShading;
		this.fog = source.fog;
		return this;
	}
};
/**
* A material for drawing geometry by depth. Depth is based off of the camera
* near and far plane. White is nearest, black is farthest.
*
* @augments Material
* @demo scenes/material-browser.html#MeshDepthMaterial
*/
var MeshDepthMaterial = class extends Material {
	/**
	* Constructs a new mesh depth material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshDepthMaterial = true;
		this.type = "MeshDepthMaterial";
		/**
		* Type for depth packing.
		*
		* @type {(BasicDepthPacking|RGBADepthPacking|RGBDepthPacking|RGDepthPacking)}
		* @default BasicDepthPacking
		*/
		this.depthPacking = BasicDepthPacking;
		/**
		* The color map. May optionally include an alpha channel, typically combined
		* with {@link Material#transparent} or {@link Material#alphaTest}.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* The alpha map is a grayscale texture that controls the opacity across the
		* surface (black: fully transparent; white: fully opaque).
		*
		* Only the color of the texture is used, ignoring the alpha channel if one
		* exists. For RGB and RGBA textures, the renderer will use the green channel
		* when sampling this texture due to the extra bit of precision provided for
		* green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		* luminance/alpha textures will also still work as expected.
		*
		* @type {?Texture}
		* @default null
		*/
		this.alphaMap = null;
		/**
		* The displacement map affects the position of the mesh's vertices. Unlike
		* other maps which only affect the light and shade of the material the
		* displaced vertices can cast shadows, block other objects, and otherwise
		* act as real geometry. The displacement texture is an image where the value
		* of each pixel (white being the highest) is mapped against, and
		* repositions, the vertices of the mesh.
		*
		* @type {?Texture}
		* @default null
		*/
		this.displacementMap = null;
		/**
		* How much the displacement map affects the mesh (where black is no
		* displacement, and white is maximum displacement). Without a displacement
		* map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementScale = 1;
		/**
		* The offset of the displacement map's values on the mesh's vertices.
		* The bias is added to the scaled sample of the displacement map.
		* Without a displacement map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementBias = 0;
		/**
		* Renders the geometry as a wireframe.
		*
		* @type {boolean}
		* @default false
		*/
		this.wireframe = false;
		/**
		* Controls the thickness of the wireframe.
		*
		* WebGL and WebGPU ignore this property and always render
		* 1 pixel wide lines.
		*
		* @type {number}
		* @default 1
		*/
		this.wireframeLinewidth = 1;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.depthPacking = source.depthPacking;
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		return this;
	}
};
/**
* A material used internally for implementing shadow mapping with
* point lights.
*
* Can also be used to customize the shadow casting of an object by assigning
* an instance of `MeshDistanceMaterial` to {@link Object3D#customDistanceMaterial}.
* The following examples demonstrates this approach in order to ensure
* transparent parts of objects do not cast shadows.
*
* @augments Material
*/
var MeshDistanceMaterial = class extends Material {
	/**
	* Constructs a new mesh distance material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshDistanceMaterial = true;
		this.type = "MeshDistanceMaterial";
		/**
		* The color map. May optionally include an alpha channel, typically combined
		* with {@link Material#transparent} or {@link Material#alphaTest}.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* The alpha map is a grayscale texture that controls the opacity across the
		* surface (black: fully transparent; white: fully opaque).
		*
		* Only the color of the texture is used, ignoring the alpha channel if one
		* exists. For RGB and RGBA textures, the renderer will use the green channel
		* when sampling this texture due to the extra bit of precision provided for
		* green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		* luminance/alpha textures will also still work as expected.
		*
		* @type {?Texture}
		* @default null
		*/
		this.alphaMap = null;
		/**
		* The displacement map affects the position of the mesh's vertices. Unlike
		* other maps which only affect the light and shade of the material the
		* displaced vertices can cast shadows, block other objects, and otherwise
		* act as real geometry. The displacement texture is an image where the value
		* of each pixel (white being the highest) is mapped against, and
		* repositions, the vertices of the mesh.
		*
		* @type {?Texture}
		* @default null
		*/
		this.displacementMap = null;
		/**
		* How much the displacement map affects the mesh (where black is no
		* displacement, and white is maximum displacement). Without a displacement
		* map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementScale = 1;
		/**
		* The offset of the displacement map's values on the mesh's vertices.
		* The bias is added to the scaled sample of the displacement map.
		* Without a displacement map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementBias = 0;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		return this;
	}
};
/**
* This material is defined by a MatCap (or Lit Sphere) texture, which encodes the
* material color and shading.
*
* `MeshMatcapMaterial` does not respond to lights since the matcap image file encodes
* baked lighting. It will cast a shadow onto an object that receives shadows
* (and shadow clipping works), but it will not self-shadow or receive
* shadows.
*
* @augments Material
* @demo scenes/material-browser.html#MeshMatcapMaterial
*/
var MeshMatcapMaterial = class extends Material {
	/**
	* Constructs a new mesh matcap material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshMatcapMaterial = true;
		this.defines = { "MATCAP": "" };
		this.type = "MeshMatcapMaterial";
		/**
		* Color of the material.
		*
		* @type {Color}
		* @default (1,1,1)
		*/
		this.color = new Color$1(16777215);
		/**
		* The matcap map.
		*
		* @type {?Texture}
		* @default null
		*/
		this.matcap = null;
		/**
		* The color map. May optionally include an alpha channel, typically combined
		* with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		* color is modulated by the diffuse `color`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* The texture to create a bump map. The black and white values map to the
		* perceived depth in relation to the lights. Bump doesn't actually affect
		* the geometry of the object, only the lighting. If a normal map is defined
		* this will be ignored.
		*
		* @type {?Texture}
		* @default null
		*/
		this.bumpMap = null;
		/**
		* How much the bump map affects the material. Typical range is `[0,1]`.
		*
		* @type {number}
		* @default 1
		*/
		this.bumpScale = 1;
		/**
		* The texture to create a normal map. The RGB values affect the surface
		* normal for each pixel fragment and change the way the color is lit. Normal
		* maps do not change the actual shape of the surface, only the lighting. In
		* case the material has a normal map authored using the left handed
		* convention, the `y` component of `normalScale` should be negated to compensate
		* for the different handedness.
		*
		* @type {?Texture}
		* @default null
		*/
		this.normalMap = null;
		/**
		* The type of normal map.
		*
		* @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		* @default TangentSpaceNormalMap
		*/
		this.normalMapType = TangentSpaceNormalMap;
		/**
		* How much the normal map affects the material. Typical value range is `[0,1]`.
		*
		* @type {Vector2}
		* @default (1,1)
		*/
		this.normalScale = new Vector2(1, 1);
		/**
		* The displacement map affects the position of the mesh's vertices. Unlike
		* other maps which only affect the light and shade of the material the
		* displaced vertices can cast shadows, block other objects, and otherwise
		* act as real geometry. The displacement texture is an image where the value
		* of each pixel (white being the highest) is mapped against, and
		* repositions, the vertices of the mesh.
		*
		* @type {?Texture}
		* @default null
		*/
		this.displacementMap = null;
		/**
		* How much the displacement map affects the mesh (where black is no
		* displacement, and white is maximum displacement). Without a displacement
		* map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementScale = 1;
		/**
		* The offset of the displacement map's values on the mesh's vertices.
		* The bias is added to the scaled sample of the displacement map.
		* Without a displacement map set, this value is not applied.
		*
		* @type {number}
		* @default 0
		*/
		this.displacementBias = 0;
		/**
		* The alpha map is a grayscale texture that controls the opacity across the
		* surface (black: fully transparent; white: fully opaque).
		*
		* Only the color of the texture is used, ignoring the alpha channel if one
		* exists. For RGB and RGBA textures, the renderer will use the green channel
		* when sampling this texture due to the extra bit of precision provided for
		* green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		* luminance/alpha textures will also still work as expected.
		*
		* @type {?Texture}
		* @default null
		*/
		this.alphaMap = null;
		/**
		* Renders the geometry as a wireframe.
		*
		* @type {boolean}
		* @default false
		*/
		this.wireframe = false;
		/**
		* Controls the thickness of the wireframe.
		*
		* Can only be used with {@link SVGRenderer}.
		*
		* @type {number}
		* @default 1
		*/
		this.wireframeLinewidth = 1;
		/**
		* Whether the material is rendered with flat shading or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.flatShading = false;
		/**
		* Whether the material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.defines = { "MATCAP": "" };
		this.color.copy(source.color);
		this.matcap = source.matcap;
		this.map = source.map;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.alphaMap = source.alphaMap;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.flatShading = source.flatShading;
		this.fog = source.fog;
		return this;
	}
};
/**
* A material for rendering line primitives.
*
* Materials define the appearance of renderable 3D objects.
*
* ```js
* const material = new THREE.LineDashedMaterial( {
* 	color: 0xffffff,
* 	scale: 1,
* 	dashSize: 3,
* 	gapSize: 1,
* } );
* ```
*
* @augments LineBasicMaterial
*/
var LineDashedMaterial = class extends LineBasicMaterial {
	/**
	* Constructs a new line dashed material.
	*
	* @param {Object} [parameters] - An object with one or more properties
	* defining the material's appearance. Any property of the material
	* (including any property from inherited materials) can be passed
	* in here. Color values can be passed any type of value accepted
	* by {@link Color#set}.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isLineDashedMaterial = true;
		this.type = "LineDashedMaterial";
		/**
		* The scale of the dashed part of a line.
		*
		* @type {number}
		* @default 1
		*/
		this.scale = 1;
		/**
		* The size of the dash. This is both the gap with the stroke.
		*
		* @type {number}
		* @default 3
		*/
		this.dashSize = 3;
		/**
		* The size of the gap.
		*
		* @type {number}
		* @default 1
		*/
		this.gapSize = 1;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;
		return this;
	}
};
/**
* Converts an array to a specific type.
*
* @param {TypedArray|Array} array - The array to convert.
* @param {TypedArray.constructor} type - The constructor of a typed array that defines the new type.
* @return {TypedArray} The converted array.
*/
function convertArray(array$2, type$1) {
	if (!array$2 || array$2.constructor === type$1) return array$2;
	if (typeof type$1.BYTES_PER_ELEMENT === "number") return new type$1(array$2);
	return Array.prototype.slice.call(array$2);
}
/**
* Returns `true` if the given object is a typed array.
*
* @param {any} object - The object to check.
* @return {boolean} Whether the given object is a typed array.
*/
function isTypedArray(object) {
	return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
/**
* Abstract base class of interpolants over parametric samples.
*
* The parameter domain is one dimensional, typically the time or a path
* along a curve defined by the data.
*
* The sample values can have any dimensionality and derived classes may
* apply special interpretations to the data.
*
* This class provides the interval seek in a Template Method, deferring
* the actual interpolation to derived classes.
*
* Time complexity is O(1) for linear access crossing at most two points
* and O(log N) for random access, where N is the number of positions.
*
* References: {@link http://www.oodesign.com/template-method-pattern.html}
*
* @abstract
*/
var Interpolant = class {
	/**
	* Constructs a new interpolant.
	*
	* @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
	* @param {TypedArray} sampleValues - The sample values.
	* @param {number} sampleSize - The sample size
	* @param {TypedArray} [resultBuffer] - The result buffer.
	*/
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		/**
		* The parameter positions.
		*
		* @type {TypedArray}
		*/
		this.parameterPositions = parameterPositions;
		/**
		* A cache index.
		*
		* @private
		* @type {number}
		* @default 0
		*/
		this._cachedIndex = 0;
		/**
		* The result buffer.
		*
		* @type {TypedArray}
		*/
		this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
		/**
		* The sample values.
		*
		* @type {TypedArray}
		*/
		this.sampleValues = sampleValues;
		/**
		* The value size.
		*
		* @type {TypedArray}
		*/
		this.valueSize = sampleSize;
		/**
		* The interpolation settings.
		*
		* @type {?Object}
		* @default null
		*/
		this.settings = null;
		/**
		* The default settings object.
		*
		* @type {Object}
		*/
		this.DefaultSettings_ = {};
	}
	/**
	* Evaluate the interpolant at position `t`.
	*
	* @param {number} t - The interpolation factor.
	* @return {TypedArray} The result buffer.
	*/
	evaluate(t) {
		const pp = this.parameterPositions;
		let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
		validate_interval: {
			seek: {
				let right;
				linear_scan: {
					forward_scan: if (!(t < t1)) {
						for (let giveUpAt = i1 + 2;;) {
							if (t1 === void 0) {
								if (t < t0) break forward_scan;
								i1 = pp.length;
								this._cachedIndex = i1;
								return this.copySampleValue_(i1 - 1);
							}
							if (i1 === giveUpAt) break;
							t0 = t1;
							t1 = pp[++i1];
							if (t < t1) break seek;
						}
						right = pp.length;
						break linear_scan;
					}
					if (!(t >= t0)) {
						const t1global = pp[1];
						if (t < t1global) {
							i1 = 2;
							t0 = t1global;
						}
						for (let giveUpAt = i1 - 2;;) {
							if (t0 === void 0) {
								this._cachedIndex = 0;
								return this.copySampleValue_(0);
							}
							if (i1 === giveUpAt) break;
							t1 = t0;
							t0 = pp[--i1 - 1];
							if (t >= t0) break seek;
						}
						right = i1;
						i1 = 0;
						break linear_scan;
					}
					break validate_interval;
				}
				while (i1 < right) {
					const mid = i1 + right >>> 1;
					if (t < pp[mid]) right = mid;
					else i1 = mid + 1;
				}
				t1 = pp[i1];
				t0 = pp[i1 - 1];
				if (t0 === void 0) {
					this._cachedIndex = 0;
					return this.copySampleValue_(0);
				}
				if (t1 === void 0) {
					i1 = pp.length;
					this._cachedIndex = i1;
					return this.copySampleValue_(i1 - 1);
				}
			}
			this._cachedIndex = i1;
			this.intervalChanged_(i1, t0, t1);
		}
		return this.interpolate_(i1, t0, t, t1);
	}
	/**
	* Returns the interpolation settings.
	*
	* @return {Object} The interpolation settings.
	*/
	getSettings_() {
		return this.settings || this.DefaultSettings_;
	}
	/**
	* Copies a sample value to the result buffer.
	*
	* @param {number} index - An index into the sample value buffer.
	* @return {TypedArray} The result buffer.
	*/
	copySampleValue_(index) {
		const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
		for (let i = 0; i !== stride; ++i) result[i] = values[offset + i];
		return result;
	}
	/**
	* Copies a sample value to the result buffer.
	*
	* @abstract
	* @param {number} i1 - An index into the sample value buffer.
	* @param {number} t0 - The previous interpolation factor.
	* @param {number} t - The current interpolation factor.
	* @param {number} t1 - The next interpolation factor.
	* @return {TypedArray} The result buffer.
	*/
	interpolate_() {
		throw new Error("call to abstract method");
	}
	/**
	* Optional method that is executed when the interval has changed.
	*
	* @param {number} i1 - An index into the sample value buffer.
	* @param {number} t0 - The previous interpolation factor.
	* @param {number} t - The current interpolation factor.
	*/
	intervalChanged_() {}
};
/**
* Fast and simple cubic spline interpolant.
*
* It was derived from a Hermitian construction setting the first derivative
* at each sample position to the linear slope between neighboring positions
* over their parameter interval.
*
* @augments Interpolant
*/
var CubicInterpolant = class extends Interpolant {
	/**
	* Constructs a new cubic interpolant.
	*
	* @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
	* @param {TypedArray} sampleValues - The sample values.
	* @param {number} sampleSize - The sample size
	* @param {TypedArray} [resultBuffer] - The result buffer.
	*/
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		this._weightPrev = -0;
		this._offsetPrev = -0;
		this._weightNext = -0;
		this._offsetNext = -0;
		this.DefaultSettings_ = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};
	}
	intervalChanged_(i1, t0, t1) {
		const pp = this.parameterPositions;
		let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
		if (tPrev === void 0) switch (this.getSettings_().endingStart) {
			case ZeroSlopeEnding:
				iPrev = i1;
				tPrev = 2 * t0 - t1;
				break;
			case WrapAroundEnding:
				iPrev = pp.length - 2;
				tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
				break;
			default:
				iPrev = i1;
				tPrev = t1;
		}
		if (tNext === void 0) switch (this.getSettings_().endingEnd) {
			case ZeroSlopeEnding:
				iNext = i1;
				tNext = 2 * t1 - t0;
				break;
			case WrapAroundEnding:
				iNext = 1;
				tNext = t1 + pp[1] - pp[0];
				break;
			default:
				iNext = i1 - 1;
				tNext = t0;
		}
		const halfDt = (t1 - t0) * .5, stride = this.valueSize;
		this._weightPrev = halfDt / (t0 - tPrev);
		this._weightNext = halfDt / (tNext - t1);
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;
	}
	interpolate_(i1, t0, t, t1) {
		const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p$1 = (t - t0) / (t1 - t0), pp = p$1 * p$1, ppp = pp * p$1;
		const sP = -wP * ppp + 2 * wP * pp - wP * p$1;
		const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-.5 + wP) * p$1 + 1;
		const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + .5 * p$1;
		const sN = wN * ppp - wN * pp;
		for (let i = 0; i !== stride; ++i) result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
		return result;
	}
};
/**
* A basic linear interpolant.
*
* @augments Interpolant
*/
var LinearInterpolant = class extends Interpolant {
	/**
	* Constructs a new linear interpolant.
	*
	* @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
	* @param {TypedArray} sampleValues - The sample values.
	* @param {number} sampleSize - The sample size
	* @param {TypedArray} [resultBuffer] - The result buffer.
	*/
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer);
	}
	interpolate_(i1, t0, t, t1) {
		const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
		for (let i = 0; i !== stride; ++i) result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
		return result;
	}
};
/**
* Interpolant that evaluates to the sample value at the position preceding
* the parameter.
*
* @augments Interpolant
*/
var DiscreteInterpolant = class extends Interpolant {
	/**
	* Constructs a new discrete interpolant.
	*
	* @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
	* @param {TypedArray} sampleValues - The sample values.
	* @param {number} sampleSize - The sample size
	* @param {TypedArray} [resultBuffer] - The result buffer.
	*/
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer);
	}
	interpolate_(i1) {
		return this.copySampleValue_(i1 - 1);
	}
};
/**
* Represents s a timed sequence of keyframes, which are composed of lists of
* times and related values, and which are used to animate a specific property
* of an object.
*/
var KeyframeTrack = class {
	/**
	* Constructs a new keyframe track.
	*
	* @param {string} name - The keyframe track's name.
	* @param {Array<number>} times - A list of keyframe times.
	* @param {Array<number|string|boolean>} values - A list of keyframe values.
	* @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	*/
	constructor(name, times, values, interpolation$1) {
		if (name === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
		if (times === void 0 || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
		/**
		* The track's name can refer to morph targets or bones or
		* possibly other values within an animated object. See {@link PropertyBinding#parseTrackName}
		* for the forms of strings that can be parsed for property binding.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* The keyframe times.
		*
		* @type {Float32Array}
		*/
		this.times = convertArray(times, this.TimeBufferType);
		/**
		* The keyframe values.
		*
		* @type {Float32Array}
		*/
		this.values = convertArray(values, this.ValueBufferType);
		this.setInterpolation(interpolation$1 || this.DefaultInterpolation);
	}
	/**
	* Converts the keyframe track to JSON.
	*
	* @static
	* @param {KeyframeTrack} track - The keyframe track to serialize.
	* @return {Object} The serialized keyframe track as JSON.
	*/
	static toJSON(track) {
		const trackType = track.constructor;
		let json;
		if (trackType.toJSON !== this.toJSON) json = trackType.toJSON(track);
		else {
			json = {
				"name": track.name,
				"times": convertArray(track.times, Array),
				"values": convertArray(track.values, Array)
			};
			const interpolation$1 = track.getInterpolation();
			if (interpolation$1 !== track.DefaultInterpolation) json.interpolation = interpolation$1;
		}
		json.type = track.ValueTypeName;
		return json;
	}
	/**
	* Factory method for creating a new discrete interpolant.
	*
	* @static
	* @param {TypedArray} [result] - The result buffer.
	* @return {DiscreteInterpolant} The new interpolant.
	*/
	InterpolantFactoryMethodDiscrete(result) {
		return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
	}
	/**
	* Factory method for creating a new linear interpolant.
	*
	* @static
	* @param {TypedArray} [result] - The result buffer.
	* @return {LinearInterpolant} The new interpolant.
	*/
	InterpolantFactoryMethodLinear(result) {
		return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
	}
	/**
	* Factory method for creating a new smooth interpolant.
	*
	* @static
	* @param {TypedArray} [result] - The result buffer.
	* @return {CubicInterpolant} The new interpolant.
	*/
	InterpolantFactoryMethodSmooth(result) {
		return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
	}
	/**
	* Defines the interpolation factor method for this keyframe track.
	*
	* @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.
	* @return {KeyframeTrack} A reference to this keyframe track.
	*/
	setInterpolation(interpolation$1) {
		let factoryMethod;
		switch (interpolation$1) {
			case InterpolateDiscrete:
				factoryMethod = this.InterpolantFactoryMethodDiscrete;
				break;
			case InterpolateLinear:
				factoryMethod = this.InterpolantFactoryMethodLinear;
				break;
			case InterpolateSmooth:
				factoryMethod = this.InterpolantFactoryMethodSmooth;
				break;
		}
		if (factoryMethod === void 0) {
			const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
			if (this.createInterpolant === void 0) if (interpolation$1 !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
			else throw new Error(message);
			warn("KeyframeTrack:", message);
			return this;
		}
		this.createInterpolant = factoryMethod;
		return this;
	}
	/**
	* Returns the current interpolation type.
	*
	* @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.
	*/
	getInterpolation() {
		switch (this.createInterpolant) {
			case this.InterpolantFactoryMethodDiscrete: return InterpolateDiscrete;
			case this.InterpolantFactoryMethodLinear: return InterpolateLinear;
			case this.InterpolantFactoryMethodSmooth: return InterpolateSmooth;
		}
	}
	/**
	* Returns the value size.
	*
	* @return {number} The value size.
	*/
	getValueSize() {
		return this.values.length / this.times.length;
	}
	/**
	* Moves all keyframes either forward or backward in time.
	*
	* @param {number} timeOffset - The offset to move the time values.
	* @return {KeyframeTrack} A reference to this keyframe track.
	*/
	shift(timeOffset) {
		if (timeOffset !== 0) {
			const times = this.times;
			for (let i = 0, n$2 = times.length; i !== n$2; ++i) times[i] += timeOffset;
		}
		return this;
	}
	/**
	* Scale all keyframe times by a factor (useful for frame - seconds conversions).
	*
	* @param {number} timeScale - The time scale.
	* @return {KeyframeTrack} A reference to this keyframe track.
	*/
	scale(timeScale) {
		if (timeScale !== 1) {
			const times = this.times;
			for (let i = 0, n$2 = times.length; i !== n$2; ++i) times[i] *= timeScale;
		}
		return this;
	}
	/**
	* Removes keyframes before and after animation without changing any values within the defined time range.
	*
	* Note: The method does not shift around keys to the start of the track time, because for interpolated
	* keys this will change their values
	*
	* @param {number} startTime - The start time.
	* @param {number} endTime - The end time.
	* @return {KeyframeTrack} A reference to this keyframe track.
	*/
	trim(startTime, endTime) {
		const times = this.times, nKeys = times.length;
		let from = 0, to$1 = nKeys - 1;
		while (from !== nKeys && times[from] < startTime) ++from;
		while (to$1 !== -1 && times[to$1] > endTime) --to$1;
		++to$1;
		if (from !== 0 || to$1 !== nKeys) {
			if (from >= to$1) {
				to$1 = Math.max(to$1, 1);
				from = to$1 - 1;
			}
			const stride = this.getValueSize();
			this.times = times.slice(from, to$1);
			this.values = this.values.slice(from * stride, to$1 * stride);
		}
		return this;
	}
	/**
	* Performs minimal validation on the keyframe track. Returns `true` if the values
	* are valid.
	*
	* @return {boolean} Whether the keyframes are valid or not.
	*/
	validate() {
		let valid = true;
		const valueSize = this.getValueSize();
		if (valueSize - Math.floor(valueSize) !== 0) {
			error("KeyframeTrack: Invalid value size in track.", this);
			valid = false;
		}
		const times = this.times, values = this.values, nKeys = times.length;
		if (nKeys === 0) {
			error("KeyframeTrack: Track is empty.", this);
			valid = false;
		}
		let prevTime = null;
		for (let i = 0; i !== nKeys; i++) {
			const currTime = times[i];
			if (typeof currTime === "number" && isNaN(currTime)) {
				error("KeyframeTrack: Time is not a valid number.", this, i, currTime);
				valid = false;
				break;
			}
			if (prevTime !== null && prevTime > currTime) {
				error("KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
				valid = false;
				break;
			}
			prevTime = currTime;
		}
		if (values !== void 0) {
			if (isTypedArray(values)) for (let i = 0, n$2 = values.length; i !== n$2; ++i) {
				const value = values[i];
				if (isNaN(value)) {
					error("KeyframeTrack: Value is not a valid number.", this, i, value);
					valid = false;
					break;
				}
			}
		}
		return valid;
	}
	/**
	* Optimizes this keyframe track by removing equivalent sequential keys (which are
	* common in morph target sequences).
	*
	* @return {AnimationClip} A reference to this animation clip.
	*/
	optimize() {
		const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
		let writeIndex = 1;
		for (let i = 1; i < lastIndex; ++i) {
			let keep = false;
			const time$2 = times[i];
			const timeNext = times[i + 1];
			if (time$2 !== timeNext && (i !== 1 || time$2 !== times[0])) if (!smoothInterpolation) {
				const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
				for (let j = 0; j !== stride; ++j) {
					const value = values[offset + j];
					if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
						keep = true;
						break;
					}
				}
			} else keep = true;
			if (keep) {
				if (i !== writeIndex) {
					times[writeIndex] = times[i];
					const readOffset = i * stride, writeOffset = writeIndex * stride;
					for (let j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
				}
				++writeIndex;
			}
		}
		if (lastIndex > 0) {
			times[writeIndex] = times[lastIndex];
			for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
			++writeIndex;
		}
		if (writeIndex !== times.length) {
			this.times = times.slice(0, writeIndex);
			this.values = values.slice(0, writeIndex * stride);
		} else {
			this.times = times;
			this.values = values;
		}
		return this;
	}
	/**
	* Returns a new keyframe track with copied values from this instance.
	*
	* @return {KeyframeTrack} A clone of this instance.
	*/
	clone() {
		const times = this.times.slice();
		const values = this.values.slice();
		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack(this.name, times, values);
		track.createInterpolant = this.createInterpolant;
		return track;
	}
};
/**
* The value type name.
*
* @type {String}
* @default ''
*/
KeyframeTrack.prototype.ValueTypeName = "";
/**
* The time buffer type of this keyframe track.
*
* @type {TypedArray|Array}
* @default Float32Array.constructor
*/
KeyframeTrack.prototype.TimeBufferType = Float32Array;
/**
* The value buffer type of this keyframe track.
*
* @type {TypedArray|Array}
* @default Float32Array.constructor
*/
KeyframeTrack.prototype.ValueBufferType = Float32Array;
/**
* The default interpolation type of this keyframe track.
*
* @type {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)}
* @default InterpolateLinear
*/
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
/**
* A track for boolean keyframe values.
*
* @augments KeyframeTrack
*/
var BooleanKeyframeTrack = class extends KeyframeTrack {
	/**
	* Constructs a new boolean keyframe track.
	*
	* This keyframe track type has no `interpolation` parameter because the
	* interpolation is always discrete.
	*
	* @param {string} name - The keyframe track's name.
	* @param {Array<number>} times - A list of keyframe times.
	* @param {Array<boolean>} values - A list of keyframe values.
	*/
	constructor(name, times, values) {
		super(name, times, values);
	}
};
/**
* The value type name.
*
* @type {String}
* @default 'bool'
*/
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
/**
* The value buffer type of this keyframe track.
*
* @type {TypedArray|Array}
* @default Array.constructor
*/
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
/**
* The default interpolation type of this keyframe track.
*
* @type {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)}
* @default InterpolateDiscrete
*/
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
/**
* A track for color keyframe values.
*
* @augments KeyframeTrack
*/
var ColorKeyframeTrack = class extends KeyframeTrack {
	/**
	* Constructs a new color keyframe track.
	*
	* @param {string} name - The keyframe track's name.
	* @param {Array<number>} times - A list of keyframe times.
	* @param {Array<number>} values - A list of keyframe values.
	* @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	*/
	constructor(name, times, values, interpolation$1) {
		super(name, times, values, interpolation$1);
	}
};
/**
* The value type name.
*
* @type {String}
* @default 'color'
*/
ColorKeyframeTrack.prototype.ValueTypeName = "color";
/**
* A track for numeric keyframe values.
*
* @augments KeyframeTrack
*/
var NumberKeyframeTrack = class extends KeyframeTrack {
	/**
	* Constructs a new number keyframe track.
	*
	* @param {string} name - The keyframe track's name.
	* @param {Array<number>} times - A list of keyframe times.
	* @param {Array<number>} values - A list of keyframe values.
	* @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	*/
	constructor(name, times, values, interpolation$1) {
		super(name, times, values, interpolation$1);
	}
};
/**
* The value type name.
*
* @type {String}
* @default 'number'
*/
NumberKeyframeTrack.prototype.ValueTypeName = "number";
/**
* Spherical linear unit quaternion interpolant.
*
* @augments Interpolant
*/
var QuaternionLinearInterpolant = class extends Interpolant {
	/**
	* Constructs a new SLERP interpolant.
	*
	* @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
	* @param {TypedArray} sampleValues - The sample values.
	* @param {number} sampleSize - The sample size
	* @param {TypedArray} [resultBuffer] - The result buffer.
	*/
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer);
	}
	interpolate_(i1, t0, t, t1) {
		const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
		let offset = i1 * stride;
		for (let end = offset + stride; offset !== end; offset += 4) Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
		return result;
	}
};
/**
* A track for Quaternion keyframe values.
*
* @augments KeyframeTrack
*/
var QuaternionKeyframeTrack = class extends KeyframeTrack {
	/**
	* Constructs a new Quaternion keyframe track.
	*
	* @param {string} name - The keyframe track's name.
	* @param {Array<number>} times - A list of keyframe times.
	* @param {Array<number>} values - A list of keyframe values.
	* @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	*/
	constructor(name, times, values, interpolation$1) {
		super(name, times, values, interpolation$1);
	}
	/**
	* Overwritten so the method returns Quaternion based interpolant.
	*
	* @static
	* @param {TypedArray} [result] - The result buffer.
	* @return {QuaternionLinearInterpolant} The new interpolant.
	*/
	InterpolantFactoryMethodLinear(result) {
		return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
	}
};
/**
* The value type name.
*
* @type {String}
* @default 'quaternion'
*/
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
/**
* A track for string keyframe values.
*
* @augments KeyframeTrack
*/
var StringKeyframeTrack = class extends KeyframeTrack {
	/**
	* Constructs a new string keyframe track.
	*
	* This keyframe track type has no `interpolation` parameter because the
	* interpolation is always discrete.
	*
	* @param {string} name - The keyframe track's name.
	* @param {Array<number>} times - A list of keyframe times.
	* @param {Array<string>} values - A list of keyframe values.
	*/
	constructor(name, times, values) {
		super(name, times, values);
	}
};
/**
* The value type name.
*
* @type {String}
* @default 'string'
*/
StringKeyframeTrack.prototype.ValueTypeName = "string";
/**
* The value buffer type of this keyframe track.
*
* @type {TypedArray|Array}
* @default Array.constructor
*/
StringKeyframeTrack.prototype.ValueBufferType = Array;
/**
* The default interpolation type of this keyframe track.
*
* @type {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)}
* @default InterpolateDiscrete
*/
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
/**
* A track for vector keyframe values.
*
* @augments KeyframeTrack
*/
var VectorKeyframeTrack = class extends KeyframeTrack {
	/**
	* Constructs a new vector keyframe track.
	*
	* @param {string} name - The keyframe track's name.
	* @param {Array<number>} times - A list of keyframe times.
	* @param {Array<number>} values - A list of keyframe values.
	* @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	*/
	constructor(name, times, values, interpolation$1) {
		super(name, times, values, interpolation$1);
	}
};
/**
* The value type name.
*
* @type {String}
* @default 'vector'
*/
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
/**
* @class
* @classdesc A simple caching system, used internally by {@link FileLoader}.
* To enable caching across all loaders that use {@link FileLoader}, add `THREE.Cache.enabled = true.` once in your app.
* @hideconstructor
*/
var Cache = {
	enabled: false,
	files: {},
	add: function(key, file) {
		if (this.enabled === false) return;
		this.files[key] = file;
	},
	get: function(key) {
		if (this.enabled === false) return;
		return this.files[key];
	},
	remove: function(key) {
		delete this.files[key];
	},
	clear: function() {
		this.files = {};
	}
};
/**
* Handles and keeps track of loaded and pending data. A default global
* instance of this class is created and used by loaders if not supplied
* manually.
*
* In general that should be sufficient, however there are times when it can
* be useful to have separate loaders - for example if you want to show
* separate loading bars for objects and textures.
*
* ```js
* const manager = new THREE.LoadingManager();
* manager.onLoad = () => console.log( 'Loading complete!' );
*
* const loader1 = new OBJLoader( manager );
* const loader2 = new ColladaLoader( manager );
* ```
*/
var LoadingManager = class {
	/**
	* Constructs a new loading manager.
	*
	* @param {Function} [onLoad] - Executes when all items have been loaded.
	* @param {Function} [onProgress] - Executes when single items have been loaded.
	* @param {Function} [onError] - Executes when an error occurs.
	*/
	constructor(onLoad, onProgress, onError) {
		const scope = this;
		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = void 0;
		const handlers = [];
		/**
		* Executes when an item starts loading.
		*
		* @type {Function|undefined}
		* @default undefined
		*/
		this.onStart = void 0;
		/**
		* Executes when all items have been loaded.
		*
		* @type {Function|undefined}
		* @default undefined
		*/
		this.onLoad = onLoad;
		/**
		* Executes when single items have been loaded.
		*
		* @type {Function|undefined}
		* @default undefined
		*/
		this.onProgress = onProgress;
		/**
		* Executes when an error occurs.
		*
		* @type {Function|undefined}
		* @default undefined
		*/
		this.onError = onError;
		/**
		* Used for aborting ongoing requests in loaders using this manager.
		*
		* @private
		* @type {AbortController | null}
		*/
		this._abortController = null;
		/**
		* This should be called by any loader using the manager when the loader
		* starts loading an item.
		*
		* @param {string} url - The URL to load.
		*/
		this.itemStart = function(url) {
			itemsTotal++;
			if (isLoading === false) {
				if (scope.onStart !== void 0) scope.onStart(url, itemsLoaded, itemsTotal);
			}
			isLoading = true;
		};
		/**
		* This should be called by any loader using the manager when the loader
		* ended loading an item.
		*
		* @param {string} url - The URL of the loaded item.
		*/
		this.itemEnd = function(url) {
			itemsLoaded++;
			if (scope.onProgress !== void 0) scope.onProgress(url, itemsLoaded, itemsTotal);
			if (itemsLoaded === itemsTotal) {
				isLoading = false;
				if (scope.onLoad !== void 0) scope.onLoad();
			}
		};
		/**
		* This should be called by any loader using the manager when the loader
		* encounters an error when loading an item.
		*
		* @param {string} url - The URL of the item that produces an error.
		*/
		this.itemError = function(url) {
			if (scope.onError !== void 0) scope.onError(url);
		};
		/**
		* Given a URL, uses the URL modifier callback (if any) and returns a
		* resolved URL. If no URL modifier is set, returns the original URL.
		*
		* @param {string} url - The URL to load.
		* @return {string} The resolved URL.
		*/
		this.resolveURL = function(url) {
			if (urlModifier) return urlModifier(url);
			return url;
		};
		/**
		* If provided, the callback will be passed each resource URL before a
		* request is sent. The callback may return the original URL, or a new URL to
		* override loading behavior. This behavior can be used to load assets from
		* .ZIP files, drag-and-drop APIs, and Data URIs.
		*
		* ```js
		* const blobs = {'fish.gltf': blob1, 'diffuse.png': blob2, 'normal.png': blob3};
		*
		* const manager = new THREE.LoadingManager();
		*
		* // Initialize loading manager with URL callback.
		* const objectURLs = [];
		* manager.setURLModifier( ( url ) => {
		*
		* 	url = URL.createObjectURL( blobs[ url ] );
		* 	objectURLs.push( url );
		* 	return url;
		*
		* } );
		*
		* // Load as usual, then revoke the blob URLs.
		* const loader = new GLTFLoader( manager );
		* loader.load( 'fish.gltf', (gltf) => {
		*
		* 	scene.add( gltf.scene );
		* 	objectURLs.forEach( ( url ) => URL.revokeObjectURL( url ) );
		*
		* } );
		* ```
		*
		* @param {function(string):string} transform - URL modifier callback. Called with an URL and must return a resolved URL.
		* @return {LoadingManager} A reference to this loading manager.
		*/
		this.setURLModifier = function(transform) {
			urlModifier = transform;
			return this;
		};
		/**
		* Registers a loader with the given regular expression. Can be used to
		* define what loader should be used in order to load specific files. A
		* typical use case is to overwrite the default loader for textures.
		*
		* ```js
		* // add handler for TGA textures
		* manager.addHandler( /\.tga$/i, new TGALoader() );
		* ```
		*
		* @param {string} regex - A regular expression.
		* @param {Loader} loader - A loader that should handle matched cases.
		* @return {LoadingManager} A reference to this loading manager.
		*/
		this.addHandler = function(regex, loader) {
			handlers.push(regex, loader);
			return this;
		};
		/**
		* Removes the loader for the given regular expression.
		*
		* @param {string} regex - A regular expression.
		* @return {LoadingManager} A reference to this loading manager.
		*/
		this.removeHandler = function(regex) {
			const index = handlers.indexOf(regex);
			if (index !== -1) handlers.splice(index, 2);
			return this;
		};
		/**
		* Can be used to retrieve the registered loader for the given file path.
		*
		* @param {string} file - The file path.
		* @return {?Loader} The registered loader. Returns `null` if no loader was found.
		*/
		this.getHandler = function(file) {
			for (let i = 0, l = handlers.length; i < l; i += 2) {
				const regex = handlers[i];
				const loader = handlers[i + 1];
				if (regex.global) regex.lastIndex = 0;
				if (regex.test(file)) return loader;
			}
			return null;
		};
		/**
		* Can be used to abort ongoing loading requests in loaders using this manager.
		* The abort only works if the loaders implement {@link Loader#abort} and `AbortSignal.any()`
		* is supported in the browser.
		*
		* @return {LoadingManager} A reference to this loading manager.
		*/
		this.abort = function() {
			this.abortController.abort();
			this._abortController = null;
			return this;
		};
	}
	/**
	* Used for aborting ongoing requests in loaders using this manager.
	*
	* @type {AbortController}
	*/
	get abortController() {
		if (!this._abortController) this._abortController = new AbortController();
		return this._abortController;
	}
};
/**
* The global default loading manager.
*
* @constant
* @type {LoadingManager}
*/
var DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
/**
* Abstract base class for loaders.
*
* @abstract
*/
var Loader = class {
	/**
	* Constructs a new loader.
	*
	* @param {LoadingManager} [manager] - The loading manager.
	*/
	constructor(manager) {
		/**
		* The loading manager.
		*
		* @type {LoadingManager}
		* @default DefaultLoadingManager
		*/
		this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
		/**
		* The crossOrigin string to implement CORS for loading the url from a
		* different domain that allows CORS.
		*
		* @type {string}
		* @default 'anonymous'
		*/
		this.crossOrigin = "anonymous";
		/**
		* Whether the XMLHttpRequest uses credentials.
		*
		* @type {boolean}
		* @default false
		*/
		this.withCredentials = false;
		/**
		* The base path from which the asset will be loaded.
		*
		* @type {string}
		*/
		this.path = "";
		/**
		* The base path from which additional resources like textures will be loaded.
		*
		* @type {string}
		*/
		this.resourcePath = "";
		/**
		* The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header)
		* used in HTTP request.
		*
		* @type {Object<string, any>}
		*/
		this.requestHeader = {};
	}
	/**
	* This method needs to be implemented by all concrete loaders. It holds the
	* logic for loading assets from the backend.
	*
	* @abstract
	* @param {string} url - The path/URL of the file to be loaded.
	* @param {Function} onLoad - Executed when the loading process has been finished.
	* @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
	* @param {onErrorCallback} [onError] - Executed when errors occur.
	*/
	load() {}
	/**
	* A async version of {@link Loader#load}.
	*
	* @param {string} url - The path/URL of the file to be loaded.
	* @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
	* @return {Promise} A Promise that resolves when the asset has been loaded.
	*/
	loadAsync(url, onProgress) {
		const scope = this;
		return new Promise(function(resolve, reject) {
			scope.load(url, resolve, onProgress, reject);
		});
	}
	/**
	* This method needs to be implemented by all concrete loaders. It holds the
	* logic for parsing the asset into three.js entities.
	*
	* @abstract
	* @param {any} data - The data to parse.
	*/
	parse() {}
	/**
	* Sets the `crossOrigin` String to implement CORS for loading the URL
	* from a different domain that allows CORS.
	*
	* @param {string} crossOrigin - The `crossOrigin` value.
	* @return {Loader} A reference to this instance.
	*/
	setCrossOrigin(crossOrigin) {
		this.crossOrigin = crossOrigin;
		return this;
	}
	/**
	* Whether the XMLHttpRequest uses credentials such as cookies, authorization
	* headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials).
	*
	* Note: This setting has no effect if you are loading files locally or from the same domain.
	*
	* @param {boolean} value - The `withCredentials` value.
	* @return {Loader} A reference to this instance.
	*/
	setWithCredentials(value) {
		this.withCredentials = value;
		return this;
	}
	/**
	* Sets the base path for the asset.
	*
	* @param {string} path - The base path.
	* @return {Loader} A reference to this instance.
	*/
	setPath(path) {
		this.path = path;
		return this;
	}
	/**
	* Sets the base path for dependent resources like textures.
	*
	* @param {string} resourcePath - The resource path.
	* @return {Loader} A reference to this instance.
	*/
	setResourcePath(resourcePath) {
		this.resourcePath = resourcePath;
		return this;
	}
	/**
	* Sets the given request header.
	*
	* @param {Object} requestHeader - A [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header)
	* for configuring the HTTP request.
	* @return {Loader} A reference to this instance.
	*/
	setRequestHeader(requestHeader) {
		this.requestHeader = requestHeader;
		return this;
	}
	/**
	* This method can be implemented in loaders for aborting ongoing requests.
	*
	* @abstract
	* @return {Loader} A reference to this instance.
	*/
	abort() {
		return this;
	}
};
/**
* Callback for onProgress in loaders.
*
* @callback onProgressCallback
* @param {ProgressEvent} event - An instance of `ProgressEvent` that represents the current loading status.
*/
/**
* Callback for onError in loaders.
*
* @callback onErrorCallback
* @param {Error} error - The error which occurred during the loading process.
*/
/**
* The default material name that is used by loaders
* when creating materials for loaded 3D objects.
*
* Note: Not all loaders might honor this setting.
*
* @static
* @type {string}
* @default '__DEFAULT'
*/
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
var _loading = /* @__PURE__ */ new WeakMap();
/**
* A loader for loading images. The class loads images with the HTML `Image` API.
*
* ```js
* const loader = new THREE.ImageLoader();
* const image = await loader.loadAsync( 'image.png' );
* ```
* Please note that `ImageLoader` has dropped support for progress
* events in `r84`. For an `ImageLoader` that supports progress events, see
* [this thread](https://github.com/mrdoob/three.js/issues/10439#issuecomment-275785639).
*
* @augments Loader
*/
var ImageLoader = class extends Loader {
	/**
	* Constructs a new image loader.
	*
	* @param {LoadingManager} [manager] - The loading manager.
	*/
	constructor(manager) {
		super(manager);
	}
	/**
	* Starts loading from the given URL and passes the loaded image
	* to the `onLoad()` callback. The method also returns a new `Image` object which can
	* directly be used for texture creation. If you do it this way, the texture
	* may pop up in your scene once the respective loading process is finished.
	*
	* @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	* @param {function(Image)} onLoad - Executed when the loading process has been finished.
	* @param {onProgressCallback} onProgress - Unsupported in this loader.
	* @param {onErrorCallback} onError - Executed when errors occur.
	* @return {Image} The image.
	*/
	load(url, onLoad, onProgress, onError) {
		if (this.path !== void 0) url = this.path + url;
		url = this.manager.resolveURL(url);
		const scope = this;
		const cached = Cache.get(`image:${url}`);
		if (cached !== void 0) {
			if (cached.complete === true) {
				scope.manager.itemStart(url);
				setTimeout(function() {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
			} else {
				let arr = _loading.get(cached);
				if (arr === void 0) {
					arr = [];
					_loading.set(cached, arr);
				}
				arr.push({
					onLoad,
					onError
				});
			}
			return cached;
		}
		const image = createElementNS("img");
		function onImageLoad() {
			removeEventListeners();
			if (onLoad) onLoad(this);
			const callbacks = _loading.get(this) || [];
			for (let i = 0; i < callbacks.length; i++) {
				const callback = callbacks[i];
				if (callback.onLoad) callback.onLoad(this);
			}
			_loading.delete(this);
			scope.manager.itemEnd(url);
		}
		function onImageError(event) {
			removeEventListeners();
			if (onError) onError(event);
			Cache.remove(`image:${url}`);
			const callbacks = _loading.get(this) || [];
			for (let i = 0; i < callbacks.length; i++) {
				const callback = callbacks[i];
				if (callback.onError) callback.onError(event);
			}
			_loading.delete(this);
			scope.manager.itemError(url);
			scope.manager.itemEnd(url);
		}
		function removeEventListeners() {
			image.removeEventListener("load", onImageLoad, false);
			image.removeEventListener("error", onImageError, false);
		}
		image.addEventListener("load", onImageLoad, false);
		image.addEventListener("error", onImageError, false);
		if (url.slice(0, 5) !== "data:") {
			if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
		}
		Cache.add(`image:${url}`, image);
		scope.manager.itemStart(url);
		image.src = url;
		return image;
	}
};
/**
* Class for loading textures. Images are internally
* loaded via {@link ImageLoader}.
*
* ```js
* const loader = new THREE.TextureLoader();
* const texture = await loader.loadAsync( 'textures/land_ocean_ice_cloud_2048.jpg' );
*
* const material = new THREE.MeshBasicMaterial( { map:texture } );
* ```
* Please note that `TextureLoader` has dropped support for progress
* events in `r84`. For a `TextureLoader` that supports progress events, see
* [this thread](https://github.com/mrdoob/three.js/issues/10439#issuecomment-293260145).
*
* @augments Loader
*/
var TextureLoader = class extends Loader {
	/**
	* Constructs a new texture loader.
	*
	* @param {LoadingManager} [manager] - The loading manager.
	*/
	constructor(manager) {
		super(manager);
	}
	/**
	* Starts loading from the given URL and pass the fully loaded texture
	* to the `onLoad()` callback. The method also returns a new texture object which can
	* directly be used for material creation. If you do it this way, the texture
	* may pop up in your scene once the respective loading process is finished.
	*
	* @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	* @param {function(Texture)} onLoad - Executed when the loading process has been finished.
	* @param {onProgressCallback} onProgress - Unsupported in this loader.
	* @param {onErrorCallback} onError - Executed when errors occur.
	* @return {Texture} The texture.
	*/
	load(url, onLoad, onProgress, onError) {
		const texture$2 = new Texture();
		const loader = new ImageLoader(this.manager);
		loader.setCrossOrigin(this.crossOrigin);
		loader.setPath(this.path);
		loader.load(url, function(image) {
			texture$2.image = image;
			texture$2.needsUpdate = true;
			if (onLoad !== void 0) onLoad(texture$2);
		}, onProgress, onError);
		return texture$2;
	}
};
/**
* Abstract base class for lights - all other light types inherit the
* properties and methods described here.
*
* @abstract
* @augments Object3D
*/
var Light = class extends Object3D {
	/**
	* Constructs a new light.
	*
	* @param {(number|Color|string)} [color=0xffffff] - The light's color.
	* @param {number} [intensity=1] - The light's strength/intensity.
	*/
	constructor(color$2, intensity = 1) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isLight = true;
		this.type = "Light";
		/**
		* The light's color.
		*
		* @type {Color}
		*/
		this.color = new Color$1(color$2);
		/**
		* The light's intensity.
		*
		* @type {number}
		* @default 1
		*/
		this.intensity = intensity;
	}
	/**
	* Frees the GPU-related resources allocated by this instance. Call this
	* method whenever this instance is no longer used in your app.
	*/
	dispose() {}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.color.copy(source.color);
		this.intensity = source.intensity;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;
		if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
		if (this.distance !== void 0) data.object.distance = this.distance;
		if (this.angle !== void 0) data.object.angle = this.angle;
		if (this.decay !== void 0) data.object.decay = this.decay;
		if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
		if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
		if (this.target !== void 0) data.object.target = this.target.uuid;
		return data;
	}
};
/**
* A light source positioned directly above the scene, with color fading from
* the sky color to the ground color.
*
* This light cannot be used to cast shadows.
*
* ```js
* const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
* scene.add( light );
* ```
*
* @augments Light
*/
var HemisphereLight = class extends Light {
	/**
	* Constructs a new hemisphere light.
	*
	* @param {(number|Color|string)} [skyColor=0xffffff] - The light's sky color.
	* @param {(number|Color|string)} [groundColor=0xffffff] - The light's ground color.
	* @param {number} [intensity=1] - The light's strength/intensity.
	*/
	constructor(skyColor, groundColor, intensity) {
		super(skyColor, intensity);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isHemisphereLight = true;
		this.type = "HemisphereLight";
		this.position.copy(Object3D.DEFAULT_UP);
		this.updateMatrix();
		/**
		* The light's ground color.
		*
		* @type {Color}
		*/
		this.groundColor = new Color$1(groundColor);
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.groundColor.copy(source.groundColor);
		return this;
	}
};
var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
var _lookTarget$1 = /* @__PURE__ */ new Vector3();
/**
* Abstract base class for light shadow classes. These classes
* represent the shadow configuration for different light types.
*
* @abstract
*/
var LightShadow = class {
	/**
	* Constructs a new light shadow.
	*
	* @param {Camera} camera - The light's view of the world.
	*/
	constructor(camera) {
		/**
		* The light's view of the world.
		*
		* @type {Camera}
		*/
		this.camera = camera;
		/**
		* The intensity of the shadow. The default is `1`.
		* Valid values are in the range `[0, 1]`.
		*
		* @type {number}
		* @default 1
		*/
		this.intensity = 1;
		/**
		* Shadow map bias, how much to add or subtract from the normalized depth
		* when deciding whether a surface is in shadow.
		*
		* The default is `0`. Very tiny adjustments here (in the order of `0.0001`)
		* may help reduce artifacts in shadows.
		*
		* @type {number}
		* @default 0
		*/
		this.bias = 0;
		/**
		* Defines how much the position used to query the shadow map is offset along
		* the object normal. The default is `0`. Increasing this value can be used to
		* reduce shadow acne especially in large scenes where light shines onto
		* geometry at a shallow angle. The cost is that shadows may appear distorted.
		*
		* @type {number}
		* @default 0
		*/
		this.normalBias = 0;
		/**
		* Setting this to values greater than 1 will blur the edges of the shadow.
		* High values will cause unwanted banding effects in the shadows - a greater
		* map size will allow for a higher value to be used here before these effects
		* become visible.
		*
		* The property has no effect when the shadow map type is `PCFSoftShadowMap` and
		* and it is recommended to increase softness by decreasing the shadow map size instead.
		*
		* The property has no effect when the shadow map type is `BasicShadowMap`.
		*
		* @type {number}
		* @default 1
		*/
		this.radius = 1;
		/**
		* The amount of samples to use when blurring a VSM shadow map.
		*
		* @type {number}
		* @default 8
		*/
		this.blurSamples = 8;
		/**
		* Defines the width and height of the shadow map. Higher values give better quality
		* shadows at the cost of computation time. Values must be powers of two.
		*
		* @type {Vector2}
		* @default (512,512)
		*/
		this.mapSize = new Vector2(512, 512);
		/**
		* The type of shadow texture. The default is `UnsignedByteType`.
		*
		* @type {number}
		* @default UnsignedByteType
		*/
		this.mapType = UnsignedByteType;
		/**
		* The depth map generated using the internal camera; a location beyond a
		* pixel's depth is in shadow. Computed internally during rendering.
		*
		* @type {?RenderTarget}
		* @default null
		*/
		this.map = null;
		/**
		* The distribution map generated using the internal camera; an occlusion is
		* calculated based on the distribution of depths. Computed internally during
		* rendering.
		*
		* @type {?RenderTarget}
		* @default null
		*/
		this.mapPass = null;
		/**
		* Model to shadow camera space, to compute location and depth in shadow map.
		* This is computed internally during rendering.
		*
		* @type {Matrix4}
		*/
		this.matrix = new Matrix4();
		/**
		* Enables automatic updates of the light's shadow. If you do not require dynamic
		* lighting / shadows, you may set this to `false`.
		*
		* @type {boolean}
		* @default true
		*/
		this.autoUpdate = true;
		/**
		* When set to `true`, shadow maps will be updated in the next `render` call.
		* If you have set {@link LightShadow#autoUpdate} to `false`, you will need to
		* set this property to `true` and then make a render call to update the light's shadow.
		*
		* @type {boolean}
		* @default false
		*/
		this.needsUpdate = false;
		this._frustum = new Frustum();
		this._frameExtents = new Vector2(1, 1);
		this._viewportCount = 1;
		this._viewports = [new Vector4(0, 0, 1, 1)];
	}
	/**
	* Used internally by the renderer to get the number of viewports that need
	* to be rendered for this shadow.
	*
	* @return {number} The viewport count.
	*/
	getViewportCount() {
		return this._viewportCount;
	}
	/**
	* Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
	*
	* @return {Frustum} The shadow camera frustum.
	*/
	getFrustum() {
		return this._frustum;
	}
	/**
	* Update the matrices for the camera and shadow, used internally by the renderer.
	*
	* @param {Light} light - The light for which the shadow is being rendered.
	*/
	updateMatrices(light) {
		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;
		_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
		shadowCamera.position.copy(_lightPositionWorld$1);
		_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
		shadowCamera.lookAt(_lookTarget$1);
		shadowCamera.updateMatrixWorld();
		_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
		this._frustum.setFromProjectionMatrix(_projScreenMatrix$1, shadowCamera.coordinateSystem, shadowCamera.reversedDepth);
		if (shadowCamera.reversedDepth) shadowMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1);
		else shadowMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
		shadowMatrix.multiply(_projScreenMatrix$1);
	}
	/**
	* Returns a viewport definition for the given viewport index.
	*
	* @param {number} viewportIndex - The viewport index.
	* @return {Vector4} The viewport.
	*/
	getViewport(viewportIndex) {
		return this._viewports[viewportIndex];
	}
	/**
	* Returns the frame extends.
	*
	* @return {Vector2} The frame extends.
	*/
	getFrameExtents() {
		return this._frameExtents;
	}
	/**
	* Frees the GPU-related resources allocated by this instance. Call this
	* method whenever this instance is no longer used in your app.
	*/
	dispose() {
		if (this.map) this.map.dispose();
		if (this.mapPass) this.mapPass.dispose();
	}
	/**
	* Copies the values of the given light shadow instance to this instance.
	*
	* @param {LightShadow} source - The light shadow to copy.
	* @return {LightShadow} A reference to this light shadow instance.
	*/
	copy(source) {
		this.camera = source.camera.clone();
		this.intensity = source.intensity;
		this.bias = source.bias;
		this.radius = source.radius;
		this.autoUpdate = source.autoUpdate;
		this.needsUpdate = source.needsUpdate;
		this.normalBias = source.normalBias;
		this.blurSamples = source.blurSamples;
		this.mapSize.copy(source.mapSize);
		return this;
	}
	/**
	* Returns a new light shadow instance with copied values from this instance.
	*
	* @return {LightShadow} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	/**
	* Serializes the light shadow into JSON.
	*
	* @return {Object} A JSON object representing the serialized light shadow.
	* @see {@link ObjectLoader#parse}
	*/
	toJSON() {
		const object = {};
		if (this.intensity !== 1) object.intensity = this.intensity;
		if (this.bias !== 0) object.bias = this.bias;
		if (this.normalBias !== 0) object.normalBias = this.normalBias;
		if (this.radius !== 1) object.radius = this.radius;
		if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
		object.camera = this.camera.toJSON(false).object;
		delete object.camera.matrix;
		return object;
	}
};
/**
* Represents the shadow configuration of directional lights.
*
* @augments LightShadow
*/
var SpotLightShadow = class extends LightShadow {
	/**
	* Constructs a new spot light shadow.
	*/
	constructor() {
		super(new PerspectiveCamera(50, 1, .5, 500));
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSpotLightShadow = true;
		/**
		* Used to focus the shadow camera. The camera's field of view is set as a
		* percentage of the spotlight's field-of-view. Range is `[0, 1]`.
		*
		* @type {number}
		* @default 1
		*/
		this.focus = 1;
		/**
		* Texture aspect ratio.
		*
		* @type {number}
		* @default 1
		*/
		this.aspect = 1;
	}
	updateMatrices(light) {
		const camera = this.camera;
		const fov$1 = RAD2DEG * 2 * light.angle * this.focus;
		const aspect$1 = this.mapSize.width / this.mapSize.height * this.aspect;
		const far = light.distance || camera.far;
		if (fov$1 !== camera.fov || aspect$1 !== camera.aspect || far !== camera.far) {
			camera.fov = fov$1;
			camera.aspect = aspect$1;
			camera.far = far;
			camera.updateProjectionMatrix();
		}
		super.updateMatrices(light);
	}
	copy(source) {
		super.copy(source);
		this.focus = source.focus;
		return this;
	}
};
/**
* This light gets emitted from a single point in one direction, along a cone
* that increases in size the further from the light it gets.
*
* This light can cast shadows - see the {@link SpotLightShadow} for details.
*
* ```js
* // white spotlight shining from the side, modulated by a texture
* const spotLight = new THREE.SpotLight( 0xffffff );
* spotLight.position.set( 100, 1000, 100 );
* spotLight.map = new THREE.TextureLoader().load( url );
*
* spotLight.castShadow = true;
* spotLight.shadow.mapSize.width = 1024;
* spotLight.shadow.mapSize.height = 1024;
* spotLight.shadow.camera.near = 500;
* spotLight.shadow.camera.far = 4000;
* spotLight.shadow.camera.fov = 30;s
* ```
*
* @augments Light
*/
var SpotLight = class extends Light {
	/**
	* Constructs a new spot light.
	*
	* @param {(number|Color|string)} [color=0xffffff] - The light's color.
	* @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
	* @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
	* @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
	* @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
	* @param {number} [decay=2] - The amount the light dims along the distance of the light.
	*/
	constructor(color$2, intensity, distance$3 = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
		super(color$2, intensity);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSpotLight = true;
		this.type = "SpotLight";
		this.position.copy(Object3D.DEFAULT_UP);
		this.updateMatrix();
		/**
		* The spot light points from its position to the
		* target's position.
		*
		* For the target's position to be changed to anything other
		* than the default, it must be added to the scene.
		*
		* It is also possible to set the target to be another 3D object
		* in the scene. The light will now track the target object.
		*
		* @type {Object3D}
		*/
		this.target = new Object3D();
		/**
		* Maximum range of the light. `0` means no limit.
		*
		* @type {number}
		* @default 0
		*/
		this.distance = distance$3;
		/**
		* Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
		*
		* @type {number}
		* @default Math.PI/3
		*/
		this.angle = angle;
		/**
		* Percent of the spotlight cone that is attenuated due to penumbra.
		* Value range is `[0,1]`.
		*
		* @type {number}
		* @default 0
		*/
		this.penumbra = penumbra;
		/**
		* The amount the light dims along the distance of the light. In context of
		* physically-correct rendering the default value should not be changed.
		*
		* @type {number}
		* @default 2
		*/
		this.decay = decay;
		/**
		* A texture used to modulate the color of the light. The spot light
		* color is mixed with the RGB value of this texture, with a ratio
		* corresponding to its alpha value. The cookie-like masking effect is
		* reproduced using pixel values (0, 0, 0, 1-cookie_value).
		*
		* *Warning*: This property is disabled if {@link Object3D#castShadow} is set to `false`.
		*
		* @type {?Texture}
		* @default null
		*/
		this.map = null;
		/**
		* This property holds the light's shadow configuration.
		*
		* @type {SpotLightShadow}
		*/
		this.shadow = new SpotLightShadow();
	}
	/**
	* The light's power. Power is the luminous power of the light measured in lumens (lm).
	*  Changing the power will also change the light's intensity.
	*
	* @type {number}
	*/
	get power() {
		return this.intensity * Math.PI;
	}
	set power(power) {
		this.intensity = power / Math.PI;
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;
		this.target = source.target.clone();
		this.shadow = source.shadow.clone();
		return this;
	}
};
var _projScreenMatrix$3 = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld = /* @__PURE__ */ new Vector3();
var _lookTarget = /* @__PURE__ */ new Vector3();
/**
* Represents the shadow configuration of point lights.
*
* @augments LightShadow
*/
var PointLightShadow = class extends LightShadow {
	/**
	* Constructs a new point light shadow.
	*/
	constructor() {
		super(new PerspectiveCamera(90, 1, .5, 500));
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isPointLightShadow = true;
		this._frameExtents = new Vector2(4, 2);
		this._viewportCount = 6;
		this._viewports = [
			new Vector4(2, 1, 1, 1),
			new Vector4(0, 1, 1, 1),
			new Vector4(3, 1, 1, 1),
			new Vector4(1, 1, 1, 1),
			new Vector4(3, 0, 1, 1),
			new Vector4(1, 0, 1, 1)
		];
		this._cubeDirections = [
			new Vector3(1, 0, 0),
			new Vector3(-1, 0, 0),
			new Vector3(0, 0, 1),
			new Vector3(0, 0, -1),
			new Vector3(0, 1, 0),
			new Vector3(0, -1, 0)
		];
		this._cubeUps = [
			new Vector3(0, 1, 0),
			new Vector3(0, 1, 0),
			new Vector3(0, 1, 0),
			new Vector3(0, 1, 0),
			new Vector3(0, 0, 1),
			new Vector3(0, 0, -1)
		];
	}
	/**
	* Update the matrices for the camera and shadow, used internally by the renderer.
	*
	* @param {Light} light - The light for which the shadow is being rendered.
	* @param {number} [viewportIndex=0] - The viewport index.
	*/
	updateMatrices(light, viewportIndex = 0) {
		const camera = this.camera;
		const shadowMatrix = this.matrix;
		const far = light.distance || camera.far;
		if (far !== camera.far) {
			camera.far = far;
			camera.updateProjectionMatrix();
		}
		_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
		camera.position.copy(_lightPositionWorld);
		_lookTarget.copy(camera.position);
		_lookTarget.add(this._cubeDirections[viewportIndex]);
		camera.up.copy(this._cubeUps[viewportIndex]);
		camera.lookAt(_lookTarget);
		camera.updateMatrixWorld();
		shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
		_projScreenMatrix$3.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
		this._frustum.setFromProjectionMatrix(_projScreenMatrix$3, camera.coordinateSystem, camera.reversedDepth);
	}
};
/**
* A light that gets emitted from a single point in all directions. A common
* use case for this is to replicate the light emitted from a bare
* lightbulb.
*
* This light can cast shadows - see the {@link PointLightShadow} for details.
*
* ```js
* const light = new THREE.PointLight( 0xff0000, 1, 100 );
* light.position.set( 50, 50, 50 );
* scene.add( light );
* ```
*
* @augments Light
*/
var PointLight = class extends Light {
	/**
	* Constructs a new point light.
	*
	* @param {(number|Color|string)} [color=0xffffff] - The light's color.
	* @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
	* @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
	* @param {number} [decay=2] - The amount the light dims along the distance of the light.
	*/
	constructor(color$2, intensity, distance$3 = 0, decay = 2) {
		super(color$2, intensity);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isPointLight = true;
		this.type = "PointLight";
		/**
		* When distance is zero, light will attenuate according to inverse-square
		* law to infinite distance. When distance is non-zero, light will attenuate
		* according to inverse-square law until near the distance cutoff, where it
		* will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not
		* physically correct.
		*
		* @type {number}
		* @default 0
		*/
		this.distance = distance$3;
		/**
		* The amount the light dims along the distance of the light. In context of
		* physically-correct rendering the default value should not be changed.
		*
		* @type {number}
		* @default 2
		*/
		this.decay = decay;
		/**
		* This property holds the light's shadow configuration.
		*
		* @type {PointLightShadow}
		*/
		this.shadow = new PointLightShadow();
	}
	/**
	* The light's power. Power is the luminous power of the light measured in lumens (lm).
	* Changing the power will also change the light's intensity.
	*
	* @type {number}
	*/
	get power() {
		return this.intensity * 4 * Math.PI;
	}
	set power(power) {
		this.intensity = power / (4 * Math.PI);
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.distance = source.distance;
		this.decay = source.decay;
		this.shadow = source.shadow.clone();
		return this;
	}
};
/**
* Camera that uses [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection).
*
* In this projection mode, an object's size in the rendered image stays
* constant regardless of its distance from the camera. This can be useful
* for rendering 2D scenes and UI elements, amongst other things.
*
* ```js
* const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
* scene.add( camera );
* ```
*
* @augments Camera
*/
var OrthographicCamera = class extends Camera {
	/**
	* Constructs a new orthographic camera.
	*
	* @param {number} [left=-1] - The left plane of the camera's frustum.
	* @param {number} [right=1] - The right plane of the camera's frustum.
	* @param {number} [top=1] - The top plane of the camera's frustum.
	* @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
	* @param {number} [near=0.1] - The camera's near plane.
	* @param {number} [far=2000] - The camera's far plane.
	*/
	constructor(left = -1, right = 1, top = 1, bottom = -1, near = .1, far = 2e3) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isOrthographicCamera = true;
		this.type = "OrthographicCamera";
		/**
		* The zoom factor of the camera.
		*
		* @type {number}
		* @default 1
		*/
		this.zoom = 1;
		/**
		* Represents the frustum window specification. This property should not be edited
		* directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
		*
		* @type {?Object}
		* @default null
		*/
		this.view = null;
		/**
		* The left plane of the camera's frustum.
		*
		* @type {number}
		* @default -1
		*/
		this.left = left;
		/**
		* The right plane of the camera's frustum.
		*
		* @type {number}
		* @default 1
		*/
		this.right = right;
		/**
		* The top plane of the camera's frustum.
		*
		* @type {number}
		* @default 1
		*/
		this.top = top;
		/**
		* The bottom plane of the camera's frustum.
		*
		* @type {number}
		* @default -1
		*/
		this.bottom = bottom;
		/**
		* The camera's near plane. The valid range is greater than `0`
		* and less than the current value of {@link OrthographicCamera#far}.
		*
		* Note that, unlike for the {@link PerspectiveCamera}, `0` is a
		* valid value for an orthographic camera's near plane.
		*
		* @type {number}
		* @default 0.1
		*/
		this.near = near;
		/**
		* The camera's far plane. Must be greater than the
		* current value of {@link OrthographicCamera#near}.
		*
		* @type {number}
		* @default 2000
		*/
		this.far = far;
		this.updateProjectionMatrix();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;
		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign({}, source.view);
		return this;
	}
	/**
	* Sets an offset in a larger frustum. This is useful for multi-window or
	* multi-monitor/multi-machine setups.
	*
	* @param {number} fullWidth - The full width of multiview setup.
	* @param {number} fullHeight - The full height of multiview setup.
	* @param {number} x - The horizontal offset of the subcamera.
	* @param {number} y - The vertical offset of the subcamera.
	* @param {number} width - The width of subcamera.
	* @param {number} height - The height of subcamera.
	* @see {@link PerspectiveCamera#setViewOffset}
	*/
	setViewOffset(fullWidth, fullHeight, x, y, width, height) {
		if (this.view === null) this.view = {
			enabled: true,
			fullWidth: 1,
			fullHeight: 1,
			offsetX: 0,
			offsetY: 0,
			width: 1,
			height: 1
		};
		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;
		this.updateProjectionMatrix();
	}
	/**
	* Removes the view offset from the projection matrix.
	*/
	clearViewOffset() {
		if (this.view !== null) this.view.enabled = false;
		this.updateProjectionMatrix();
	}
	/**
	* Updates the camera's projection matrix. Must be called after any change of
	* camera properties.
	*/
	updateProjectionMatrix() {
		const dx = (this.right - this.left) / (2 * this.zoom);
		const dy = (this.top - this.bottom) / (2 * this.zoom);
		const cx = (this.right + this.left) / 2;
		const cy = (this.top + this.bottom) / 2;
		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;
		if (this.view !== null && this.view.enabled) {
			const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
			const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;
		}
		this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem, this.reversedDepth);
		this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;
		if (this.view !== null) data.object.view = Object.assign({}, this.view);
		return data;
	}
};
/**
* Represents the shadow configuration of directional lights.
*
* @augments LightShadow
*/
var DirectionalLightShadow = class extends LightShadow {
	/**
	* Constructs a new directional light shadow.
	*/
	constructor() {
		super(new OrthographicCamera(-5, 5, 5, -5, .5, 500));
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isDirectionalLightShadow = true;
	}
};
/**
* A light that gets emitted in a specific direction. This light will behave
* as though it is infinitely far away and the rays produced from it are all
* parallel. The common use case for this is to simulate daylight; the sun is
* far enough away that its position can be considered to be infinite, and
* all light rays coming from it are parallel.
*
* A common point of confusion for directional lights is that setting the
* rotation has no effect. This is because three.js's DirectionalLight is the
* equivalent to what is often called a 'Target Direct Light' in other
* applications.
*
* This means that its direction is calculated as pointing from the light's
* {@link Object3D#position} to the {@link DirectionalLight#target} position
* (as opposed to a 'Free Direct Light' that just has a rotation
* component).
*
* This light can cast shadows - see the {@link DirectionalLightShadow} for details.
*
* ```js
* // White directional light at half intensity shining from the top.
* const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
* scene.add( directionalLight );
* ```
*
* @augments Light
*/
var DirectionalLight = class extends Light {
	/**
	* Constructs a new directional light.
	*
	* @param {(number|Color|string)} [color=0xffffff] - The light's color.
	* @param {number} [intensity=1] - The light's strength/intensity.
	*/
	constructor(color$2, intensity) {
		super(color$2, intensity);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isDirectionalLight = true;
		this.type = "DirectionalLight";
		this.position.copy(Object3D.DEFAULT_UP);
		this.updateMatrix();
		/**
		* The directional light points from its position to the
		* target's position.
		*
		* For the target's position to be changed to anything other
		* than the default, it must be added to the scene.
		*
		* It is also possible to set the target to be another 3D object
		* in the scene. The light will now track the target object.
		*
		* @type {Object3D}
		*/
		this.target = new Object3D();
		/**
		* This property holds the light's shadow configuration.
		*
		* @type {DirectionalLightShadow}
		*/
		this.shadow = new DirectionalLightShadow();
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(source) {
		super.copy(source);
		this.target = source.target.clone();
		this.shadow = source.shadow.clone();
		return this;
	}
};
/**
* This light globally illuminates all objects in the scene equally.
*
* It cannot be used to cast shadows as it does not have a direction.
*
* ```js
* const light = new THREE.AmbientLight( 0x404040 ); // soft white light
* scene.add( light );
* ```
*
* @augments Light
*/
var AmbientLight = class extends Light {
	/**
	* Constructs a new ambient light.
	*
	* @param {(number|Color|string)} [color=0xffffff] - The light's color.
	* @param {number} [intensity=1] - The light's strength/intensity.
	*/
	constructor(color$2, intensity) {
		super(color$2, intensity);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isAmbientLight = true;
		this.type = "AmbientLight";
	}
};
/**
* This class emits light uniformly across the face a rectangular plane.
* This light type can be used to simulate light sources such as bright
* windows or strip lighting.
*
* Important Notes:
*
* - There is no shadow support.
* - Only PBR materials are supported.
* - You have to include `RectAreaLightUniformsLib` (`WebGLRenderer`) or `RectAreaLightTexturesLib` (`WebGPURenderer`)
* into your app and init the uniforms/textures.
*
* ```js
* RectAreaLightUniformsLib.init(); // only relevant for WebGLRenderer
* THREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() ); //  only relevant for WebGPURenderer
*
* const intensity = 1; const width = 10; const height = 10;
* const rectLight = new THREE.RectAreaLight( 0xffffff, intensity, width, height );
* rectLight.position.set( 5, 5, 0 );
* rectLight.lookAt( 0, 0, 0 );
* scene.add( rectLight )
* ```
*
* @augments Light
*/
var RectAreaLight = class extends Light {
	/**
	* Constructs a new area light.
	*
	* @param {(number|Color|string)} [color=0xffffff] - The light's color.
	* @param {number} [intensity=1] - The light's strength/intensity.
	* @param {number} [width=10] - The width of the light.
	* @param {number} [height=10] - The height of the light.
	*/
	constructor(color$2, intensity, width = 10, height = 10) {
		super(color$2, intensity);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isRectAreaLight = true;
		this.type = "RectAreaLight";
		/**
		* The width of the light.
		*
		* @type {number}
		* @default 10
		*/
		this.width = width;
		/**
		* The height of the light.
		*
		* @type {number}
		* @default 10
		*/
		this.height = height;
	}
	/**
	* The light's power. Power is the luminous power of the light measured in lumens (lm).
	* Changing the power will also change the light's intensity.
	*
	* @type {number}
	*/
	get power() {
		return this.intensity * this.width * this.height * Math.PI;
	}
	set power(power) {
		this.intensity = power / (this.width * this.height * Math.PI);
	}
	copy(source) {
		super.copy(source);
		this.width = source.width;
		this.height = source.height;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.width = this.width;
		data.object.height = this.height;
		return data;
	}
};
/**
* Represents a third-order spherical harmonics (SH). Light probes use this class
* to encode lighting information.
*
* - Primary reference: {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf}
* - Secondary reference: {@link https://www.ppsloan.org/publications/StupidSH36.pdf}
*/
var SphericalHarmonics3 = class {
	/**
	* Constructs a new spherical harmonics.
	*/
	constructor() {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSphericalHarmonics3 = true;
		/**
		* An array holding the (9) SH coefficients.
		*
		* @type {Array<Vector3>}
		*/
		this.coefficients = [];
		for (let i = 0; i < 9; i++) this.coefficients.push(new Vector3());
	}
	/**
	* Sets the given SH coefficients to this instance by copying
	* the values.
	*
	* @param {Array<Vector3>} coefficients - The SH coefficients.
	* @return {SphericalHarmonics3} A reference to this spherical harmonics.
	*/
	set(coefficients) {
		for (let i = 0; i < 9; i++) this.coefficients[i].copy(coefficients[i]);
		return this;
	}
	/**
	* Sets all SH coefficients to `0`.
	*
	* @return {SphericalHarmonics3} A reference to this spherical harmonics.
	*/
	zero() {
		for (let i = 0; i < 9; i++) this.coefficients[i].set(0, 0, 0);
		return this;
	}
	/**
	* Returns the radiance in the direction of the given normal.
	*
	* @param {Vector3} normal - The normal vector (assumed to be unit length)
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The radiance.
	*/
	getAt(normal$1, target) {
		const x = normal$1.x, y = normal$1.y, z = normal$1.z;
		const coeff = this.coefficients;
		target.copy(coeff[0]).multiplyScalar(.282095);
		target.addScaledVector(coeff[1], .488603 * y);
		target.addScaledVector(coeff[2], .488603 * z);
		target.addScaledVector(coeff[3], .488603 * x);
		target.addScaledVector(coeff[4], 1.092548 * (x * y));
		target.addScaledVector(coeff[5], 1.092548 * (y * z));
		target.addScaledVector(coeff[6], .315392 * (3 * z * z - 1));
		target.addScaledVector(coeff[7], 1.092548 * (x * z));
		target.addScaledVector(coeff[8], .546274 * (x * x - y * y));
		return target;
	}
	/**
	* Returns the irradiance (radiance convolved with cosine lobe) in the
	* direction of the given normal.
	*
	* @param {Vector3} normal - The normal vector (assumed to be unit length)
	* @param {Vector3} target - The target vector that is used to store the method's result.
	* @return {Vector3} The irradiance.
	*/
	getIrradianceAt(normal$1, target) {
		const x = normal$1.x, y = normal$1.y, z = normal$1.z;
		const coeff = this.coefficients;
		target.copy(coeff[0]).multiplyScalar(.886227);
		target.addScaledVector(coeff[1], 2 * .511664 * y);
		target.addScaledVector(coeff[2], 2 * .511664 * z);
		target.addScaledVector(coeff[3], 2 * .511664 * x);
		target.addScaledVector(coeff[4], 2 * .429043 * x * y);
		target.addScaledVector(coeff[5], 2 * .429043 * y * z);
		target.addScaledVector(coeff[6], .743125 * z * z - .247708);
		target.addScaledVector(coeff[7], 2 * .429043 * x * z);
		target.addScaledVector(coeff[8], .429043 * (x * x - y * y));
		return target;
	}
	/**
	* Adds the given SH to this instance.
	*
	* @param {SphericalHarmonics3} sh - The SH to add.
	* @return {SphericalHarmonics3} A reference to this spherical harmonics.
	*/
	add(sh) {
		for (let i = 0; i < 9; i++) this.coefficients[i].add(sh.coefficients[i]);
		return this;
	}
	/**
	* A convenience method for performing {@link SphericalHarmonics3#add} and
	* {@link SphericalHarmonics3#scale} at once.
	*
	* @param {SphericalHarmonics3} sh - The SH to add.
	* @param {number} s - The scale factor.
	* @return {SphericalHarmonics3} A reference to this spherical harmonics.
	*/
	addScaledSH(sh, s) {
		for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(sh.coefficients[i], s);
		return this;
	}
	/**
	* Scales this SH by the given scale factor.
	*
	* @param {number} s - The scale factor.
	* @return {SphericalHarmonics3} A reference to this spherical harmonics.
	*/
	scale(s) {
		for (let i = 0; i < 9; i++) this.coefficients[i].multiplyScalar(s);
		return this;
	}
	/**
	* Linear interpolates between the given SH and this instance by the given
	* alpha factor.
	*
	* @param {SphericalHarmonics3} sh - The SH to interpolate with.
	* @param {number} alpha - The alpha factor.
	* @return {SphericalHarmonics3} A reference to this spherical harmonics.
	*/
	lerp(sh, alpha) {
		for (let i = 0; i < 9; i++) this.coefficients[i].lerp(sh.coefficients[i], alpha);
		return this;
	}
	/**
	* Returns `true` if this spherical harmonics is equal with the given one.
	*
	* @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.
	* @return {boolean} Whether this spherical harmonics is equal with the given one.
	*/
	equals(sh) {
		for (let i = 0; i < 9; i++) if (!this.coefficients[i].equals(sh.coefficients[i])) return false;
		return true;
	}
	/**
	* Copies the values of the given spherical harmonics to this instance.
	*
	* @param {SphericalHarmonics3} sh - The spherical harmonics to copy.
	* @return {SphericalHarmonics3} A reference to this spherical harmonics.
	*/
	copy(sh) {
		return this.set(sh.coefficients);
	}
	/**
	* Returns a new spherical harmonics with copied values from this instance.
	*
	* @return {SphericalHarmonics3} A clone of this instance.
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	/**
	* Sets the SH coefficients of this instance from the given array.
	*
	* @param {Array<number>} array - An array holding the SH coefficients.
	* @param {number} [offset=0] - The array offset where to start copying.
	* @return {SphericalHarmonics3} A clone of this instance.
	*/
	fromArray(array$2, offset = 0) {
		const coefficients = this.coefficients;
		for (let i = 0; i < 9; i++) coefficients[i].fromArray(array$2, offset + i * 3);
		return this;
	}
	/**
	* Returns an array with the SH coefficients, or copies them into the provided
	* array. The coefficients are represented as numbers.
	*
	* @param {Array<number>} [array=[]] - The target array.
	* @param {number} [offset=0] - The array offset where to start copying.
	* @return {Array<number>} An array with flat SH coefficients.
	*/
	toArray(array$2 = [], offset = 0) {
		const coefficients = this.coefficients;
		for (let i = 0; i < 9; i++) coefficients[i].toArray(array$2, offset + i * 3);
		return array$2;
	}
	/**
	* Computes the SH basis for the given normal vector.
	*
	* @param {Vector3} normal - The normal.
	* @param {Array<number>} shBasis - The target array holding the SH basis.
	*/
	static getBasisAt(normal$1, shBasis) {
		const x = normal$1.x, y = normal$1.y, z = normal$1.z;
		shBasis[0] = .282095;
		shBasis[1] = .488603 * y;
		shBasis[2] = .488603 * z;
		shBasis[3] = .488603 * x;
		shBasis[4] = 1.092548 * x * y;
		shBasis[5] = 1.092548 * y * z;
		shBasis[6] = .315392 * (3 * z * z - 1);
		shBasis[7] = 1.092548 * x * z;
		shBasis[8] = .546274 * (x * x - y * y);
	}
};
/**
* Light probes are an alternative way of adding light to a 3D scene. Unlike
* classical light sources (e.g. directional, point or spot lights), light
* probes do not emit light. Instead they store information about light
* passing through 3D space. During rendering, the light that hits a 3D
* object is approximated by using the data from the light probe.
*
* Light probes are usually created from (radiance) environment maps. The
* class {@link LightProbeGenerator} can be used to create light probes from
* cube textures or render targets. However, light estimation data could also
* be provided in other forms e.g. by WebXR. This enables the rendering of
* augmented reality content that reacts to real world lighting.
*
* The current probe implementation in three.js supports so-called diffuse
* light probes. This type of light probe is functionally equivalent to an
* irradiance environment map.
*
* @augments Light
*/
var LightProbe = class extends Light {
	/**
	* Constructs a new light probe.
	*
	* @param {SphericalHarmonics3} sh - The spherical harmonics which represents encoded lighting information.
	* @param {number} [intensity=1] - The light's strength/intensity.
	*/
	constructor(sh = new SphericalHarmonics3(), intensity = 1) {
		super(void 0, intensity);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isLightProbe = true;
		/**
		* A light probe uses spherical harmonics to encode lighting information.
		*
		* @type {SphericalHarmonics3}
		*/
		this.sh = sh;
	}
	copy(source) {
		super.copy(source);
		this.sh.copy(source.sh);
		return this;
	}
	/**
	* Deserializes the light prove from the given JSON.
	*
	* @param {Object} json - The JSON holding the serialized light probe.
	* @return {LightProbe} A reference to this light probe.
	*/
	fromJSON(json) {
		this.intensity = json.intensity;
		this.sh.fromArray(json.sh);
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.sh = this.sh.toArray();
		return data;
	}
};
/**
* This type of camera can be used in order to efficiently render a scene with a
* predefined set of cameras. This is an important performance aspect for
* rendering VR scenes.
*
* An instance of `ArrayCamera` always has an array of sub cameras. It's mandatory
* to define for each sub camera the `viewport` property which determines the
* part of the viewport that is rendered with this camera.
*
* @augments PerspectiveCamera
*/
var ArrayCamera = class extends PerspectiveCamera {
	/**
	* Constructs a new array camera.
	*
	* @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
	*/
	constructor(array$2 = []) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isArrayCamera = true;
		/**
		* Whether this camera is used with multiview rendering or not.
		*
		* @type {boolean}
		* @readonly
		* @default false
		*/
		this.isMultiViewCamera = false;
		/**
		* An array of perspective sub cameras.
		*
		* @type {Array<PerspectiveCamera>}
		*/
		this.cameras = array$2;
	}
};
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = /* @__PURE__ */ new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
var _supportedObjectNames = [
	"material",
	"materials",
	"bones",
	"map"
];
var Composite = class {
	constructor(targetGroup, path, optionalParsedPath) {
		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_(path, parsedPath);
	}
	getValue(array$2, offset) {
		this.bind();
		const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
		if (binding !== void 0) binding.getValue(array$2, offset);
	}
	setValue(array$2, offset) {
		const bindings = this._bindings;
		for (let i = this._targetGroup.nCachedObjects_, n$2 = bindings.length; i !== n$2; ++i) bindings[i].setValue(array$2, offset);
	}
	bind() {
		const bindings = this._bindings;
		for (let i = this._targetGroup.nCachedObjects_, n$2 = bindings.length; i !== n$2; ++i) bindings[i].bind();
	}
	unbind() {
		const bindings = this._bindings;
		for (let i = this._targetGroup.nCachedObjects_, n$2 = bindings.length; i !== n$2; ++i) bindings[i].unbind();
	}
};
/**
* This holds a reference to a real property in the scene graph; used internally.
*/
var PropertyBinding = class PropertyBinding {
	/**
	* Constructs a new property binding.
	*
	* @param {Object} rootNode - The root node.
	* @param {string} path - The path.
	* @param {?Object} [parsedPath] - The parsed path.
	*/
	constructor(rootNode, path, parsedPath) {
		/**
		* The object path to the animated property.
		*
		* @type {string}
		*/
		this.path = path;
		/**
		* An object holding information about the path.
		*
		* @type {Object}
		*/
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
		/**
		* The object owns the animated property.
		*
		* @type {?Object}
		*/
		this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
		/**
		* The root node.
		*
		* @type {Object3D|Skeleton}
		*/
		this.rootNode = rootNode;
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;
	}
	/**
	* Factory method for creating a property binding from the given parameters.
	*
	* @static
	* @param {Object} root - The root node.
	* @param {string} path - The path.
	* @param {?Object} [parsedPath] - The parsed path.
	* @return {PropertyBinding|Composite} The created property binding or composite.
	*/
	static create(root, path, parsedPath) {
		if (!(root && root.isAnimationObjectGroup)) return new PropertyBinding(root, path, parsedPath);
		else return new PropertyBinding.Composite(root, path, parsedPath);
	}
	/**
	* Replaces spaces with underscores and removes unsupported characters from
	* node names, to ensure compatibility with parseTrackName().
	*
	* @param {string} name - Node name to be sanitized.
	* @return {string} The sanitized node name.
	*/
	static sanitizeNodeName(name) {
		return name.replace(/\s/g, "_").replace(_reservedRe, "");
	}
	/**
	* Parses the given track name (an object path to an animated property) and
	* returns an object with information about the path. Matches strings in the following forms:
	*
	* - nodeName.property
	* - nodeName.property[accessor]
	* - nodeName.material.property[accessor]
	* - uuid.property[accessor]
	* - uuid.objectName[objectIndex].propertyName[propertyIndex]
	* - parentName/nodeName.property
	* - parentName/parentName/nodeName.property[index]
	* - .bone[Armature.DEF_cog].position
	* - scene:helium_balloon_model:helium_balloon_model.position
	*
	* @static
	* @param {string} trackName - The track name to parse.
	* @return {Object} The parsed track name as an object.
	*/
	static parseTrackName(trackName) {
		const matches = _trackRe.exec(trackName);
		if (matches === null) throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
		const results = {
			nodeName: matches[2],
			objectName: matches[3],
			objectIndex: matches[4],
			propertyName: matches[5],
			propertyIndex: matches[6]
		};
		const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
		if (lastDot !== void 0 && lastDot !== -1) {
			const objectName = results.nodeName.substring(lastDot + 1);
			if (_supportedObjectNames.indexOf(objectName) !== -1) {
				results.nodeName = results.nodeName.substring(0, lastDot);
				results.objectName = objectName;
			}
		}
		if (results.propertyName === null || results.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
		return results;
	}
	/**
	* Searches for a node in the hierarchy of the given root object by the given
	* node name.
	*
	* @static
	* @param {Object} root - The root object.
	* @param {string|number} nodeName - The name of the node.
	* @return {?Object} The found node. Returns `null` if no object was found.
	*/
	static findNode(root, nodeName) {
		if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) return root;
		if (root.skeleton) {
			const bone = root.skeleton.getBoneByName(nodeName);
			if (bone !== void 0) return bone;
		}
		if (root.children) {
			const searchNodeSubtree = function(children) {
				for (let i = 0; i < children.length; i++) {
					const childNode = children[i];
					if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
					const result = searchNodeSubtree(childNode.children);
					if (result) return result;
				}
				return null;
			};
			const subTreeNode = searchNodeSubtree(root.children);
			if (subTreeNode) return subTreeNode;
		}
		return null;
	}
	_getValue_unavailable() {}
	_setValue_unavailable() {}
	_getValue_direct(buffer$2, offset) {
		buffer$2[offset] = this.targetObject[this.propertyName];
	}
	_getValue_array(buffer$2, offset) {
		const source = this.resolvedProperty;
		for (let i = 0, n$2 = source.length; i !== n$2; ++i) buffer$2[offset++] = source[i];
	}
	_getValue_arrayElement(buffer$2, offset) {
		buffer$2[offset] = this.resolvedProperty[this.propertyIndex];
	}
	_getValue_toArray(buffer$2, offset) {
		this.resolvedProperty.toArray(buffer$2, offset);
	}
	_setValue_direct(buffer$2, offset) {
		this.targetObject[this.propertyName] = buffer$2[offset];
	}
	_setValue_direct_setNeedsUpdate(buffer$2, offset) {
		this.targetObject[this.propertyName] = buffer$2[offset];
		this.targetObject.needsUpdate = true;
	}
	_setValue_direct_setMatrixWorldNeedsUpdate(buffer$2, offset) {
		this.targetObject[this.propertyName] = buffer$2[offset];
		this.targetObject.matrixWorldNeedsUpdate = true;
	}
	_setValue_array(buffer$2, offset) {
		const dest = this.resolvedProperty;
		for (let i = 0, n$2 = dest.length; i !== n$2; ++i) dest[i] = buffer$2[offset++];
	}
	_setValue_array_setNeedsUpdate(buffer$2, offset) {
		const dest = this.resolvedProperty;
		for (let i = 0, n$2 = dest.length; i !== n$2; ++i) dest[i] = buffer$2[offset++];
		this.targetObject.needsUpdate = true;
	}
	_setValue_array_setMatrixWorldNeedsUpdate(buffer$2, offset) {
		const dest = this.resolvedProperty;
		for (let i = 0, n$2 = dest.length; i !== n$2; ++i) dest[i] = buffer$2[offset++];
		this.targetObject.matrixWorldNeedsUpdate = true;
	}
	_setValue_arrayElement(buffer$2, offset) {
		this.resolvedProperty[this.propertyIndex] = buffer$2[offset];
	}
	_setValue_arrayElement_setNeedsUpdate(buffer$2, offset) {
		this.resolvedProperty[this.propertyIndex] = buffer$2[offset];
		this.targetObject.needsUpdate = true;
	}
	_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer$2, offset) {
		this.resolvedProperty[this.propertyIndex] = buffer$2[offset];
		this.targetObject.matrixWorldNeedsUpdate = true;
	}
	_setValue_fromArray(buffer$2, offset) {
		this.resolvedProperty.fromArray(buffer$2, offset);
	}
	_setValue_fromArray_setNeedsUpdate(buffer$2, offset) {
		this.resolvedProperty.fromArray(buffer$2, offset);
		this.targetObject.needsUpdate = true;
	}
	_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer$2, offset) {
		this.resolvedProperty.fromArray(buffer$2, offset);
		this.targetObject.matrixWorldNeedsUpdate = true;
	}
	_getValue_unbound(targetArray, offset) {
		this.bind();
		this.getValue(targetArray, offset);
	}
	_setValue_unbound(sourceArray, offset) {
		this.bind();
		this.setValue(sourceArray, offset);
	}
	/**
	* Creates a getter / setter pair for the property tracked by this binding.
	*/
	bind() {
		let targetObject = this.node;
		const parsedPath = this.parsedPath;
		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;
		if (!targetObject) {
			targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
			this.node = targetObject;
		}
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;
		if (!targetObject) {
			warn("PropertyBinding: No target node found for track: " + this.path + ".");
			return;
		}
		if (objectName) {
			let objectIndex = parsedPath.objectIndex;
			switch (objectName) {
				case "materials":
					if (!targetObject.material) {
						error("PropertyBinding: Can not bind to material as node does not have a material.", this);
						return;
					}
					if (!targetObject.material.materials) {
						error("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
						return;
					}
					targetObject = targetObject.material.materials;
					break;
				case "bones":
					if (!targetObject.skeleton) {
						error("PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
						return;
					}
					targetObject = targetObject.skeleton.bones;
					for (let i = 0; i < targetObject.length; i++) if (targetObject[i].name === objectIndex) {
						objectIndex = i;
						break;
					}
					break;
				case "map":
					if ("map" in targetObject) {
						targetObject = targetObject.map;
						break;
					}
					if (!targetObject.material) {
						error("PropertyBinding: Can not bind to material as node does not have a material.", this);
						return;
					}
					if (!targetObject.material.map) {
						error("PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
						return;
					}
					targetObject = targetObject.material.map;
					break;
				default:
					if (targetObject[objectName] === void 0) {
						error("PropertyBinding: Can not bind to objectName of node undefined.", this);
						return;
					}
					targetObject = targetObject[objectName];
			}
			if (objectIndex !== void 0) {
				if (targetObject[objectIndex] === void 0) {
					error("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
					return;
				}
				targetObject = targetObject[objectIndex];
			}
		}
		const nodeProperty = targetObject[propertyName];
		if (nodeProperty === void 0) {
			const nodeName = parsedPath.nodeName;
			error("PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
			return;
		}
		let versioning = this.Versioning.None;
		this.targetObject = targetObject;
		if (targetObject.isMaterial === true) versioning = this.Versioning.NeedsUpdate;
		else if (targetObject.isObject3D === true) versioning = this.Versioning.MatrixWorldNeedsUpdate;
		let bindingType = this.BindingType.Direct;
		if (propertyIndex !== void 0) {
			if (propertyName === "morphTargetInfluences") {
				if (!targetObject.geometry) {
					error("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
					return;
				}
				if (!targetObject.geometry.morphAttributes) {
					error("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
					return;
				}
				if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
			}
			bindingType = this.BindingType.ArrayElement;
			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;
		} else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
			bindingType = this.BindingType.HasFromToArray;
			this.resolvedProperty = nodeProperty;
		} else if (Array.isArray(nodeProperty)) {
			bindingType = this.BindingType.EntireArray;
			this.resolvedProperty = nodeProperty;
		} else this.propertyName = propertyName;
		this.getValue = this.GetterByBindingType[bindingType];
		this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
	}
	/**
	* Unbinds the property.
	*/
	unbind() {
		this.node = null;
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;
	}
};
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
	PropertyBinding.prototype._getValue_direct,
	PropertyBinding.prototype._getValue_array,
	PropertyBinding.prototype._getValue_arrayElement,
	PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
	[
		PropertyBinding.prototype._setValue_direct,
		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
	],
	[
		PropertyBinding.prototype._setValue_array,
		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
	],
	[
		PropertyBinding.prototype._setValue_arrayElement,
		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
	],
	[
		PropertyBinding.prototype._setValue_fromArray,
		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
	]
];
var _controlInterpolantsResultBuffer = new Float32Array(1);
/**
* An instanced version of an interleaved buffer.
*
* @augments InterleavedBuffer
*/
var InstancedInterleavedBuffer = class extends InterleavedBuffer {
	/**
	* Constructs a new instanced interleaved buffer.
	*
	* @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
	* @param {number} stride - The number of typed-array elements per vertex.
	* @param {number} [meshPerAttribute=1] - Defines how often a value of this interleaved buffer should be repeated.
	*/
	constructor(array$2, stride, meshPerAttribute = 1) {
		super(array$2, stride);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isInstancedInterleavedBuffer = true;
		/**
		* Defines how often a value of this buffer attribute should be repeated,
		* see {@link InstancedBufferAttribute#meshPerAttribute}.
		*
		* @type {number}
		* @default 1
		*/
		this.meshPerAttribute = meshPerAttribute;
	}
	copy(source) {
		super.copy(source);
		this.meshPerAttribute = source.meshPerAttribute;
		return this;
	}
	clone(data) {
		const ib = super.clone(data);
		ib.meshPerAttribute = this.meshPerAttribute;
		return ib;
	}
	toJSON(data) {
		const json = super.toJSON(data);
		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;
		return json;
	}
};
/**
* Represents a 2x2 matrix.
*
* A Note on Row-Major and Column-Major Ordering:
*
* The constructor and {@link Matrix2#set} method take arguments in
* [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
* order, while internally they are stored in the {@link Matrix2#elements} array in column-major order.
* This means that calling:
* ```js
* const m = new THREE.Matrix2();
* m.set( 11, 12,
*        21, 22 );
* ```
* will result in the elements array containing:
* ```js
* m.elements = [ 11, 21,
*                12, 22 ];
* ```
* and internally all calculations are performed using column-major ordering.
* However, as the actual ordering makes no difference mathematically and
* most people are used to thinking about matrices in row-major order, the
* three.js documentation shows matrices in row-major order. Just bear in
* mind that if you are reading the source code, you'll have to take the
* transpose of any matrices outlined here to make sense of the calculations.
*/
var Matrix2 = class Matrix2 {
	/**
	* Constructs a new 2x2 matrix. The arguments are supposed to be
	* in row-major order. If no arguments are provided, the constructor
	* initializes the matrix as an identity matrix.
	*
	* @param {number} [n11] - 1-1 matrix element.
	* @param {number} [n12] - 1-2 matrix element.
	* @param {number} [n21] - 2-1 matrix element.
	* @param {number} [n22] - 2-2 matrix element.
	*/
	constructor(n11, n12, n21, n22) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		Matrix2.prototype.isMatrix2 = true;
		/**
		* A column-major list of matrix values.
		*
		* @type {Array<number>}
		*/
		this.elements = [
			1,
			0,
			0,
			1
		];
		if (n11 !== void 0) this.set(n11, n12, n21, n22);
	}
	/**
	* Sets this matrix to the 2x2 identity matrix.
	*
	* @return {Matrix2} A reference to this matrix.
	*/
	identity() {
		this.set(1, 0, 0, 1);
		return this;
	}
	/**
	* Sets the elements of the matrix from the given array.
	*
	* @param {Array<number>} array - The matrix elements in column-major order.
	* @param {number} [offset=0] - Index of the first element in the array.
	* @return {Matrix2} A reference to this matrix.
	*/
	fromArray(array$2, offset = 0) {
		for (let i = 0; i < 4; i++) this.elements[i] = array$2[i + offset];
		return this;
	}
	/**
	* Sets the elements of the matrix.The arguments are supposed to be
	* in row-major order.
	*
	* @param {number} n11 - 1-1 matrix element.
	* @param {number} n12 - 1-2 matrix element.
	* @param {number} n21 - 2-1 matrix element.
	* @param {number} n22 - 2-2 matrix element.
	* @return {Matrix2} A reference to this matrix.
	*/
	set(n11, n12, n21, n22) {
		const te = this.elements;
		te[0] = n11;
		te[2] = n12;
		te[1] = n21;
		te[3] = n22;
		return this;
	}
};
/**
* Determines how many bytes must be used to represent the texture.
*
* @param {number} width - The width of the texture.
* @param {number} height - The height of the texture.
* @param {number} format - The texture's format.
* @param {number} type - The texture's type.
* @return {number} The byte length.
*/
function getByteLength(width, height, format, type$1) {
	const typeByteLength = getTextureTypeByteLength(type$1);
	switch (format) {
		case AlphaFormat: return width * height;
		case RedFormat: return width * height / typeByteLength.components * typeByteLength.byteLength;
		case RedIntegerFormat: return width * height / typeByteLength.components * typeByteLength.byteLength;
		case RGFormat: return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
		case RGIntegerFormat: return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
		case RGBFormat: return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
		case RGBAFormat: return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
		case RGBAIntegerFormat: return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
		case RGB_S3TC_DXT1_Format:
		case RGBA_S3TC_DXT1_Format: return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
		case RGBA_S3TC_DXT3_Format:
		case RGBA_S3TC_DXT5_Format: return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
		case RGB_PVRTC_2BPPV1_Format:
		case RGBA_PVRTC_2BPPV1_Format: return Math.max(width, 16) * Math.max(height, 8) / 4;
		case RGB_PVRTC_4BPPV1_Format:
		case RGBA_PVRTC_4BPPV1_Format: return Math.max(width, 8) * Math.max(height, 8) / 2;
		case RGB_ETC1_Format:
		case RGB_ETC2_Format: return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
		case RGBA_ETC2_EAC_Format: return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
		case RGBA_ASTC_4x4_Format: return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
		case RGBA_ASTC_5x4_Format: return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
		case RGBA_ASTC_5x5_Format: return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
		case RGBA_ASTC_6x5_Format: return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
		case RGBA_ASTC_6x6_Format: return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
		case RGBA_ASTC_8x5_Format: return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
		case RGBA_ASTC_8x6_Format: return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
		case RGBA_ASTC_8x8_Format: return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
		case RGBA_ASTC_10x5_Format: return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
		case RGBA_ASTC_10x6_Format: return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
		case RGBA_ASTC_10x8_Format: return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
		case RGBA_ASTC_10x10_Format: return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
		case RGBA_ASTC_12x10_Format: return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
		case RGBA_ASTC_12x12_Format: return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
		case RGBA_BPTC_Format:
		case RGB_BPTC_SIGNED_Format:
		case RGB_BPTC_UNSIGNED_Format: return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
		case RED_RGTC1_Format:
		case SIGNED_RED_RGTC1_Format: return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
		case RED_GREEN_RGTC2_Format:
		case SIGNED_RED_GREEN_RGTC2_Format: return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
	}
	throw new Error(`Unable to determine texture byte length for ${format} format.`);
}
function getTextureTypeByteLength(type$1) {
	switch (type$1) {
		case UnsignedByteType:
		case ByteType: return {
			byteLength: 1,
			components: 1
		};
		case UnsignedShortType:
		case ShortType:
		case HalfFloatType: return {
			byteLength: 2,
			components: 1
		};
		case UnsignedShort4444Type:
		case UnsignedShort5551Type: return {
			byteLength: 2,
			components: 4
		};
		case UnsignedIntType:
		case IntType:
		case FloatType: return {
			byteLength: 4,
			components: 1
		};
		case UnsignedInt5999Type:
		case UnsignedInt101111Type: return {
			byteLength: 4,
			components: 3
		};
	}
	throw new Error(`Unknown texture type ${type$1}.`);
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: REVISION } }));
if (typeof window !== "undefined") if (window.__THREE__) warn("WARNING: Multiple instances of Three.js being imported.");
else window.__THREE__ = REVISION;

//#endregion
//#region node_modules/three/build/three.webgpu.js
var refreshUniforms = [
	"alphaMap",
	"alphaTest",
	"anisotropy",
	"anisotropyMap",
	"anisotropyRotation",
	"aoMap",
	"aoMapIntensity",
	"attenuationColor",
	"attenuationDistance",
	"bumpMap",
	"clearcoat",
	"clearcoatMap",
	"clearcoatNormalMap",
	"clearcoatNormalScale",
	"clearcoatRoughness",
	"color",
	"dispersion",
	"displacementMap",
	"emissive",
	"emissiveIntensity",
	"emissiveMap",
	"envMap",
	"envMapIntensity",
	"gradientMap",
	"ior",
	"iridescence",
	"iridescenceIOR",
	"iridescenceMap",
	"iridescenceThicknessMap",
	"lightMap",
	"lightMapIntensity",
	"map",
	"matcap",
	"metalness",
	"metalnessMap",
	"normalMap",
	"normalScale",
	"opacity",
	"roughness",
	"roughnessMap",
	"sheen",
	"sheenColor",
	"sheenColorMap",
	"sheenRoughnessMap",
	"shininess",
	"specular",
	"specularColor",
	"specularColorMap",
	"specularIntensity",
	"specularIntensityMap",
	"specularMap",
	"thickness",
	"transmission",
	"transmissionMap"
];
/**
* A WeakMap to cache lights data for node materials.
* Cache lights data by render ID to avoid unnecessary recalculations.
*
* @private
* @type {WeakMap<LightsNode,Object>}
*/
var _lightsCache = /* @__PURE__ */ new WeakMap();
/**
* This class is used by {@link WebGPURenderer} as management component.
* It's primary purpose is to determine whether render objects require a
* refresh right before they are going to be rendered or not.
*/
var NodeMaterialObserver = class {
	/**
	* Constructs a new node material observer.
	*
	* @param {NodeBuilder} builder - The node builder.
	*/
	constructor(builder) {
		/**
		* A node material can be used by more than one render object so the
		* monitor must maintain a list of render objects.
		*
		* @type {WeakMap<RenderObject,Object>}
		*/
		this.renderObjects = /* @__PURE__ */ new WeakMap();
		/**
		* Whether the material uses node objects or not.
		*
		* @type {boolean}
		*/
		this.hasNode = this.containsNode(builder);
		/**
		* Whether the node builder's 3D object is animated or not.
		*
		* @type {boolean}
		*/
		this.hasAnimation = builder.object.isSkinnedMesh === true;
		/**
		* A list of all possible material uniforms
		*
		* @type {Array<string>}
		*/
		this.refreshUniforms = refreshUniforms;
		/**
		* Holds the current render ID from the node frame.
		*
		* @type {number}
		* @default 0
		*/
		this.renderId = 0;
	}
	/**
	* Returns `true` if the given render object is verified for the first time of this observer.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {boolean} Whether the given render object is verified for the first time of this observer.
	*/
	firstInitialization(renderObject) {
		if (this.renderObjects.has(renderObject) === false) {
			this.getRenderObjectData(renderObject);
			return true;
		}
		return false;
	}
	/**
	* Returns `true` if the current rendering produces motion vectors.
	*
	* @param {Renderer} renderer - The renderer.
	* @return {boolean} Whether the current rendering produces motion vectors or not.
	*/
	needsVelocity(renderer) {
		const mrt$2 = renderer.getMRT();
		return mrt$2 !== null && mrt$2.has("velocity");
	}
	/**
	* Returns monitoring data for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {Object} The monitoring data.
	*/
	getRenderObjectData(renderObject) {
		let data = this.renderObjects.get(renderObject);
		if (data === void 0) {
			const { geometry, material, object } = renderObject;
			data = {
				material: this.getMaterialData(material),
				geometry: {
					id: geometry.id,
					attributes: this.getAttributesData(geometry.attributes),
					indexVersion: geometry.index ? geometry.index.version : null,
					drawRange: {
						start: geometry.drawRange.start,
						count: geometry.drawRange.count
					}
				},
				worldMatrix: object.matrixWorld.clone()
			};
			if (object.center) data.center = object.center.clone();
			if (object.morphTargetInfluences) data.morphTargetInfluences = object.morphTargetInfluences.slice();
			if (renderObject.bundle !== null) data.version = renderObject.bundle.version;
			if (data.material.transmission > 0) {
				const { width, height } = renderObject.context;
				data.bufferWidth = width;
				data.bufferHeight = height;
			}
			data.lights = this.getLightsData(renderObject.lightsNode.getLights());
			this.renderObjects.set(renderObject, data);
		}
		return data;
	}
	/**
	* Returns an attribute data structure holding the attributes versions for
	* monitoring.
	*
	* @param {Object} attributes - The geometry attributes.
	* @return {Object} An object for monitoring the versions of attributes.
	*/
	getAttributesData(attributes) {
		const attributesData = {};
		for (const name in attributes) attributesData[name] = { version: attributes[name].version };
		return attributesData;
	}
	/**
	* Returns `true` if the node builder's material uses
	* node properties.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {boolean} Whether the node builder's material uses node properties or not.
	*/
	containsNode(builder) {
		const material = builder.material;
		for (const property$2 in material) if (material[property$2] && material[property$2].isNode) return true;
		if (builder.renderer.overrideNodes.modelViewMatrix !== null || builder.renderer.overrideNodes.modelNormalViewMatrix !== null) return true;
		return false;
	}
	/**
	* Returns a material data structure holding the material property values for
	* monitoring.
	*
	* @param {Material} material - The material.
	* @return {Object} An object for monitoring material properties.
	*/
	getMaterialData(material) {
		const data = {};
		for (const property$2 of this.refreshUniforms) {
			const value = material[property$2];
			if (value === null || value === void 0) continue;
			if (typeof value === "object" && value.clone !== void 0) if (value.isTexture === true) data[property$2] = {
				id: value.id,
				version: value.version
			};
			else data[property$2] = value.clone();
			else data[property$2] = value;
		}
		return data;
	}
	/**
	* Returns `true` if the given render object has not changed its state.
	*
	* @param {RenderObject} renderObject - The render object.
	* @param {Array<Light>} lightsData - The current material lights.
	* @return {boolean} Whether the given render object has changed its state or not.
	*/
	equals(renderObject, lightsData) {
		const { object, material, geometry } = renderObject;
		const renderObjectData = this.getRenderObjectData(renderObject);
		if (renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {
			renderObjectData.worldMatrix.copy(object.matrixWorld);
			return false;
		}
		const materialData = renderObjectData.material;
		for (const property$2 in materialData) {
			const value = materialData[property$2];
			const mtlValue = material[property$2];
			if (value.equals !== void 0) {
				if (value.equals(mtlValue) === false) {
					value.copy(mtlValue);
					return false;
				}
			} else if (mtlValue.isTexture === true) {
				if (value.id !== mtlValue.id || value.version !== mtlValue.version) {
					value.id = mtlValue.id;
					value.version = mtlValue.version;
					return false;
				}
			} else if (value !== mtlValue) {
				materialData[property$2] = mtlValue;
				return false;
			}
		}
		if (materialData.transmission > 0) {
			const { width, height } = renderObject.context;
			if (renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height) {
				renderObjectData.bufferWidth = width;
				renderObjectData.bufferHeight = height;
				return false;
			}
		}
		const storedGeometryData = renderObjectData.geometry;
		const attributes = geometry.attributes;
		const storedAttributes = storedGeometryData.attributes;
		const storedAttributeNames = Object.keys(storedAttributes);
		const currentAttributeNames = Object.keys(attributes);
		if (storedGeometryData.id !== geometry.id) {
			storedGeometryData.id = geometry.id;
			return false;
		}
		if (storedAttributeNames.length !== currentAttributeNames.length) {
			renderObjectData.geometry.attributes = this.getAttributesData(attributes);
			return false;
		}
		for (const name of storedAttributeNames) {
			const storedAttributeData = storedAttributes[name];
			const attribute$2 = attributes[name];
			if (attribute$2 === void 0) {
				delete storedAttributes[name];
				return false;
			}
			if (storedAttributeData.version !== attribute$2.version) {
				storedAttributeData.version = attribute$2.version;
				return false;
			}
		}
		const index = geometry.index;
		const storedIndexVersion = storedGeometryData.indexVersion;
		const currentIndexVersion = index ? index.version : null;
		if (storedIndexVersion !== currentIndexVersion) {
			storedGeometryData.indexVersion = currentIndexVersion;
			return false;
		}
		if (storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count) {
			storedGeometryData.drawRange.start = geometry.drawRange.start;
			storedGeometryData.drawRange.count = geometry.drawRange.count;
			return false;
		}
		if (renderObjectData.morphTargetInfluences) {
			let morphChanged = false;
			for (let i = 0; i < renderObjectData.morphTargetInfluences.length; i++) if (renderObjectData.morphTargetInfluences[i] !== object.morphTargetInfluences[i]) {
				renderObjectData.morphTargetInfluences[i] = object.morphTargetInfluences[i];
				morphChanged = true;
			}
			if (morphChanged) return false;
		}
		if (renderObjectData.lights) {
			for (let i = 0; i < lightsData.length; i++) if (renderObjectData.lights[i].map !== lightsData[i].map) return false;
		}
		if (renderObjectData.center) {
			if (renderObjectData.center.equals(object.center) === false) {
				renderObjectData.center.copy(object.center);
				return true;
			}
		}
		if (renderObject.bundle !== null) renderObjectData.version = renderObject.bundle.version;
		return true;
	}
	/**
	* Returns the lights data for the given material lights.
	*
	* @param {Array<Light>} materialLights - The material lights.
	* @return {Array<Object>} The lights data for the given material lights.
	*/
	getLightsData(materialLights) {
		const lights$2 = [];
		for (const light of materialLights) if (light.isSpotLight === true && light.map !== null) lights$2.push({ map: light.map.version });
		return lights$2;
	}
	/**
	* Returns the lights for the given lights node and render ID.
	*
	* @param {LightsNode} lightsNode - The lights node.
	* @param {number} renderId - The render ID.
	* @return {Array<Object>} The lights for the given lights node and render ID.
	*/
	getLights(lightsNode, renderId) {
		if (_lightsCache.has(lightsNode)) {
			const cached = _lightsCache.get(lightsNode);
			if (cached.renderId === renderId) return cached.lightsData;
		}
		const lightsData = this.getLightsData(lightsNode.getLights());
		_lightsCache.set(lightsNode, {
			renderId,
			lightsData
		});
		return lightsData;
	}
	/**
	* Checks if the given render object requires a refresh.
	*
	* @param {RenderObject} renderObject - The render object.
	* @param {NodeFrame} nodeFrame - The current node frame.
	* @return {boolean} Whether the given render object requires a refresh or not.
	*/
	needsRefresh(renderObject, nodeFrame) {
		if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject) || this.needsVelocity(nodeFrame.renderer)) return true;
		const { renderId } = nodeFrame;
		if (this.renderId !== renderId) {
			this.renderId = renderId;
			return true;
		}
		const isStatic = renderObject.object.static === true;
		const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData(renderObject).version === renderObject.bundle.version;
		if (isStatic || isBundle) return false;
		const lightsData = this.getLights(renderObject.lightsNode, renderId);
		return this.equals(renderObject, lightsData) !== true;
	}
};
function cyrb53(value, seed = 0) {
	let h1$1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
	if (value instanceof Array) for (let i = 0, val; i < value.length; i++) {
		val = value[i];
		h1$1 = Math.imul(h1$1 ^ val, 2654435761);
		h2 = Math.imul(h2 ^ val, 1597334677);
	}
	else for (let i = 0, ch; i < value.length; i++) {
		ch = value.charCodeAt(i);
		h1$1 = Math.imul(h1$1 ^ ch, 2654435761);
		h2 = Math.imul(h2 ^ ch, 1597334677);
	}
	h1$1 = Math.imul(h1$1 ^ h1$1 >>> 16, 2246822507);
	h1$1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
	h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
	h2 ^= Math.imul(h1$1 ^ h1$1 >>> 13, 3266489909);
	return 4294967296 * (2097151 & h2) + (h1$1 >>> 0);
}
/**
* Computes a hash for the given string.
*
* @private
* @method
* @param {string} str - The string to be hashed.
* @return {number} The hash.
*/
var hashString = (str) => cyrb53(str);
/**
* Computes a hash for the given array.
*
* @private
* @method
* @param {Array<number>} array - The array to be hashed.
* @return {number} The hash.
*/
var hashArray = (array$2) => cyrb53(array$2);
/**
* Computes a hash for the given list of parameters.
*
* @private
* @method
* @param {...number} params - A list of parameters.
* @return {number} The hash.
*/
var hash$1 = (...params) => cyrb53(params);
var typeFromLength = /* @__PURE__ */ new Map([
	[1, "float"],
	[2, "vec2"],
	[3, "vec3"],
	[4, "vec4"],
	[9, "mat3"],
	[16, "mat4"]
]);
var dataFromObject = /* @__PURE__ */ new WeakMap();
/**
* Returns the data type for the given the length.
*
* @private
* @method
* @param {number} length - The length.
* @return {string} The data type.
*/
function getTypeFromLength(length$2) {
	return typeFromLength.get(length$2);
}
/**
* Returns the typed array for the given data type.
*
* @private
* @method
* @param {string} type - The data type.
* @return {TypedArray} The typed array.
*/
function getTypedArrayFromType(type$1) {
	if (/[iu]?vec\d/.test(type$1)) {
		if (type$1.startsWith("ivec")) return Int32Array;
		if (type$1.startsWith("uvec")) return Uint32Array;
		return Float32Array;
	}
	if (/mat\d/.test(type$1)) return Float32Array;
	if (/float/.test(type$1)) return Float32Array;
	if (/uint/.test(type$1)) return Uint32Array;
	if (/int/.test(type$1)) return Int32Array;
	throw new Error(`THREE.NodeUtils: Unsupported type: ${type$1}`);
}
/**
* Returns the length for the given data type.
*
* @private
* @method
* @param {string} type - The data type.
* @return {number} The length.
*/
function getLengthFromType(type$1) {
	if (/float|int|uint/.test(type$1)) return 1;
	if (/vec2/.test(type$1)) return 2;
	if (/vec3/.test(type$1)) return 3;
	if (/vec4/.test(type$1)) return 4;
	if (/mat2/.test(type$1)) return 4;
	if (/mat3/.test(type$1)) return 9;
	if (/mat4/.test(type$1)) return 16;
	error("TSL: Unsupported type:", type$1);
}
/**
* Returns the gpu memory length for the given data type.
*
* @private
* @method
* @param {string} type - The data type.
* @return {number} The length.
*/
function getMemoryLengthFromType(type$1) {
	if (/float|int|uint/.test(type$1)) return 1;
	if (/vec2/.test(type$1)) return 2;
	if (/vec3/.test(type$1)) return 3;
	if (/vec4/.test(type$1)) return 4;
	if (/mat2/.test(type$1)) return 4;
	if (/mat3/.test(type$1)) return 12;
	if (/mat4/.test(type$1)) return 16;
	error("TSL: Unsupported type:", type$1);
}
/**
* Returns the byte boundary for the given data type.
*
* @private
* @method
* @param {string} type - The data type.
* @return {number} The byte boundary.
*/
function getByteBoundaryFromType(type$1) {
	if (/float|int|uint/.test(type$1)) return 4;
	if (/vec2/.test(type$1)) return 8;
	if (/vec3/.test(type$1)) return 16;
	if (/vec4/.test(type$1)) return 16;
	if (/mat2/.test(type$1)) return 8;
	if (/mat3/.test(type$1)) return 48;
	if (/mat4/.test(type$1)) return 64;
	error("TSL: Unsupported type:", type$1);
}
/**
* Returns the data type for the given value.
*
* @private
* @method
* @param {any} value - The value.
* @return {?string} The data type.
*/
function getValueType(value) {
	if (value === void 0 || value === null) return null;
	const typeOf = typeof value;
	if (value.isNode === true) return "node";
	else if (typeOf === "number") return "float";
	else if (typeOf === "boolean") return "bool";
	else if (typeOf === "string") return "string";
	else if (typeOf === "function") return "shader";
	else if (value.isVector2 === true) return "vec2";
	else if (value.isVector3 === true) return "vec3";
	else if (value.isVector4 === true) return "vec4";
	else if (value.isMatrix2 === true) return "mat2";
	else if (value.isMatrix3 === true) return "mat3";
	else if (value.isMatrix4 === true) return "mat4";
	else if (value.isColor === true) return "color";
	else if (value instanceof ArrayBuffer) return "ArrayBuffer";
	return null;
}
/**
* Returns the value/object for the given data type and parameters.
*
* @private
* @method
* @param {string} type - The given type.
* @param {...any} params - A parameter list.
* @return {any} The value/object.
*/
function getValueFromType(type$1, ...params) {
	const last4 = type$1 ? type$1.slice(-4) : void 0;
	if (params.length === 1) {
		if (last4 === "vec2") params = [params[0], params[0]];
		else if (last4 === "vec3") params = [
			params[0],
			params[0],
			params[0]
		];
		else if (last4 === "vec4") params = [
			params[0],
			params[0],
			params[0],
			params[0]
		];
	}
	if (type$1 === "color") return new Color$1(...params);
	else if (last4 === "vec2") return new Vector2(...params);
	else if (last4 === "vec3") return new Vector3(...params);
	else if (last4 === "vec4") return new Vector4(...params);
	else if (last4 === "mat2") return new Matrix2(...params);
	else if (last4 === "mat3") return new Matrix3(...params);
	else if (last4 === "mat4") return new Matrix4(...params);
	else if (type$1 === "bool") return params[0] || false;
	else if (type$1 === "float" || type$1 === "int" || type$1 === "uint") return params[0] || 0;
	else if (type$1 === "string") return params[0] || "";
	else if (type$1 === "ArrayBuffer") return base64ToArrayBuffer(params[0]);
	return null;
}
/**
* Gets the object data that can be shared between different rendering steps.
*
* @private
* @param {Object} object - The object to get the data for.
* @return {Object} The object data.
*/
function getDataFromObject(object) {
	let data = dataFromObject.get(object);
	if (data === void 0) {
		data = {};
		dataFromObject.set(object, data);
	}
	return data;
}
/**
* Converts the given array buffer to a Base64 string.
*
* @private
* @method
* @param {ArrayBuffer} arrayBuffer - The array buffer.
* @return {string} The Base64 string.
*/
function arrayBufferToBase64(arrayBuffer$2) {
	let chars = "";
	const array$2 = new Uint8Array(arrayBuffer$2);
	for (let i = 0; i < array$2.length; i++) chars += String.fromCharCode(array$2[i]);
	return btoa(chars);
}
/**
* Converts the given Base64 string to an array buffer.
*
* @private
* @method
* @param {string} base64 - The Base64 string.
* @return {ArrayBuffer} The array buffer.
*/
function base64ToArrayBuffer(base64) {
	return Uint8Array.from(atob(base64), (c$1) => c$1.charCodeAt(0)).buffer;
}
/**
* Possible shader stages.
*
* @property {string} VERTEX The vertex shader stage.
* @property {string} FRAGMENT The fragment shader stage.
*/
var NodeShaderStage$1 = {
	VERTEX: "vertex",
	FRAGMENT: "fragment"
};
/**
* Update types of a node.
*
* @property {string} NONE The update method is not executed.
* @property {string} FRAME The update method is executed per frame.
* @property {string} RENDER The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME.
* @property {string} OBJECT The update method is executed per {@link Object3D} that uses the node for rendering.
*/
var NodeUpdateType$1 = {
	NONE: "none",
	FRAME: "frame",
	RENDER: "render",
	OBJECT: "object"
};
/**
* Data types of a node.
*
* @property {string} BOOLEAN Boolean type.
* @property {string} INTEGER Integer type.
* @property {string} FLOAT Float type.
* @property {string} VECTOR2 Two-dimensional vector type.
* @property {string} VECTOR3 Three-dimensional vector type.
* @property {string} VECTOR4 Four-dimensional vector type.
* @property {string} MATRIX2 2x2 matrix type.
* @property {string} MATRIX3 3x3 matrix type.
* @property {string} MATRIX4 4x4 matrix type.
*/
var NodeType$1 = {
	BOOLEAN: "bool",
	INTEGER: "int",
	FLOAT: "float",
	VECTOR2: "vec2",
	VECTOR3: "vec3",
	VECTOR4: "vec4",
	MATRIX2: "mat2",
	MATRIX3: "mat3",
	MATRIX4: "mat4"
};
/**
* Access types of a node. These are relevant for compute and storage usage.
*
* @property {string} READ_ONLY Read-only access
* @property {string} WRITE_ONLY Write-only access.
* @property {string} READ_WRITE Read and write access.
*/
var NodeAccess$1 = {
	READ_ONLY: "readOnly",
	WRITE_ONLY: "writeOnly",
	READ_WRITE: "readWrite"
};
var defaultShaderStages$1 = ["fragment", "vertex"];
var defaultBuildStages$1 = [
	"setup",
	"analyze",
	"generate"
];
var shaderStages$1 = [...defaultShaderStages$1, "compute"];
var vectorComponents$1 = [
	"x",
	"y",
	"z",
	"w"
];
var _parentBuildStage = {
	analyze: "setup",
	generate: "analyze"
};
var _nodeId = 0;
/**
* Base class for all nodes.
*
* @augments EventDispatcher
*/
var Node = class extends EventDispatcher {
	static get type() {
		return "Node";
	}
	/**
	* Constructs a new node.
	*
	* @param {?string} nodeType - The node type.
	*/
	constructor(nodeType = null) {
		super();
		/**
		* The node type. This represents the result type of the node (e.g. `float` or `vec3`).
		*
		* @type {?string}
		* @default null
		*/
		this.nodeType = nodeType;
		/**
		* The update type of the node's {@link Node#update} method. Possible values are listed in {@link NodeUpdateType}.
		*
		* @type {string}
		* @default 'none'
		*/
		this.updateType = NodeUpdateType$1.NONE;
		/**
		* The update type of the node's {@link Node#updateBefore} method. Possible values are listed in {@link NodeUpdateType}.
		*
		* @type {string}
		* @default 'none'
		*/
		this.updateBeforeType = NodeUpdateType$1.NONE;
		/**
		* The update type of the node's {@link Node#updateAfter} method. Possible values are listed in {@link NodeUpdateType}.
		*
		* @type {string}
		* @default 'none'
		*/
		this.updateAfterType = NodeUpdateType$1.NONE;
		/**
		* The UUID of the node.
		*
		* @type {string}
		* @readonly
		*/
		this.uuid = MathUtils.generateUUID();
		/**
		* The version of the node. The version automatically is increased when {@link Node#needsUpdate} is set to `true`.
		*
		* @type {number}
		* @readonly
		* @default 0
		*/
		this.version = 0;
		/**
		* The name of the node.
		*
		* @type {string}
		* @default ''
		*/
		this.name = "";
		/**
		* Whether this node is global or not. This property is relevant for the internal
		* node caching system. All nodes which should be declared just once should
		* set this flag to `true` (a typical example is {@link AttributeNode}).
		*
		* @type {boolean}
		* @default false
		*/
		this.global = false;
		/**
		* Create a list of parents for this node during the build process.
		*
		* @type {boolean}
		* @default false
		*/
		this.parents = false;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isNode = true;
		this._beforeNodes = null;
		/**
		* The cache key of this node.
		*
		* @private
		* @type {?number}
		* @default null
		*/
		this._cacheKey = null;
		/**
		* The cache key 's version.
		*
		* @private
		* @type {number}
		* @default 0
		*/
		this._cacheKeyVersion = 0;
		Object.defineProperty(this, "id", { value: _nodeId++ });
	}
	/**
	* Set this property to `true` when the node should be regenerated.
	*
	* @type {boolean}
	* @default false
	* @param {boolean} value
	*/
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
	/**
	* The type of the class. The value is usually the constructor name.
	*
	* @type {string}
	* @readonly
	*/
	get type() {
		return this.constructor.type;
	}
	/**
	* Convenient method for defining {@link Node#update}.
	*
	* @param {Function} callback - The update method.
	* @param {string} updateType - The update type.
	* @return {Node} A reference to this node.
	*/
	onUpdate(callback, updateType) {
		this.updateType = updateType;
		this.update = callback.bind(this);
		return this;
	}
	/**
	* Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
	* this method automatically sets the update type to `FRAME`.
	*
	* @param {Function} callback - The update method.
	* @return {Node} A reference to this node.
	*/
	onFrameUpdate(callback) {
		return this.onUpdate(callback, NodeUpdateType$1.FRAME);
	}
	/**
	* Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
	* this method automatically sets the update type to `RENDER`.
	*
	* @param {Function} callback - The update method.
	* @return {Node} A reference to this node.
	*/
	onRenderUpdate(callback) {
		return this.onUpdate(callback, NodeUpdateType$1.RENDER);
	}
	/**
	* Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
	* this method automatically sets the update type to `OBJECT`.
	*
	* @param {Function} callback - The update method.
	* @return {Node} A reference to this node.
	*/
	onObjectUpdate(callback) {
		return this.onUpdate(callback, NodeUpdateType$1.OBJECT);
	}
	/**
	* Convenient method for defining {@link Node#updateReference}.
	*
	* @param {Function} callback - The update method.
	* @return {Node} A reference to this node.
	*/
	onReference(callback) {
		this.updateReference = callback.bind(this);
		return this;
	}
	/**
	* Nodes might refer to other objects like materials. This method allows to dynamically update the reference
	* to such objects based on a given state (e.g. the current node frame or builder).
	*
	* @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
	* @return {any} The updated reference.
	*/
	updateReference() {
		return this;
	}
	/**
	* By default this method returns the value of the {@link Node#global} flag. This method
	* can be overwritten in derived classes if an analytical way is required to determine the
	* global cache referring to the current shader-stage.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {boolean} Whether this node is global or not.
	*/
	isGlobal() {
		return this.global;
	}
	/**
	* Generator function that can be used to iterate over the child nodes.
	*
	* @generator
	* @yields {Node} A child node.
	*/
	*getChildren() {
		for (const { childNode } of this._getChildren()) yield childNode;
	}
	/**
	* Calling this method dispatches the `dispose` event. This event can be used
	* to register event listeners for clean up tasks.
	*/
	dispose() {
		this.dispatchEvent({ type: "dispose" });
	}
	/**
	* Callback for {@link Node#traverse}.
	*
	* @callback traverseCallback
	* @param {Node} node - The current node.
	*/
	/**
	* Can be used to traverse through the node's hierarchy.
	*
	* @param {traverseCallback} callback - A callback that is executed per node.
	*/
	traverse(callback) {
		callback(this);
		for (const childNode of this.getChildren()) childNode.traverse(callback);
	}
	/**
	* Returns the child nodes of this node.
	*
	* @private
	* @param {Set<Node>} [ignores=new Set()] - A set of nodes to ignore during the search to avoid circular references.
	* @returns {Array<Object>} An array of objects describing the child nodes.
	*/
	_getChildren(ignores = /* @__PURE__ */ new Set()) {
		const children = [];
		ignores.add(this);
		for (const property$2 of Object.getOwnPropertyNames(this)) {
			const object = this[property$2];
			if (property$2.startsWith("_") === true || ignores.has(object)) continue;
			if (Array.isArray(object) === true) for (let i = 0; i < object.length; i++) {
				const child = object[i];
				if (child && child.isNode === true) children.push({
					property: property$2,
					index: i,
					childNode: child
				});
			}
			else if (object && object.isNode === true) children.push({
				property: property$2,
				childNode: object
			});
			else if (object && Object.getPrototypeOf(object) === Object.prototype) for (const subProperty in object) {
				if (subProperty.startsWith("_") === true) continue;
				const child = object[subProperty];
				if (child && child.isNode === true) children.push({
					property: property$2,
					index: subProperty,
					childNode: child
				});
			}
		}
		return children;
	}
	/**
	* Returns the cache key for this node.
	*
	* @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
	* @param {Set<Node>} [ignores=null] - A set of nodes to ignore during the computation of the cache key.
	* @return {number} The cache key of the node.
	*/
	getCacheKey(force = false, ignores = null) {
		force = force || this.version !== this._cacheKeyVersion;
		if (force === true || this._cacheKey === null) {
			if (ignores === null) ignores = /* @__PURE__ */ new Set();
			const values = [];
			for (const { property: property$2, childNode } of this._getChildren(ignores)) values.push(hashString(property$2.slice(0, -4)), childNode.getCacheKey(force, ignores));
			this._cacheKey = hash$1(hashArray(values), this.customCacheKey());
			this._cacheKeyVersion = this.version;
		}
		return this._cacheKey;
	}
	/**
	* Generate a custom cache key for this node.
	*
	* @return {number} The cache key of the node.
	*/
	customCacheKey() {
		return this.id;
	}
	/**
	* Returns the references to this node which is by default `this`.
	*
	* @return {Node} A reference to this node.
	*/
	getScope() {
		return this;
	}
	/**
	* Returns the hash of the node which is used to identify the node. By default it's
	* the {@link Node#uuid} however derived node classes might have to overwrite this method
	* depending on their implementation.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The hash.
	*/
	getHash() {
		return this.uuid;
	}
	/**
	* Returns the update type of {@link Node#update}.
	*
	* @return {NodeUpdateType} The update type.
	*/
	getUpdateType() {
		return this.updateType;
	}
	/**
	* Returns the update type of {@link Node#updateBefore}.
	*
	* @return {NodeUpdateType} The update type.
	*/
	getUpdateBeforeType() {
		return this.updateBeforeType;
	}
	/**
	* Returns the update type of {@link Node#updateAfter}.
	*
	* @return {NodeUpdateType} The update type.
	*/
	getUpdateAfterType() {
		return this.updateAfterType;
	}
	/**
	* Certain types are composed of multiple elements. For example a `vec3`
	* is composed of three `float` values. This method returns the type of
	* these elements.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The type of the node.
	*/
	getElementType(builder) {
		const type$1 = this.getNodeType(builder);
		return builder.getElementType(type$1);
	}
	/**
	* Returns the node member type for the given name.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} name - The name of the member.
	* @return {string} The type of the node.
	*/
	getMemberType() {
		return "void";
	}
	/**
	* Returns the node's type.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The type of the node.
	*/
	getNodeType(builder) {
		const nodeProperties = builder.getNodeProperties(this);
		if (nodeProperties.outputNode) return nodeProperties.outputNode.getNodeType(builder);
		return this.nodeType;
	}
	/**
	* This method is used during the build process of a node and ensures
	* equal nodes are not built multiple times but just once. For example if
	* `attribute( 'uv' )` is used multiple times by the user, the build
	* process makes sure to process just the first node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node} The shared node if possible. Otherwise `this` is returned.
	*/
	getShared(builder) {
		const hash$3 = this.getHash(builder);
		return builder.getNodeFromHash(hash$3) || this;
	}
	/**
	* Returns the number of elements in the node array.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {?number} The number of elements in the node array.
	*/
	getArrayCount() {
		return null;
	}
	/**
	* Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
	* This method is often overwritten in derived modules to prepare the node which is used as a node's output/result.
	* If an output node is prepared, then it must be returned in the `return` statement of the derived module's setup function.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {?Node} The output node.
	*/
	setup(builder) {
		const nodeProperties = builder.getNodeProperties(this);
		let index = 0;
		for (const childNode of this.getChildren()) nodeProperties["node" + index++] = childNode;
		return nodeProperties.outputNode || null;
	}
	/**
	* Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
	* This stage analyzes the node hierarchy and ensures descendent nodes are built.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {?Node} output - The target output node.
	*/
	analyze(builder, output$2 = null) {
		const usageCount = builder.increaseUsage(this);
		if (this.parents === true) {
			const nodeData = builder.getDataFromNode(this, "any");
			nodeData.stages = nodeData.stages || {};
			nodeData.stages[builder.shaderStage] = nodeData.stages[builder.shaderStage] || [];
			nodeData.stages[builder.shaderStage].push(output$2);
		}
		if (usageCount === 1) {
			const nodeProperties = builder.getNodeProperties(this);
			for (const childNode of Object.values(nodeProperties)) if (childNode && childNode.isNode === true) childNode.build(builder, this);
		}
	}
	/**
	* Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
	* This state builds the output node and returns the resulting shader string.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {?string} [output] - Can be used to define the output type.
	* @return {?string} The generated shader string.
	*/
	generate(builder, output$2) {
		const { outputNode } = builder.getNodeProperties(this);
		if (outputNode && outputNode.isNode === true) return outputNode.build(builder, output$2);
	}
	/**
	* The method can be implemented to update the node's internal state before it is used to render an object.
	* The {@link Node#updateBeforeType} property defines how often the update is executed.
	*
	* @abstract
	* @param {NodeFrame} frame - A reference to the current node frame.
	* @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
	*/
	updateBefore() {
		warn("Abstract function.");
	}
	/**
	* The method can be implemented to update the node's internal state after it was used to render an object.
	* The {@link Node#updateAfterType} property defines how often the update is executed.
	*
	* @abstract
	* @param {NodeFrame} frame - A reference to the current node frame.
	* @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
	*/
	updateAfter() {
		warn("Abstract function.");
	}
	/**
	* The method can be implemented to update the node's internal state when it is used to render an object.
	* The {@link Node#updateType} property defines how often the update is executed.
	*
	* @abstract
	* @param {NodeFrame} frame - A reference to the current node frame.
	* @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
	*/
	update() {
		warn("Abstract function.");
	}
	before(node) {
		if (this._beforeNodes === null) this._beforeNodes = [];
		this._beforeNodes.push(node);
		return this;
	}
	/**
	* This method performs the build of a node. The behavior and return value depend on the current build stage:
	* - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
	* - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
	* - **generate**: Generates the shader code for the node. Returns the generated shader string.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {?(string|Node)} [output=null] - Can be used to define the output type.
	* @return {?(Node|string)} The result of the build process, depending on the build stage.
	*/
	build(builder, output$2 = null) {
		const refNode = this.getShared(builder);
		if (this !== refNode) return refNode.build(builder, output$2);
		if (this._beforeNodes !== null) {
			const currentBeforeNodes = this._beforeNodes;
			this._beforeNodes = null;
			for (const beforeNode of currentBeforeNodes) beforeNode.build(builder, output$2);
			this._beforeNodes = currentBeforeNodes;
		}
		const nodeData = builder.getDataFromNode(this);
		nodeData.buildStages = nodeData.buildStages || {};
		nodeData.buildStages[builder.buildStage] = true;
		const parentBuildStage = _parentBuildStage[builder.buildStage];
		if (parentBuildStage && nodeData.buildStages[parentBuildStage] !== true) {
			const previousBuildStage = builder.getBuildStage();
			builder.setBuildStage(parentBuildStage);
			this.build(builder);
			builder.setBuildStage(previousBuildStage);
		}
		builder.addNode(this);
		builder.addChain(this);
		let result = null;
		const buildStage = builder.getBuildStage();
		if (buildStage === "setup") {
			this.updateReference(builder);
			const properties = builder.getNodeProperties(this);
			if (properties.initialized !== true) {
				properties.initialized = true;
				properties.outputNode = this.setup(builder) || properties.outputNode || null;
				for (const childNode of Object.values(properties)) if (childNode && childNode.isNode === true) {
					if (childNode.parents === true) {
						const childProperties = builder.getNodeProperties(childNode);
						childProperties.parents = childProperties.parents || [];
						childProperties.parents.push(this);
					}
					childNode.build(builder);
				}
			}
			result = properties.outputNode;
		} else if (buildStage === "analyze") this.analyze(builder, output$2);
		else if (buildStage === "generate") {
			if (this.generate.length < 2) {
				const type$1 = this.getNodeType(builder);
				const nodeData$1 = builder.getDataFromNode(this);
				result = nodeData$1.snippet;
				if (result === void 0) if (nodeData$1.generated === void 0) {
					nodeData$1.generated = true;
					result = this.generate(builder) || "";
					nodeData$1.snippet = result;
				} else {
					warn("Node: Recursion detected.", this);
					result = "/* Recursion detected. */";
				}
				else if (nodeData$1.flowCodes !== void 0 && builder.context.nodeBlock !== void 0) builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);
				result = builder.format(result, type$1, output$2);
			} else result = this.generate(builder, output$2) || "";
			if (result === "" && output$2 !== null && output$2 !== "void" && output$2 !== "OutputType") {
				error(`TSL: Invalid generated code, expected a "${output$2}".`);
				result = builder.generateConst(output$2);
			}
		}
		builder.removeChain(this);
		builder.addSequentialNode(this);
		return result;
	}
	/**
	* Returns the child nodes as a JSON object.
	*
	* @return {Generator<Object>} An iterable list of serialized child objects as JSON.
	*/
	getSerializeChildren() {
		return this._getChildren();
	}
	/**
	* Serializes the node to JSON.
	*
	* @param {Object} json - The output JSON object.
	*/
	serialize(json) {
		const nodeChildren = this.getSerializeChildren();
		const inputNodes = {};
		for (const { property: property$2, index, childNode } of nodeChildren) if (index !== void 0) {
			if (inputNodes[property$2] === void 0) inputNodes[property$2] = Number.isInteger(index) ? [] : {};
			inputNodes[property$2][index] = childNode.toJSON(json.meta).uuid;
		} else inputNodes[property$2] = childNode.toJSON(json.meta).uuid;
		if (Object.keys(inputNodes).length > 0) json.inputNodes = inputNodes;
	}
	/**
	* Deserializes the node from the given JSON.
	*
	* @param {Object} json - The JSON object.
	*/
	deserialize(json) {
		if (json.inputNodes !== void 0) {
			const nodes = json.meta.nodes;
			for (const property$2 in json.inputNodes) if (Array.isArray(json.inputNodes[property$2])) {
				const inputArray = [];
				for (const uuid of json.inputNodes[property$2]) inputArray.push(nodes[uuid]);
				this[property$2] = inputArray;
			} else if (typeof json.inputNodes[property$2] === "object") {
				const inputObject = {};
				for (const subProperty in json.inputNodes[property$2]) {
					const uuid = json.inputNodes[property$2][subProperty];
					inputObject[subProperty] = nodes[uuid];
				}
				this[property$2] = inputObject;
			} else {
				const uuid = json.inputNodes[property$2];
				this[property$2] = nodes[uuid];
			}
		}
	}
	/**
	* Serializes the node into the three.js JSON Object/Scene format.
	*
	* @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
	* @return {Object} The serialized node.
	*/
	toJSON(meta) {
		const { uuid, type: type$1 } = this;
		const isRoot = meta === void 0 || typeof meta === "string";
		if (isRoot) meta = {
			textures: {},
			images: {},
			nodes: {}
		};
		let data = meta.nodes[uuid];
		if (data === void 0) {
			data = {
				uuid,
				type: type$1,
				meta,
				metadata: {
					version: 4.7,
					type: "Node",
					generator: "Node.toJSON"
				}
			};
			if (isRoot !== true) meta.nodes[data.uuid] = data;
			this.serialize(data);
			delete data.meta;
		}
		function extractFromCache(cache$2) {
			const values = [];
			for (const key in cache$2) {
				const data$1 = cache$2[key];
				delete data$1.metadata;
				values.push(data$1);
			}
			return values;
		}
		if (isRoot) {
			const textures = extractFromCache(meta.textures);
			const images = extractFromCache(meta.images);
			const nodes = extractFromCache(meta.nodes);
			if (textures.length > 0) data.textures = textures;
			if (images.length > 0) data.images = images;
			if (nodes.length > 0) data.nodes = nodes;
		}
		return data;
	}
};
/**
* Base class for representing element access on an array-like
* node data structures.
*
* @augments Node
*/
var ArrayElementNode = class extends Node {
	static get type() {
		return "ArrayElementNode";
	}
	/**
	* Constructs an array element node.
	*
	* @param {Node} node - The array-like node.
	* @param {Node} indexNode - The index node that defines the element access.
	*/
	constructor(node, indexNode) {
		super();
		/**
		* The array-like node.
		*
		* @type {Node}
		*/
		this.node = node;
		/**
		* The index node that defines the element access.
		*
		* @type {Node}
		*/
		this.indexNode = indexNode;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isArrayElementNode = true;
	}
	/**
	* This method is overwritten since the node type is inferred from the array-like node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		return this.node.getElementType(builder);
	}
	generate(builder) {
		const indexType = this.indexNode.getNodeType(builder);
		const nodeSnippet = this.node.build(builder);
		const indexSnippet = this.indexNode.build(builder, !builder.isVector(indexType) && builder.isInteger(indexType) ? indexType : "uint");
		return `${nodeSnippet}[ ${indexSnippet} ]`;
	}
};
/**
* This module is part of the TSL core and usually not used in app level code.
* It represents a convert operation during the shader generation process
* meaning it converts the data type of a node to a target data type.
*
* @augments Node
*/
var ConvertNode = class extends Node {
	static get type() {
		return "ConvertNode";
	}
	/**
	* Constructs a new convert node.
	*
	* @param {Node} node - The node which type should be converted.
	* @param {string} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
	*/
	constructor(node, convertTo) {
		super();
		/**
		* The node which type should be converted.
		*
		* @type {Node}
		*/
		this.node = node;
		/**
		* The target node type. Multiple types can be defined by separating them with a `|` sign.
		*
		* @type {string}
		*/
		this.convertTo = convertTo;
	}
	/**
	* This method is overwritten since the implementation tries to infer the best
	* matching type from the {@link ConvertNode#convertTo} property.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		const requestType = this.node.getNodeType(builder);
		let convertTo = null;
		for (const overloadingType of this.convertTo.split("|")) if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) convertTo = overloadingType;
		return convertTo;
	}
	serialize(data) {
		super.serialize(data);
		data.convertTo = this.convertTo;
	}
	deserialize(data) {
		super.deserialize(data);
		this.convertTo = data.convertTo;
	}
	generate(builder, output$2) {
		const node = this.node;
		const type$1 = this.getNodeType(builder);
		const snippet = node.build(builder, type$1);
		return builder.format(snippet, type$1, output$2);
	}
};
/**
* This module uses cache management to create temporary variables
* if the node is used more than once to prevent duplicate calculations.
*
* The class acts as a base class for many other nodes types.
*
* @augments Node
*/
var TempNode = class extends Node {
	static get type() {
		return "TempNode";
	}
	/**
	* Constructs a temp node.
	*
	* @param {?string} nodeType - The node type.
	*/
	constructor(nodeType = null) {
		super(nodeType);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isTempNode = true;
	}
	/**
	* Whether this node is used more than once in context of other nodes.
	*
	* @param {NodeBuilder} builder - The node builder.
	* @return {boolean} A flag that indicates if there is more than one dependency to other nodes.
	*/
	hasDependencies(builder) {
		return builder.getDataFromNode(this).usageCount > 1;
	}
	build(builder, output$2) {
		if (builder.getBuildStage() === "generate") {
			const type$1 = builder.getVectorType(this.getNodeType(builder, output$2));
			const nodeData = builder.getDataFromNode(this);
			if (nodeData.propertyName !== void 0) return builder.format(nodeData.propertyName, type$1, output$2);
			else if (type$1 !== "void" && output$2 !== "void" && this.hasDependencies(builder)) {
				const snippet = super.build(builder, type$1);
				const nodeVar = builder.getVarFromNode(this, null, type$1);
				const propertyName = builder.getPropertyName(nodeVar);
				builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
				nodeData.snippet = snippet;
				nodeData.propertyName = propertyName;
				return builder.format(nodeData.propertyName, type$1, output$2);
			}
		}
		return super.build(builder, output$2);
	}
};
/**
* This module is part of the TSL core and usually not used in app level code.
* It represents a join operation during the shader generation process.
* For example in can compose/join two single floats into a `vec2` type.
*
* @augments TempNode
*/
var JoinNode = class extends TempNode {
	static get type() {
		return "JoinNode";
	}
	/**
	* Constructs a new join node.
	*
	* @param {Array<Node>} nodes - An array of nodes that should be joined.
	* @param {?string} [nodeType=null] - The node type.
	*/
	constructor(nodes = [], nodeType = null) {
		super(nodeType);
		/**
		* An array of nodes that should be joined.
		*
		* @type {Array<Node>}
		*/
		this.nodes = nodes;
	}
	/**
	* This method is overwritten since the node type must be inferred from the
	* joined data length if not explicitly defined.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		if (this.nodeType !== null) return builder.getVectorType(this.nodeType);
		return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
	}
	generate(builder, output$2) {
		const type$1 = this.getNodeType(builder);
		const maxLength = builder.getTypeLength(type$1);
		const nodes = this.nodes;
		const primitiveType = builder.getComponentType(type$1);
		const snippetValues = [];
		let length$2 = 0;
		for (const input of nodes) {
			if (length$2 >= maxLength) {
				error(`TSL: Length of parameters exceeds maximum length of function '${type$1}()' type.`);
				break;
			}
			let inputType = input.getNodeType(builder);
			let inputTypeLength = builder.getTypeLength(inputType);
			let inputSnippet;
			if (length$2 + inputTypeLength > maxLength) {
				error(`TSL: Length of '${type$1}()' data exceeds maximum length of output type.`);
				inputTypeLength = maxLength - length$2;
				inputType = builder.getTypeFromLength(inputTypeLength);
			}
			length$2 += inputTypeLength;
			inputSnippet = input.build(builder, inputType);
			if (builder.getComponentType(inputType) !== primitiveType) {
				const targetType = builder.getTypeFromLength(inputTypeLength, primitiveType);
				inputSnippet = builder.format(inputSnippet, inputType, targetType);
			}
			snippetValues.push(inputSnippet);
		}
		const snippet = `${builder.getType(type$1)}( ${snippetValues.join(", ")} )`;
		return builder.format(snippet, type$1, output$2);
	}
};
var _stringVectorComponents = vectorComponents$1.join("");
/**
* This module is part of the TSL core and usually not used in app level code.
* `SplitNode` represents a property access operation which means it is
* used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.
* For example:
* ```js
* const redValue = color.r;
* ```
*
* @augments Node
*/
var SplitNode = class extends Node {
	static get type() {
		return "SplitNode";
	}
	/**
	* Constructs a new split node.
	*
	* @param {Node} node - The node that should be accessed.
	* @param {string} [components='x'] - The components that should be accessed.
	*/
	constructor(node, components = "x") {
		super();
		/**
		* The node that should be accessed.
		*
		* @type {Node}
		*/
		this.node = node;
		/**
		* The components that should be accessed.
		*
		* @type {string}
		*/
		this.components = components;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSplitNode = true;
	}
	/**
	* Returns the vector length which is computed based on the requested components.
	*
	* @return {number} The vector length.
	*/
	getVectorLength() {
		let vectorLength = this.components.length;
		for (const c$1 of this.components) vectorLength = Math.max(vectorComponents$1.indexOf(c$1) + 1, vectorLength);
		return vectorLength;
	}
	/**
	* Returns the component type of the node's type.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The component type.
	*/
	getComponentType(builder) {
		return builder.getComponentType(this.node.getNodeType(builder));
	}
	/**
	* This method is overwritten since the node type is inferred from requested components.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));
	}
	/**
	* Returns the scope of the node.
	*
	* @return {Node} The scope of the node.
	*/
	getScope() {
		return this.node.getScope();
	}
	generate(builder, output$2) {
		const node = this.node;
		const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
		let snippet = null;
		if (nodeTypeLength > 1) {
			let type$1 = null;
			if (this.getVectorLength() >= nodeTypeLength) type$1 = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));
			const nodeSnippet = node.build(builder, type$1);
			if (this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice(0, this.components.length)) snippet = builder.format(nodeSnippet, type$1, output$2);
			else snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output$2);
		} else snippet = node.build(builder, output$2);
		return snippet;
	}
	serialize(data) {
		super.serialize(data);
		data.components = this.components;
	}
	deserialize(data) {
		super.deserialize(data);
		this.components = data.components;
	}
};
/**
* This module is part of the TSL core and usually not used in app level code.
* `SetNode` represents a set operation which means it is used to implement any
* `setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.
* For example:
* ```js
* materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );
* ```
*
* @augments TempNode
*/
var SetNode = class extends TempNode {
	static get type() {
		return "SetNode";
	}
	/**
	* Constructs a new set node.
	*
	* @param {Node} sourceNode - The node that should be updated.
	* @param {string} components - The components that should be updated.
	* @param {Node} targetNode - The value node.
	*/
	constructor(sourceNode, components, targetNode) {
		super();
		/**
		* The node that should be updated.
		*
		* @type {Node}
		*/
		this.sourceNode = sourceNode;
		/**
		* The components that should be updated.
		*
		* @type {string}
		*/
		this.components = components;
		/**
		* The value node.
		*
		* @type {Node}
		*/
		this.targetNode = targetNode;
	}
	/**
	* This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		return this.sourceNode.getNodeType(builder);
	}
	generate(builder) {
		const { sourceNode, components, targetNode } = this;
		const sourceType = this.getNodeType(builder);
		const componentType = builder.getComponentType(targetNode.getNodeType(builder));
		const targetType = builder.getTypeFromLength(components.length, componentType);
		const targetSnippet = targetNode.build(builder, targetType);
		const sourceSnippet = sourceNode.build(builder, sourceType);
		const length$2 = builder.getTypeLength(sourceType);
		const snippetValues = [];
		for (let i = 0; i < length$2; i++) {
			const component = vectorComponents$1[i];
			if (component === components[0]) {
				snippetValues.push(targetSnippet);
				i += components.length - 1;
			} else snippetValues.push(sourceSnippet + "." + component);
		}
		return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
	}
};
/**
* This module is part of the TSL core and usually not used in app level code.
* It represents a flip operation during the shader generation process
* meaning it flips normalized values with the following formula:
* ```
* x = 1 - x;
* ```
* `FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and
* `flipSTPQ()` method invocations on node objects. For example:
* ```js
* uvNode = uvNode.flipY();
* ```
*
* @augments TempNode
*/
var FlipNode = class extends TempNode {
	static get type() {
		return "FlipNode";
	}
	/**
	* Constructs a new flip node.
	*
	* @param {Node} sourceNode - The node which component(s) should be flipped.
	* @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.
	*/
	constructor(sourceNode, components) {
		super();
		/**
		* The node which component(s) should be flipped.
		*
		* @type {Node}
		*/
		this.sourceNode = sourceNode;
		/**
		* The components that should be flipped e.g. `'x'` or `'xy'`.
		*
		* @type {string}
		*/
		this.components = components;
	}
	/**
	* This method is overwritten since the node type is inferred from the source node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		return this.sourceNode.getNodeType(builder);
	}
	generate(builder) {
		const { components, sourceNode } = this;
		const sourceType = this.getNodeType(builder);
		const sourceSnippet = sourceNode.build(builder);
		const sourceCache = builder.getVarFromNode(this);
		const sourceProperty = builder.getPropertyName(sourceCache);
		builder.addLineFlowCode(sourceProperty + " = " + sourceSnippet, this);
		const length$2 = builder.getTypeLength(sourceType);
		const snippetValues = [];
		let componentIndex = 0;
		for (let i = 0; i < length$2; i++) {
			const component = vectorComponents$1[i];
			if (component === components[componentIndex]) {
				snippetValues.push("1.0 - " + (sourceProperty + "." + component));
				componentIndex++;
			} else snippetValues.push(sourceProperty + "." + component);
		}
		return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
	}
};
/**
* Base class for representing data input nodes.
*
* @augments Node
*/
var InputNode = class extends Node {
	static get type() {
		return "InputNode";
	}
	/**
	* Constructs a new input node.
	*
	* @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
	* @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
	*/
	constructor(value, nodeType = null) {
		super(nodeType);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isInputNode = true;
		/**
		* The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
		*
		* @type {any}
		*/
		this.value = value;
		/**
		* The precision of the value in the shader.
		*
		* @type {?('low'|'medium'|'high')}
		* @default null
		*/
		this.precision = null;
	}
	getNodeType() {
		if (this.nodeType === null) return getValueType(this.value);
		return this.nodeType;
	}
	/**
	* Returns the input type of the node which is by default the node type. Derived modules
	* might overwrite this method and use a fixed type or compute one analytically.
	*
	* A typical example for different input and node types are textures. The input type of a
	* normal RGBA texture is `texture` whereas its node type is `vec4`.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType(builder) {
		return this.getNodeType(builder);
	}
	/**
	* Sets the precision to the given value. The method can be
	* overwritten in derived classes if the final precision must be computed
	* analytically.
	*
	* @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
	* @return {InputNode} A reference to this node.
	*/
	setPrecision(precision) {
		this.precision = precision;
		return this;
	}
	serialize(data) {
		super.serialize(data);
		data.value = this.value;
		if (this.value && this.value.toArray) data.value = this.value.toArray();
		data.valueType = getValueType(this.value);
		data.nodeType = this.nodeType;
		if (data.valueType === "ArrayBuffer") data.value = arrayBufferToBase64(data.value);
		data.precision = this.precision;
	}
	deserialize(data) {
		super.deserialize(data);
		this.nodeType = data.nodeType;
		this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
		this.precision = data.precision || null;
		if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
	}
	generate() {
		warn("Abstract function.");
	}
};
var _regNum = /float|u?int/;
/**
* Class for representing a constant value in the shader.
*
* @augments InputNode
*/
var ConstNode = class extends InputNode {
	static get type() {
		return "ConstNode";
	}
	/**
	* Constructs a new input node.
	*
	* @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
	* @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
	*/
	constructor(value, nodeType = null) {
		super(value, nodeType);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isConstNode = true;
	}
	/**
	* Generates the shader string of the value with the current node builder.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The generated value as a shader string.
	*/
	generateConst(builder) {
		return builder.generateConst(this.getNodeType(builder), this.value);
	}
	generate(builder, output$2) {
		const type$1 = this.getNodeType(builder);
		if (_regNum.test(type$1) && _regNum.test(output$2)) return builder.generateConst(output$2, this.value);
		return builder.format(this.generateConst(builder), type$1, output$2);
	}
};
/**
* Base class for representing member access on an object-like
* node data structures.
*
* @augments Node
*/
var MemberNode = class extends Node {
	static get type() {
		return "MemberNode";
	}
	/**
	* Constructs a member node.
	*
	* @param {Node} structNode - The struct node.
	* @param {string} property - The property name.
	*/
	constructor(structNode, property$2) {
		super();
		/**
		* The struct node.
		*
		* @type {Node}
		*/
		this.structNode = structNode;
		/**
		* The property name.
		*
		* @type {Node}
		*/
		this.property = property$2;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMemberNode = true;
	}
	hasMember(builder) {
		if (this.structNode.isMemberNode) {
			if (this.structNode.hasMember(builder) === false) return false;
		}
		return this.structNode.getMemberType(builder, this.property) !== "void";
	}
	getNodeType(builder) {
		if (this.hasMember(builder) === false) return "float";
		return this.structNode.getMemberType(builder, this.property);
	}
	getMemberType(builder, name) {
		if (this.hasMember(builder) === false) return "float";
		const type$1 = this.getNodeType(builder);
		return builder.getStructTypeNode(type$1).getMemberType(builder, name);
	}
	generate(builder) {
		if (this.hasMember(builder) === false) {
			warn(`TSL: Member "${this.property}" does not exist in struct.`);
			const type$1 = this.getNodeType(builder);
			return builder.generateConst(type$1);
		}
		return this.structNode.build(builder) + "." + this.property;
	}
};
var currentStack = null;
var NodeElements = /* @__PURE__ */ new Map();
function addMethodChaining$1(name, nodeElement) {
	if (NodeElements.has(name)) {
		warn(`TSL: Redefinition of method chaining '${name}'.`);
		return;
	}
	if (typeof nodeElement !== "function") throw new Error(`THREE.TSL: Node element ${name} is not a function`);
	NodeElements.set(name, nodeElement);
	if (name !== "assign") {
		Node.prototype[name] = function(...params) {
			return this.isStackNode ? this.addToStack(nodeElement(...params)) : nodeElement(this, ...params);
		};
		Node.prototype[name + "Assign"] = function(...params) {
			return this.isStackNode ? this.assign(params[0], nodeElement(...params)) : this.assign(nodeElement(this, ...params));
		};
	}
}
var parseSwizzle = (props) => props.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
var parseSwizzleAndSort = (props) => parseSwizzle(props).split("").sort().join("");
Node.prototype.assign = function(...params) {
	if (this.isStackNode !== true) {
		if (currentStack !== null) currentStack.assign(this, ...params);
		else error("TSL: No stack defined for assign operation. Make sure the assign is inside a Fn().");
		return this;
	} else {
		const nodeElement = NodeElements.get("assign");
		return this.addToStack(nodeElement(...params));
	}
};
Node.prototype.toVarIntent = function() {
	return this;
};
Node.prototype.get = function(value) {
	return new MemberNode(this, value);
};
var proto = {};
function setProtoSwizzle(property$2, altA, altB) {
	proto[property$2] = proto[altA] = proto[altB] = {
		get() {
			this._cache = this._cache || {};
			let split$2 = this._cache[property$2];
			if (split$2 === void 0) {
				split$2 = new SplitNode(this, property$2);
				this._cache[property$2] = split$2;
			}
			return split$2;
		},
		set(value) {
			this[property$2].assign(nodeObject$1(value));
		}
	};
	const propUpper = property$2.toUpperCase();
	const altAUpper = altA.toUpperCase();
	const altBUpper = altB.toUpperCase();
	Node.prototype["set" + propUpper] = Node.prototype["set" + altAUpper] = Node.prototype["set" + altBUpper] = function(value) {
		const swizzle = parseSwizzleAndSort(property$2);
		return new SetNode(this, swizzle, nodeObject$1(value));
	};
	Node.prototype["flip" + propUpper] = Node.prototype["flip" + altAUpper] = Node.prototype["flip" + altBUpper] = function() {
		const swizzle = parseSwizzleAndSort(property$2);
		return new FlipNode(this, swizzle);
	};
}
var swizzleA = [
	"x",
	"y",
	"z",
	"w"
];
var swizzleB = [
	"r",
	"g",
	"b",
	"a"
];
var swizzleC = [
	"s",
	"t",
	"p",
	"q"
];
for (let a$1 = 0; a$1 < 4; a$1++) {
	let prop = swizzleA[a$1];
	let altA = swizzleB[a$1];
	let altB = swizzleC[a$1];
	setProtoSwizzle(prop, altA, altB);
	for (let b$2 = 0; b$2 < 4; b$2++) {
		prop = swizzleA[a$1] + swizzleA[b$2];
		altA = swizzleB[a$1] + swizzleB[b$2];
		altB = swizzleC[a$1] + swizzleC[b$2];
		setProtoSwizzle(prop, altA, altB);
		for (let c$1 = 0; c$1 < 4; c$1++) {
			prop = swizzleA[a$1] + swizzleA[b$2] + swizzleA[c$1];
			altA = swizzleB[a$1] + swizzleB[b$2] + swizzleB[c$1];
			altB = swizzleC[a$1] + swizzleC[b$2] + swizzleC[c$1];
			setProtoSwizzle(prop, altA, altB);
			for (let d$1 = 0; d$1 < 4; d$1++) {
				prop = swizzleA[a$1] + swizzleA[b$2] + swizzleA[c$1] + swizzleA[d$1];
				altA = swizzleB[a$1] + swizzleB[b$2] + swizzleB[c$1] + swizzleB[d$1];
				altB = swizzleC[a$1] + swizzleC[b$2] + swizzleC[c$1] + swizzleC[d$1];
				setProtoSwizzle(prop, altA, altB);
			}
		}
	}
}
for (let i = 0; i < 32; i++) proto[i] = {
	get() {
		this._cache = this._cache || {};
		let element$2 = this._cache[i];
		if (element$2 === void 0) {
			element$2 = new ArrayElementNode(this, new ConstNode(i, "uint"));
			this._cache[i] = element$2;
		}
		return element$2;
	},
	set(value) {
		this[i].assign(nodeObject$1(value));
	}
};
Object.defineProperties(Node.prototype, proto);
var nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj, altType = null) {
	const type$1 = getValueType(obj);
	if (type$1 === "node") return obj;
	else if (altType === null && (type$1 === "float" || type$1 === "boolean") || type$1 && type$1 !== "shader" && type$1 !== "string") return nodeObject$1(getConstNode(obj, altType));
	else if (type$1 === "shader") return obj.isFn ? obj : Fn$1(obj);
	return obj;
};
var ShaderNodeObjects = function(objects, altType = null) {
	for (const name in objects) objects[name] = nodeObject$1(objects[name], altType);
	return objects;
};
var ShaderNodeArray = function(array$2, altType = null) {
	const len = array$2.length;
	for (let i = 0; i < len; i++) array$2[i] = nodeObject$1(array$2[i], altType);
	return array$2;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
	function assignNode(node) {
		if (settings !== null) {
			node = nodeObject$1(Object.assign(node, settings));
			if (settings.intent === true) node = node.toVarIntent();
		} else node = nodeObject$1(node);
		return node;
	}
	let fn, name = scope, minParams, maxParams;
	function verifyParamsLimit(params) {
		let tslName;
		if (name) tslName = /[a-z]/i.test(name) ? name + "()" : name;
		else tslName = NodeClass.type;
		if (minParams !== void 0 && params.length < minParams) {
			error(`TSL: "${tslName}" parameter length is less than minimum required.`);
			return params.concat(new Array(minParams - params.length).fill(0));
		} else if (maxParams !== void 0 && params.length > maxParams) {
			error(`TSL: "${tslName}" parameter length exceeds limit.`);
			return params.slice(0, maxParams);
		}
		return params;
	}
	if (scope === null) fn = (...params) => {
		return assignNode(new NodeClass(...nodeArray$1(verifyParamsLimit(params))));
	};
	else if (factor !== null) {
		factor = nodeObject$1(factor);
		fn = (...params) => {
			return assignNode(new NodeClass(scope, ...nodeArray$1(verifyParamsLimit(params)), factor));
		};
	} else fn = (...params) => {
		return assignNode(new NodeClass(scope, ...nodeArray$1(verifyParamsLimit(params))));
	};
	fn.setParameterLength = (...params) => {
		if (params.length === 1) minParams = maxParams = params[0];
		else if (params.length === 2) [minParams, maxParams] = params;
		return fn;
	};
	fn.setName = (value) => {
		name = value;
		return fn;
	};
	return fn;
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
	return nodeObject$1(new NodeClass(...nodeArray$1(params)));
};
var ShaderCallNodeInternal = class extends Node {
	constructor(shaderNode, rawInputs) {
		super();
		this.shaderNode = shaderNode;
		this.rawInputs = rawInputs;
		this.isShaderCallNodeInternal = true;
	}
	getNodeType(builder) {
		return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
	}
	getElementType(builder) {
		return this.getOutputNode(builder).getElementType(builder);
	}
	getMemberType(builder, name) {
		return this.getOutputNode(builder).getMemberType(builder, name);
	}
	call(builder) {
		const { shaderNode, rawInputs } = this;
		const properties = builder.getNodeProperties(shaderNode);
		const subBuild$2 = builder.getClosestSubBuild(shaderNode.subBuilds) || "";
		const subBuildProperty = subBuild$2 || "default";
		if (properties[subBuildProperty]) return properties[subBuildProperty];
		const previousSubBuildFn = builder.subBuildFn;
		const previousFnCall = builder.fnCall;
		builder.subBuildFn = subBuild$2;
		builder.fnCall = this;
		let result = null;
		if (shaderNode.layout) {
			let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
			if (functionNodesCacheMap === void 0) {
				functionNodesCacheMap = /* @__PURE__ */ new WeakMap();
				nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
			}
			let functionNode = functionNodesCacheMap.get(shaderNode);
			if (functionNode === void 0) {
				functionNode = nodeObject$1(builder.buildFunctionNode(shaderNode));
				functionNodesCacheMap.set(shaderNode, functionNode);
			}
			builder.addInclude(functionNode);
			const inputs = rawInputs ? getLayoutParameters(rawInputs) : null;
			result = nodeObject$1(functionNode.call(inputs));
		} else {
			const secureNodeBuilder = new Proxy(builder, { get: (target, property$2, receiver) => {
				let value;
				if (Symbol.iterator === property$2) value = function* () {
					yield void 0;
				};
				else value = Reflect.get(target, property$2, receiver);
				return value;
			} });
			const inputs = rawInputs ? getProxyParameters(rawInputs) : null;
			const hasParameters = Array.isArray(rawInputs) ? rawInputs.length > 0 : rawInputs !== null;
			const jsFunc = shaderNode.jsFunc;
			const outputNode = hasParameters || jsFunc.length > 1 ? jsFunc(inputs, secureNodeBuilder) : jsFunc(secureNodeBuilder);
			result = nodeObject$1(outputNode);
		}
		builder.subBuildFn = previousSubBuildFn;
		builder.fnCall = previousFnCall;
		if (shaderNode.once) properties[subBuildProperty] = result;
		return result;
	}
	setupOutput(builder) {
		builder.addStack();
		builder.stack.outputNode = this.call(builder);
		return builder.removeStack();
	}
	getOutputNode(builder) {
		const properties = builder.getNodeProperties(this);
		const subBuildOutput = builder.getSubBuildOutput(this);
		properties[subBuildOutput] = properties[subBuildOutput] || this.setupOutput(builder);
		properties[subBuildOutput].subBuild = builder.getClosestSubBuild(this);
		return properties[subBuildOutput];
	}
	build(builder, output$2 = null) {
		let result = null;
		const buildStage = builder.getBuildStage();
		const properties = builder.getNodeProperties(this);
		const subBuildOutput = builder.getSubBuildOutput(this);
		const outputNode = this.getOutputNode(builder);
		const previousFnCall = builder.fnCall;
		builder.fnCall = this;
		if (buildStage === "setup") {
			const subBuildInitialized = builder.getSubBuildProperty("initialized", this);
			if (properties[subBuildInitialized] !== true) {
				properties[subBuildInitialized] = true;
				properties[subBuildOutput] = this.getOutputNode(builder);
				properties[subBuildOutput].build(builder);
				if (this.shaderNode.subBuilds) for (const node of builder.chaining) {
					const nodeData = builder.getDataFromNode(node, "any");
					nodeData.subBuilds = nodeData.subBuilds || /* @__PURE__ */ new Set();
					for (const subBuild$2 of this.shaderNode.subBuilds) nodeData.subBuilds.add(subBuild$2);
				}
			}
			result = properties[subBuildOutput];
		} else if (buildStage === "analyze") outputNode.build(builder, output$2);
		else if (buildStage === "generate") result = outputNode.build(builder, output$2) || "";
		builder.fnCall = previousFnCall;
		return result;
	}
};
function getLayoutParameters(params) {
	let output$2;
	nodeObjects$1(params);
	if (params[0] && (params[0].isNode || Object.getPrototypeOf(params[0]) !== Object.prototype)) output$2 = [...params];
	else output$2 = params[0];
	return output$2;
}
function getProxyParameters(params) {
	let index = 0;
	nodeObjects$1(params);
	return new Proxy(params, { get: (target, property$2, receiver) => {
		let value;
		if (property$2 === "length") {
			value = params.length;
			return value;
		}
		if (Symbol.iterator === property$2) value = function* () {
			for (const inputNode of params) yield nodeObject$1(inputNode);
		};
		else {
			if (params.length > 0) {
				if (Object.getPrototypeOf(params[0]) === Object.prototype) {
					const objectTarget = params[0];
					if (objectTarget[property$2] === void 0) value = objectTarget[index++];
					else value = Reflect.get(objectTarget, property$2, receiver);
				} else if (params[0] instanceof Node) if (params[property$2] === void 0) value = params[index++];
				else value = Reflect.get(params, property$2, receiver);
			} else value = Reflect.get(target, property$2, receiver);
			value = nodeObject$1(value);
		}
		return value;
	} });
}
var ShaderNodeInternal = class extends Node {
	constructor(jsFunc, nodeType) {
		super(nodeType);
		this.jsFunc = jsFunc;
		this.layout = null;
		this.global = true;
		this.once = false;
	}
	setLayout(layout) {
		this.layout = layout;
		return this;
	}
	getLayout() {
		return this.layout;
	}
	call(rawInputs = null) {
		return new ShaderCallNodeInternal(this, rawInputs);
	}
	setup() {
		return this.call();
	}
};
var bools = [false, true];
var uints = [
	0,
	1,
	2,
	3
];
var ints = [-1, -2];
var floats = [
	.5,
	1.5,
	1 / 3,
	1e-6,
	1e6,
	Math.PI,
	Math.PI * 2,
	1 / Math.PI,
	2 / Math.PI,
	1 / (Math.PI * 2),
	Math.PI / 2
];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool$2 of bools) boolsCacheMap.set(bool$2, new ConstNode(bool$2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint$2 of uints) uintsCacheMap.set(uint$2, new ConstNode(uint$2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode(el.value, "int")));
for (const int$2 of ints) intsCacheMap.set(int$2, new ConstNode(int$2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode(el.value)));
for (const float$2 of floats) floatsCacheMap.set(float$2, new ConstNode(float$2));
for (const float$2 of floats) floatsCacheMap.set(-float$2, new ConstNode(-float$2));
var cacheMaps = {
	bool: boolsCacheMap,
	uint: uintsCacheMap,
	ints: intsCacheMap,
	float: floatsCacheMap
};
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getConstNode = (value, type$1) => {
	if (constNodesCacheMap.has(value)) return constNodesCacheMap.get(value);
	else if (value.isNode === true) return value;
	else return new ConstNode(value, type$1);
};
var ConvertType = function(type$1, cacheMap = null) {
	return (...params) => {
		for (const param of params) if (param === void 0) {
			error(`TSL: Invalid parameter for the type "${type$1}".`);
			return nodeObject$1(new ConstNode(0, type$1));
		}
		if (params.length === 0 || ![
			"bool",
			"float",
			"int",
			"uint"
		].includes(type$1) && params.every((param) => {
			const paramType = typeof param;
			return paramType !== "object" && paramType !== "function";
		})) params = [getValueFromType(type$1, ...params)];
		if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) return nodeObjectIntent$1(cacheMap.get(params[0]));
		if (params.length === 1) {
			const node = getConstNode(params[0], type$1);
			if (node.nodeType === type$1) return nodeObjectIntent$1(node);
			return nodeObjectIntent$1(new ConvertNode(node, type$1));
		}
		const nodes = params.map((param) => getConstNode(param));
		return nodeObjectIntent$1(new JoinNode(nodes, type$1));
	};
};
var defined$1 = (v) => typeof v === "object" && v !== null ? v.value : v;
var getConstNodeType$1 = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode$1(jsFunc, nodeType) {
	return new ShaderNodeInternal(jsFunc, nodeType);
}
var nodeObject$1 = (val, altType = null) => ShaderNodeObject(val, altType);
var nodeObjectIntent$1 = (val, altType = null) => nodeObject$1(val, altType).toVarIntent();
var nodeObjects$1 = (val, altType = null) => new ShaderNodeObjects(val, altType);
var nodeArray$1 = (val, altType = null) => new ShaderNodeArray(val, altType);
var nodeProxy$1 = (NodeClass, scope = null, factor = null, settings = null) => new ShaderNodeProxy(NodeClass, scope, factor, settings);
var nodeImmutable$1 = (NodeClass, ...params) => new ShaderNodeImmutable(NodeClass, ...params);
var nodeProxyIntent$1 = (NodeClass, scope = null, factor = null, settings = {}) => new ShaderNodeProxy(NodeClass, scope, factor, {
	...settings,
	intent: true
});
var fnId = 0;
var FnNode = class extends Node {
	constructor(jsFunc, layout = null) {
		super();
		let nodeType = null;
		if (layout !== null) if (typeof layout === "object") nodeType = layout.return;
		else {
			if (typeof layout === "string") nodeType = layout;
			else error("TSL: Invalid layout type.");
			layout = null;
		}
		this.shaderNode = new ShaderNode$1(jsFunc, nodeType);
		if (layout !== null) this.setLayout(layout);
		this.isFn = true;
	}
	setLayout(layout) {
		const nodeType = this.shaderNode.nodeType;
		if (typeof layout.inputs !== "object") {
			const fullLayout = {
				name: "fn" + fnId++,
				type: nodeType,
				inputs: []
			};
			for (const name in layout) {
				if (name === "return") continue;
				fullLayout.inputs.push({
					name,
					type: layout[name]
				});
			}
			layout = fullLayout;
		}
		this.shaderNode.setLayout(layout);
		return this;
	}
	getNodeType(builder) {
		return this.shaderNode.getNodeType(builder) || "float";
	}
	call(...params) {
		const fnCall = this.shaderNode.call(params);
		if (this.shaderNode.nodeType === "void") fnCall.toStack();
		return fnCall.toVarIntent();
	}
	once(subBuilds = null) {
		this.shaderNode.once = true;
		this.shaderNode.subBuilds = subBuilds;
		return this;
	}
	generate(builder) {
		const type$1 = this.getNodeType(builder);
		error("TSL: \"Fn()\" was declared but not invoked. Try calling it like \"Fn()( ...params )\".");
		return builder.generateConst(type$1);
	}
};
function Fn$1(jsFunc, layout = null) {
	const instance$2 = new FnNode(jsFunc, layout);
	return new Proxy(() => {}, {
		apply(target, thisArg, params) {
			return instance$2.call(...params);
		},
		get(target, prop, receiver) {
			return Reflect.get(instance$2, prop, receiver);
		},
		set(target, prop, value, receiver) {
			return Reflect.set(instance$2, prop, value, receiver);
		}
	});
}
var setCurrentStack$1 = (stack$2) => {
	currentStack = stack$2;
};
var getCurrentStack$1 = () => currentStack;
/**
* Represent a conditional node using if/else statements.
*
* ```js
* If( condition, function )
* 	.ElseIf( condition, function )
* 	.Else( function )
* ```
* @tsl
* @function
* @param {...any} params - The parameters for the conditional node.
* @returns {StackNode} The conditional node.
*/
var If$1 = (...params) => currentStack.If(...params);
/**
* Represent a conditional node using switch/case statements.
*
* ```js
* Switch( value )
* 	.Case( 1, function )
* 	.Case( 2, 3, 4, function )
* 	.Default( function )
* ```
* @tsl
* @function
* @param {...any} params - The parameters for the conditional node.
* @returns {StackNode} The conditional node.
*/
var Switch$1 = (...params) => currentStack.Switch(...params);
/**
* Add the given node to the current stack.
*
* @param {Node} node - The node to add.
* @returns {Node} The node that was added to the stack.
*/
function Stack$1(node) {
	if (currentStack) currentStack.addToStack(node);
	return node;
}
addMethodChaining$1("toStack", Stack$1);
var color$1 = new ConvertType("color");
var float$1 = new ConvertType("float", cacheMaps.float);
var int$1 = new ConvertType("int", cacheMaps.ints);
var uint$1 = new ConvertType("uint", cacheMaps.uint);
var bool$1 = new ConvertType("bool", cacheMaps.bool);
var vec2$1 = new ConvertType("vec2");
var ivec2$1 = new ConvertType("ivec2");
var uvec2$1 = new ConvertType("uvec2");
var bvec2$1 = new ConvertType("bvec2");
var vec3$1 = new ConvertType("vec3");
var ivec3$1 = new ConvertType("ivec3");
var uvec3$1 = new ConvertType("uvec3");
var bvec3$1 = new ConvertType("bvec3");
var vec4$1 = new ConvertType("vec4");
var ivec4$1 = new ConvertType("ivec4");
var uvec4$1 = new ConvertType("uvec4");
var bvec4$1 = new ConvertType("bvec4");
var mat2$1 = new ConvertType("mat2");
var mat3$1 = new ConvertType("mat3");
var mat4$1 = new ConvertType("mat4");
var string$1 = (value = "") => nodeObject$1(new ConstNode(value, "string"));
var arrayBuffer$1 = (value) => nodeObject$1(new ConstNode(value, "ArrayBuffer"));
addMethodChaining$1("toColor", color$1);
addMethodChaining$1("toFloat", float$1);
addMethodChaining$1("toInt", int$1);
addMethodChaining$1("toUint", uint$1);
addMethodChaining$1("toBool", bool$1);
addMethodChaining$1("toVec2", vec2$1);
addMethodChaining$1("toIVec2", ivec2$1);
addMethodChaining$1("toUVec2", uvec2$1);
addMethodChaining$1("toBVec2", bvec2$1);
addMethodChaining$1("toVec3", vec3$1);
addMethodChaining$1("toIVec3", ivec3$1);
addMethodChaining$1("toUVec3", uvec3$1);
addMethodChaining$1("toBVec3", bvec3$1);
addMethodChaining$1("toVec4", vec4$1);
addMethodChaining$1("toIVec4", ivec4$1);
addMethodChaining$1("toUVec4", uvec4$1);
addMethodChaining$1("toBVec4", bvec4$1);
addMethodChaining$1("toMat2", mat2$1);
addMethodChaining$1("toMat3", mat3$1);
addMethodChaining$1("toMat4", mat4$1);
var element$1 = /* @__PURE__ */ nodeProxy$1(ArrayElementNode).setParameterLength(2);
var convert$1 = (node, types) => nodeObject$1(new ConvertNode(nodeObject$1(node), types));
var split$1 = (node, channels) => nodeObject$1(new SplitNode(nodeObject$1(node), channels));
addMethodChaining$1("element", element$1);
addMethodChaining$1("convert", convert$1);
/**
* @tsl
* @function
* @deprecated since r176. Use {@link Stack} instead.
*
* @param {Node} node - The node to add.
* @returns {Function}
*/
var append$1 = (node) => {
	warn("TSL: append() has been renamed to Stack().");
	return Stack$1(node);
};
addMethodChaining$1("append", (node) => {
	warn("TSL: .append() has been renamed to .toStack().");
	return Stack$1(node);
});
/**
* This class represents a shader property. It can be used
* to explicitly define a property and assign a value to it.
*
* ```js
* const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );
*```
* `PropertyNode` is used by the engine to predefined common material properties
* for TSL code.
*
* @augments Node
*/
var PropertyNode = class extends Node {
	static get type() {
		return "PropertyNode";
	}
	/**
	* Constructs a new property node.
	*
	* @param {string} nodeType - The type of the node.
	* @param {?string} [name=null] - The name of the property in the shader.
	* @param {boolean} [varying=false] - Whether this property is a varying or not.
	*/
	constructor(nodeType, name = null, varying$2 = false) {
		super(nodeType);
		/**
		* The name of the property in the shader. If no name is defined,
		* the node system auto-generates one.
		*
		* @type {?string}
		* @default null
		*/
		this.name = name;
		/**
		* Whether this property is a varying or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.varying = varying$2;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isPropertyNode = true;
		/**
		* This flag is used for global cache.
		*
		* @type {boolean}
		* @default true
		*/
		this.global = true;
	}
	customCacheKey() {
		return hashString(this.type + ":" + (this.name || "") + ":" + (this.varying ? "1" : "0"));
	}
	getHash(builder) {
		return this.name || super.getHash(builder);
	}
	generate(builder) {
		let nodeVar;
		if (this.varying === true) {
			nodeVar = builder.getVaryingFromNode(this, this.name);
			nodeVar.needsInterpolation = true;
		} else nodeVar = builder.getVarFromNode(this, this.name);
		return builder.getPropertyName(nodeVar);
	}
};
/**
* TSL function for creating a property node.
*
* @tsl
* @function
* @param {string} type - The type of the node.
* @param {?string} [name=null] - The name of the property in the shader.
* @returns {PropertyNode}
*/
var property$1 = (type$1, name) => nodeObject$1(new PropertyNode(type$1, name));
/**
* TSL function for creating a varying property node.
*
* @tsl
* @function
* @param {string} type - The type of the node.
* @param {?string} [name=null] - The name of the varying in the shader.
* @returns {PropertyNode}
*/
var varyingProperty$1 = (type$1, name) => nodeObject$1(new PropertyNode(type$1, name, true));
/**
* TSL object that represents the shader variable `DiffuseColor`.
*
* @tsl
* @type {PropertyNode<vec4>}
*/
var diffuseColor$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "vec4", "DiffuseColor");
/**
* TSL object that represents the shader variable `EmissiveColor`.
*
* @tsl
* @type {PropertyNode<vec3>}
*/
var emissive$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "vec3", "EmissiveColor");
/**
* TSL object that represents the shader variable `Roughness`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var roughness$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "Roughness");
/**
* TSL object that represents the shader variable `Metalness`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var metalness$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "Metalness");
/**
* TSL object that represents the shader variable `Clearcoat`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var clearcoat$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "Clearcoat");
/**
* TSL object that represents the shader variable `ClearcoatRoughness`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var clearcoatRoughness$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "ClearcoatRoughness");
/**
* TSL object that represents the shader variable `Sheen`.
*
* @tsl
* @type {PropertyNode<vec3>}
*/
var sheen$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "vec3", "Sheen");
/**
* TSL object that represents the shader variable `SheenRoughness`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var sheenRoughness$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "SheenRoughness");
/**
* TSL object that represents the shader variable `Iridescence`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var iridescence$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "Iridescence");
/**
* TSL object that represents the shader variable `IridescenceIOR`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var iridescenceIOR$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "IridescenceIOR");
/**
* TSL object that represents the shader variable `IridescenceThickness`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var iridescenceThickness$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "IridescenceThickness");
/**
* TSL object that represents the shader variable `AlphaT`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var alphaT$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "AlphaT");
/**
* TSL object that represents the shader variable `Anisotropy`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var anisotropy$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "Anisotropy");
/**
* TSL object that represents the shader variable `AnisotropyT`.
*
* @tsl
* @type {PropertyNode<vec3>}
*/
var anisotropyT$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "vec3", "AnisotropyT");
/**
* TSL object that represents the shader variable `AnisotropyB`.
*
* @tsl
* @type {PropertyNode<vec3>}
*/
var anisotropyB$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "vec3", "AnisotropyB");
/**
* TSL object that represents the shader variable `SpecularColor`.
*
* @tsl
* @type {PropertyNode<color>}
*/
var specularColor$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "color", "SpecularColor");
/**
* TSL object that represents the shader variable `SpecularF90`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var specularF90$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "SpecularF90");
/**
* TSL object that represents the shader variable `Shininess`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var shininess$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "Shininess");
/**
* TSL object that represents the shader variable `Output`.
*
* @tsl
* @type {PropertyNode<vec4>}
*/
var output$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "vec4", "Output");
/**
* TSL object that represents the shader variable `dashSize`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var dashSize$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "dashSize");
/**
* TSL object that represents the shader variable `gapSize`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var gapSize$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "gapSize");
/**
* TSL object that represents the shader variable `pointWidth`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var pointWidth$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "pointWidth");
/**
* TSL object that represents the shader variable `IOR`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var ior$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "IOR");
/**
* TSL object that represents the shader variable `Transmission`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var transmission$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "Transmission");
/**
* TSL object that represents the shader variable `Thickness`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var thickness$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "Thickness");
/**
* TSL object that represents the shader variable `AttenuationDistance`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var attenuationDistance$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "AttenuationDistance");
/**
* TSL object that represents the shader variable `AttenuationColor`.
*
* @tsl
* @type {PropertyNode<color>}
*/
var attenuationColor$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "color", "AttenuationColor");
/**
* TSL object that represents the shader variable `Dispersion`.
*
* @tsl
* @type {PropertyNode<float>}
*/
var dispersion$1 = /* @__PURE__ */ nodeImmutable$1(PropertyNode, "float", "Dispersion");
/**
* This node can be used to group single instances of {@link UniformNode}
* and manage them as a uniform buffer.
*
* In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`
* will be used when defining the {@link UniformNode#groupNode} property.
*
* - `objectGroup`: Uniform buffer per object.
* - `renderGroup`: Shared uniform buffer, updated once per render call.
* - `frameGroup`: Shared uniform buffer, updated once per frame.
*
* @augments Node
*/
var UniformGroupNode = class extends Node {
	static get type() {
		return "UniformGroupNode";
	}
	/**
	* Constructs a new uniform group node.
	*
	* @param {string} name - The name of the uniform group node.
	* @param {boolean} [shared=false] - Whether this uniform group node is shared or not.
	* @param {number} [order=1] - Influences the internal sorting.
	*/
	constructor(name, shared = false, order = 1) {
		super("string");
		/**
		* The name of the uniform group node.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* Whether this uniform group node is shared or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.shared = shared;
		/**
		* Influences the internal sorting.
		* TODO: Add details when this property should be changed.
		*
		* @type {number}
		* @default 1
		*/
		this.order = order;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isUniformGroup = true;
	}
	serialize(data) {
		super.serialize(data);
		data.name = this.name;
		data.version = this.version;
		data.shared = this.shared;
	}
	deserialize(data) {
		super.deserialize(data);
		this.name = data.name;
		this.version = data.version;
		this.shared = data.shared;
	}
};
/**
* TSL function for creating a uniform group node with the given name.
*
* @tsl
* @function
* @param {string} name - The name of the uniform group node.
* @returns {UniformGroupNode}
*/
var uniformGroup$1 = (name) => new UniformGroupNode(name);
/**
* TSL function for creating a shared uniform group node with the given name and order.
*
* @tsl
* @function
* @param {string} name - The name of the uniform group node.
* @param {number} [order=0] - Influences the internal sorting.
* @returns {UniformGroupNode}
*/
var sharedUniformGroup$1 = (name, order = 0) => new UniformGroupNode(name, true, order);
/**
* TSL object that represents a shared uniform group node which is updated once per frame.
*
* @tsl
* @type {UniformGroupNode}
*/
var frameGroup$1 = /* @__PURE__ */ sharedUniformGroup$1("frame");
/**
* TSL object that represents a shared uniform group node which is updated once per render.
*
* @tsl
* @type {UniformGroupNode}
*/
var renderGroup$1 = /* @__PURE__ */ sharedUniformGroup$1("render");
/**
* TSL object that represents a uniform group node which is updated once per object.
*
* @tsl
* @type {UniformGroupNode}
*/
var objectGroup$1 = /* @__PURE__ */ uniformGroup$1("object");
/**
* Class for representing a uniform.
*
* @augments InputNode
*/
var UniformNode = class extends InputNode {
	static get type() {
		return "UniformNode";
	}
	/**
	* Constructs a new uniform node.
	*
	* @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
	* @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
	*/
	constructor(value, nodeType = null) {
		super(value, nodeType);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isUniformNode = true;
		/**
		* The name or label of the uniform.
		*
		* @type {string}
		* @default ''
		*/
		this.name = "";
		/**
		* The uniform group of this uniform. By default, uniforms are
		* managed per object but they might belong to a shared group
		* which is updated per frame or render call.
		*
		* @type {UniformGroupNode}
		*/
		this.groupNode = objectGroup$1;
	}
	/**
	* Sets the {@link UniformNode#name} property.
	*
	* @param {string} name - The name of the uniform.
	* @return {UniformNode} A reference to this node.
	*/
	setName(name) {
		this.name = name;
		return this;
	}
	/**
	* Sets the {@link UniformNode#name} property.
	*
	* @deprecated
	* @param {string} name - The name of the uniform.
	* @return {UniformNode} A reference to this node.
	*/
	label(name) {
		warn("TSL: \"label()\" has been deprecated. Use \"setName()\" instead.");
		return this.setName(name);
	}
	/**
	* Sets the {@link UniformNode#groupNode} property.
	*
	* @param {UniformGroupNode} group - The uniform group.
	* @return {UniformNode} A reference to this node.
	*/
	setGroup(group) {
		this.groupNode = group;
		return this;
	}
	/**
	* Returns the {@link UniformNode#groupNode}.
	*
	* @return {UniformGroupNode} The uniform group.
	*/
	getGroup() {
		return this.groupNode;
	}
	/**
	* By default, this method returns the result of {@link Node#getHash} but derived
	* classes might overwrite this method with a different implementation.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The uniform hash.
	*/
	getUniformHash(builder) {
		return this.getHash(builder);
	}
	onUpdate(callback, updateType) {
		callback = callback.bind(this);
		return super.onUpdate((frame) => {
			const value = callback(frame, this);
			if (value !== void 0) this.value = value;
		}, updateType);
	}
	getInputType(builder) {
		let type$1 = super.getInputType(builder);
		if (type$1 === "bool") type$1 = "uint";
		return type$1;
	}
	generate(builder, output$2) {
		const type$1 = this.getNodeType(builder);
		const hash$3 = this.getUniformHash(builder);
		let sharedNode = builder.getNodeFromHash(hash$3);
		if (sharedNode === void 0) {
			builder.setHashNode(this, hash$3);
			sharedNode = this;
		}
		const sharedNodeType = sharedNode.getInputType(builder);
		const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.nodeName);
		const uniformName = builder.getPropertyName(nodeUniform);
		if (builder.context.nodeName !== void 0) delete builder.context.nodeName;
		let snippet = uniformName;
		if (type$1 === "bool") {
			const nodeData = builder.getDataFromNode(this);
			let propertyName = nodeData.propertyName;
			if (propertyName === void 0) {
				const nodeVar = builder.getVarFromNode(this, null, "bool");
				propertyName = builder.getPropertyName(nodeVar);
				nodeData.propertyName = propertyName;
				snippet = builder.format(uniformName, sharedNodeType, type$1);
				builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
			}
			snippet = propertyName;
		}
		return builder.format(snippet, type$1, output$2);
	}
};
/**
* TSL function for creating a uniform node.
*
* @tsl
* @function
* @param {any|string} value - The value of this uniform or your type. Usually a JS primitive or three.js object (vector, matrix, color, texture).
* @param {string} [type] - The node type. If no explicit type is defined, the node tries to derive the type from its value.
* @returns {UniformNode}
*/
var uniform$1 = (value, type$1) => {
	const nodeType = getConstNodeType$1(type$1 || value);
	if (nodeType === value) value = getValueFromType(nodeType);
	value = value && value.isNode === true ? value.node && value.node.value || value.value : value;
	return nodeObject$1(new UniformNode(value, nodeType));
};
/**
* ArrayNode represents a collection of nodes, typically created using the {@link array} function.
* ```js
* const colors = array( [
* 	vec3( 1, 0, 0 ),
* 	vec3( 0, 1, 0 ),
* 	vec3( 0, 0, 1 )
* ] );
*
* const redColor = tintColors.element( 0 );
* ```
*
* @augments TempNode
*/
var ArrayNode = class extends TempNode {
	static get type() {
		return "ArrayNode";
	}
	/**
	* Constructs a new array node.
	*
	* @param {?string} nodeType - The data type of the elements.
	* @param {number} count - Size of the array.
	* @param {?Array<Node>} [values=null] - Array default values.
	*/
	constructor(nodeType, count, values = null) {
		super(nodeType);
		/**
		* Array size.
		*
		* @type {number}
		*/
		this.count = count;
		/**
		* Array default values.
		*
		* @type {?Array<Node>}
		*/
		this.values = values;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isArrayNode = true;
	}
	/**
	* Returns the number of elements in the node array.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {number} The number of elements in the node array.
	*/
	getArrayCount() {
		return this.count;
	}
	/**
	* Returns the node's type.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The type of the node.
	*/
	getNodeType(builder) {
		if (this.nodeType === null) this.nodeType = this.values[0].getNodeType(builder);
		return this.nodeType;
	}
	/**
	* Returns the node's type.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The type of the node.
	*/
	getElementType(builder) {
		return this.getNodeType(builder);
	}
	/**
	* This method builds the output node and returns the resulting array as a shader string.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The generated shader string.
	*/
	generate(builder) {
		const type$1 = this.getNodeType(builder);
		return builder.generateArray(type$1, this.count, this.values);
	}
};
/**
* TSL function for creating an array node.
*
* @tsl
* @function
* @param {string|Array<Node>} nodeTypeOrValues - A string representing the element type (e.g., 'vec3')
* or an array containing the default values (e.g., [ vec3() ]).
* @param {?number} [count] - Size of the array.
* @returns {ArrayNode}
*/
var array$1 = (...params) => {
	let node;
	if (params.length === 1) {
		const values = params[0];
		node = new ArrayNode(null, values.length, values);
	} else {
		const nodeType = params[0];
		const count = params[1];
		node = new ArrayNode(nodeType, count);
	}
	return nodeObject$1(node);
};
addMethodChaining$1("toArray", (node, count) => array$1(Array(count).fill(node)));
/**
* These node represents an assign operation. Meaning a node is assigned
* to another node.
*
* @augments TempNode
*/
var AssignNode = class extends TempNode {
	static get type() {
		return "AssignNode";
	}
	/**
	* Constructs a new assign node.
	*
	* @param {Node} targetNode - The target node.
	* @param {Node} sourceNode - The source type.
	*/
	constructor(targetNode, sourceNode) {
		super();
		/**
		* The target node.
		*
		* @type {Node}
		*/
		this.targetNode = targetNode;
		/**
		* The source node.
		*
		* @type {Node}
		*/
		this.sourceNode = sourceNode;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isAssignNode = true;
	}
	/**
	* Whether this node is used more than once in context of other nodes. This method
	* is overwritten since it always returns `false` (assigns are unique).
	*
	* @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
	*/
	hasDependencies() {
		return false;
	}
	getNodeType(builder, output$2) {
		return output$2 !== "void" ? this.targetNode.getNodeType(builder) : "void";
	}
	/**
	* Whether a split is required when assigning source to target. This can happen when the component length of
	* target and source data type does not match.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {boolean} Whether a split is required when assigning source to target.
	*/
	needsSplitAssign(builder) {
		const { targetNode } = this;
		if (builder.isAvailable("swizzleAssign") === false && targetNode.isSplitNode && targetNode.components.length > 1) {
			const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));
			return vectorComponents$1.join("").slice(0, targetLength) !== targetNode.components;
		}
		return false;
	}
	setup(builder) {
		const { targetNode, sourceNode } = this;
		const scope = targetNode.getScope();
		const targetProperties = builder.getNodeProperties(scope);
		targetProperties.assign = true;
		const properties = builder.getNodeProperties(this);
		properties.sourceNode = sourceNode;
		properties.targetNode = targetNode.context({ assign: true });
	}
	generate(builder, output$2) {
		const { targetNode, sourceNode } = builder.getNodeProperties(this);
		const needsSplitAssign = this.needsSplitAssign(builder);
		const target = targetNode.build(builder);
		const targetType = targetNode.getNodeType(builder);
		const source = sourceNode.build(builder, targetType);
		const sourceType = sourceNode.getNodeType(builder);
		const nodeData = builder.getDataFromNode(this);
		let snippet;
		if (nodeData.initialized === true) {
			if (output$2 !== "void") snippet = target;
		} else if (needsSplitAssign) {
			const sourceVar = builder.getVarFromNode(this, null, targetType);
			const sourceProperty = builder.getPropertyName(sourceVar);
			builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);
			const splitNode = targetNode.node;
			const targetRoot = splitNode.node.context({ assign: true }).build(builder);
			for (let i = 0; i < splitNode.components.length; i++) {
				const component = splitNode.components[i];
				builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`, this);
			}
			if (output$2 !== "void") snippet = target;
		} else {
			snippet = `${target} = ${source}`;
			if (output$2 === "void" || sourceType === "void") {
				builder.addLineFlowCode(snippet, this);
				if (output$2 !== "void") snippet = target;
			}
		}
		nodeData.initialized = true;
		return builder.format(snippet, targetType, output$2);
	}
};
/**
* TSL function for creating an assign node.
*
* @tsl
* @function
* @param {Node} targetNode - The target node.
* @param {Node} sourceNode - The source type.
* @returns {AssignNode}
*/
var assign$1 = /* @__PURE__ */ nodeProxy$1(AssignNode).setParameterLength(2);
addMethodChaining$1("assign", assign$1);
/**
* This module represents the call of a {@link FunctionNode}. Developers are usually not confronted
* with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate
* this logic.
*
* @augments TempNode
*/
var FunctionCallNode = class extends TempNode {
	static get type() {
		return "FunctionCallNode";
	}
	/**
	* Constructs a new function call node.
	*
	* @param {?FunctionNode} functionNode - The function node.
	* @param {Object<string, Node>} [parameters={}] - The parameters for the function call.
	*/
	constructor(functionNode = null, parameters = {}) {
		super();
		/**
		* The function node.
		*
		* @type {?FunctionNode}
		* @default null
		*/
		this.functionNode = functionNode;
		/**
		* The parameters of the function call.
		*
		* @type {Object<string, Node>}
		* @default {}
		*/
		this.parameters = parameters;
	}
	/**
	* Sets the parameters of the function call node.
	*
	* @param {Object<string, Node>} parameters - The parameters to set.
	* @return {FunctionCallNode} A reference to this node.
	*/
	setParameters(parameters) {
		this.parameters = parameters;
		return this;
	}
	/**
	* Returns the parameters of the function call node.
	*
	* @return {Object<string, Node>} The parameters of this node.
	*/
	getParameters() {
		return this.parameters;
	}
	/**
	* Returns the type of this function call node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @returns {string} The type of this node.
	*/
	getNodeType(builder) {
		return this.functionNode.getNodeType(builder);
	}
	/**
	* Returns the function node of this function call node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} [name] - The name of the member.
	* @returns {string} The type of the member.
	*/
	getMemberType(builder, name) {
		return this.functionNode.getMemberType(builder, name);
	}
	generate(builder) {
		const params = [];
		const functionNode = this.functionNode;
		const inputs = functionNode.getInputs(builder);
		const parameters = this.parameters;
		const generateInput = (node, inputNode) => {
			const type$1 = inputNode.type;
			const pointer = type$1 === "pointer";
			let output$2;
			if (pointer) output$2 = "&" + node.build(builder);
			else output$2 = node.build(builder, type$1);
			return output$2;
		};
		if (Array.isArray(parameters)) {
			if (parameters.length > inputs.length) {
				error("TSL: The number of provided parameters exceeds the expected number of inputs in 'Fn()'.");
				parameters.length = inputs.length;
			} else if (parameters.length < inputs.length) {
				error("TSL: The number of provided parameters is less than the expected number of inputs in 'Fn()'.");
				while (parameters.length < inputs.length) parameters.push(float$1(0));
			}
			for (let i = 0; i < parameters.length; i++) params.push(generateInput(parameters[i], inputs[i]));
		} else for (const inputNode of inputs) {
			const node = parameters[inputNode.name];
			if (node !== void 0) params.push(generateInput(node, inputNode));
			else {
				error(`TSL: Input '${inputNode.name}' not found in \'Fn()\'.`);
				params.push(generateInput(float$1(0), inputNode));
			}
		}
		return `${functionNode.build(builder, "property")}( ${params.join(", ")} )`;
	}
};
var call$1 = (func, ...params) => {
	params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray$1(params) : nodeObjects$1(params[0]);
	return new FunctionCallNode(nodeObject$1(func), params);
};
addMethodChaining$1("call", call$1);
var _vectorOperators = {
	"==": "equal",
	"!=": "notEqual",
	"<": "lessThan",
	">": "greaterThan",
	"<=": "lessThanEqual",
	">=": "greaterThanEqual",
	"%": "mod"
};
/**
* This node represents basic mathematical and logical operations like addition,
* subtraction or comparisons (e.g. `equal()`).
*
* @augments TempNode
*/
var OperatorNode = class OperatorNode extends TempNode {
	static get type() {
		return "OperatorNode";
	}
	/**
	* Constructs a new operator node.
	*
	* @param {string} op - The operator.
	* @param {Node} aNode - The first input.
	* @param {Node} bNode - The second input.
	* @param {...Node} params - Additional input parameters.
	*/
	constructor(op, aNode, bNode, ...params) {
		super();
		if (params.length > 0) {
			let finalOp = new OperatorNode(op, aNode, bNode);
			for (let i = 0; i < params.length - 1; i++) finalOp = new OperatorNode(op, finalOp, params[i]);
			aNode = finalOp;
			bNode = params[params.length - 1];
		}
		/**
		* The operator.
		*
		* @type {string}
		*/
		this.op = op;
		/**
		* The first input.
		*
		* @type {Node}
		*/
		this.aNode = aNode;
		/**
		* The second input.
		*
		* @type {Node}
		*/
		this.bNode = bNode;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isOperatorNode = true;
	}
	/**
	* Returns the operator method name.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} output - The output type.
	* @returns {string} The operator method name.
	*/
	getOperatorMethod(builder, output$2) {
		return builder.getMethod(_vectorOperators[this.op], output$2);
	}
	/**
	* This method is overwritten since the node type is inferred from the operator
	* and the input node types.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {?string} [output=null] - The output type.
	* @return {string} The node type.
	*/
	getNodeType(builder, output$2 = null) {
		const op = this.op;
		const aNode = this.aNode;
		const bNode = this.bNode;
		const typeA = aNode.getNodeType(builder);
		const typeB = bNode ? bNode.getNodeType(builder) : null;
		if (typeA === "void" || typeB === "void") return output$2 || "void";
		else if (op === "%") return typeA;
		else if (op === "~" || op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") return builder.getIntegerType(typeA);
		else if (op === "!" || op === "&&" || op === "||" || op === "^^") return "bool";
		else if (op === "==" || op === "!=" || op === "<" || op === ">" || op === "<=" || op === ">=") {
			const typeLength = Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
			return typeLength > 1 ? `bvec${typeLength}` : "bool";
		} else {
			if (builder.isMatrix(typeA)) {
				if (typeB === "float") return typeA;
				else if (builder.isVector(typeB)) return builder.getVectorFromMatrix(typeA);
				else if (builder.isMatrix(typeB)) return typeA;
			} else if (builder.isMatrix(typeB)) {
				if (typeA === "float") return typeB;
				else if (builder.isVector(typeA)) return builder.getVectorFromMatrix(typeB);
			}
			if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) return typeB;
			return typeA;
		}
	}
	generate(builder, output$2) {
		const op = this.op;
		const { aNode, bNode } = this;
		const type$1 = this.getNodeType(builder, output$2);
		let typeA = null;
		let typeB = null;
		if (type$1 !== "void") {
			typeA = aNode.getNodeType(builder);
			typeB = bNode ? bNode.getNodeType(builder) : null;
			if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==" || op === "!=") {
				if (builder.isVector(typeA)) typeB = typeA;
				else if (builder.isVector(typeB)) typeA = typeB;
				else if (typeA !== typeB) typeA = typeB = "float";
			} else if (op === ">>" || op === "<<") {
				typeA = type$1;
				typeB = builder.changeComponentType(typeB, "uint");
			} else if (op === "%") {
				typeA = type$1;
				typeB = builder.isInteger(typeA) && builder.isInteger(typeB) ? typeB : typeA;
			} else if (builder.isMatrix(typeA)) if (typeB === "float") typeB = "float";
			else if (builder.isVector(typeB)) typeB = builder.getVectorFromMatrix(typeA);
			else if (builder.isMatrix(typeB));
			else typeA = typeB = type$1;
			else if (builder.isMatrix(typeB)) if (typeA === "float") typeA = "float";
			else if (builder.isVector(typeA)) typeA = builder.getVectorFromMatrix(typeB);
			else typeA = typeB = type$1;
			else typeA = typeB = type$1;
		} else typeA = typeB = type$1;
		const a$1 = aNode.build(builder, typeA);
		const b$2 = bNode ? bNode.build(builder, typeB) : null;
		const fnOpSnippet = builder.getFunctionOperator(op);
		if (output$2 !== "void") {
			const isGLSL = builder.renderer.coordinateSystem === WebGLCoordinateSystem;
			if (op === "==" || op === "!=" || op === "<" || op === ">" || op === "<=" || op === ">=") if (isGLSL) if (builder.isVector(typeA)) return builder.format(`${this.getOperatorMethod(builder, output$2)}( ${a$1}, ${b$2} )`, type$1, output$2);
			else return builder.format(`( ${a$1} ${op} ${b$2} )`, type$1, output$2);
			else return builder.format(`( ${a$1} ${op} ${b$2} )`, type$1, output$2);
			else if (op === "%") if (builder.isInteger(typeB)) return builder.format(`( ${a$1} % ${b$2} )`, type$1, output$2);
			else return builder.format(`${this.getOperatorMethod(builder, type$1)}( ${a$1}, ${b$2} )`, type$1, output$2);
			else if (op === "!" || op === "~") return builder.format(`(${op}${a$1})`, typeA, output$2);
			else if (fnOpSnippet) return builder.format(`${fnOpSnippet}( ${a$1}, ${b$2} )`, type$1, output$2);
			else if (builder.isMatrix(typeA) && typeB === "float") return builder.format(`( ${b$2} ${op} ${a$1} )`, type$1, output$2);
			else if (typeA === "float" && builder.isMatrix(typeB)) return builder.format(`${a$1} ${op} ${b$2}`, type$1, output$2);
			else {
				let snippet = `( ${a$1} ${op} ${b$2} )`;
				if (!isGLSL && type$1 === "bool" && builder.isVector(typeA) && builder.isVector(typeB)) snippet = `all${snippet}`;
				return builder.format(snippet, type$1, output$2);
			}
		} else if (typeA !== "void") if (fnOpSnippet) return builder.format(`${fnOpSnippet}( ${a$1}, ${b$2} )`, type$1, output$2);
		else if (builder.isMatrix(typeA) && typeB === "float") return builder.format(`${b$2} ${op} ${a$1}`, type$1, output$2);
		else return builder.format(`${a$1} ${op} ${b$2}`, type$1, output$2);
	}
	serialize(data) {
		super.serialize(data);
		data.op = this.op;
	}
	deserialize(data) {
		super.deserialize(data);
		this.op = data.op;
	}
};
/**
* Returns the addition of two or more value.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @param {...Node} params - Additional input parameters.
* @returns {OperatorNode}
*/
var add$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "+").setParameterLength(2, Infinity).setName("add");
/**
* Returns the subtraction of two or more value.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @param {...Node} params - Additional input parameters.
* @returns {OperatorNode}
*/
var sub$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "-").setParameterLength(2, Infinity).setName("sub");
/**
* Returns the multiplication of two or more value.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @param {...Node} params - Additional input parameters.
* @returns {OperatorNode}
*/
var mul$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "*").setParameterLength(2, Infinity).setName("mul");
/**
* Returns the division of two or more value.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @param {...Node} params - Additional input parameters.
* @returns {OperatorNode}
*/
var div$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "/").setParameterLength(2, Infinity).setName("div");
/**
* Computes the remainder of dividing the first node by the second one.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var mod$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "%").setParameterLength(2).setName("mod");
/**
* Checks if two nodes are equal.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var equal$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "==").setParameterLength(2).setName("equal");
/**
* Checks if two nodes are not equal.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var notEqual$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "!=").setParameterLength(2).setName("notEqual");
/**
* Checks if the first node is less than the second.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var lessThan$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "<").setParameterLength(2).setName("lessThan");
/**
* Checks if the first node is greater than the second.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var greaterThan$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, ">").setParameterLength(2).setName("greaterThan");
/**
* Checks if the first node is less than or equal to the second.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var lessThanEqual$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "<=").setParameterLength(2).setName("lessThanEqual");
/**
* Checks if the first node is greater than or equal to the second.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var greaterThanEqual$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, ">=").setParameterLength(2).setName("greaterThanEqual");
/**
* Performs a logical AND operation on multiple nodes.
*
* @tsl
* @function
* @param {...Node} nodes - The input nodes to be combined using AND.
* @returns {OperatorNode}
*/
var and$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "&&").setParameterLength(2, Infinity).setName("and");
/**
* Performs a logical OR operation on multiple nodes.
*
* @tsl
* @function
* @param {...Node} nodes - The input nodes to be combined using OR.
* @returns {OperatorNode}
*/
var or$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "||").setParameterLength(2, Infinity).setName("or");
/**
* Performs logical NOT on a node.
*
* @tsl
* @function
* @param {Node} value - The value.
* @returns {OperatorNode}
*/
var not$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "!").setParameterLength(1).setName("not");
/**
* Performs logical XOR on two nodes.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var xor$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "^^").setParameterLength(2).setName("xor");
/**
* Performs bitwise AND on two nodes.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var bitAnd$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "&").setParameterLength(2).setName("bitAnd");
/**
* Performs bitwise NOT on a node.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var bitNot$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "~").setParameterLength(1).setName("bitNot");
/**
* Performs bitwise OR on two nodes.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var bitOr$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "|").setParameterLength(2).setName("bitOr");
/**
* Performs bitwise XOR on two nodes.
*
* @tsl
* @function
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var bitXor$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "^").setParameterLength(2).setName("bitXor");
/**
* Shifts a node to the left.
*
* @tsl
* @function
* @param {Node} a - The node to shift.
* @param {Node} b - The value to shift.
* @returns {OperatorNode}
*/
var shiftLeft$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, "<<").setParameterLength(2).setName("shiftLeft");
/**
* Shifts a node to the right.
*
* @tsl
* @function
* @param {Node} a - The node to shift.
* @param {Node} b - The value to shift.
* @returns {OperatorNode}
*/
var shiftRight$1 = /* @__PURE__ */ nodeProxyIntent$1(OperatorNode, ">>").setParameterLength(2).setName("shiftRight");
/**
* Increments a node by 1.
*
* @tsl
* @function
* @param {Node} a - The node to increment.
* @returns {OperatorNode}
*/
var incrementBefore$1 = Fn$1(([a$1]) => {
	a$1.addAssign(1);
	return a$1;
});
/**
* Decrements a node by 1.
*
* @tsl
* @function
* @param {Node} a - The node to decrement.
* @returns {OperatorNode}
*/
var decrementBefore$1 = Fn$1(([a$1]) => {
	a$1.subAssign(1);
	return a$1;
});
/**
* Increments a node by 1 and returns the previous value.
*
* @tsl
* @function
* @param {Node} a - The node to increment.
* @returns {OperatorNode}
*/
var increment$1 = /* @__PURE__ */ Fn$1(([a$1]) => {
	const temp = int$1(a$1).toConst();
	a$1.addAssign(1);
	return temp;
});
/**
* Decrements a node by 1 and returns the previous value.
*
* @tsl
* @function
* @param {Node} a - The node to decrement.
* @returns {OperatorNode}
*/
var decrement$1 = /* @__PURE__ */ Fn$1(([a$1]) => {
	const temp = int$1(a$1).toConst();
	a$1.subAssign(1);
	return temp;
});
addMethodChaining$1("add", add$1);
addMethodChaining$1("sub", sub$1);
addMethodChaining$1("mul", mul$1);
addMethodChaining$1("div", div$1);
addMethodChaining$1("mod", mod$1);
addMethodChaining$1("equal", equal$1);
addMethodChaining$1("notEqual", notEqual$1);
addMethodChaining$1("lessThan", lessThan$1);
addMethodChaining$1("greaterThan", greaterThan$1);
addMethodChaining$1("lessThanEqual", lessThanEqual$1);
addMethodChaining$1("greaterThanEqual", greaterThanEqual$1);
addMethodChaining$1("and", and$1);
addMethodChaining$1("or", or$1);
addMethodChaining$1("not", not$1);
addMethodChaining$1("xor", xor$1);
addMethodChaining$1("bitAnd", bitAnd$1);
addMethodChaining$1("bitNot", bitNot$1);
addMethodChaining$1("bitOr", bitOr$1);
addMethodChaining$1("bitXor", bitXor$1);
addMethodChaining$1("shiftLeft", shiftLeft$1);
addMethodChaining$1("shiftRight", shiftRight$1);
addMethodChaining$1("incrementBefore", incrementBefore$1);
addMethodChaining$1("decrementBefore", decrementBefore$1);
addMethodChaining$1("increment", increment$1);
addMethodChaining$1("decrement", decrement$1);
/**
* @tsl
* @function
* @deprecated since r175. Use {@link mod} instead.
*
* @param {Node} a - The first input.
* @param {Node} b - The second input.
* @returns {OperatorNode}
*/
var modInt$1 = (a$1, b$2) => {
	warn("TSL: \"modInt()\" is deprecated. Use \"mod( int( ... ) )\" instead.");
	return mod$1(int$1(a$1), int$1(b$2));
};
addMethodChaining$1("modInt", modInt$1);
/**
* This node represents a variety of mathematical methods available in shaders.
* They are divided into three categories:
*
* - Methods with one input like `sin`, `cos` or `normalize`.
* - Methods with two inputs like `dot`, `cross` or `pow`.
* - Methods with three inputs like `mix`, `clamp` or `smoothstep`.
*
* @augments TempNode
*/
var MathNode = class MathNode extends TempNode {
	static get type() {
		return "MathNode";
	}
	/**
	* Constructs a new math node.
	*
	* @param {string} method - The method name.
	* @param {Node} aNode - The first input.
	* @param {?Node} [bNode=null] - The second input.
	* @param {?Node} [cNode=null] - The third input.
	*/
	constructor(method, aNode, bNode = null, cNode = null) {
		super();
		if ((method === MathNode.MAX || method === MathNode.MIN) && arguments.length > 3) {
			let finalOp = new MathNode(method, aNode, bNode);
			for (let i = 2; i < arguments.length - 1; i++) finalOp = new MathNode(method, finalOp, arguments[i]);
			aNode = finalOp;
			bNode = arguments[arguments.length - 1];
			cNode = null;
		}
		/**
		* The method name.
		*
		* @type {string}
		*/
		this.method = method;
		/**
		* The first input.
		*
		* @type {Node}
		*/
		this.aNode = aNode;
		/**
		* The second input.
		*
		* @type {?Node}
		* @default null
		*/
		this.bNode = bNode;
		/**
		* The third input.
		*
		* @type {?Node}
		* @default null
		*/
		this.cNode = cNode;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMathNode = true;
	}
	/**
	* The input type is inferred from the node types of the input nodes.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType(builder) {
		const aType = this.aNode.getNodeType(builder);
		const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
		const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
		const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
		const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
		const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
		if (aLen > bLen && aLen > cLen) return aType;
		else if (bLen > cLen) return bType;
		else if (cLen > aLen) return cType;
		return aType;
	}
	/**
	* The selected method as well as the input type determine the node type of this node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		const method = this.method;
		if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) return "float";
		else if (method === MathNode.CROSS) return "vec3";
		else if (method === MathNode.ALL || method === MathNode.ANY) return "bool";
		else if (method === MathNode.EQUALS) return builder.changeComponentType(this.aNode.getNodeType(builder), "bool");
		else return this.getInputType(builder);
	}
	setup(builder) {
		const { aNode, bNode, method } = this;
		let outputNode = null;
		if (method === MathNode.ONE_MINUS) outputNode = sub$1(1, aNode);
		else if (method === MathNode.RECIPROCAL) outputNode = div$1(1, aNode);
		else if (method === MathNode.DIFFERENCE) outputNode = abs$1(sub$1(aNode, bNode));
		else if (method === MathNode.TRANSFORM_DIRECTION) {
			let tA = aNode;
			let tB = bNode;
			if (builder.isMatrix(tA.getNodeType(builder))) tB = vec4$1(vec3$1(tB), 0);
			else tA = vec4$1(vec3$1(tA), 0);
			const mulNode = mul$1(tA, tB).xyz;
			outputNode = normalize$1(mulNode);
		}
		if (outputNode !== null) return outputNode;
		else return super.setup(builder);
	}
	generate(builder, output$2) {
		if (builder.getNodeProperties(this).outputNode) return super.generate(builder, output$2);
		let method = this.method;
		const type$1 = this.getNodeType(builder);
		const inputType = this.getInputType(builder);
		const a$1 = this.aNode;
		const b$2 = this.bNode;
		const c$1 = this.cNode;
		const coordinateSystem = builder.renderer.coordinateSystem;
		if (method === MathNode.NEGATE) return builder.format("( - " + a$1.build(builder, inputType) + " )", type$1, output$2);
		else {
			const params = [];
			if (method === MathNode.CROSS) params.push(a$1.build(builder, type$1), b$2.build(builder, type$1));
			else if (coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP) params.push(a$1.build(builder, builder.getTypeLength(a$1.getNodeType(builder)) === 1 ? "float" : inputType), b$2.build(builder, inputType));
			else if (coordinateSystem === WebGLCoordinateSystem && (method === MathNode.MIN || method === MathNode.MAX)) params.push(a$1.build(builder, inputType), b$2.build(builder, builder.getTypeLength(b$2.getNodeType(builder)) === 1 ? "float" : inputType));
			else if (method === MathNode.REFRACT) params.push(a$1.build(builder, inputType), b$2.build(builder, inputType), c$1.build(builder, "float"));
			else if (method === MathNode.MIX) params.push(a$1.build(builder, inputType), b$2.build(builder, inputType), c$1.build(builder, builder.getTypeLength(c$1.getNodeType(builder)) === 1 ? "float" : inputType));
			else {
				if (coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b$2 !== null) method = "atan2";
				if (builder.shaderStage !== "fragment" && (method === MathNode.DFDX || method === MathNode.DFDY)) {
					warn(`TSL: '${method}' is not supported in the ${builder.shaderStage} stage.`);
					method = "/*" + method + "*/";
				}
				params.push(a$1.build(builder, inputType));
				if (b$2 !== null) params.push(b$2.build(builder, inputType));
				if (c$1 !== null) params.push(c$1.build(builder, inputType));
			}
			return builder.format(`${builder.getMethod(method, type$1)}( ${params.join(", ")} )`, type$1, output$2);
		}
	}
	serialize(data) {
		super.serialize(data);
		data.method = this.method;
	}
	deserialize(data) {
		super.deserialize(data);
		this.method = data.method;
	}
};
MathNode.ALL = "all";
MathNode.ANY = "any";
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.TRANSPOSE = "transpose";
MathNode.DETERMINANT = "determinant";
MathNode.INVERSE = "inverse";
MathNode.EQUALS = "equals";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
/**
* A small value used to handle floating-point precision errors.
*
* @tsl
* @type {Node<float>}
*/
var EPSILON$1 = /* @__PURE__ */ float$1(1e-6);
/**
* Represents infinity.
*
* @tsl
* @type {Node<float>}
*/
var INFINITY$1 = /* @__PURE__ */ float$1(1e6);
/**
* Represents PI.
*
* @tsl
* @type {Node<float>}
*/
var PI$1 = /* @__PURE__ */ float$1(Math.PI);
/**
* Represents PI * 2. Please use the non-deprecated version `TWO_PI`.
*
* @tsl
* @deprecated
* @type {Node<float>}
*/
var PI2$1 = /* @__PURE__ */ float$1(Math.PI * 2);
/**
* Represents PI * 2.
*
* @tsl
* @type {Node<float>}
*/
var TWO_PI$1 = /* @__PURE__ */ float$1(Math.PI * 2);
/**
* Represents PI / 2.
*
* @tsl
* @type {Node<float>}
*/
var HALF_PI$1 = /* @__PURE__ */ float$1(Math.PI * .5);
/**
* Returns `true` if all components of `x` are `true`.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node<bool>}
*/
var all$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.ALL).setParameterLength(1);
/**
* Returns `true` if any components of `x` are `true`.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node<bool>}
*/
var any$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.ANY).setParameterLength(1);
/**
* Converts a quantity in degrees to radians.
*
* @tsl
* @function
* @param {Node | number} x - The input in degrees.
* @returns {Node}
*/
var radians$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.RADIANS).setParameterLength(1);
/**
* Convert a quantity in radians to degrees.
*
* @tsl
* @function
* @param {Node | number} x - The input in radians.
* @returns {Node}
*/
var degrees$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.DEGREES).setParameterLength(1);
/**
* Returns the natural exponentiation of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var exp$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.EXP).setParameterLength(1);
/**
* Returns 2 raised to the power of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var exp2$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.EXP2).setParameterLength(1);
/**
* Returns the natural logarithm of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var log$2 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.LOG).setParameterLength(1);
/**
* Returns the base 2 logarithm of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var log2$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.LOG2).setParameterLength(1);
/**
* Returns the square root of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var sqrt$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.SQRT).setParameterLength(1);
/**
* Returns the inverse of the square root of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var inverseSqrt$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.INVERSE_SQRT).setParameterLength(1);
/**
* Finds the nearest integer less than or equal to the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var floor$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.FLOOR).setParameterLength(1);
/**
* Finds the nearest integer that is greater than or equal to the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var ceil$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.CEIL).setParameterLength(1);
/**
* Calculates the unit vector in the same direction as the original vector.
*
* @tsl
* @function
* @param {Node} x - The input vector.
* @returns {Node}
*/
var normalize$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.NORMALIZE).setParameterLength(1);
/**
* Computes the fractional part of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var fract$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.FRACT).setParameterLength(1);
/**
* Returns the sine of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var sin$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.SIN).setParameterLength(1);
/**
* Returns the cosine of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var cos$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.COS).setParameterLength(1);
/**
* Returns the tangent of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var tan$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.TAN).setParameterLength(1);
/**
* Returns the arcsine of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var asin$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.ASIN).setParameterLength(1);
/**
* Returns the arccosine of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var acos$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.ACOS).setParameterLength(1);
/**
* Returns the arc-tangent of the parameter.
* If two parameters are provided, the result is `atan2(y/x)`.
*
* @tsl
* @function
* @param {Node | number} y - The y parameter.
* @param {?(Node | number)} x - The x parameter.
* @returns {Node}
*/
var atan$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.ATAN).setParameterLength(1, 2);
/**
* Returns the absolute value of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var abs$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.ABS).setParameterLength(1);
/**
* Extracts the sign of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var sign$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.SIGN).setParameterLength(1);
/**
* Calculates the length of a vector.
*
* @tsl
* @function
* @param {Node} x - The parameter.
* @returns {Node<float>}
*/
var length$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.LENGTH).setParameterLength(1);
/**
* Negates the value of the parameter (-x).
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var negate$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.NEGATE).setParameterLength(1);
/**
* Return `1` minus the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var oneMinus$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.ONE_MINUS).setParameterLength(1);
/**
* Returns the partial derivative of the parameter with respect to x.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var dFdx$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.DFDX).setParameterLength(1);
/**
* Returns the partial derivative of the parameter with respect to y.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var dFdy$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.DFDY).setParameterLength(1);
/**
* Rounds the parameter to the nearest integer.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var round$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.ROUND).setParameterLength(1);
/**
* Returns the reciprocal of the parameter `(1/x)`.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var reciprocal$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.RECIPROCAL).setParameterLength(1);
/**
* Truncates the parameter, removing the fractional part.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var trunc$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.TRUNC).setParameterLength(1);
/**
* Returns the sum of the absolute derivatives in x and y.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @returns {Node}
*/
var fwidth$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.FWIDTH).setParameterLength(1);
/**
* Returns the transpose of a matrix.
*
* @tsl
* @function
* @param {Node<mat2|mat3|mat4>} x - The parameter.
* @returns {Node}
*/
var transpose$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.TRANSPOSE).setParameterLength(1);
/**
* Returns the determinant of a matrix.
*
* @tsl
* @function
* @param {Node<mat2|mat3|mat4>} x - The parameter.
* @returns {Node<float>}
*/
var determinant$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.DETERMINANT).setParameterLength(1);
/**
* Returns the inverse of a matrix.
*
* @tsl
* @function
* @param {Node<mat2|mat3|mat4>} x - The parameter.
* @returns {Node<mat2|mat3|mat4>}
*/
var inverse$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.INVERSE).setParameterLength(1);
/**
* Returns `true` if `x` equals `y`.
*
* @tsl
* @function
* @param {Node | number} x - The first parameter.
* @param {Node | number} y - The second parameter.
* @deprecated since r175. Use {@link equal} instead.
* @returns {Node<bool>}
*/
var equals$2 = (x, y) => {
	warn("TSL: \"equals\" is deprecated. Use \"equal\" inside a vector instead, like: \"bvec*( equal( ... ) )\"");
	return equal$1(x, y);
};
/**
* Returns the least of the given values.
*
* @tsl
* @function
* @param {...(Node | number)} values - The values to compare.
* @returns {Node}
*/
var min$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.MIN).setParameterLength(2, Infinity);
/**
* Returns the greatest of the given values.
*
* @tsl
* @function
* @param {...(Node | number)} values - The values to compare.
* @returns {Node}
*/
var max$1$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.MAX).setParameterLength(2, Infinity);
/**
* Generate a step function by comparing two values.
*
* @tsl
* @function
* @param {Node | number} x - The y parameter.
* @param {Node | number} y - The x parameter.
* @returns {Node}
*/
var step$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.STEP).setParameterLength(2);
/**
* Calculates the reflection direction for an incident vector.
*
* @tsl
* @function
* @param {Node<vec2|vec3|vec4>} I - The incident vector.
* @param {Node<vec2|vec3|vec4>} N - The normal vector.
* @returns {Node<vec2|vec3|vec4>}
*/
var reflect$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.REFLECT).setParameterLength(2);
/**
* Calculates the distance between two points.
*
* @tsl
* @function
* @param {Node<vec2|vec3|vec4>} x - The first point.
* @param {Node<vec2|vec3|vec4>} y - The second point.
* @returns {Node<float>}
*/
var distance$2 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.DISTANCE).setParameterLength(2);
/**
* Calculates the absolute difference between two values.
*
* @tsl
* @function
* @param {Node | number} x - The first parameter.
* @param {Node | number} y - The second parameter.
* @returns {Node}
*/
var difference$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.DIFFERENCE).setParameterLength(2);
/**
* Calculates the dot product of two vectors.
*
* @tsl
* @function
* @param {Node<vec2|vec3|vec4>} x - The first vector.
* @param {Node<vec2|vec3|vec4>} y - The second vector.
* @returns {Node<float>}
*/
var dot$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.DOT).setParameterLength(2);
/**
* Calculates the cross product of two vectors.
*
* @tsl
* @function
* @param {Node<vec2|vec3>} x - The first vector.
* @param {Node<vec2|vec3>} y - The second vector.
* @returns {Node<float|vec3>}
*/
var cross$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.CROSS).setParameterLength(2);
/**
* Return the value of the first parameter raised to the power of the second one.
*
* @tsl
* @function
* @param {Node | number} x - The first parameter.
* @param {Node | number} y - The second parameter.
* @returns {Node}
*/
var pow$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.POW).setParameterLength(2);
/**
* Returns the square of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The first parameter.
* @returns {Node}
*/
var pow2$1 = (x) => mul$1(x, x);
/**
* Returns the cube of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The first parameter.
* @returns {Node}
*/
var pow3$1 = (x) => mul$1(x, x, x);
/**
* Returns the fourth power of the parameter.
*
* @tsl
* @function
* @param {Node | number} x - The first parameter.
* @returns {Node}
*/
var pow4$1 = (x) => mul$1(x, x, x, x);
/**
* Transforms the direction of a vector by a matrix and then normalizes the result.
*
* @tsl
* @function
* @param {Node<vec2|vec3|vec4>} direction - The direction vector.
* @param {Node<mat2|mat3|mat4>} matrix - The transformation matrix.
* @returns {Node}
*/
var transformDirection$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.TRANSFORM_DIRECTION).setParameterLength(2);
/**
* Returns the cube root of a number.
*
* @tsl
* @function
* @param {Node | number} a - The first parameter.
* @returns {Node}
*/
var cbrt$1 = (a$1) => mul$1(sign$1(a$1), pow$1(abs$1(a$1), 1 / 3));
/**
* Calculate the squared length of a vector.
*
* @tsl
* @function
* @param {Node<vec2|vec3|vec4>} a - The vector.
* @returns {Node<float>}
*/
var lengthSq$1 = (a$1) => dot$1(a$1, a$1);
/**
* Linearly interpolates between two values.
*
* @tsl
* @function
* @param {Node | number} a - The first parameter.
* @param {Node | number} b - The second parameter.
* @param {Node | number} t - The interpolation value.
* @returns {Node}
*/
var mix$2 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.MIX).setParameterLength(3);
/**
* Constrains a value to lie between two further values.
*
* @tsl
* @function
* @param {Node | number} value - The value to constrain.
* @param {Node | number} [low=0] - The lower bound.
* @param {Node | number} [high=1] - The upper bound.
* @returns {Node}
*/
var clamp$2 = (value, low = 0, high = 1) => nodeObject$1(new MathNode(MathNode.CLAMP, nodeObject$1(value), nodeObject$1(low), nodeObject$1(high)));
/**
* Constrains a value between `0` and `1`.
*
* @tsl
* @function
* @param {Node | number} value - The value to constrain.
* @returns {Node}
*/
var saturate$1 = (value) => clamp$2(value);
/**
* Calculates the refraction direction for an incident vector.
*
* @tsl
* @function
* @param {Node<vec2|vec3|vec4>} I - The incident vector.
* @param {Node<vec2|vec3|vec4>} N - The normal vector.
* @param {Node<float>} eta - The ratio of indices of refraction.
* @returns {Node<vec2|vec3|vec4>}
*/
var refract$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.REFRACT).setParameterLength(3);
/**
* Performs a Hermite interpolation between two values.
*
* @tsl
* @function
* @param {Node | number} low - The value of the lower edge of the Hermite function.
* @param {Node | number} high - The value of the upper edge of the Hermite function.
* @param {Node | number} x - The source value for interpolation.
* @returns {Node}
*/
var smoothstep$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.SMOOTHSTEP).setParameterLength(3);
/**
* Returns a vector pointing in the same direction as another.
*
* @tsl
* @function
* @param {Node<vec2|vec3|vec4>} N - The vector to orient.
* @param {Node<vec2|vec3|vec4>} I - The incident vector.
* @param {Node<vec2|vec3|vec4>} Nref - The reference vector.
* @returns {Node<vec2|vec3|vec4>}
*/
var faceForward$1 = /* @__PURE__ */ nodeProxyIntent$1(MathNode, MathNode.FACEFORWARD).setParameterLength(3);
/**
* Returns a random value for the given uv.
*
* @tsl
* @function
* @param {Node<vec2>} uv - The uv node.
* @returns {Node<float>}
*/
var rand$1 = /* @__PURE__ */ Fn$1(([uv$3]) => {
	const a$1 = 12.9898, b$2 = 78.233, c$1 = 43758.5453;
	const dt = dot$1(uv$3.xy, vec2$1(a$1, b$2)), sn = mod$1(dt, PI$1);
	return fract$1(sin$1(sn).mul(c$1));
});
/**
* Alias for `mix()` with a different parameter order.
*
* @tsl
* @function
* @param {Node | number} t - The interpolation value.
* @param {Node | number} e1 - The first parameter.
* @param {Node | number} e2 - The second parameter.
* @returns {Node}
*/
var mixElement$1 = (t, e1, e2) => mix$2(e1, e2, t);
/**
* Alias for `smoothstep()` with a different parameter order.
*
* @tsl
* @function
* @param {Node | number} x - The source value for interpolation.
* @param {Node | number} low - The value of the lower edge of the Hermite function.
* @param {Node | number} high - The value of the upper edge of the Hermite function.
* @returns {Node}
*/
var smoothstepElement$1 = (x, low, high) => smoothstep$1(low, high, x);
/**
* Alias for `step()` with a different parameter order.
*
* @tsl
* @function
* @param {Node | number} x - The source value for interpolation.
* @param {Node | number} edge - The edge value.
* @returns {Node}
*/
var stepElement$1 = (x, edge) => step$1(edge, x);
/**
* Returns the arc-tangent of the quotient of its parameters.
*
* @tsl
* @function
* @deprecated since r172. Use {@link atan} instead.
*
* @param {Node | number} y - The y parameter.
* @param {Node | number} x - The x parameter.
* @returns {Node}
*/
var atan2$1 = (y, x) => {
	warn("TSL: \"atan2\" is overloaded. Use \"atan\" instead.");
	return atan$1(y, x);
};
var faceforward$1 = faceForward$1;
var inversesqrt$1 = inverseSqrt$1;
addMethodChaining$1("all", all$1);
addMethodChaining$1("any", any$1);
addMethodChaining$1("equals", equals$2);
addMethodChaining$1("radians", radians$1);
addMethodChaining$1("degrees", degrees$1);
addMethodChaining$1("exp", exp$1);
addMethodChaining$1("exp2", exp2$1);
addMethodChaining$1("log", log$2);
addMethodChaining$1("log2", log2$1);
addMethodChaining$1("sqrt", sqrt$1);
addMethodChaining$1("inverseSqrt", inverseSqrt$1);
addMethodChaining$1("floor", floor$1);
addMethodChaining$1("ceil", ceil$1);
addMethodChaining$1("normalize", normalize$1);
addMethodChaining$1("fract", fract$1);
addMethodChaining$1("sin", sin$1);
addMethodChaining$1("cos", cos$1);
addMethodChaining$1("tan", tan$1);
addMethodChaining$1("asin", asin$1);
addMethodChaining$1("acos", acos$1);
addMethodChaining$1("atan", atan$1);
addMethodChaining$1("abs", abs$1);
addMethodChaining$1("sign", sign$1);
addMethodChaining$1("length", length$1);
addMethodChaining$1("lengthSq", lengthSq$1);
addMethodChaining$1("negate", negate$1);
addMethodChaining$1("oneMinus", oneMinus$1);
addMethodChaining$1("dFdx", dFdx$1);
addMethodChaining$1("dFdy", dFdy$1);
addMethodChaining$1("round", round$1);
addMethodChaining$1("reciprocal", reciprocal$1);
addMethodChaining$1("trunc", trunc$1);
addMethodChaining$1("fwidth", fwidth$1);
addMethodChaining$1("atan2", atan2$1);
addMethodChaining$1("min", min$1);
addMethodChaining$1("max", max$1$1);
addMethodChaining$1("step", stepElement$1);
addMethodChaining$1("reflect", reflect$1);
addMethodChaining$1("distance", distance$2);
addMethodChaining$1("dot", dot$1);
addMethodChaining$1("cross", cross$1);
addMethodChaining$1("pow", pow$1);
addMethodChaining$1("pow2", pow2$1);
addMethodChaining$1("pow3", pow3$1);
addMethodChaining$1("pow4", pow4$1);
addMethodChaining$1("transformDirection", transformDirection$1);
addMethodChaining$1("mix", mixElement$1);
addMethodChaining$1("clamp", clamp$2);
addMethodChaining$1("refract", refract$1);
addMethodChaining$1("smoothstep", smoothstepElement$1);
addMethodChaining$1("faceForward", faceForward$1);
addMethodChaining$1("difference", difference$1);
addMethodChaining$1("saturate", saturate$1);
addMethodChaining$1("cbrt", cbrt$1);
addMethodChaining$1("transpose", transpose$1);
addMethodChaining$1("determinant", determinant$1);
addMethodChaining$1("inverse", inverse$1);
addMethodChaining$1("rand", rand$1);
/**
* Represents a logical `if/else` statement. Can be used as an alternative
* to the `If()`/`Else()` syntax.
*
* The corresponding TSL `select()` looks like so:
* ```js
* velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );
* ```
* The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`
* determine the outcome of the entire statement.
*
* @augments Node
*/
var ConditionalNode = class extends Node {
	static get type() {
		return "ConditionalNode";
	}
	/**
	* Constructs a new conditional node.
	*
	* @param {Node} condNode - The node that defines the condition.
	* @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
	* @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
	*/
	constructor(condNode, ifNode, elseNode = null) {
		super();
		/**
		* The node that defines the condition.
		*
		* @type {Node}
		*/
		this.condNode = condNode;
		/**
		* The node that is evaluate when the condition ends up `true`.
		*
		* @type {Node}
		*/
		this.ifNode = ifNode;
		/**
		* The node that is evaluate when the condition ends up `false`.
		*
		* @type {?Node}
		* @default null
		*/
		this.elseNode = elseNode;
	}
	/**
	* This method is overwritten since the node type is inferred from the if/else
	* nodes.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		const { ifNode, elseNode } = builder.getNodeProperties(this);
		if (ifNode === void 0) {
			builder.flowBuildStage(this, "setup");
			return this.getNodeType(builder);
		}
		const ifType = ifNode.getNodeType(builder);
		if (elseNode !== null) {
			const elseType = elseNode.getNodeType(builder);
			if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) return elseType;
		}
		return ifType;
	}
	setup(builder) {
		const condNode = this.condNode;
		const ifNode = this.ifNode.isolate();
		const elseNode = this.elseNode ? this.elseNode.isolate() : null;
		const currentNodeBlock = builder.context.nodeBlock;
		builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;
		if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;
		const isUniformFlow = builder.context.uniformFlow;
		const properties = builder.getNodeProperties(this);
		properties.condNode = condNode;
		properties.ifNode = isUniformFlow ? ifNode : ifNode.context({ nodeBlock: ifNode });
		properties.elseNode = elseNode ? isUniformFlow ? elseNode : elseNode.context({ nodeBlock: elseNode }) : null;
	}
	generate(builder, output$2) {
		const type$1 = this.getNodeType(builder);
		const nodeData = builder.getDataFromNode(this);
		if (nodeData.nodeProperty !== void 0) return nodeData.nodeProperty;
		const { condNode, ifNode, elseNode } = builder.getNodeProperties(this);
		const functionNode = builder.currentFunctionNode;
		const needsOutput = output$2 !== "void";
		const nodeProperty = needsOutput ? property$1(type$1).build(builder) : "";
		nodeData.nodeProperty = nodeProperty;
		const nodeSnippet = condNode.build(builder, "bool");
		if (builder.context.uniformFlow && elseNode !== null) {
			const ifSnippet$1 = ifNode.build(builder, type$1);
			const elseSnippet = elseNode.build(builder, type$1);
			const mathSnippet = builder.getTernary(nodeSnippet, ifSnippet$1, elseSnippet);
			return builder.format(mathSnippet, type$1, output$2);
		}
		builder.addFlowCode(`\n${builder.tab}if ( ${nodeSnippet} ) {\n\n`).addFlowTab();
		let ifSnippet = ifNode.build(builder, type$1);
		if (ifSnippet) if (needsOutput) ifSnippet = nodeProperty + " = " + ifSnippet + ";";
		else {
			ifSnippet = "return " + ifSnippet + ";";
			if (functionNode === null) {
				warn("TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values.");
				ifSnippet = "// " + ifSnippet;
			}
		}
		builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
		if (elseNode !== null) {
			builder.addFlowCode(" else {\n\n").addFlowTab();
			let elseSnippet = elseNode.build(builder, type$1);
			if (elseSnippet) if (needsOutput) elseSnippet = nodeProperty + " = " + elseSnippet + ";";
			else {
				elseSnippet = "return " + elseSnippet + ";";
				if (functionNode === null) {
					warn("TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values.");
					elseSnippet = "// " + elseSnippet;
				}
			}
			builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
		} else builder.addFlowCode("\n\n");
		return builder.format(nodeProperty, type$1, output$2);
	}
};
/**
* TSL function for creating a conditional node.
*
* @tsl
* @function
* @param {Node} condNode - The node that defines the condition.
* @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
* @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
* @returns {ConditionalNode}
*/
var select$1 = /* @__PURE__ */ nodeProxy$1(ConditionalNode).setParameterLength(2, 3);
addMethodChaining$1("select", select$1);
/**
* This node can be used as a context management component for another node.
* {@link NodeBuilder} performs its node building process in a specific context and
* this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:
*
* ```js
*node.context( { getUV: () => customCoord } );
*```
* @augments Node
*/
var ContextNode = class extends Node {
	static get type() {
		return "ContextNode";
	}
	/**
	* Constructs a new context node.
	*
	* @param {Node} node - The node whose context should be modified.
	* @param {Object} [value={}] - The modified context data.
	*/
	constructor(node, value = {}) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isContextNode = true;
		/**
		* The node whose context should be modified.
		*
		* @type {Node}
		*/
		this.node = node;
		/**
		* The modified context data.
		*
		* @type {Object}
		* @default {}
		*/
		this.value = value;
	}
	/**
	* This method is overwritten to ensure it returns the reference to {@link ContextNode#node}.
	*
	* @return {Node} A reference to {@link ContextNode#node}.
	*/
	getScope() {
		return this.node.getScope();
	}
	/**
	* This method is overwritten to ensure it returns the type of {@link ContextNode#node}.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		return this.node.getNodeType(builder);
	}
	/**
	* This method is overwritten to ensure it returns the member type of {@link ContextNode#node}.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} name - The member name.
	* @returns {string} The member type.
	*/
	getMemberType(builder, name) {
		return this.node.getMemberType(builder, name);
	}
	analyze(builder) {
		const previousContext = builder.addContext(this.value);
		this.node.build(builder);
		builder.setContext(previousContext);
	}
	setup(builder) {
		const previousContext = builder.addContext(this.value);
		this.node.build(builder);
		builder.setContext(previousContext);
	}
	generate(builder, output$2) {
		const previousContext = builder.addContext(this.value);
		const snippet = this.node.build(builder, output$2);
		builder.setContext(previousContext);
		return snippet;
	}
};
/**
* TSL function for creating a context node.
*
* @tsl
* @function
* @param {Node} node - The node whose context should be modified.
* @param {Object} [value={}] - The modified context data.
* @returns {ContextNode}
*/
var context$1 = /* @__PURE__ */ nodeProxy$1(ContextNode).setParameterLength(1, 2);
/**
* TSL function for defining a uniformFlow context value for a given node.
*
* @tsl
* @function
* @param {Node} node - The node whose dependencies should all execute within a uniform control-flow path.
* @returns {ContextNode}
*/
var uniformFlow$1 = (node) => context$1(node, { uniformFlow: true });
/**
* TSL function for defining a name for the context value for a given node.
*
* @tsl
* @function
* @param {Node} node - The node whose context should be modified.
* @param {string} name - The name to set.
* @returns {ContextNode}
*/
var setName$1 = (node, name) => context$1(node, { nodeName: name });
/**
* TSL function for defining a label context value for a given node.
*
* @tsl
* @function
* @deprecated
* @param {Node} node - The node whose context should be modified.
* @param {string} name - The name/label to set.
* @returns {ContextNode}
*/
function label$1(node, name) {
	warn("TSL: \"label()\" has been deprecated. Use \"setName()\" instead.");
	return setName$1(node, name);
}
addMethodChaining$1("context", context$1);
addMethodChaining$1("label", label$1);
addMethodChaining$1("uniformFlow", uniformFlow$1);
addMethodChaining$1("setName", setName$1);
/**
* Class for representing shader variables as nodes. Variables are created from
* existing nodes like the following:
*
* ```js
* const depth = sampleDepth( uvNode ).toVar( 'depth' );
* ```
*
* @augments Node
*/
var VarNode = class extends Node {
	static get type() {
		return "VarNode";
	}
	/**
	* Constructs a new variable node.
	*
	* @param {Node} node - The node for which a variable should be created.
	* @param {?string} [name=null] - The name of the variable in the shader.
	* @param {boolean} [readOnly=false] - The read-only flag.
	*/
	constructor(node, name = null, readOnly = false) {
		super();
		/**
		* The node for which a variable should be created.
		*
		* @type {Node}
		*/
		this.node = node;
		/**
		* The name of the variable in the shader. If no name is defined,
		* the node system auto-generates one.
		*
		* @type {?string}
		* @default null
		*/
		this.name = name;
		/**
		* `VarNode` sets this property to `true` by default.
		*
		* @type {boolean}
		* @default true
		*/
		this.global = true;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isVarNode = true;
		/**
		*
		* The read-only flag.
		*
		* @type {boolean}
		* @default false
		*/
		this.readOnly = readOnly;
		/**
		*
		* Add this flag to the node system to indicate that this node require parents.
		*
		* @type {boolean}
		* @default true
		*/
		this.parents = true;
		/**
		* This flag is used to indicate that this node is used for intent.
		*
		* @type {boolean}
		* @default false
		*/
		this.intent = false;
	}
	/**
	* Sets the intent flag for this node.
	*
	* This flag is used to indicate that this node is used for intent
	* and should not be built directly. Instead, it is used to indicate that
	* the node should be treated as a variable intent.
	*
	* It's useful for assigning variables without needing creating a new variable node.
	*
	* @param {boolean} value - The value to set for the intent flag.
	* @returns {VarNode} This node.
	*/
	setIntent(value) {
		this.intent = value;
		return this;
	}
	/**
	* Returns the intent flag of this node.
	*
	* @return {boolean} The intent flag.
	*/
	getIntent() {
		return this.intent;
	}
	getMemberType(builder, name) {
		return this.node.getMemberType(builder, name);
	}
	getElementType(builder) {
		return this.node.getElementType(builder);
	}
	getNodeType(builder) {
		return this.node.getNodeType(builder);
	}
	getArrayCount(builder) {
		return this.node.getArrayCount(builder);
	}
	isAssign(builder) {
		let assign$2 = builder.getNodeProperties(this).assign;
		if (assign$2 !== true) {
			if (this.node.isShaderCallNodeInternal && this.node.shaderNode.getLayout() === null) {
				if (builder.fnCall && builder.fnCall.shaderNode) {
					if (builder.getDataFromNode(this.node.shaderNode).hasLoop) assign$2 = true;
				}
			}
		}
		return assign$2;
	}
	build(...params) {
		const builder = params[0];
		if (this._hasStack(builder) === false && builder.buildStage === "setup") {
			if (builder.context.nodeLoop || builder.context.nodeBlock) builder.getBaseStack().addToStack(this);
		}
		if (this.intent === true) {
			if (this.isAssign(builder) !== true) return this.node.build(...params);
		}
		return super.build(...params);
	}
	generate(builder) {
		const { node, name, readOnly } = this;
		const { renderer } = builder;
		const isWebGPUBackend = renderer.backend.isWebGPUBackend === true;
		let isDeterministic = false;
		let shouldTreatAsReadOnly = false;
		if (readOnly) {
			isDeterministic = builder.isDeterministic(node);
			shouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;
		}
		const nodeType = this.getNodeType(builder);
		if (nodeType == "void") {
			if (this.intent !== true) error("TSL: \".toVar()\" can not be used with void type.");
			return node.build(builder);
		}
		const vectorType = builder.getVectorType(nodeType);
		const snippet = node.build(builder, vectorType);
		const nodeVar = builder.getVarFromNode(this, name, vectorType, void 0, shouldTreatAsReadOnly);
		const propertyName = builder.getPropertyName(nodeVar);
		let declarationPrefix = propertyName;
		if (shouldTreatAsReadOnly) if (isWebGPUBackend) declarationPrefix = isDeterministic ? `const ${propertyName}` : `let ${propertyName}`;
		else {
			const count = node.getArrayCount(builder);
			declarationPrefix = `const ${builder.getVar(nodeVar.type, propertyName, count)}`;
		}
		builder.addLineFlowCode(`${declarationPrefix} = ${snippet}`, this);
		return propertyName;
	}
	_hasStack(builder) {
		return builder.getDataFromNode(this).stack !== void 0;
	}
};
/**
* TSL function for creating a var node.
*
* @tsl
* @function
* @param {Node} node - The node for which a variable should be created.
* @param {?string} name - The name of the variable in the shader.
* @returns {VarNode}
*/
var createVar = /* @__PURE__ */ nodeProxy$1(VarNode);
/**
* TSL function for creating a var node.
*
* @tsl
* @function
* @param {Node} node - The node for which a variable should be created.
* @param {?string} name - The name of the variable in the shader.
* @returns {VarNode}
*/
var Var$1 = (node, name = null) => createVar(node, name).toStack();
/**
* TSL function for creating a const node.
*
* @tsl
* @function
* @param {Node} node - The node for which a constant should be created.
* @param {?string} name - The name of the constant in the shader.
* @returns {VarNode}
*/
var Const$1 = (node, name = null) => createVar(node, name, true).toStack();
/**
* TSL function for creating a var intent node.
*
* @tsl
* @function
* @param {Node} node - The node for which a variable should be created.
* @param {?string} name - The name of the variable in the shader.
* @returns {VarNode}
*/
var VarIntent$1 = (node) => {
	return createVar(node).setIntent(true).toStack();
};
addMethodChaining$1("toVar", Var$1);
addMethodChaining$1("toConst", Const$1);
addMethodChaining$1("toVarIntent", VarIntent$1);
/**
* This node is used to build a sub-build in the node system.
*
* @augments Node
* @param {Node} node - The node to be built in the sub-build.
* @param {string} name - The name of the sub-build.
* @param {?string} [nodeType=null] - The type of the node, if known.
*/
var SubBuildNode = class extends Node {
	static get type() {
		return "SubBuild";
	}
	constructor(node, name, nodeType = null) {
		super(nodeType);
		/**
		* The node to be built in the sub-build.
		*
		* @type {Node}
		*/
		this.node = node;
		/**
		* The name of the sub-build.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSubBuildNode = true;
	}
	getNodeType(builder) {
		if (this.nodeType !== null) return this.nodeType;
		builder.addSubBuild(this.name);
		const nodeType = this.node.getNodeType(builder);
		builder.removeSubBuild();
		return nodeType;
	}
	build(builder, ...params) {
		builder.addSubBuild(this.name);
		const data = this.node.build(builder, ...params);
		builder.removeSubBuild();
		return data;
	}
};
/**
* Creates a new sub-build node.
*
* @tsl
* @function
* @param {Node} node - The node to be built in the sub-build.
* @param {string} name - The name of the sub-build.
* @param {?string} [type=null] - The type of the node, if known.
* @returns {Node} A node object wrapping the SubBuildNode instance.
*/
var subBuild$1 = (node, name, type$1 = null) => nodeObject$1(new SubBuildNode(nodeObject$1(node), name, type$1));
/**
* Class for representing shader varyings as nodes. Varyings are create from
* existing nodes like the following:
*
* ```js
* const positionLocal = positionGeometry.toVarying( 'vPositionLocal' );
* ```
*
* @augments Node
*/
var VaryingNode = class extends Node {
	static get type() {
		return "VaryingNode";
	}
	/**
	* Constructs a new varying node.
	*
	* @param {Node} node - The node for which a varying should be created.
	* @param {?string} name - The name of the varying in the shader.
	*/
	constructor(node, name = null) {
		super();
		/**
		* The node for which a varying should be created.
		*
		* @type {Node}
		*/
		this.node = node;
		/**
		* The name of the varying in the shader. If no name is defined,
		* the node system auto-generates one.
		*
		* @type {?string}
		* @default null
		*/
		this.name = name;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isVaryingNode = true;
		/**
		* The interpolation type of the varying data.
		*
		* @type {?string}
		* @default null
		*/
		this.interpolationType = null;
		/**
		* The interpolation sampling type of varying data.
		*
		* @type {?string}
		* @default null
		*/
		this.interpolationSampling = null;
		/**
		* This flag is used for global cache.
		*
		* @type {boolean}
		* @default true
		*/
		this.global = true;
	}
	/**
	* Defines the interpolation type of the varying.
	*
	* @param {string} type - The interpolation type.
	* @param {?string} sampling - The interpolation sampling type
	* @return {VaryingNode} A reference to this node.
	*/
	setInterpolation(type$1, sampling = null) {
		this.interpolationType = type$1;
		this.interpolationSampling = sampling;
		return this;
	}
	getHash(builder) {
		return this.name || super.getHash(builder);
	}
	getNodeType(builder) {
		return this.node.getNodeType(builder);
	}
	/**
	* This method performs the setup of a varying node with the current node builder.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {NodeVarying} The node varying from the node builder.
	*/
	setupVarying(builder) {
		const properties = builder.getNodeProperties(this);
		let varying$2 = properties.varying;
		if (varying$2 === void 0) {
			const name = this.name;
			const type$1 = this.getNodeType(builder);
			const interpolationType = this.interpolationType;
			const interpolationSampling = this.interpolationSampling;
			properties.varying = varying$2 = builder.getVaryingFromNode(this, name, type$1, interpolationType, interpolationSampling);
			properties.node = subBuild$1(this.node, "VERTEX");
		}
		varying$2.needsInterpolation || (varying$2.needsInterpolation = builder.shaderStage === "fragment");
		return varying$2;
	}
	setup(builder) {
		this.setupVarying(builder);
		builder.flowNodeFromShaderStage(NodeShaderStage$1.VERTEX, this.node);
	}
	analyze(builder) {
		this.setupVarying(builder);
		builder.flowNodeFromShaderStage(NodeShaderStage$1.VERTEX, this.node);
	}
	generate(builder) {
		const propertyKey = builder.getSubBuildProperty("property", builder.currentStack);
		const properties = builder.getNodeProperties(this);
		const varying$2 = this.setupVarying(builder);
		if (properties[propertyKey] === void 0) {
			const type$1 = this.getNodeType(builder);
			const propertyName = builder.getPropertyName(varying$2, NodeShaderStage$1.VERTEX);
			builder.flowNodeFromShaderStage(NodeShaderStage$1.VERTEX, properties.node, type$1, propertyName);
			properties[propertyKey] = propertyName;
		}
		return builder.getPropertyName(varying$2);
	}
};
/**
* TSL function for creating a varying node.
*
* @tsl
* @function
* @param {Node} node - The node for which a varying should be created.
* @param {?string} name - The name of the varying in the shader.
* @returns {VaryingNode}
*/
var varying$1 = /* @__PURE__ */ nodeProxy$1(VaryingNode).setParameterLength(1, 2);
/**
* Computes a node in the vertex stage.
*
* @tsl
* @function
* @param {Node} node - The node which should be executed in the vertex stage.
* @returns {VaryingNode}
*/
var vertexStage$1 = (node) => varying$1(node);
addMethodChaining$1("toVarying", varying$1);
addMethodChaining$1("toVertexStage", vertexStage$1);
addMethodChaining$1("varying", (...params) => {
	warn("TSL: .varying() has been renamed to .toVarying().");
	return varying$1(...params);
});
addMethodChaining$1("vertexStage", (...params) => {
	warn("TSL: .vertexStage() has been renamed to .toVertexStage().");
	return varying$1(...params);
});
/**
* Converts the given color value from sRGB to linear-sRGB color space.
*
* @tsl
* @function
* @param {Node<vec3>} color - The sRGB color.
* @return {Node<vec3>} The linear-sRGB color.
*/
var sRGBTransferEOTF$1 = /* @__PURE__ */ Fn$1(([color$2]) => {
	const a$1 = color$2.mul(.9478672986).add(.0521327014).pow(2.4);
	const b$2 = color$2.mul(.0773993808);
	const factor = color$2.lessThanEqual(.04045);
	return mix$2(a$1, b$2, factor);
}).setLayout({
	name: "sRGBTransferEOTF",
	type: "vec3",
	inputs: [{
		name: "color",
		type: "vec3"
	}]
});
/**
* Converts the given color value from linear-sRGB to sRGB color space.
*
* @tsl
* @function
* @param {Node<vec3>} color - The linear-sRGB color.
* @return {Node<vec3>} The sRGB color.
*/
var sRGBTransferOETF$1 = /* @__PURE__ */ Fn$1(([color$2]) => {
	const a$1 = color$2.pow(.41666).mul(1.055).sub(.055);
	const b$2 = color$2.mul(12.92);
	const factor = color$2.lessThanEqual(.0031308);
	return mix$2(a$1, b$2, factor);
}).setLayout({
	name: "sRGBTransferOETF",
	type: "vec3",
	inputs: [{
		name: "color",
		type: "vec3"
	}]
});
var WORKING_COLOR_SPACE = "WorkingColorSpace";
var OUTPUT_COLOR_SPACE = "OutputColorSpace";
/**
* This node represents a color space conversion. Meaning it converts
* a color value from a source to a target color space.
*
* @augments TempNode
*/
var ColorSpaceNode = class extends TempNode {
	static get type() {
		return "ColorSpaceNode";
	}
	/**
	* Constructs a new color space node.
	*
	* @param {Node} colorNode - Represents the color to convert.
	* @param {string} source - The source color space.
	* @param {string} target - The target color space.
	*/
	constructor(colorNode, source, target) {
		super("vec4");
		/**
		* Represents the color to convert.
		*
		* @type {Node}
		*/
		this.colorNode = colorNode;
		/**
		* The source color space.
		*
		* @type {string}
		*/
		this.source = source;
		/**
		* The target color space.
		*
		* @type {string}
		*/
		this.target = target;
	}
	/**
	* This method resolves the constants `WORKING_COLOR_SPACE` and
	* `OUTPUT_COLOR_SPACE` based on the current configuration of the
	* color management and renderer.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} colorSpace - The color space to resolve.
	* @return {string} The resolved color space.
	*/
	resolveColorSpace(builder, colorSpace) {
		if (colorSpace === WORKING_COLOR_SPACE) return ColorManagement.workingColorSpace;
		else if (colorSpace === OUTPUT_COLOR_SPACE) return builder.context.outputColorSpace || builder.renderer.outputColorSpace;
		return colorSpace;
	}
	setup(builder) {
		const { colorNode } = this;
		const source = this.resolveColorSpace(builder, this.source);
		const target = this.resolveColorSpace(builder, this.target);
		let outputNode = colorNode;
		if (ColorManagement.enabled === false || source === target || !source || !target) return outputNode;
		if (ColorManagement.getTransfer(source) === SRGBTransfer) outputNode = vec4$1(sRGBTransferEOTF$1(outputNode.rgb), outputNode.a);
		if (ColorManagement.getPrimaries(source) !== ColorManagement.getPrimaries(target)) outputNode = vec4$1(mat3$1(ColorManagement._getMatrix(new Matrix3(), source, target)).mul(outputNode.rgb), outputNode.a);
		if (ColorManagement.getTransfer(target) === SRGBTransfer) outputNode = vec4$1(sRGBTransferOETF$1(outputNode.rgb), outputNode.a);
		return outputNode;
	}
};
/**
* TSL function for converting a given color node from the current working color space to the given color space.
*
* @tsl
* @function
* @param {Node} node - Represents the node to convert.
* @param {string} targetColorSpace - The target color space.
* @returns {ColorSpaceNode}
*/
var workingToColorSpace$1 = (node, targetColorSpace) => nodeObject$1(new ColorSpaceNode(nodeObject$1(node), WORKING_COLOR_SPACE, targetColorSpace));
/**
* TSL function for converting a given color node from the given color space to the current working color space.
*
* @tsl
* @function
* @param {Node} node - Represents the node to convert.
* @param {string} sourceColorSpace - The source color space.
* @returns {ColorSpaceNode}
*/
var colorSpaceToWorking$1 = (node, sourceColorSpace) => nodeObject$1(new ColorSpaceNode(nodeObject$1(node), sourceColorSpace, WORKING_COLOR_SPACE));
/**
* TSL function for converting a given color node from one color space to another one.
*
* @tsl
* @function
* @param {Node} node - Represents the node to convert.
* @param {string} sourceColorSpace - The source color space.
* @param {string} targetColorSpace - The target color space.
* @returns {ColorSpaceNode}
*/
var convertColorSpace$1 = (node, sourceColorSpace, targetColorSpace) => nodeObject$1(new ColorSpaceNode(nodeObject$1(node), sourceColorSpace, targetColorSpace));
addMethodChaining$1("workingToColorSpace", workingToColorSpace$1);
addMethodChaining$1("colorSpaceToWorking", colorSpaceToWorking$1);
/**
* This class is only relevant if the referenced property is array-like.
* In this case, `ReferenceElementNode` allows to refer to a specific
* element inside the data structure via an index.
*
* @augments ArrayElementNode
*/
var ReferenceElementNode$1 = class ReferenceElementNode$2 extends ArrayElementNode {
	static get type() {
		return "ReferenceElementNode";
	}
	/**
	* Constructs a new reference element node.
	*
	* @param {ReferenceBaseNode} referenceNode - The reference node.
	* @param {Node} indexNode - The index node that defines the element access.
	*/
	constructor(referenceNode, indexNode) {
		super(referenceNode, indexNode);
		/**
		* Similar to {@link ReferenceBaseNode#reference}, an additional
		* property references to the current node.
		*
		* @type {?ReferenceBaseNode}
		* @default null
		*/
		this.referenceNode = referenceNode;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isReferenceElementNode = true;
	}
	/**
	* This method is overwritten since the node type is inferred from
	* the uniform type of the reference node.
	*
	* @return {string} The node type.
	*/
	getNodeType() {
		return this.referenceNode.uniformType;
	}
	generate(builder) {
		const snippet = super.generate(builder);
		const arrayType = this.referenceNode.getNodeType();
		const elementType = this.getNodeType();
		return builder.format(snippet, arrayType, elementType);
	}
};
/**
* Base class for nodes which establishes a reference to a property of another object.
* In this way, the value of the node is automatically linked to the value of
* referenced object. Reference nodes internally represent the linked value
* as a uniform.
*
* @augments Node
*/
var ReferenceBaseNode = class extends Node {
	static get type() {
		return "ReferenceBaseNode";
	}
	/**
	* Constructs a new reference base node.
	*
	* @param {string} property - The name of the property the node refers to.
	* @param {string} uniformType - The uniform type that should be used to represent the property value.
	* @param {?Object} [object=null] - The object the property belongs to.
	* @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
	*/
	constructor(property$2, uniformType, object = null, count = null) {
		super();
		/**
		* The name of the property the node refers to.
		*
		* @type {string}
		*/
		this.property = property$2;
		/**
		* The uniform type that should be used to represent the property value.
		*
		* @type {string}
		*/
		this.uniformType = uniformType;
		/**
		* The object the property belongs to.
		*
		* @type {?Object}
		* @default null
		*/
		this.object = object;
		/**
		* When the linked property is an array, this parameter defines its length.
		*
		* @type {?number}
		* @default null
		*/
		this.count = count;
		/**
		* The property name might have dots so nested properties can be referred.
		* The hierarchy of the names is stored inside this array.
		*
		* @type {Array<string>}
		*/
		this.properties = property$2.split(".");
		/**
		* Points to the current referred object. This property exists next to {@link ReferenceNode#object}
		* since the final reference might be updated from calling code.
		*
		* @type {?Object}
		* @default null
		*/
		this.reference = object;
		/**
		* The uniform node that holds the value of the reference node.
		*
		* @type {UniformNode}
		* @default null
		*/
		this.node = null;
		/**
		* The uniform group of the internal uniform.
		*
		* @type {UniformGroupNode}
		* @default null
		*/
		this.group = null;
		/**
		* Overwritten since reference nodes are updated per object.
		*
		* @type {string}
		* @default 'object'
		*/
		this.updateType = NodeUpdateType$1.OBJECT;
	}
	/**
	* Sets the uniform group for this reference node.
	*
	* @param {UniformGroupNode} group - The uniform group to set.
	* @return {ReferenceBaseNode} A reference to this node.
	*/
	setGroup(group) {
		this.group = group;
		return this;
	}
	/**
	* When the referred property is array-like, this method can be used
	* to access elements via an index node.
	*
	* @param {IndexNode} indexNode - indexNode.
	* @return {ReferenceElementNode} A reference to an element.
	*/
	element(indexNode) {
		return nodeObject$1(new ReferenceElementNode$1(this, nodeObject$1(indexNode)));
	}
	/**
	* Sets the node type which automatically defines the internal
	* uniform type.
	*
	* @param {string} uniformType - The type to set.
	*/
	setNodeType(uniformType) {
		const node = uniform$1(null, uniformType);
		if (this.group !== null) node.setGroup(this.group);
		this.node = node;
	}
	/**
	* This method is overwritten since the node type is inferred from
	* the type of the reference node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		if (this.node === null) {
			this.updateReference(builder);
			this.updateValue();
		}
		return this.node.getNodeType(builder);
	}
	/**
	* Returns the property value from the given referred object.
	*
	* @param {Object} [object=this.reference] - The object to retrieve the property value from.
	* @return {any} The value.
	*/
	getValueFromReference(object = this.reference) {
		const { properties } = this;
		let value = object[properties[0]];
		for (let i = 1; i < properties.length; i++) value = value[properties[i]];
		return value;
	}
	/**
	* Allows to update the reference based on the given state. The state is only
	* evaluated {@link ReferenceBaseNode#object} is not set.
	*
	* @param {(NodeFrame|NodeBuilder)} state - The current state.
	* @return {Object} The updated reference.
	*/
	updateReference(state) {
		this.reference = this.object !== null ? this.object : state.object;
		return this.reference;
	}
	/**
	* The output of the reference node is the internal uniform node.
	*
	* @return {UniformNode} The output node.
	*/
	setup() {
		this.updateValue();
		return this.node;
	}
	/**
	* Overwritten to update the internal uniform value.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update() {
		this.updateValue();
	}
	/**
	* Retrieves the value from the referred object property and uses it
	* to updated the internal uniform.
	*/
	updateValue() {
		if (this.node === null) this.setNodeType(this.uniformType);
		const value = this.getValueFromReference();
		if (Array.isArray(value)) this.node.array = value;
		else this.node.value = value;
	}
};
/**
* TSL function for creating a reference base node.
*
* @tsl
* @function
* @param {string} name - The name of the property the node refers to.
* @param {string} type - The uniform type that should be used to represent the property value.
* @param {Object} object - The object the property belongs to.
* @returns {ReferenceBaseNode}
*/
var reference$1 = (name, type$1, object) => nodeObject$1(new ReferenceBaseNode(name, type$1, object));
/**
* This node is a special type of reference node which is intended
* for linking renderer properties with node values.
* ```js
* const exposureNode = rendererReference( 'toneMappingExposure', 'float', renderer );
* ```
* When changing `renderer.toneMappingExposure`, the node value of `exposureNode` will
* automatically be updated.
*
* @augments ReferenceBaseNode
*/
var RendererReferenceNode = class extends ReferenceBaseNode {
	static get type() {
		return "RendererReferenceNode";
	}
	/**
	* Constructs a new renderer reference node.
	*
	* @param {string} property - The name of the property the node refers to.
	* @param {string} inputType - The uniform type that should be used to represent the property value.
	* @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,
	* the node refers to the renderer of the current state.
	*/
	constructor(property$2, inputType, renderer = null) {
		super(property$2, inputType, renderer);
		/**
		* The renderer the property belongs to. When no renderer is set,
		* the node refers to the renderer of the current state.
		*
		* @type {?Renderer}
		* @default null
		*/
		this.renderer = renderer;
		this.setGroup(renderGroup$1);
	}
	/**
	* Updates the reference based on the given state. The state is only evaluated
	* {@link RendererReferenceNode#renderer} is not set.
	*
	* @param {(NodeFrame|NodeBuilder)} state - The current state.
	* @return {Object} The updated reference.
	*/
	updateReference(state) {
		this.reference = this.renderer !== null ? this.renderer : state.renderer;
		return this.reference;
	}
};
/**
* TSL function for creating a renderer reference node.
*
* @tsl
* @function
* @param {string} name - The name of the property the node refers to.
* @param {string} type - The uniform type that should be used to represent the property value.
* @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,
* the node refers to the renderer of the current state.
* @returns {RendererReferenceNode}
*/
var rendererReference$1 = (name, type$1, renderer = null) => nodeObject$1(new RendererReferenceNode(name, type$1, renderer));
/**
* This node represents a tone mapping operation.
*
* @augments TempNode
*/
var ToneMappingNode = class extends TempNode {
	static get type() {
		return "ToneMappingNode";
	}
	/**
	* Constructs a new tone mapping node.
	*
	* @param {number} toneMapping - The tone mapping type.
	* @param {Node} exposureNode - The tone mapping exposure.
	* @param {Node} [colorNode=null] - The color node to process.
	*/
	constructor(toneMapping$2, exposureNode = toneMappingExposure$1, colorNode = null) {
		super("vec3");
		/**
		* The tone mapping type.
		*
		* @private
		* @type {number}
		*/
		this._toneMapping = toneMapping$2;
		/**
		* The tone mapping exposure.
		*
		* @type {Node}
		* @default null
		*/
		this.exposureNode = exposureNode;
		/**
		* Represents the color to process.
		*
		* @type {?Node}
		* @default null
		*/
		this.colorNode = colorNode;
	}
	/**
	* Overwrites the default `customCacheKey()` implementation by including the tone
	* mapping type into the cache key.
	*
	* @return {number} The hash.
	*/
	customCacheKey() {
		return hash$1(this._toneMapping);
	}
	/**
	* Sets the tone mapping type.
	*
	* @param {number} value - The tone mapping type.
	* @return {ToneMappingNode} A reference to this node.
	*/
	setToneMapping(value) {
		this._toneMapping = value;
		return this;
	}
	/**
	* Gets the tone mapping type.
	*
	* @returns {number} The tone mapping type.
	*/
	getToneMapping() {
		return this._toneMapping;
	}
	setup(builder) {
		const colorNode = this.colorNode || builder.context.color;
		const toneMapping$2 = this._toneMapping;
		if (toneMapping$2 === NoToneMapping) return colorNode;
		let outputNode = null;
		const toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping$2);
		if (toneMappingFn !== null) outputNode = vec4$1(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);
		else {
			error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping$2);
			outputNode = colorNode;
		}
		return outputNode;
	}
};
/**
* TSL function for creating a tone mapping node.
*
* @tsl
* @function
* @param {number} mapping - The tone mapping type.
* @param {Node<float> | number} exposure - The tone mapping exposure.
* @param {Node<vec3> | Color} color - The color node to process.
* @returns {ToneMappingNode<vec3>}
*/
var toneMapping$1 = (mapping, exposure, color$2) => nodeObject$1(new ToneMappingNode(mapping, nodeObject$1(exposure), nodeObject$1(color$2)));
/**
* TSL object that represents the global tone mapping exposure of the renderer.
*
* @tsl
* @type {RendererReferenceNode<vec3>}
*/
var toneMappingExposure$1 = /* @__PURE__ */ rendererReference$1("toneMappingExposure", "float");
addMethodChaining$1("toneMapping", (color$2, mapping, exposure) => toneMapping$1(mapping, exposure, color$2));
/**
* In earlier `three.js` versions it was only possible to define attribute data
* on geometry level. With `BufferAttributeNode`, it is also possible to do this
* on the node level.
* ```js
* const geometry = new THREE.PlaneGeometry();
* const positionAttribute = geometry.getAttribute( 'position' );
*
* const colors = [];
* for ( let i = 0; i < position.count; i ++ ) {
* 	colors.push( 1, 0, 0 );
* }
*
* material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );
* ```
* This new approach is especially interesting when geometry data are generated via
* compute shaders. The below line converts a storage buffer into an attribute node.
* ```js
* material.positionNode = positionBuffer.toAttribute();
* ```
* @augments InputNode
*/
var BufferAttributeNode = class extends InputNode {
	static get type() {
		return "BufferAttributeNode";
	}
	/**
	* Constructs a new buffer attribute node.
	*
	* @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
	* @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).
	* @param {number} [bufferStride=0] - The buffer stride.
	* @param {number} [bufferOffset=0] - The buffer offset.
	*/
	constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
		super(value, bufferType);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isBufferNode = true;
		/**
		* The buffer type (e.g. `'vec3'`).
		*
		* @type {?string}
		* @default null
		*/
		this.bufferType = bufferType;
		/**
		* The buffer stride.
		*
		* @type {number}
		* @default 0
		*/
		this.bufferStride = bufferStride;
		/**
		* The buffer offset.
		*
		* @type {number}
		* @default 0
		*/
		this.bufferOffset = bufferOffset;
		/**
		* The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,
		* if you are planning to update the attribute data per frame.
		*
		* @type {number}
		* @default StaticDrawUsage
		*/
		this.usage = StaticDrawUsage;
		/**
		* Whether the attribute is instanced or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.instanced = false;
		/**
		* A reference to the buffer attribute.
		*
		* @type {?BufferAttribute}
		* @default null
		*/
		this.attribute = null;
		/**
		* `BufferAttributeNode` sets this property to `true` by default.
		*
		* @type {boolean}
		* @default true
		*/
		this.global = true;
		if (value && value.isBufferAttribute === true) {
			this.attribute = value;
			this.usage = value.usage;
			this.instanced = value.isInstancedBufferAttribute;
		}
	}
	/**
	* This method is overwritten since the attribute data might be shared
	* and thus the hash should be shared as well.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The hash.
	*/
	getHash(builder) {
		if (this.bufferStride === 0 && this.bufferOffset === 0) {
			let bufferData = builder.globalCache.getData(this.value);
			if (bufferData === void 0) {
				bufferData = { node: this };
				builder.globalCache.setData(this.value, bufferData);
			}
			return bufferData.node.uuid;
		}
		return this.uuid;
	}
	/**
	* This method is overwritten since the node type is inferred from
	* the buffer attribute.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		if (this.bufferType === null) this.bufferType = builder.getTypeFromAttribute(this.attribute);
		return this.bufferType;
	}
	/**
	* Depending on which value was passed to the node, `setup()` behaves
	* differently. If no instance of `BufferAttribute` was passed, the method
	* creates an internal attribute and configures it respectively.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setup(builder) {
		if (this.attribute !== null) return;
		const type$1 = this.getNodeType(builder);
		const array$2 = this.value;
		const itemSize = builder.getTypeLength(type$1);
		const stride = this.bufferStride || itemSize;
		const offset = this.bufferOffset;
		const buffer$2 = array$2.isInterleavedBuffer === true ? array$2 : new InterleavedBuffer(array$2, stride);
		const bufferAttribute$2 = new InterleavedBufferAttribute(buffer$2, itemSize, offset);
		buffer$2.setUsage(this.usage);
		this.attribute = bufferAttribute$2;
		this.attribute.isInstancedBufferAttribute = this.instanced;
	}
	/**
	* Generates the code snippet of the buffer attribute node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The generated code snippet.
	*/
	generate(builder) {
		const nodeType = this.getNodeType(builder);
		const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
		const propertyName = builder.getPropertyName(nodeAttribute);
		let output$2 = null;
		if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
			this.name = propertyName;
			output$2 = propertyName;
		} else output$2 = varying$1(this).build(builder, nodeType);
		return output$2;
	}
	/**
	* Overwrites the default implementation to return a fixed value `'bufferAttribute'`.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType() {
		return "bufferAttribute";
	}
	/**
	* Sets the `usage` property to the given value.
	*
	* @param {number} value - The usage to set.
	* @return {BufferAttributeNode} A reference to this node.
	*/
	setUsage(value) {
		this.usage = value;
		if (this.attribute && this.attribute.isBufferAttribute === true) this.attribute.usage = value;
		return this;
	}
	/**
	* Sets the `instanced` property to the given value.
	*
	* @param {boolean} value - The value to set.
	* @return {BufferAttributeNode} A reference to this node.
	*/
	setInstanced(value) {
		this.instanced = value;
		return this;
	}
};
/**
* TSL function for creating a buffer attribute node.
*
* @tsl
* @function
* @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
* @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
* @param {number} [stride=0] - The buffer stride.
* @param {number} [offset=0] - The buffer offset.
* @returns {BufferAttributeNode}
*/
var bufferAttribute$1 = (array$2, type$1 = null, stride = 0, offset = 0) => nodeObject$1(new BufferAttributeNode(array$2, type$1, stride, offset));
/**
* TSL function for creating a buffer attribute node but with dynamic draw usage.
* Use this function if attribute data are updated per frame.
*
* @tsl
* @function
* @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
* @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
* @param {number} [stride=0] - The buffer stride.
* @param {number} [offset=0] - The buffer offset.
* @returns {BufferAttributeNode}
*/
var dynamicBufferAttribute$1 = (array$2, type$1 = null, stride = 0, offset = 0) => bufferAttribute$1(array$2, type$1, stride, offset).setUsage(DynamicDrawUsage);
/**
* TSL function for creating a buffer attribute node but with enabled instancing
*
* @tsl
* @function
* @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
* @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
* @param {number} [stride=0] - The buffer stride.
* @param {number} [offset=0] - The buffer offset.
* @returns {BufferAttributeNode}
*/
var instancedBufferAttribute$1 = (array$2, type$1 = null, stride = 0, offset = 0) => bufferAttribute$1(array$2, type$1, stride, offset).setInstanced(true);
/**
* TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing
*
* @tsl
* @function
* @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
* @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
* @param {number} [stride=0] - The buffer stride.
* @param {number} [offset=0] - The buffer offset.
* @returns {BufferAttributeNode}
*/
var instancedDynamicBufferAttribute$1 = (array$2, type$1 = null, stride = 0, offset = 0) => dynamicBufferAttribute$1(array$2, type$1, stride, offset).setInstanced(true);
addMethodChaining$1("toAttribute", (bufferNode) => bufferAttribute$1(bufferNode.value));
/**
* TODO
*
* @augments Node
*/
var ComputeNode = class extends Node {
	static get type() {
		return "ComputeNode";
	}
	/**
	* Constructs a new compute node.
	*
	* @param {Node} computeNode - TODO
	* @param {Array<number>} workgroupSize - TODO.
	*/
	constructor(computeNode, workgroupSize) {
		super("void");
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isComputeNode = true;
		/**
		* TODO
		*
		* @type {Node}
		*/
		this.computeNode = computeNode;
		/**
		* TODO
		*
		* @type {Array<number>}
		* @default [ 64 ]
		*/
		this.workgroupSize = workgroupSize;
		/**
		* TODO
		*
		* @type {number|Array<number>}
		*/
		this.count = null;
		/**
		* TODO
		*
		* @type {number}
		*/
		this.version = 1;
		/**
		* The name or label of the uniform.
		*
		* @type {string}
		* @default ''
		*/
		this.name = "";
		/**
		* The `updateBeforeType` is set to `NodeUpdateType.OBJECT` since {@link ComputeNode#updateBefore}
		* is executed once per object by default.
		*
		* @type {string}
		* @default 'object'
		*/
		this.updateBeforeType = NodeUpdateType$1.OBJECT;
		/**
		* TODO
		*
		* @type {?Function}
		*/
		this.onInitFunction = null;
	}
	/**
	* TODO
	*
	* @param {number|Array<number>} count - Array with [ x, y, z ] values for dispatch or a single number for the count
	* @return {ComputeNode}
	*/
	setCount(count) {
		this.count = count;
		return this;
	}
	/**
	* TODO
	*
	* @return {number|Array<number>}
	*/
	getCount() {
		return this.count;
	}
	/**
	* Executes the `dispose` event for this node.
	*/
	dispose() {
		this.dispatchEvent({ type: "dispose" });
	}
	/**
	* Sets the {@link ComputeNode#name} property.
	*
	* @param {string} name - The name of the uniform.
	* @return {ComputeNode} A reference to this node.
	*/
	setName(name) {
		this.name = name;
		return this;
	}
	/**
	* Sets the {@link ComputeNode#name} property.
	*
	* @deprecated
	* @param {string} name - The name of the uniform.
	* @return {ComputeNode} A reference to this node.
	*/
	label(name) {
		warn("TSL: \"label()\" has been deprecated. Use \"setName()\" instead.");
		return this.setName(name);
	}
	/**
	* TODO
	*
	* @param {Function} callback - TODO.
	* @return {ComputeNode} A reference to this node.
	*/
	onInit(callback) {
		this.onInitFunction = callback;
		return this;
	}
	/**
	* The method execute the compute for this node.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	updateBefore({ renderer }) {
		renderer.compute(this);
	}
	setup(builder) {
		const result = this.computeNode.build(builder);
		if (result) {
			const properties = builder.getNodeProperties(this);
			properties.outputComputeNode = result.outputNode;
			result.outputNode = null;
		}
		return result;
	}
	generate(builder, output$2) {
		const { shaderStage } = builder;
		if (shaderStage === "compute") {
			const snippet = this.computeNode.build(builder, "void");
			if (snippet !== "") builder.addLineFlowCode(snippet, this);
		} else {
			const outputComputeNode = builder.getNodeProperties(this).outputComputeNode;
			if (outputComputeNode) return outputComputeNode.build(builder, output$2);
		}
	}
};
/**
* TSL function for creating a compute kernel node.
*
* @tsl
* @function
* @param {Node} node - TODO
* @param {Array<number>} [workgroupSize=[64]] - TODO.
* @returns {AtomicFunctionNode}
*/
var computeKernel$1 = (node, workgroupSize = [64]) => {
	if (workgroupSize.length === 0 || workgroupSize.length > 3) error("TSL: compute() workgroupSize must have 1, 2, or 3 elements");
	for (let i = 0; i < workgroupSize.length; i++) {
		const val = workgroupSize[i];
		if (typeof val !== "number" || val <= 0 || !Number.isInteger(val)) error(`TSL: compute() workgroupSize element at index [ ${i} ] must be a positive integer`);
	}
	while (workgroupSize.length < 3) workgroupSize.push(1);
	return nodeObject$1(new ComputeNode(nodeObject$1(node), workgroupSize));
};
/**
* TSL function for creating a compute node.
*
* @tsl
* @function
* @param {Node} node - TODO
* @param {number|Array<number>} count - TODO.
* @param {Array<number>} [workgroupSize=[64]] - TODO.
* @returns {AtomicFunctionNode}
*/
var compute$1 = (node, count, workgroupSize) => computeKernel$1(node, workgroupSize).setCount(count);
addMethodChaining$1("compute", compute$1);
addMethodChaining$1("computeKernel", computeKernel$1);
/**
* This node can be used as a cache management component for another node.
* Caching is in general used by default in {@link NodeBuilder} but this node
* allows the usage of a shared parent cache during the build process.
*
* @augments Node
*/
var IsolateNode = class extends Node {
	static get type() {
		return "IsolateNode";
	}
	/**
	* Constructs a new cache node.
	*
	* @param {Node} node - The node that should be cached.
	* @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
	*/
	constructor(node, parent = true) {
		super();
		/**
		* The node that should be cached.
		*
		* @type {Node}
		*/
		this.node = node;
		/**
		* Whether this node refers to a shared parent cache or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.parent = parent;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isIsolateNode = true;
	}
	getNodeType(builder) {
		const previousCache = builder.getCache();
		const cache$2 = builder.getCacheFromNode(this, this.parent);
		builder.setCache(cache$2);
		const nodeType = this.node.getNodeType(builder);
		builder.setCache(previousCache);
		return nodeType;
	}
	build(builder, ...params) {
		const previousCache = builder.getCache();
		const cache$2 = builder.getCacheFromNode(this, this.parent);
		builder.setCache(cache$2);
		const data = this.node.build(builder, ...params);
		builder.setCache(previousCache);
		return data;
	}
	setParent(parent) {
		this.parent = parent;
		return this;
	}
	getParent() {
		return this.parent;
	}
};
/**
* TSL function for creating a cache node.
*
* @tsl
* @function
* @param {Node} node - The node that should be cached.
* @returns {IsolateNode}
*/
var isolate = (node) => new IsolateNode(nodeObject$1(node));
/**
* TSL function for creating a cache node.
*
* @tsl
* @function
* @deprecated
* @param {Node} node - The node that should be cached.
* @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
* @returns {IsolateNode}
*/
function cache$1(node, parent = true) {
	warn("TSL: \"cache()\" has been deprecated. Use \"isolate()\" instead.");
	return isolate(node).setParent(parent);
}
addMethodChaining$1("cache", cache$1);
addMethodChaining$1("isolate", isolate);
/**
* The class generates the code of a given node but returns another node in the output.
* This can be used to call a method or node that does not return a value, i.e.
* type `void` on an input where returning a value is required. Example:
*
* ```js
* material.colorNode = myColor.bypass( runVoidFn() )
*```
*
* @augments Node
*/
var BypassNode = class extends Node {
	static get type() {
		return "BypassNode";
	}
	/**
	* Constructs a new bypass node.
	*
	* @param {Node} outputNode - The output node.
	* @param {Node} callNode - The call node.
	*/
	constructor(outputNode, callNode) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isBypassNode = true;
		/**
		* The output node.
		*
		* @type {Node}
		*/
		this.outputNode = outputNode;
		/**
		* The call node.
		*
		* @type {Node}
		*/
		this.callNode = callNode;
	}
	getNodeType(builder) {
		return this.outputNode.getNodeType(builder);
	}
	generate(builder) {
		const snippet = this.callNode.build(builder, "void");
		if (snippet !== "") builder.addLineFlowCode(snippet, this);
		return this.outputNode.build(builder);
	}
};
/**
* TSL function for creating a bypass node.
*
* @tsl
* @function
* @param {Node} outputNode - The output node.
* @param {Node} callNode - The call node.
* @returns {BypassNode}
*/
var bypass$1 = /* @__PURE__ */ nodeProxy$1(BypassNode).setParameterLength(2);
addMethodChaining$1("bypass", bypass$1);
/**
* This node allows to remap a node value from one range into another. E.g a value of
* `0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.
* `RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.
*
* @augments Node
*/
var RemapNode = class extends Node {
	static get type() {
		return "RemapNode";
	}
	/**
	* Constructs a new remap node.
	*
	* @param {Node} node - The node that should be remapped.
	* @param {Node} inLowNode - The source or current lower bound of the range.
	* @param {Node} inHighNode - The source or current upper bound of the range.
	* @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
	* @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
	*/
	constructor(node, inLowNode, inHighNode, outLowNode = float$1(0), outHighNode = float$1(1)) {
		super();
		/**
		* The node that should be remapped.
		*
		* @type {Node}
		*/
		this.node = node;
		/**
		* The source or current lower bound of the range.
		*
		* @type {Node}
		*/
		this.inLowNode = inLowNode;
		/**
		* The source or current upper bound of the range.
		*
		* @type {Node}
		*/
		this.inHighNode = inHighNode;
		/**
		* The target lower bound of the range.
		*
		* @type {Node}
		* @default float(0)
		*/
		this.outLowNode = outLowNode;
		/**
		* The target upper bound of the range.
		*
		* @type {Node}
		* @default float(1)
		*/
		this.outHighNode = outHighNode;
		/**
		* Whether the node value should be clamped before
		* remapping it to the target range.
		*
		* @type {boolean}
		* @default true
		*/
		this.doClamp = true;
	}
	setup() {
		const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
		let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
		if (doClamp === true) t = t.clamp();
		return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
	}
};
/**
* TSL function for creating a remap node.
*
* @tsl
* @function
* @param {Node} node - The node that should be remapped.
* @param {Node} inLowNode - The source or current lower bound of the range.
* @param {Node} inHighNode - The source or current upper bound of the range.
* @param {?Node} [outLowNode=float(0)] - The target lower bound of the range.
* @param {?Node} [outHighNode=float(1)] - The target upper bound of the range.
* @returns {RemapNode}
*/
var remap$1 = /* @__PURE__ */ nodeProxy$1(RemapNode, null, null, { doClamp: false }).setParameterLength(3, 5);
/**
* TSL function for creating a remap node, but with enabled clamping.
*
* @tsl
* @function
* @param {Node} node - The node that should be remapped.
* @param {Node} inLowNode - The source or current lower bound of the range.
* @param {Node} inHighNode - The source or current upper bound of the range.
* @param {?Node} [outLowNode=float(0)] - The target lower bound of the range.
* @param {?Node} [outHighNode=float(1)] - The target upper bound of the range.
* @returns {RemapNode}
*/
var remapClamp$1 = /* @__PURE__ */ nodeProxy$1(RemapNode).setParameterLength(3, 5);
addMethodChaining$1("remap", remap$1);
addMethodChaining$1("remapClamp", remapClamp$1);
/**
* This class can be used to implement basic expressions in shader code.
* Basic examples for that are `return`, `continue` or `discard` statements.
*
* @augments Node
*/
var ExpressionNode = class extends Node {
	static get type() {
		return "ExpressionNode";
	}
	/**
	* Constructs a new expression node.
	*
	* @param {string} [snippet=''] - The native code snippet.
	* @param {string} [nodeType='void'] - The node type.
	*/
	constructor(snippet = "", nodeType = "void") {
		super(nodeType);
		/**
		* The native code snippet.
		*
		* @type {string}
		* @default ''
		*/
		this.snippet = snippet;
	}
	generate(builder, output$2) {
		const type$1 = this.getNodeType(builder);
		const snippet = this.snippet;
		if (type$1 === "void") builder.addLineFlowCode(snippet, this);
		else return builder.format(snippet, type$1, output$2);
	}
};
/**
* TSL function for creating an expression node.
*
* @tsl
* @function
* @param {string} [snippet] - The native code snippet.
* @param {?string} [nodeType='void'] - The node type.
* @returns {ExpressionNode}
*/
var expression$1 = /* @__PURE__ */ nodeProxy$1(ExpressionNode).setParameterLength(1, 2);
/**
* Represents a `discard` shader operation in TSL.
*
* @tsl
* @function
* @param {?ConditionalNode} conditional - An optional conditional node. It allows to decide whether the discard should be executed or not.
* @return {Node} The `discard` expression.
*/
var Discard$1 = (conditional) => (conditional ? select$1(conditional, expression$1("discard")) : expression$1("discard")).toStack();
/**
* Represents a `return` shader operation in TSL.
*
* @tsl
* @function
* @return {ExpressionNode} The `return` expression.
*/
var Return$1 = () => expression$1("return").toStack();
addMethodChaining$1("discard", Discard$1);
/**
* Normally, tone mapping and color conversion happens automatically
* before outputting pixel too the default (screen) framebuffer. In certain
* post processing setups this happens to late because certain effects
* require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used
* to apply tone mapping and color space conversion at an arbitrary point
* in the effect chain.
*
* When applying tone mapping and color space conversion manually with this node,
* you have to set {@link PostProcessing#outputColorTransform} to `false`.
*
* ```js
* const postProcessing = new PostProcessing( renderer );
* postProcessing.outputColorTransform = false;
*
* const scenePass = pass( scene, camera );
* const outputPass = renderOutput( scenePass );
*
* postProcessing.outputNode = outputPass;
* ```
*
* @augments TempNode
*/
var RenderOutputNode = class extends TempNode {
	static get type() {
		return "RenderOutputNode";
	}
	/**
	* Constructs a new render output node.
	*
	* @param {Node} colorNode - The color node to process.
	* @param {?number} toneMapping - The tone mapping type.
	* @param {?string} outputColorSpace - The output color space.
	*/
	constructor(colorNode, toneMapping$2, outputColorSpace) {
		super("vec4");
		/**
		* The color node to process.
		*
		* @type {Node}
		*/
		this.colorNode = colorNode;
		/**
		* The tone mapping type.
		*
		* @private
		* @type {?number}
		*/
		this._toneMapping = toneMapping$2;
		/**
		* The output color space.
		*
		* @type {?string}
		*/
		this.outputColorSpace = outputColorSpace;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isRenderOutputNode = true;
	}
	/**
	* Sets the tone mapping type.
	*
	* @param {number} value - The tone mapping type.
	* @return {ToneMappingNode} A reference to this node.
	*/
	setToneMapping(value) {
		this._toneMapping = value;
		return this;
	}
	/**
	* Gets the tone mapping type.
	*
	* @returns {number} The tone mapping type.
	*/
	getToneMapping() {
		return this._toneMapping;
	}
	setup({ context: context$2 }) {
		let outputNode = this.colorNode || context$2.color;
		const toneMapping$2 = (this._toneMapping !== null ? this._toneMapping : context$2.toneMapping) || NoToneMapping;
		const outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context$2.outputColorSpace) || NoColorSpace;
		if (toneMapping$2 !== NoToneMapping) outputNode = outputNode.toneMapping(toneMapping$2);
		if (outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace) outputNode = outputNode.workingToColorSpace(outputColorSpace);
		return outputNode;
	}
};
/**
* TSL function for creating a posterize node.
*
* @tsl
* @function
* @param {Node} color - The color node to process.
* @param {?number} [toneMapping=null] - The tone mapping type.
* @param {?string} [outputColorSpace=null] - The output color space.
* @returns {RenderOutputNode}
*/
var renderOutput$1 = (color$2, toneMapping$2 = null, outputColorSpace = null) => nodeObject$1(new RenderOutputNode(nodeObject$1(color$2), toneMapping$2, outputColorSpace));
addMethodChaining$1("renderOutput", renderOutput$1);
var DebugNode = class extends TempNode {
	static get type() {
		return "DebugNode";
	}
	constructor(node, callback = null) {
		super();
		this.node = node;
		this.callback = callback;
	}
	getNodeType(builder) {
		return this.node.getNodeType(builder);
	}
	setup(builder) {
		return this.node.build(builder);
	}
	analyze(builder) {
		return this.node.build(builder);
	}
	generate(builder) {
		const callback = this.callback;
		const snippet = this.node.build(builder);
		const title = "--- TSL debug - " + builder.shaderStage + " shader ---";
		const border = "-".repeat(title.length);
		let code$2 = "";
		code$2 += "// #" + title + "#\n";
		code$2 += builder.flow.code.replace(/^\t/gm, "") + "\n";
		code$2 += "/* ... */ " + snippet + " /* ... */\n";
		code$2 += "// #" + border + "#\n";
		if (callback !== null) callback(builder, code$2);
		else log(code$2);
		return snippet;
	}
};
/**
* TSL function for creating a debug node.
*
* @tsl
* @function
* @param {Node} node - The node to debug.
* @param {?Function} [callback=null] - Optional callback function to handle the debug output.
* @returns {DebugNode}
*/
var debug$1 = (node, callback = null) => nodeObject$1(new DebugNode(nodeObject$1(node), callback)).toStack();
addMethodChaining$1("debug", debug$1);
/**
* InspectorBase is the base class for all inspectors.
*
* @class InspectorBase
*/
var InspectorBase = class {
	/**
	* Creates a new InspectorBase.
	*/
	constructor() {
		/**
		* The renderer associated with this inspector.
		*
		* @type {WebGLRenderer}
		* @private
		*/
		this._renderer = null;
		/**
		* The current frame being processed.
		*
		* @type {Object}
		*/
		this.currentFrame = null;
	}
	/**
	* Returns the node frame for the current renderer.
	*
	* @return {Object} The node frame.
	*/
	get nodeFrame() {
		return this._renderer._nodes.nodeFrame;
	}
	/**
	* Sets the renderer for this inspector.
	*
	* @param {WebGLRenderer} renderer - The renderer to associate with this inspector.
	* @return {InspectorBase} This inspector instance.
	*/
	setRenderer(renderer) {
		this._renderer = renderer;
		return this;
	}
	/**
	* Returns the renderer associated with this inspector.
	*
	* @return {WebGLRenderer} The associated renderer.
	*/
	getRenderer() {
		return this._renderer;
	}
	/**
	* Initializes the inspector.
	*/
	init() {}
	/**
	* Called when a frame begins.
	*/
	begin() {}
	/**
	* Called when a frame ends.
	*/
	finish() {}
	/**
	* Inspects a node.
	*
	* @param {Node} node - The node to inspect.
	*/
	inspect() {}
	/**
	* When a compute operation is performed.
	*
	* @param {ComputeNode} computeNode - The compute node being executed.
	* @param {number|Array<number>} dispatchSizeOrCount - The dispatch size or count.
	*/
	computeAsync() {}
	/**
	* Called when a compute operation begins.
	*
	* @param {string} uid - A unique identifier for the render context.
	* @param {ComputeNode} computeNode - The compute node being executed.
	*/
	beginCompute() {}
	/**
	* Called when a compute operation ends.
	*
	* @param {string} uid - A unique identifier for the render context.
	* @param {ComputeNode} computeNode - The compute node being executed.
	*/
	finishCompute() {}
	/**
	* Called when a render operation begins.
	*
	* @param {string} uid - A unique identifier for the render context.
	* @param {Scene} scene - The scene being rendered.
	* @param {Camera} camera - The camera being used for rendering.
	* @param {?WebGLRenderTarget} renderTarget - The render target, if any.
	*/
	beginRender() {}
	/**
	* Called when an animation loop ends.
	*
	* @param {string} uid - A unique identifier for the render context.
	*/
	finishRender() {}
	/**
	* Called when a texture copy operation is performed.
	*
	* @param {Texture} srcTexture - The source texture.
	* @param {Texture} dstTexture - The destination texture.
	*/
	copyTextureToTexture() {}
	/**
	* Called when a framebuffer copy operation is performed.
	*
	* @param {Texture} framebufferTexture - The texture associated with the framebuffer.
	*/
	copyFramebufferToTexture() {}
};
/**
* InspectorNode is a wrapper node that allows inspection of node values during rendering.
* It can be used to debug or analyze node outputs in the rendering pipeline.
*
* @augments Node
*/
var InspectorNode = class extends Node {
	/**
	* Returns the type of the node.
	*
	* @returns {string}
	*/
	static get type() {
		return "InspectorNode";
	}
	/**
	* Creates an InspectorNode.
	*
	* @param {Node} node - The node to inspect.
	* @param {string} [name=''] - Optional name for the inspector node.
	* @param {Function|null} [callback=null] - Optional callback to modify the node during setup.
	*/
	constructor(node, name = "", callback = null) {
		super();
		this.node = node;
		this.name = name;
		this.callback = callback;
		this.updateType = NodeUpdateType$1.FRAME;
		this.isInspectorNode = true;
	}
	/**
	* Returns the name of the inspector node.
	*
	* @returns {string}
	*/
	getName() {
		return this.name || this.node.name;
	}
	/**
	* Updates the inspector node, allowing inspection of the wrapped node.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update(frame) {
		frame.renderer.inspector.inspect(this);
	}
	/**
	* Returns the type of the wrapped node.
	*
	* @param {NodeBuilder} builder - The node builder.
	* @returns {string}
	*/
	getNodeType(builder) {
		return this.node.getNodeType(builder);
	}
	/**
	* Sets up the inspector node.
	*
	* @param {NodeBuilder} builder - The node builder.
	* @returns {Node} The setup node.
	*/
	setup(builder) {
		let node = this.node;
		if (builder.context.inspector === true && this.callback !== null) node = this.callback(node);
		if (builder.renderer.backend.isWebGPUBackend !== true && builder.renderer.inspector.constructor !== InspectorBase) warnOnce("TSL: \".toInspector()\" is only available with WebGPU.");
		return node;
	}
};
/**
* Creates an inspector node to wrap around a given node for inspection purposes.
*
* @tsl
* @param {Node} node - The node to inspect.
* @param {string} [name=''] - Optional name for the inspector node.
* @param {Function|null} [callback=null] - Optional callback to modify the node during setup.
* @returns {Node} The inspector node.
*/
function inspector(node, name = "", callback = null) {
	node = nodeObject$1(node);
	return node.before(new InspectorNode(node, name, callback));
}
addMethodChaining$1("toInspector", inspector);
function addNodeElement$1(name) {
	warn("TSL: AddNodeElement has been removed in favor of tree-shaking. Trying add", name);
}
/**
* Base class for representing shader attributes as nodes.
*
* @augments Node
*/
var AttributeNode = class extends Node {
	static get type() {
		return "AttributeNode";
	}
	/**
	* Constructs a new attribute node.
	*
	* @param {string} attributeName - The name of the attribute.
	* @param {?string} nodeType - The node type.
	*/
	constructor(attributeName, nodeType = null) {
		super(nodeType);
		/**
		* `AttributeNode` sets this property to `true` by default.
		*
		* @type {boolean}
		* @default true
		*/
		this.global = true;
		this._attributeName = attributeName;
	}
	getHash(builder) {
		return this.getAttributeName(builder);
	}
	getNodeType(builder) {
		let nodeType = this.nodeType;
		if (nodeType === null) {
			const attributeName = this.getAttributeName(builder);
			if (builder.hasGeometryAttribute(attributeName)) {
				const attribute$2 = builder.geometry.getAttribute(attributeName);
				nodeType = builder.getTypeFromAttribute(attribute$2);
			} else nodeType = "float";
		}
		return nodeType;
	}
	/**
	* Sets the attribute name to the given value. The method can be
	* overwritten in derived classes if the final name must be computed
	* analytically.
	*
	* @param {string} attributeName - The name of the attribute.
	* @return {AttributeNode} A reference to this node.
	*/
	setAttributeName(attributeName) {
		this._attributeName = attributeName;
		return this;
	}
	/**
	* Returns the attribute name of this node. The method can be
	* overwritten in derived classes if the final name must be computed
	* analytically.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The attribute name.
	*/
	getAttributeName() {
		return this._attributeName;
	}
	generate(builder) {
		const attributeName = this.getAttributeName(builder);
		const nodeType = this.getNodeType(builder);
		if (builder.hasGeometryAttribute(attributeName) === true) {
			const attribute$2 = builder.geometry.getAttribute(attributeName);
			const attributeType = builder.getTypeFromAttribute(attribute$2);
			const nodeAttribute = builder.getAttribute(attributeName, attributeType);
			if (builder.shaderStage === "vertex") return builder.format(nodeAttribute.name, attributeType, nodeType);
			else return varying$1(this).build(builder, nodeType);
		} else {
			warn(`AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`);
			return builder.generateConst(nodeType);
		}
	}
	serialize(data) {
		super.serialize(data);
		data.global = this.global;
		data._attributeName = this._attributeName;
	}
	deserialize(data) {
		super.deserialize(data);
		this.global = data.global;
		this._attributeName = data._attributeName;
	}
};
/**
* TSL function for creating an attribute node.
*
* @tsl
* @function
* @param {string} name - The name of the attribute.
* @param {?string} [nodeType=null] - The node type.
* @returns {AttributeNode}
*/
var attribute$1 = (name, nodeType = null) => nodeObject$1(new AttributeNode(name, nodeType));
/**
* TSL function for creating an uv attribute node with the given index.
*
* @tsl
* @function
* @param {number} [index=0] - The uv index.
* @return {AttributeNode<vec2>} The uv attribute node.
*/
var uv$1$1 = (index = 0) => attribute$1("uv" + (index > 0 ? index : ""), "vec2");
/**
* A node that represents the dimensions of a texture. The texture size is
* retrieved in the shader via built-in shader functions like `textureDimensions()`
* or `textureSize()`.
*
* @augments Node
*/
var TextureSizeNode = class extends Node {
	static get type() {
		return "TextureSizeNode";
	}
	/**
	* Constructs a new texture size node.
	*
	* @param {TextureNode} textureNode - A texture node which size should be retrieved.
	* @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.
	*/
	constructor(textureNode, levelNode = null) {
		super("uvec2");
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isTextureSizeNode = true;
		/**
		* A texture node which size should be retrieved.
		*
		* @type {TextureNode}
		*/
		this.textureNode = textureNode;
		/**
		* A level node which defines the requested mip.
		*
		* @type {Node<int>}
		* @default null
		*/
		this.levelNode = levelNode;
	}
	generate(builder, output$2) {
		const textureProperty = this.textureNode.build(builder, "property");
		const level = this.levelNode === null ? "0" : this.levelNode.build(builder, "int");
		return builder.format(`${builder.getMethod("textureDimensions")}( ${textureProperty}, ${level} )`, this.getNodeType(builder), output$2);
	}
};
/**
* TSL function for creating a texture size node.
*
* @tsl
* @function
* @param {TextureNode} textureNode - A texture node which size should be retrieved.
* @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.
* @returns {TextureSizeNode}
*/
var textureSize$1 = /* @__PURE__ */ nodeProxy$1(TextureSizeNode).setParameterLength(1, 2);
/**
* A special type of uniform node that computes the
* maximum mipmap level for a given texture node.
*
* ```js
* const level = maxMipLevel( textureNode );
* ```
*
* @augments UniformNode
*/
var MaxMipLevelNode = class extends UniformNode {
	static get type() {
		return "MaxMipLevelNode";
	}
	/**
	* Constructs a new max mip level node.
	*
	* @param {TextureNode} textureNode - The texture node to compute the max mip level for.
	*/
	constructor(textureNode) {
		super(0);
		/**
		* The texture node to compute the max mip level for.
		*
		* @private
		* @type {TextureNode}
		*/
		this._textureNode = textureNode;
		/**
		* The `updateType` is set to `NodeUpdateType.FRAME` since the node updates
		* the texture once per frame in its {@link MaxMipLevelNode#update} method.
		*
		* @type {string}
		* @default 'frame'
		*/
		this.updateType = NodeUpdateType$1.FRAME;
	}
	/**
	* The texture node to compute the max mip level for.
	*
	* @readonly
	* @type {TextureNode}
	*/
	get textureNode() {
		return this._textureNode;
	}
	/**
	* The texture.
	*
	* @readonly
	* @type {Texture}
	*/
	get texture() {
		return this._textureNode.value;
	}
	update() {
		const texture$2 = this.texture;
		const images = texture$2.images;
		const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture$2.image;
		if (image && image.width !== void 0) {
			const { width, height } = image;
			this.value = Math.log2(Math.max(width, height));
		}
	}
};
/**
* TSL function for creating a max mip level node.
*
* @tsl
* @function
* @param {TextureNode} textureNode - The texture node to compute the max mip level for.
* @returns {MaxMipLevelNode}
*/
var maxMipLevel$1 = /* @__PURE__ */ nodeProxy$1(MaxMipLevelNode).setParameterLength(1);
var EmptyTexture$1 = /* @__PURE__ */ new Texture();
/**
* This type of uniform node represents a 2D texture.
*
* @augments UniformNode
*/
var TextureNode = class extends UniformNode {
	static get type() {
		return "TextureNode";
	}
	/**
	* Constructs a new texture node.
	*
	* @param {Texture} [value=EmptyTexture] - The texture.
	* @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
	* @param {?Node<int>} [levelNode=null] - The level node.
	* @param {?Node<float>} [biasNode=null] - The bias node.
	*/
	constructor(value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null) {
		super(value);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isTextureNode = true;
		/**
		* Represents the texture coordinates.
		*
		* @type {?Node<vec2|vec3>}
		* @default null
		*/
		this.uvNode = uvNode;
		/**
		* Represents the mip level that should be selected.
		*
		* @type {?Node<int>}
		* @default null
		*/
		this.levelNode = levelNode;
		/**
		* Represents the bias to be applied during level-of-detail computation.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.biasNode = biasNode;
		/**
		* Represents a reference value a texture sample is compared to.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.compareNode = null;
		/**
		* When using texture arrays, the depth node defines the layer to select.
		*
		* @type {?Node<int>}
		* @default null
		*/
		this.depthNode = null;
		/**
		* When defined, a texture is sampled using explicit gradients.
		*
		* @type {?Array<Node<vec2>>}
		* @default null
		*/
		this.gradNode = null;
		/**
		* Represents the optional texel offset applied to the unnormalized texture
		* coordinate before sampling the texture.
		*
		* @type {?Node<ivec2|ivec3>}
		* @default null
		*/
		this.offsetNode = null;
		/**
		* Whether texture values should be sampled or fetched.
		*
		* @type {boolean}
		* @default true
		*/
		this.sampler = true;
		/**
		* Whether the uv transformation matrix should be
		* automatically updated or not. Use `setUpdateMatrix()`
		* if you want to change the value of the property.
		*
		* @type {boolean}
		* @default false
		*/
		this.updateMatrix = false;
		/**
		* By default the `update()` method is not executed. Depending on
		* whether a uv transformation matrix and/or flipY is applied, `update()`
		* is executed per object.
		*
		* @type {string}
		* @default 'none'
		*/
		this.updateType = NodeUpdateType$1.NONE;
		/**
		* The reference node.
		*
		* @type {?Node}
		* @default null
		*/
		this.referenceNode = null;
		/**
		* The texture value is stored in a private property.
		*
		* @private
		* @type {Texture}
		*/
		this._value = value;
		/**
		* The uniform node that represents the uv transformation matrix.
		*
		* @private
		* @type {?UniformNode<mat3>}
		* @default null
		*/
		this._matrixUniform = null;
		/**
		* The uniform node that represents the y-flip. Only required for WebGL.
		*
		* @private
		* @type {?UniformNode<bool>}
		* @default null
		*/
		this._flipYUniform = null;
		this.setUpdateMatrix(uvNode === null);
	}
	set value(value) {
		if (this.referenceNode) this.referenceNode.value = value;
		else this._value = value;
	}
	/**
	* The texture value.
	*
	* @type {Texture}
	*/
	get value() {
		return this.referenceNode ? this.referenceNode.value : this._value;
	}
	/**
	* Overwritten since the uniform hash is defined by the texture's UUID.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The uniform hash.
	*/
	getUniformHash() {
		return this.value.uuid;
	}
	/**
	* Overwritten since the node type is inferred from the texture type.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType() {
		if (this.value.isDepthTexture === true) return "float";
		if (this.value.type === UnsignedIntType) return "uvec4";
		else if (this.value.type === IntType) return "ivec4";
		return "vec4";
	}
	/**
	* Overwrites the default implementation to return a fixed value `'texture'`.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType() {
		return "texture";
	}
	/**
	* Returns a default uvs based on the current texture's channel.
	*
	* @return {AttributeNode<vec2>} The default uvs.
	*/
	getDefaultUV() {
		return uv$1$1(this.value.channel);
	}
	/**
	* Overwritten to always return the texture reference of the node.
	*
	* @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
	* @return {Texture} The texture reference.
	*/
	updateReference() {
		return this.value;
	}
	/**
	* Transforms the given uv node with the texture transformation matrix.
	*
	* @param {Node} uvNode - The uv node to transform.
	* @return {Node} The transformed uv node.
	*/
	getTransformedUV(uvNode) {
		if (this._matrixUniform === null) this._matrixUniform = uniform$1(this.value.matrix);
		return this._matrixUniform.mul(vec3$1(uvNode, 1)).xy;
	}
	/**
	* Defines whether the uv transformation matrix should automatically be updated or not.
	*
	* @param {boolean} value - The update toggle.
	* @return {TextureNode} A reference to this node.
	*/
	setUpdateMatrix(value) {
		this.updateMatrix = value;
		return this;
	}
	/**
	* Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
	* to modify the uv node for correct sampling.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node} uvNode - The uv node to setup.
	* @return {Node} The updated uv node.
	*/
	setupUV(builder, uvNode) {
		if (builder.isFlipY()) {
			if (this._flipYUniform === null) this._flipYUniform = uniform$1(false);
			uvNode = uvNode.toVar();
			if (this.sampler) uvNode = this._flipYUniform.select(uvNode.flipY(), uvNode);
			else uvNode = this._flipYUniform.select(uvNode.setY(int$1(textureSize$1(this, this.levelNode).y).sub(uvNode.y).sub(1)), uvNode);
		}
		return uvNode;
	}
	/**
	* Setups texture node by preparing the internal nodes for code generation.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setup(builder) {
		const properties = builder.getNodeProperties(this);
		properties.referenceNode = this.referenceNode;
		const texture$2 = this.value;
		if (!texture$2 || texture$2.isTexture !== true) throw new Error("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().");
		const uvNode = Fn$1(() => {
			let uvNode$1 = this.uvNode;
			if ((uvNode$1 === null || builder.context.forceUVContext === true) && builder.context.getUV) uvNode$1 = builder.context.getUV(this, builder);
			if (!uvNode$1) uvNode$1 = this.getDefaultUV();
			if (this.updateMatrix === true) uvNode$1 = this.getTransformedUV(uvNode$1);
			uvNode$1 = this.setupUV(builder, uvNode$1);
			this.updateType = this._matrixUniform !== null || this._flipYUniform !== null ? NodeUpdateType$1.OBJECT : NodeUpdateType$1.NONE;
			return uvNode$1;
		})();
		let levelNode = this.levelNode;
		if (levelNode === null && builder.context.getTextureLevel) levelNode = builder.context.getTextureLevel(this);
		properties.uvNode = uvNode;
		properties.levelNode = levelNode;
		properties.biasNode = this.biasNode;
		properties.compareNode = this.compareNode;
		properties.gradNode = this.gradNode;
		properties.depthNode = this.depthNode;
		properties.offsetNode = this.offsetNode;
	}
	/**
	* Generates the uv code snippet.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node} uvNode - The uv node to generate code for.
	* @return {string} The generated code snippet.
	*/
	generateUV(builder, uvNode) {
		return uvNode.build(builder, this.sampler === true ? "vec2" : "ivec2");
	}
	/**
	* Generates the offset code snippet.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node} offsetNode - The offset node to generate code for.
	* @return {string} The generated code snippet.
	*/
	generateOffset(builder, offsetNode) {
		return offsetNode.build(builder, "ivec2");
	}
	/**
	* Generates the snippet for the texture sampling.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} textureProperty - The texture property.
	* @param {string} uvSnippet - The uv snippet.
	* @param {?string} levelSnippet - The level snippet.
	* @param {?string} biasSnippet - The bias snippet.
	* @param {?string} depthSnippet - The depth snippet.
	* @param {?string} compareSnippet - The compare snippet.
	* @param {?Array<string>} gradSnippet - The grad snippet.
	* @param {?string} offsetSnippet - The offset snippet.
	* @return {string} The generated code snippet.
	*/
	generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet, offsetSnippet) {
		const texture$2 = this.value;
		let snippet;
		if (biasSnippet) snippet = builder.generateTextureBias(texture$2, textureProperty, uvSnippet, biasSnippet, depthSnippet, offsetSnippet);
		else if (gradSnippet) snippet = builder.generateTextureGrad(texture$2, textureProperty, uvSnippet, gradSnippet, depthSnippet, offsetSnippet);
		else if (compareSnippet) snippet = builder.generateTextureCompare(texture$2, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet);
		else if (this.sampler === false) snippet = builder.generateTextureLoad(texture$2, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet);
		else if (levelSnippet) snippet = builder.generateTextureLevel(texture$2, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet);
		else snippet = builder.generateTexture(texture$2, textureProperty, uvSnippet, depthSnippet, offsetSnippet);
		return snippet;
	}
	/**
	* Generates the code snippet of the texture node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} output - The current output.
	* @return {string} The generated code snippet.
	*/
	generate(builder, output$2) {
		const texture$2 = this.value;
		const properties = builder.getNodeProperties(this);
		const textureProperty = super.generate(builder, "property");
		if (/^sampler/.test(output$2)) return textureProperty + "_sampler";
		else if (builder.isReference(output$2)) return textureProperty;
		else {
			const nodeData = builder.getDataFromNode(this);
			let propertyName = nodeData.propertyName;
			if (propertyName === void 0) {
				const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode, offsetNode } = properties;
				const uvSnippet = this.generateUV(builder, uvNode);
				const levelSnippet = levelNode ? levelNode.build(builder, "float") : null;
				const biasSnippet = biasNode ? biasNode.build(builder, "float") : null;
				const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
				const compareSnippet = compareNode ? compareNode.build(builder, "float") : null;
				const gradSnippet = gradNode ? [gradNode[0].build(builder, "vec2"), gradNode[1].build(builder, "vec2")] : null;
				const offsetSnippet = offsetNode ? this.generateOffset(builder, offsetNode) : null;
				const nodeVar = builder.getVarFromNode(this);
				propertyName = builder.getPropertyName(nodeVar);
				const snippet$1 = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet, offsetSnippet);
				builder.addLineFlowCode(`${propertyName} = ${snippet$1}`, this);
				nodeData.snippet = snippet$1;
				nodeData.propertyName = propertyName;
			}
			let snippet = propertyName;
			const nodeType = this.getNodeType(builder);
			if (builder.needsToWorkingColorSpace(texture$2)) snippet = colorSpaceToWorking$1(expression$1(snippet, nodeType), texture$2.colorSpace).setup(builder).build(builder, nodeType);
			return builder.format(snippet, nodeType, output$2);
		}
	}
	/**
	* Sets the sampler value.
	*
	* @param {boolean} value - The sampler value to set.
	* @return {TextureNode} A reference to this texture node.
	*/
	setSampler(value) {
		this.sampler = value;
		return this;
	}
	/**
	* Returns the sampler value.
	*
	* @return {boolean} The sampler value.
	*/
	getSampler() {
		return this.sampler;
	}
	/**
	* @function
	* @deprecated since r172. Use {@link TextureNode#sample} instead.
	*
	* @param {Node} uvNode - The uv node.
	* @return {TextureNode} A texture node representing the texture sample.
	*/
	uv(uvNode) {
		warn("TextureNode: .uv() has been renamed. Use .sample() instead.");
		return this.sample(uvNode);
	}
	/**
	* Samples the texture with the given uv node.
	*
	* @param {Node} uvNode - The uv node.
	* @return {TextureNode} A texture node representing the texture sample.
	*/
	sample(uvNode) {
		const textureNode = this.clone();
		textureNode.uvNode = nodeObject$1(uvNode);
		textureNode.referenceNode = this.getBase();
		return nodeObject$1(textureNode);
	}
	/**
	* TSL function for creating a texture node that fetches/loads texels without interpolation.
	*
	* @param {Node<uvec2>} uvNode - The uv node.
	* @returns {TextureNode} A texture node representing the texture load.
	*/
	load(uvNode) {
		return this.sample(uvNode).setSampler(false);
	}
	/**
	* Samples a blurred version of the texture by defining an internal bias.
	*
	* @param {Node<float>} amountNode - How blurred the texture should be.
	* @return {TextureNode} A texture node representing the texture sample.
	*/
	blur(amountNode) {
		const textureNode = this.clone();
		textureNode.biasNode = nodeObject$1(amountNode).mul(maxMipLevel$1(textureNode));
		textureNode.referenceNode = this.getBase();
		const map = textureNode.value;
		if (textureNode.generateMipmaps === false && (map && map.generateMipmaps === false || map.minFilter === NearestFilter || map.magFilter === NearestFilter)) {
			warn("TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture.");
			textureNode.biasNode = null;
		}
		return nodeObject$1(textureNode);
	}
	/**
	* Samples a specific mip of the texture.
	*
	* @param {Node<int>} levelNode - The mip level to sample.
	* @return {TextureNode} A texture node representing the texture sample.
	*/
	level(levelNode) {
		const textureNode = this.clone();
		textureNode.levelNode = nodeObject$1(levelNode);
		textureNode.referenceNode = this.getBase();
		return nodeObject$1(textureNode);
	}
	/**
	* Returns the texture size of the requested level.
	*
	* @param {Node<int>} levelNode - The level to compute the size for.
	* @return {TextureSizeNode} The texture size.
	*/
	size(levelNode) {
		return textureSize$1(this, levelNode);
	}
	/**
	* Samples the texture with the given bias.
	*
	* @param {Node<float>} biasNode - The bias node.
	* @return {TextureNode} A texture node representing the texture sample.
	*/
	bias(biasNode) {
		const textureNode = this.clone();
		textureNode.biasNode = nodeObject$1(biasNode);
		textureNode.referenceNode = this.getBase();
		return nodeObject$1(textureNode);
	}
	/**
	* Returns the base texture of this node.
	* @return {TextureNode} The base texture node.
	*/
	getBase() {
		return this.referenceNode ? this.referenceNode.getBase() : this;
	}
	/**
	* Samples the texture by executing a compare operation.
	*
	* @param {Node<float>} compareNode - The node that defines the compare value.
	* @return {TextureNode} A texture node representing the texture sample.
	*/
	compare(compareNode) {
		const textureNode = this.clone();
		textureNode.compareNode = nodeObject$1(compareNode);
		textureNode.referenceNode = this.getBase();
		return nodeObject$1(textureNode);
	}
	/**
	* Samples the texture using an explicit gradient.
	*
	* @param {Node<vec2>} gradNodeX - The gradX node.
	* @param {Node<vec2>} gradNodeY - The gradY node.
	* @return {TextureNode} A texture node representing the texture sample.
	*/
	grad(gradNodeX, gradNodeY) {
		const textureNode = this.clone();
		textureNode.gradNode = [nodeObject$1(gradNodeX), nodeObject$1(gradNodeY)];
		textureNode.referenceNode = this.getBase();
		return nodeObject$1(textureNode);
	}
	/**
	* Samples the texture by defining a depth node.
	*
	* @param {Node<int>} depthNode - The depth node.
	* @return {TextureNode} A texture node representing the texture sample.
	*/
	depth(depthNode) {
		const textureNode = this.clone();
		textureNode.depthNode = nodeObject$1(depthNode);
		textureNode.referenceNode = this.getBase();
		return nodeObject$1(textureNode);
	}
	/**
	* Samples the texture by defining an offset node.
	*
	* @param {Node<ivec2>} offsetNode - The offset node.
	* @return {TextureNode} A texture node representing the texture sample.
	*/
	offset(offsetNode) {
		const textureNode = this.clone();
		textureNode.offsetNode = nodeObject$1(offsetNode);
		textureNode.referenceNode = this.getBase();
		return nodeObject$1(textureNode);
	}
	serialize(data) {
		super.serialize(data);
		data.value = this.value.toJSON(data.meta).uuid;
		data.sampler = this.sampler;
		data.updateMatrix = this.updateMatrix;
		data.updateType = this.updateType;
	}
	deserialize(data) {
		super.deserialize(data);
		this.value = data.meta.textures[data.value];
		this.sampler = data.sampler;
		this.updateMatrix = data.updateMatrix;
		this.updateType = data.updateType;
	}
	/**
	* The update is used to implement the update of the uv transformation matrix.
	*/
	update() {
		const texture$2 = this.value;
		const matrixUniform = this._matrixUniform;
		if (matrixUniform !== null) matrixUniform.value = texture$2.matrix;
		if (texture$2.matrixAutoUpdate === true) texture$2.updateMatrix();
		const flipYUniform = this._flipYUniform;
		if (flipYUniform !== null) flipYUniform.value = texture$2.image instanceof ImageBitmap && texture$2.flipY === true || texture$2.isRenderTargetTexture === true || texture$2.isFramebufferTexture === true || texture$2.isDepthTexture === true;
	}
	/**
	* Clones the texture node.
	*
	* @return {TextureNode} The cloned texture node.
	*/
	clone() {
		const newNode = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
		newNode.sampler = this.sampler;
		newNode.depthNode = this.depthNode;
		newNode.compareNode = this.compareNode;
		newNode.gradNode = this.gradNode;
		newNode.offsetNode = this.offsetNode;
		return newNode;
	}
};
/**
* TSL function for creating a texture node.
*
* @tsl
* @function
* @param {?Texture} value - The texture.
* @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
* @param {?Node<int>} [levelNode=null] - The level node.
* @param {?Node<float>} [biasNode=null] - The bias node.
* @returns {TextureNode}
*/
var textureBase = /* @__PURE__ */ nodeProxy$1(TextureNode).setParameterLength(1, 4).setName("texture");
/**
* TSL function for creating a texture node or sample a texture node already existing.
*
* @tsl
* @function
* @param {?(Texture|TextureNode)} [value=EmptyTexture] - The texture.
* @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
* @param {?Node<int>} [levelNode=null] - The level node.
* @param {?Node<float>} [biasNode=null] - The bias node.
* @returns {TextureNode}
*/
var texture$1 = (value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null) => {
	let textureNode;
	if (value && value.isTextureNode === true) {
		textureNode = nodeObject$1(value.clone());
		textureNode.referenceNode = value.getBase();
		if (uvNode !== null) textureNode.uvNode = nodeObject$1(uvNode);
		if (levelNode !== null) textureNode.levelNode = nodeObject$1(levelNode);
		if (biasNode !== null) textureNode.biasNode = nodeObject$1(biasNode);
	} else textureNode = textureBase(value, uvNode, levelNode, biasNode);
	return textureNode;
};
/**
* TSL function for creating a uniform texture node.
*
* @tsl
* @function
* @param {?Texture} value - The texture.
* @returns {TextureNode}
*/
var uniformTexture$1 = (value = EmptyTexture$1) => texture$1(value);
/**
* TSL function for creating a texture node that fetches/loads texels without interpolation.
*
* @tsl
* @function
* @param {?(Texture|TextureNode)} [value=EmptyTexture] - The texture.
* @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
* @param {?Node<int>} [levelNode=null] - The level node.
* @param {?Node<float>} [biasNode=null] - The bias node.
* @returns {TextureNode}
*/
var textureLoad$1 = (...params) => texture$1(...params).setSampler(false);
var textureLevel$1 = (value, uv$3, level) => texture$1(value, uv$3).level(level);
/**
* Converts a texture or texture node to a sampler.
*
* @tsl
* @function
* @param {TextureNode|Texture} value - The texture or texture node to convert.
* @returns {Node}
*/
var sampler$1 = (value) => (value.isNode === true ? value : texture$1(value)).convert("sampler");
/**
* Converts a texture or texture node to a sampler comparison.
*
* @tsl
* @function
* @param {TextureNode|Texture} value - The texture or texture node to convert.
* @returns {Node}
*/
var samplerComparison$1 = (value) => (value.isNode === true ? value : texture$1(value)).convert("samplerComparison");
/**
* A special type of uniform node which represents array-like data
* as uniform buffers. The access usually happens via `element()`
* which returns an instance of {@link ArrayElementNode}. For example:
*
* ```js
* const bufferNode = buffer( array, 'mat4', count );
* const matrixNode = bufferNode.element( index ); // access a matrix from the buffer
* ```
* In general, it is recommended to use the more managed {@link UniformArrayNode}
* since it handles more input types and automatically cares about buffer paddings.
*
* @augments UniformNode
*/
var BufferNode = class extends UniformNode {
	static get type() {
		return "BufferNode";
	}
	/**
	* Constructs a new buffer node.
	*
	* @param {Array<number>} value - Array-like buffer data.
	* @param {string} bufferType - The data type of the buffer.
	* @param {number} [bufferCount=0] - The count of buffer elements.
	*/
	constructor(value, bufferType, bufferCount = 0) {
		super(value, bufferType);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isBufferNode = true;
		/**
		* The data type of the buffer.
		*
		* @type {string}
		*/
		this.bufferType = bufferType;
		/**
		* The uniform node that holds the value of the reference node.
		*
		* @type {number}
		* @default 0
		*/
		this.bufferCount = bufferCount;
	}
	/**
	* The data type of the buffer elements.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The element type.
	*/
	getElementType(builder) {
		return this.getNodeType(builder);
	}
	/**
	* Overwrites the default implementation to return a fixed value `'buffer'`.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType() {
		return "buffer";
	}
};
/**
* TSL function for creating a buffer node.
*
* @tsl
* @function
* @param {Array<number>} value - Array-like buffer data.
* @param {string} type - The data type of a buffer element.
* @param {number} count - The count of buffer elements.
* @returns {BufferNode}
*/
var buffer$1 = (value, type$1, count) => nodeObject$1(new BufferNode(value, type$1, count));
/**
* Represents the element access on uniform array nodes.
*
* @augments ArrayElementNode
*/
var UniformArrayElementNode = class extends ArrayElementNode {
	static get type() {
		return "UniformArrayElementNode";
	}
	/**
	* Constructs a new buffer node.
	*
	* @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.
	* @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.
	*/
	constructor(uniformArrayNode, indexNode) {
		super(uniformArrayNode, indexNode);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isArrayBufferElementNode = true;
	}
	generate(builder) {
		const snippet = super.generate(builder);
		const type$1 = this.getNodeType();
		const paddedType = this.node.getPaddedType();
		return builder.format(snippet, paddedType, type$1);
	}
};
/**
* Similar to {@link BufferNode} this module represents array-like data as
* uniform buffers. Unlike {@link BufferNode}, it can handle more common
* data types in the array (e.g `three.js` primitives) and automatically
* manage buffer padding. It should be the first choice when working with
* uniforms buffers.
* ```js
* const tintColors = uniformArray( [
* 	new Color( 1, 0, 0 ),
* 	new Color( 0, 1, 0 ),
* 	new Color( 0, 0, 1 )
* ], 'color' );
*
* const redColor = tintColors.element( 0 );
*
* @augments BufferNode
*/
var UniformArrayNode = class extends BufferNode {
	static get type() {
		return "UniformArrayNode";
	}
	/**
	* Constructs a new uniform array node.
	*
	* @param {Array<any>} value - Array holding the buffer data.
	* @param {?string} [elementType=null] - The data type of a buffer element.
	*/
	constructor(value, elementType = null) {
		super(null);
		/**
		* Array holding the buffer data. Unlike {@link BufferNode}, the array can
		* hold number primitives as well as three.js objects like vectors, matrices
		* or colors.
		*
		* @type {Array<any>}
		*/
		this.array = value;
		/**
		* The data type of an array element.
		*
		* @type {string}
		*/
		this.elementType = elementType === null ? getValueType(value[0]) : elementType;
		/**
		* The padded type. Uniform buffers must conform to a certain buffer layout
		* so a separate type is computed to ensure correct buffer size.
		*
		* @type {string}
		*/
		this.paddedType = this.getPaddedType();
		/**
		* Overwritten since uniform array nodes are updated per render.
		*
		* @type {string}
		* @default 'render'
		*/
		this.updateType = NodeUpdateType$1.RENDER;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isArrayBufferNode = true;
	}
	/**
	* This method is overwritten since the node type is inferred from the
	* {@link UniformArrayNode#paddedType}.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType() {
		return this.paddedType;
	}
	/**
	* The data type of the array elements.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The element type.
	*/
	getElementType() {
		return this.elementType;
	}
	/**
	* Returns the padded type based on the element type.
	*
	* @return {string} The padded type.
	*/
	getPaddedType() {
		const elementType = this.elementType;
		let paddedType = "vec4";
		if (elementType === "mat2") paddedType = "mat2";
		else if (/mat/.test(elementType) === true) paddedType = "mat4";
		else if (elementType.charAt(0) === "i") paddedType = "ivec4";
		else if (elementType.charAt(0) === "u") paddedType = "uvec4";
		return paddedType;
	}
	/**
	* The update makes sure to correctly transfer the data from the (complex) objects
	* in the array to the internal, correctly padded value buffer.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update() {
		const { array: array$2, value } = this;
		const elementType = this.elementType;
		if (elementType === "float" || elementType === "int" || elementType === "uint") for (let i = 0; i < array$2.length; i++) {
			const index = i * 4;
			value[index] = array$2[i];
		}
		else if (elementType === "color") for (let i = 0; i < array$2.length; i++) {
			const index = i * 4;
			const vector = array$2[i];
			value[index] = vector.r;
			value[index + 1] = vector.g;
			value[index + 2] = vector.b || 0;
		}
		else if (elementType === "mat2") for (let i = 0; i < array$2.length; i++) {
			const index = i * 4;
			const matrix = array$2[i];
			value[index] = matrix.elements[0];
			value[index + 1] = matrix.elements[1];
			value[index + 2] = matrix.elements[2];
			value[index + 3] = matrix.elements[3];
		}
		else if (elementType === "mat3") for (let i = 0; i < array$2.length; i++) {
			const index = i * 16;
			const matrix = array$2[i];
			value[index] = matrix.elements[0];
			value[index + 1] = matrix.elements[1];
			value[index + 2] = matrix.elements[2];
			value[index + 4] = matrix.elements[3];
			value[index + 5] = matrix.elements[4];
			value[index + 6] = matrix.elements[5];
			value[index + 8] = matrix.elements[6];
			value[index + 9] = matrix.elements[7];
			value[index + 10] = matrix.elements[8];
			value[index + 15] = 1;
		}
		else if (elementType === "mat4") for (let i = 0; i < array$2.length; i++) {
			const index = i * 16;
			const matrix = array$2[i];
			for (let i$1 = 0; i$1 < matrix.elements.length; i$1++) value[index + i$1] = matrix.elements[i$1];
		}
		else for (let i = 0; i < array$2.length; i++) {
			const index = i * 4;
			const vector = array$2[i];
			value[index] = vector.x;
			value[index + 1] = vector.y;
			value[index + 2] = vector.z || 0;
			value[index + 3] = vector.w || 0;
		}
	}
	/**
	* Implement the value buffer creation based on the array data.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @return {null}
	*/
	setup(builder) {
		const length$2 = this.array.length;
		const elementType = this.elementType;
		let arrayType = Float32Array;
		const paddedType = this.paddedType;
		const paddedElementLength = builder.getTypeLength(paddedType);
		if (elementType.charAt(0) === "i") arrayType = Int32Array;
		if (elementType.charAt(0) === "u") arrayType = Uint32Array;
		this.value = new arrayType(length$2 * paddedElementLength);
		this.bufferCount = length$2;
		this.bufferType = paddedType;
		return super.setup(builder);
	}
	/**
	* Overwrites the default `element()` method to provide element access
	* based on {@link UniformArrayNode}.
	*
	* @param {IndexNode} indexNode - The index node.
	* @return {UniformArrayElementNode}
	*/
	element(indexNode) {
		return nodeObject$1(new UniformArrayElementNode(this, nodeObject$1(indexNode)));
	}
};
/**
* TSL function for creating an uniform array node.
*
* @tsl
* @function
* @param {Array<any>} values - Array-like data.
* @param {?string} [nodeType] - The data type of the array elements.
* @returns {UniformArrayNode}
*/
var uniformArray$1 = (values, nodeType) => nodeObject$1(new UniformArrayNode(values, nodeType));
/**
* The node allows to set values for built-in shader variables. That is
* required for features like hardware-accelerated vertex clipping.
*
* @augments Node
*/
var BuiltinNode = class extends Node {
	/**
	* Constructs a new builtin node.
	*
	* @param {string} name - The name of the built-in shader variable.
	*/
	constructor(name) {
		super("float");
		/**
		* The name of the built-in shader variable.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isBuiltinNode = true;
	}
	/**
	* Generates the code snippet of the builtin node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The generated code snippet.
	*/
	generate() {
		return this.name;
	}
};
/**
* TSL function for creating a builtin node.
*
* @tsl
* @function
* @param {string} name - The name of the built-in shader variable.
* @returns {BuiltinNode}
*/
var builtin$1 = nodeProxy$1(BuiltinNode).setParameterLength(1);
var _screenSizeVec, _viewportVec;
/**
* This node provides a collection of screen related metrics.
* Depending on {@link ScreenNode#scope}, the nodes can represent
* resolution or viewport data as well as fragment or uv coordinates.
*
* @augments Node
*/
var ScreenNode = class ScreenNode extends Node {
	static get type() {
		return "ScreenNode";
	}
	/**
	* Constructs a new screen node.
	*
	* @param {('coordinate'|'viewport'|'size'|'uv'|'dpr')} scope - The node's scope.
	*/
	constructor(scope) {
		super();
		/**
		* The node represents different metric depending on which scope is selected.
		*
		* - `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.
		* - `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.
		* - `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.
		* - `ScreenNode.UV`: Normalized coordinates.
		* - `ScreenNode.DPR`: Device pixel ratio.
		*
		* @type {('coordinate'|'viewport'|'size'|'uv'|'dpr')}
		*/
		this.scope = scope;
		/**
		* This output node.
		*
		* @type {?Node}
		* @default null
		*/
		this._output = null;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isViewportNode = true;
	}
	/**
	* This method is overwritten since the node type depends on the selected scope.
	*
	* @return {('float'|'vec2'|'vec4')} The node type.
	*/
	getNodeType() {
		if (this.scope === ScreenNode.DPR) return "float";
		if (this.scope === ScreenNode.VIEWPORT) return "vec4";
		else return "vec2";
	}
	/**
	* This method is overwritten since the node's update type depends on the selected scope.
	*
	* @return {NodeUpdateType} The update type.
	*/
	getUpdateType() {
		let updateType = NodeUpdateType$1.NONE;
		if (this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT || this.scope === ScreenNode.DPR) updateType = NodeUpdateType$1.RENDER;
		this.updateType = updateType;
		return updateType;
	}
	/**
	* `ScreenNode` implements {@link Node#update} to retrieve viewport and size information
	* from the current renderer.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update({ renderer }) {
		const renderTarget = renderer.getRenderTarget();
		if (this.scope === ScreenNode.VIEWPORT) if (renderTarget !== null) _viewportVec.copy(renderTarget.viewport);
		else {
			renderer.getViewport(_viewportVec);
			_viewportVec.multiplyScalar(renderer.getPixelRatio());
		}
		else if (this.scope === ScreenNode.DPR) this._output.value = renderer.getPixelRatio();
		else if (renderTarget !== null) {
			_screenSizeVec.width = renderTarget.width;
			_screenSizeVec.height = renderTarget.height;
		} else renderer.getDrawingBufferSize(_screenSizeVec);
	}
	setup() {
		const scope = this.scope;
		let output$2 = null;
		if (scope === ScreenNode.SIZE) output$2 = uniform$1(_screenSizeVec || (_screenSizeVec = new Vector2()));
		else if (scope === ScreenNode.VIEWPORT) output$2 = uniform$1(_viewportVec || (_viewportVec = new Vector4()));
		else if (scope === ScreenNode.DPR) output$2 = uniform$1(1);
		else output$2 = vec2$1(screenCoordinate$1.div(screenSize$1));
		this._output = output$2;
		return output$2;
	}
	generate(builder) {
		if (this.scope === ScreenNode.COORDINATE) {
			let coord = builder.getFragCoord();
			if (builder.isFlipY()) {
				const size = builder.getNodeProperties(screenSize$1).outputNode.build(builder);
				coord = `${builder.getType("vec2")}( ${coord}.x, ${size}.y - ${coord}.y )`;
			}
			return coord;
		}
		return super.generate(builder);
	}
};
ScreenNode.COORDINATE = "coordinate";
ScreenNode.VIEWPORT = "viewport";
ScreenNode.SIZE = "size";
ScreenNode.UV = "uv";
ScreenNode.DPR = "dpr";
/**
* TSL object that represents the current DPR.
*
* @tsl
* @type {ScreenNode<float>}
*/
var screenDPR$1 = /* @__PURE__ */ nodeImmutable$1(ScreenNode, ScreenNode.DPR);
/**
* TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.
*
* @tsl
* @type {ScreenNode<vec2>}
*/
var screenUV$1 = /* @__PURE__ */ nodeImmutable$1(ScreenNode, ScreenNode.UV);
/**
* TSL object that represents the screen resolution in physical pixel units.
*
* @tsl
* @type {ScreenNode<vec2>}
*/
var screenSize$1 = /* @__PURE__ */ nodeImmutable$1(ScreenNode, ScreenNode.SIZE);
/**
* TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.
*
* @tsl
* @type {ScreenNode<vec2>}
*/
var screenCoordinate$1 = /* @__PURE__ */ nodeImmutable$1(ScreenNode, ScreenNode.COORDINATE);
/**
* TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.
*
* @tsl
* @type {ScreenNode<vec4>}
*/
var viewport$1 = /* @__PURE__ */ nodeImmutable$1(ScreenNode, ScreenNode.VIEWPORT);
/**
* TSL object that represents the viewport resolution in physical pixel units.
*
* @tsl
* @type {ScreenNode<vec2>}
*/
var viewportSize$1 = viewport$1.zw;
/**
* TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.
*
* @tsl
* @type {ScreenNode<vec2>}
*/
var viewportCoordinate$1 = /* @__PURE__ */ screenCoordinate$1.sub(viewport$1.xy);
/**
* TSL object that represents normalized viewport coordinates, unitless in `[0, 1]`.
*
* @tsl
* @type {ScreenNode<vec2>}
*/
var viewportUV$1 = /* @__PURE__ */ viewportCoordinate$1.div(viewportSize$1);
/**
* @deprecated since r169. Use {@link screenSize} instead.
*/
var viewportResolution$1 = /* @__PURE__ */ Fn$1(() => {
	warn("TSL: \"viewportResolution\" is deprecated. Use \"screenSize\" instead.");
	return screenSize$1;
}, "vec2").once()();
/**
* TSL object that represents the current `index` value of the camera if used ArrayCamera.
*
* @tsl
* @type {UniformNode<uint>}
*/
var cameraIndex$1 = /* @__PURE__ */ uniform$1(0, "uint").setName("u_cameraIndex").setGroup(sharedUniformGroup$1("cameraIndex")).toVarying("v_cameraIndex");
/**
* TSL object that represents the `near` value of the camera used for the current render.
*
* @tsl
* @type {UniformNode<float>}
*/
var cameraNear$1 = /* @__PURE__ */ uniform$1("float").setName("cameraNear").setGroup(renderGroup$1).onRenderUpdate(({ camera }) => camera.near);
/**
* TSL object that represents the `far` value of the camera used for the current render.
*
* @tsl
* @type {UniformNode<float>}
*/
var cameraFar$1 = /* @__PURE__ */ uniform$1("float").setName("cameraFar").setGroup(renderGroup$1).onRenderUpdate(({ camera }) => camera.far);
/**
* TSL object that represents the projection matrix of the camera used for the current render.
*
* @tsl
* @type {UniformNode<mat4>}
*/
var cameraProjectionMatrix$1 = /* @__PURE__ */ Fn$1(({ camera }) => {
	let cameraProjectionMatrix$2;
	if (camera.isArrayCamera && camera.cameras.length > 0) {
		const matrices = [];
		for (const subCamera of camera.cameras) matrices.push(subCamera.projectionMatrix);
		cameraProjectionMatrix$2 = uniformArray$1(matrices).setGroup(renderGroup$1).setName("cameraProjectionMatrices").element(camera.isMultiViewCamera ? builtin$1("gl_ViewID_OVR") : cameraIndex$1).toConst("cameraProjectionMatrix");
	} else cameraProjectionMatrix$2 = uniform$1("mat4").setName("cameraProjectionMatrix").setGroup(renderGroup$1).onRenderUpdate(({ camera: camera$1 }) => camera$1.projectionMatrix);
	return cameraProjectionMatrix$2;
}).once()();
/**
* TSL object that represents the inverse projection matrix of the camera used for the current render.
*
* @tsl
* @type {UniformNode<mat4>}
*/
var cameraProjectionMatrixInverse$1 = /* @__PURE__ */ Fn$1(({ camera }) => {
	let cameraProjectionMatrixInverse$2;
	if (camera.isArrayCamera && camera.cameras.length > 0) {
		const matrices = [];
		for (const subCamera of camera.cameras) matrices.push(subCamera.projectionMatrixInverse);
		cameraProjectionMatrixInverse$2 = uniformArray$1(matrices).setGroup(renderGroup$1).setName("cameraProjectionMatricesInverse").element(camera.isMultiViewCamera ? builtin$1("gl_ViewID_OVR") : cameraIndex$1).toConst("cameraProjectionMatrixInverse");
	} else cameraProjectionMatrixInverse$2 = uniform$1("mat4").setName("cameraProjectionMatrixInverse").setGroup(renderGroup$1).onRenderUpdate(({ camera: camera$1 }) => camera$1.projectionMatrixInverse);
	return cameraProjectionMatrixInverse$2;
}).once()();
/**
* TSL object that represents the view matrix of the camera used for the current render.
*
* @tsl
* @type {UniformNode<mat4>}
*/
var cameraViewMatrix$1 = /* @__PURE__ */ Fn$1(({ camera }) => {
	let cameraViewMatrix$2;
	if (camera.isArrayCamera && camera.cameras.length > 0) {
		const matrices = [];
		for (const subCamera of camera.cameras) matrices.push(subCamera.matrixWorldInverse);
		cameraViewMatrix$2 = uniformArray$1(matrices).setGroup(renderGroup$1).setName("cameraViewMatrices").element(camera.isMultiViewCamera ? builtin$1("gl_ViewID_OVR") : cameraIndex$1).toConst("cameraViewMatrix");
	} else cameraViewMatrix$2 = uniform$1("mat4").setName("cameraViewMatrix").setGroup(renderGroup$1).onRenderUpdate(({ camera: camera$1 }) => camera$1.matrixWorldInverse);
	return cameraViewMatrix$2;
}).once()();
/**
* TSL object that represents the world matrix of the camera used for the current render.
*
* @tsl
* @type {UniformNode<mat4>}
*/
var cameraWorldMatrix$1 = /* @__PURE__ */ Fn$1(({ camera }) => {
	let cameraWorldMatrix$2;
	if (camera.isArrayCamera && camera.cameras.length > 0) {
		const matrices = [];
		for (const subCamera of camera.cameras) matrices.push(subCamera.matrixWorld);
		cameraWorldMatrix$2 = uniformArray$1(matrices).setGroup(renderGroup$1).setName("cameraWorldMatrices").element(camera.isMultiViewCamera ? builtin$1("gl_ViewID_OVR") : cameraIndex$1).toConst("cameraWorldMatrix");
	} else cameraWorldMatrix$2 = uniform$1("mat4").setName("cameraWorldMatrix").setGroup(renderGroup$1).onRenderUpdate(({ camera: camera$1 }) => camera$1.matrixWorld);
	return cameraWorldMatrix$2;
}).once()();
/**
* TSL object that represents the normal matrix of the camera used for the current render.
*
* @tsl
* @type {UniformNode<mat3>}
*/
var cameraNormalMatrix$1 = /* @__PURE__ */ Fn$1(({ camera }) => {
	let cameraNormalMatrix$2;
	if (camera.isArrayCamera && camera.cameras.length > 0) {
		const matrices = [];
		for (const subCamera of camera.cameras) matrices.push(subCamera.normalMatrix);
		cameraNormalMatrix$2 = uniformArray$1(matrices).setGroup(renderGroup$1).setName("cameraNormalMatrices").element(camera.isMultiViewCamera ? builtin$1("gl_ViewID_OVR") : cameraIndex$1).toConst("cameraNormalMatrix");
	} else cameraNormalMatrix$2 = uniform$1("mat3").setName("cameraNormalMatrix").setGroup(renderGroup$1).onRenderUpdate(({ camera: camera$1 }) => camera$1.normalMatrix);
	return cameraNormalMatrix$2;
}).once()();
/**
* TSL object that represents the position in world space of the camera used for the current render.
*
* @tsl
* @type {UniformNode<vec3>}
*/
var cameraPosition$1 = /* @__PURE__ */ Fn$1(({ camera }) => {
	let cameraPosition$2;
	if (camera.isArrayCamera && camera.cameras.length > 0) {
		const positions = [];
		for (let i = 0, l = camera.cameras.length; i < l; i++) positions.push(new Vector3());
		cameraPosition$2 = uniformArray$1(positions).setGroup(renderGroup$1).setName("cameraPositions").onRenderUpdate(({ camera: camera$1 }, self$1) => {
			const subCameras = camera$1.cameras;
			const array$2 = self$1.array;
			for (let i = 0, l = subCameras.length; i < l; i++) array$2[i].setFromMatrixPosition(subCameras[i].matrixWorld);
		}).element(camera.isMultiViewCamera ? builtin$1("gl_ViewID_OVR") : cameraIndex$1).toConst("cameraPosition");
	} else cameraPosition$2 = uniform$1(new Vector3()).setName("cameraPosition").setGroup(renderGroup$1).onRenderUpdate(({ camera: camera$1 }, self$1) => self$1.value.setFromMatrixPosition(camera$1.matrixWorld));
	return cameraPosition$2;
}).once()();
/**
* TSL object that represents the viewport of the camera used for the current render.
*
* @tsl
* @type {UniformNode<vec4>}
*/
var cameraViewport$1 = /* @__PURE__ */ Fn$1(({ camera }) => {
	let cameraViewport$2;
	if (camera.isArrayCamera && camera.cameras.length > 0) {
		const viewports = [];
		for (const subCamera of camera.cameras) viewports.push(subCamera.viewport);
		cameraViewport$2 = uniformArray$1(viewports, "vec4").setGroup(renderGroup$1).setName("cameraViewports").element(cameraIndex$1).toConst("cameraViewport");
	} else cameraViewport$2 = vec4$1(0, 0, screenSize$1.x, screenSize$1.y).toConst("cameraViewport");
	return cameraViewport$2;
}).once()();
var _sphere = /* @__PURE__ */ new Sphere();
/**
* This node can be used to access transformation related metrics of 3D objects.
* Depending on the selected scope, a different metric is represented as a uniform
* in the shader. The following scopes are supported:
*
* - `POSITION`: The object's position in world space.
* - `VIEW_POSITION`: The object's position in view/camera space.
* - `DIRECTION`: The object's direction in world space.
* - `SCALE`: The object's scale in world space.
* - `WORLD_MATRIX`: The object's matrix in world space.
*
* @augments Node
*/
var Object3DNode = class Object3DNode extends Node {
	static get type() {
		return "Object3DNode";
	}
	/**
	* Constructs a new object 3D node.
	*
	* @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
	* @param {?Object3D} [object3d=null] - The 3D object.
	*/
	constructor(scope, object3d = null) {
		super();
		/**
		* The node reports a different type of transformation depending on the scope.
		*
		* @type {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')}
		*/
		this.scope = scope;
		/**
		* The 3D object.
		*
		* @type {?Object3D}
		* @default null
		*/
		this.object3d = object3d;
		/**
		* Overwritten since this type of node is updated per object.
		*
		* @type {string}
		* @default 'object'
		*/
		this.updateType = NodeUpdateType$1.OBJECT;
		/**
		* Holds the value of the node as a uniform.
		*
		* @type {UniformNode}
		*/
		this.uniformNode = new UniformNode(null);
	}
	/**
	* Overwritten since the node type is inferred from the scope.
	*
	* @return {('mat4'|'vec3'|'float')} The node type.
	*/
	getNodeType() {
		const scope = this.scope;
		if (scope === Object3DNode.WORLD_MATRIX) return "mat4";
		else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) return "vec3";
		else if (scope === Object3DNode.RADIUS) return "float";
	}
	/**
	* Updates the uniform value depending on the scope.
	*
	* @param {NodeFrame} frame - The current node frame.
	*/
	update(frame) {
		const object = this.object3d;
		const uniformNode = this.uniformNode;
		const scope = this.scope;
		if (scope === Object3DNode.WORLD_MATRIX) uniformNode.value = object.matrixWorld;
		else if (scope === Object3DNode.POSITION) {
			uniformNode.value = uniformNode.value || new Vector3();
			uniformNode.value.setFromMatrixPosition(object.matrixWorld);
		} else if (scope === Object3DNode.SCALE) {
			uniformNode.value = uniformNode.value || new Vector3();
			uniformNode.value.setFromMatrixScale(object.matrixWorld);
		} else if (scope === Object3DNode.DIRECTION) {
			uniformNode.value = uniformNode.value || new Vector3();
			object.getWorldDirection(uniformNode.value);
		} else if (scope === Object3DNode.VIEW_POSITION) {
			const camera = frame.camera;
			uniformNode.value = uniformNode.value || new Vector3();
			uniformNode.value.setFromMatrixPosition(object.matrixWorld);
			uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
		} else if (scope === Object3DNode.RADIUS) {
			const geometry = frame.object.geometry;
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
			_sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
			uniformNode.value = _sphere.radius;
		}
	}
	/**
	* Generates the code snippet of the uniform node. The node type of the uniform
	* node also depends on the selected scope.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The generated code snippet.
	*/
	generate(builder) {
		const scope = this.scope;
		if (scope === Object3DNode.WORLD_MATRIX) this.uniformNode.nodeType = "mat4";
		else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) this.uniformNode.nodeType = "vec3";
		else if (scope === Object3DNode.RADIUS) this.uniformNode.nodeType = "float";
		return this.uniformNode.build(builder);
	}
	serialize(data) {
		super.serialize(data);
		data.scope = this.scope;
	}
	deserialize(data) {
		super.deserialize(data);
		this.scope = data.scope;
	}
};
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.SCALE = "scale";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
Object3DNode.RADIUS = "radius";
/**
* TSL function for creating an object 3D node that represents the object's direction in world space.
*
* @tsl
* @function
* @param {?Object3D} [object3d] - The 3D object.
* @returns {Object3DNode<vec3>}
*/
var objectDirection$1 = /* @__PURE__ */ nodeProxy$1(Object3DNode, Object3DNode.DIRECTION).setParameterLength(1);
/**
* TSL function for creating an object 3D node that represents the object's world matrix.
*
* @tsl
* @function
* @param {?Object3D} [object3d] - The 3D object.
* @returns {Object3DNode<mat4>}
*/
var objectWorldMatrix$1 = /* @__PURE__ */ nodeProxy$1(Object3DNode, Object3DNode.WORLD_MATRIX).setParameterLength(1);
/**
* TSL function for creating an object 3D node that represents the object's position in world space.
*
* @tsl
* @function
* @param {?Object3D} [object3d] - The 3D object.
* @returns {Object3DNode<vec3>}
*/
var objectPosition$1 = /* @__PURE__ */ nodeProxy$1(Object3DNode, Object3DNode.POSITION).setParameterLength(1);
/**
* TSL function for creating an object 3D node that represents the object's scale in world space.
*
* @tsl
* @function
* @param {?Object3D} [object3d] - The 3D object.
* @returns {Object3DNode<vec3>}
*/
var objectScale$1 = /* @__PURE__ */ nodeProxy$1(Object3DNode, Object3DNode.SCALE).setParameterLength(1);
/**
* TSL function for creating an object 3D node that represents the object's position in view/camera space.
*
* @tsl
* @function
* @param {?Object3D} [object3d] - The 3D object.
* @returns {Object3DNode<vec3>}
*/
var objectViewPosition$1 = /* @__PURE__ */ nodeProxy$1(Object3DNode, Object3DNode.VIEW_POSITION).setParameterLength(1);
/**
* TSL function for creating an object 3D node that represents the object's radius.
*
* @tsl
* @function
* @param {?Object3D} [object3d] - The 3D object.
* @returns {Object3DNode<float>}
*/
var objectRadius$1 = /* @__PURE__ */ nodeProxy$1(Object3DNode, Object3DNode.RADIUS).setParameterLength(1);
/**
* This type of node is a specialized version of `Object3DNode`
* with larger set of model related metrics. Unlike `Object3DNode`,
* `ModelNode` extracts the reference to the 3D object from the
* current node frame state.
*
* @augments Object3DNode
*/
var ModelNode = class extends Object3DNode {
	static get type() {
		return "ModelNode";
	}
	/**
	* Constructs a new object model node.
	*
	* @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
	*/
	constructor(scope) {
		super(scope);
	}
	/**
	* Extracts the model reference from the frame state and then
	* updates the uniform value depending on the scope.
	*
	* @param {NodeFrame} frame - The current node frame.
	*/
	update(frame) {
		this.object3d = frame.object;
		super.update(frame);
	}
};
/**
* TSL object that represents the object's direction in world space.
*
* @tsl
* @type {ModelNode<vec3>}
*/
var modelDirection$1 = /* @__PURE__ */ nodeImmutable$1(ModelNode, ModelNode.DIRECTION);
/**
* TSL object that represents the object's world matrix.
*
* @tsl
* @type {ModelNode<mat4>}
*/
var modelWorldMatrix$1 = /* @__PURE__ */ nodeImmutable$1(ModelNode, ModelNode.WORLD_MATRIX);
/**
* TSL object that represents the object's position in world space.
*
* @tsl
* @type {ModelNode<vec3>}
*/
var modelPosition$1 = /* @__PURE__ */ nodeImmutable$1(ModelNode, ModelNode.POSITION);
/**
* TSL object that represents the object's scale in world space.
*
* @tsl
* @type {ModelNode<vec3>}
*/
var modelScale$1 = /* @__PURE__ */ nodeImmutable$1(ModelNode, ModelNode.SCALE);
/**
* TSL object that represents the object's position in view/camera space.
*
* @tsl
* @type {ModelNode<vec3>}
*/
var modelViewPosition$1 = /* @__PURE__ */ nodeImmutable$1(ModelNode, ModelNode.VIEW_POSITION);
/**
* TSL object that represents the object's radius.
*
* @tsl
* @type {ModelNode<float>}
*/
var modelRadius$1 = /* @__PURE__ */ nodeImmutable$1(ModelNode, ModelNode.RADIUS);
/**
* TSL object that represents the object's normal matrix.
*
* @tsl
* @type {UniformNode<mat3>}
*/
var modelNormalMatrix$1 = /* @__PURE__ */ uniform$1(new Matrix3()).onObjectUpdate(({ object }, self$1) => self$1.value.getNormalMatrix(object.matrixWorld));
/**
* TSL object that represents the object's inverse world matrix.
*
* @tsl
* @type {UniformNode<mat4>}
*/
var modelWorldMatrixInverse$1 = /* @__PURE__ */ uniform$1(new Matrix4()).onObjectUpdate(({ object }, self$1) => self$1.value.copy(object.matrixWorld).invert());
/**
* TSL object that represents the object's model view matrix.
*
* @tsl
* @type {Node<mat4>}
*/
var modelViewMatrix$1 = /* @__PURE__ */ Fn$1((builder) => {
	return builder.renderer.overrideNodes.modelViewMatrix || mediumpModelViewMatrix$1;
}).once()().toVar("modelViewMatrix");
/**
* TSL object that represents the object's model view in `mediump` precision.
*
* @tsl
* @type {Node<mat4>}
*/
var mediumpModelViewMatrix$1 = /* @__PURE__ */ cameraViewMatrix$1.mul(modelWorldMatrix$1);
/**
* TSL object that represents the object's model view in `highp` precision
* which is achieved by computing the matrix in JS and not in the shader.
*
* @tsl
* @type {Node<mat4>}
*/
var highpModelViewMatrix$1 = /* @__PURE__ */ Fn$1((builder) => {
	builder.context.isHighPrecisionModelViewMatrix = true;
	return uniform$1("mat4").onObjectUpdate(({ object, camera }) => {
		return object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
	});
}).once()().toVar("highpModelViewMatrix");
/**
* TSL object that represents the object's model normal view in `highp` precision
* which is achieved by computing the matrix in JS and not in the shader.
*
* @tsl
* @type {Node<mat3>}
*/
var highpModelNormalViewMatrix$1 = /* @__PURE__ */ Fn$1((builder) => {
	const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;
	return uniform$1("mat3").onObjectUpdate(({ object, camera }) => {
		if (isHighPrecisionModelViewMatrix !== true) object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
		return object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
	});
}).once()().toVar("highpModelNormalViewMatrix");
/**
* TSL object that represents the position attribute of the current rendered object.
*
* @tsl
* @type {AttributeNode<vec3>}
*/
var positionGeometry$1 = /* @__PURE__ */ attribute$1("position", "vec3");
/**
* TSL object that represents the vertex position in local space of the current rendered object.
*
* @tsl
* @type {AttributeNode<vec3>}
*/
var positionLocal$1 = /* @__PURE__ */ positionGeometry$1.toVarying("positionLocal");
/**
* TSL object that represents the previous vertex position in local space of the current rendered object.
* Used in context of {@link VelocityNode} for rendering motion vectors.
*
* @tsl
* @type {AttributeNode<vec3>}
*/
var positionPrevious$1 = /* @__PURE__ */ positionGeometry$1.toVarying("positionPrevious");
/**
* TSL object that represents the vertex position in world space of the current rendered object.
*
* @tsl
* @type {VaryingNode<vec3>}
*/
var positionWorld$1 = /* @__PURE__ */ Fn$1((builder) => {
	return modelWorldMatrix$1.mul(positionLocal$1).xyz.toVarying(builder.getSubBuildProperty("v_positionWorld"));
}, "vec3").once(["POSITION"])();
/**
* TSL object that represents the position world direction of the current rendered object.
*
* @tsl
* @type {Node<vec3>}
*/
var positionWorldDirection$1 = /* @__PURE__ */ Fn$1(() => {
	return positionLocal$1.transformDirection(modelWorldMatrix$1).toVarying("v_positionWorldDirection").normalize().toVar("positionWorldDirection");
}, "vec3").once(["POSITION"])();
/**
* TSL object that represents the vertex position in view space of the current rendered object.
*
* @tsl
* @type {VaryingNode<vec3>}
*/
var positionView$1 = /* @__PURE__ */ Fn$1((builder) => {
	return builder.context.setupPositionView().toVarying("v_positionView");
}, "vec3").once(["POSITION"])();
/**
* TSL object that represents the position view direction of the current rendered object.
*
* @tsl
* @type {VaryingNode<vec3>}
*/
var positionViewDirection$1 = /* @__PURE__ */ Fn$1((builder) => {
	let output$2;
	if (builder.camera.isOrthographicCamera) output$2 = vec3$1(0, 0, 1);
	else output$2 = positionView$1.negate().toVarying("v_positionViewDirection").normalize();
	return output$2.toVar("positionViewDirection");
}, "vec3").once(["POSITION"])();
/**
* This node can be used to evaluate whether a primitive is front or back facing.
*
* @augments Node
*/
var FrontFacingNode = class extends Node {
	static get type() {
		return "FrontFacingNode";
	}
	/**
	* Constructs a new front facing node.
	*/
	constructor() {
		super("bool");
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isFrontFacingNode = true;
	}
	generate(builder) {
		if (builder.shaderStage !== "fragment") return "true";
		const { material } = builder;
		if (material.side === BackSide) return "false";
		return builder.getFrontFacing();
	}
};
/**
* TSL object that represents whether a primitive is front or back facing
*
* @tsl
* @type {FrontFacingNode<bool>}
*/
var frontFacing$1 = /* @__PURE__ */ nodeImmutable$1(FrontFacingNode);
/**
* TSL object that represents the front facing status as a number instead of a bool.
* `1` means front facing, `-1` means back facing.
*
* @tsl
* @type {Node<float>}
*/
var faceDirection$1 = /* @__PURE__ */ float$1(frontFacing$1).mul(2).sub(1);
/**
* Converts a direction vector to a face direction vector based on the material's side.
*
* If the material is set to `BackSide`, the direction is inverted.
* If the material is set to `DoubleSide`, the direction is multiplied by `faceDirection`.
*
* @tsl
* @param {Node<vec3>} direction - The direction vector to convert.
* @returns {Node<vec3>} The converted direction vector.
*/
var directionToFaceDirection$1 = /* @__PURE__ */ Fn$1(([direction], { material }) => {
	const side = material.side;
	if (side === BackSide) direction = direction.mul(-1);
	else if (side === DoubleSide) direction = direction.mul(faceDirection$1);
	return direction;
});
/**
* TSL object that represents the normal attribute of the current rendered object in local space.
*
* @tsl
* @type {Node<vec3>}
*/
var normalGeometry$1 = /* @__PURE__ */ attribute$1("normal", "vec3");
/**
* TSL object that represents the vertex normal of the current rendered object in local space.
*
* @tsl
* @type {Node<vec3>}
*/
var normalLocal$1 = /* @__PURE__ */ Fn$1((builder) => {
	if (builder.geometry.hasAttribute("normal") === false) {
		warn("TSL: Vertex attribute \"normal\" not found on geometry.");
		return vec3$1(0, 1, 0);
	}
	return normalGeometry$1;
}, "vec3").once()().toVar("normalLocal");
/**
* TSL object that represents the flat vertex normal of the current rendered object in view space.
*
* @tsl
* @type {Node<vec3>}
*/
var normalFlat$1 = /* @__PURE__ */ positionView$1.dFdx().cross(positionView$1.dFdy()).normalize().toVar("normalFlat");
/**
* TSL object that represents the vertex normal of the current rendered object in view space.
*
* @tsl
* @type {Node<vec3>}
*/
var normalViewGeometry$1 = /* @__PURE__ */ Fn$1((builder) => {
	let node;
	if (builder.material.flatShading === true) node = normalFlat$1;
	else node = transformNormalToView$1(normalLocal$1).toVarying("v_normalViewGeometry").normalize();
	return node;
}, "vec3").once()().toVar("normalViewGeometry");
/**
* TSL object that represents the vertex normal of the current rendered object in world space.
*
* @tsl
* @type {Node<vec3>}
*/
var normalWorldGeometry$1 = /* @__PURE__ */ Fn$1((builder) => {
	let normal$1 = normalViewGeometry$1.transformDirection(cameraViewMatrix$1);
	if (builder.material.flatShading !== true) normal$1 = normal$1.toVarying("v_normalWorldGeometry");
	return normal$1.normalize().toVar("normalWorldGeometry");
}, "vec3").once()();
/**
* TSL object that represents the vertex normal of the current rendered object in view space.
*
* @tsl
* @type {Node<vec3>}
*/
var normalView$1 = /* @__PURE__ */ Fn$1(({ subBuildFn, material, context: context$2 }) => {
	let node;
	if (subBuildFn === "NORMAL" || subBuildFn === "VERTEX") {
		node = normalViewGeometry$1;
		if (material.flatShading !== true) node = directionToFaceDirection$1(node);
	} else node = context$2.setupNormal().context({ getUV: null });
	return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("normalView");
/**
* TSL object that represents the vertex normal of the current rendered object in world space.
*
* @tsl
* @type {Node<vec3>}
*/
var normalWorld$1 = /* @__PURE__ */ normalView$1.transformDirection(cameraViewMatrix$1).toVar("normalWorld");
/**
* TSL object that represents the clearcoat vertex normal of the current rendered object in view space.
*
* @tsl
* @type {Node<vec3>}
*/
var clearcoatNormalView$1 = /* @__PURE__ */ Fn$1(({ subBuildFn, context: context$2 }) => {
	let node;
	if (subBuildFn === "NORMAL" || subBuildFn === "VERTEX") node = normalView$1;
	else node = context$2.setupClearcoatNormal().context({ getUV: null });
	return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("clearcoatNormalView");
/**
* Transforms the normal with the given matrix.
*
* @tsl
* @function
* @param {Node<vec3>} normal - The normal.
* @param {Node<mat3>} [matrix=modelWorldMatrix] - The matrix.
* @return {Node<vec3>} The transformed normal.
*/
var transformNormal$1 = /* @__PURE__ */ Fn$1(([normal$1, matrix = modelWorldMatrix$1]) => {
	const m$1 = mat3$1(matrix);
	const transformedNormal = normal$1.div(vec3$1(m$1[0].dot(m$1[0]), m$1[1].dot(m$1[1]), m$1[2].dot(m$1[2])));
	return m$1.mul(transformedNormal).xyz;
});
/**
* Transforms the given normal from local to view space.
*
* @tsl
* @function
* @param {Node<vec3>} normal - The normal.
* @param {NodeBuilder} builder - The current node builder.
* @return {Node<vec3>} The transformed normal.
*/
var transformNormalToView$1 = /* @__PURE__ */ Fn$1(([normal$1], builder) => {
	const modelNormalViewMatrix = builder.renderer.overrideNodes.modelNormalViewMatrix;
	if (modelNormalViewMatrix !== null) return modelNormalViewMatrix.transformDirection(normal$1);
	const transformedNormal = modelNormalMatrix$1.mul(normal$1);
	return cameraViewMatrix$1.transformDirection(transformedNormal);
});
/**
* TSL object that represents the transformed vertex normal of the current rendered object in view space.
*
* @tsl
* @type {Node<vec3>}
* @deprecated since r178. Use `normalView` instead.
*/
var transformedNormalView$1 = Fn$1(() => {
	warn("TSL: \"transformedNormalView\" is deprecated. Use \"normalView\" instead.");
	return normalView$1;
}).once(["NORMAL", "VERTEX"])();
/**
* TSL object that represents the transformed vertex normal of the current rendered object in world space.
*
* @tsl
* @type {Node<vec3>}
* @deprecated since r178. Use `normalWorld` instead.
*/
var transformedNormalWorld$1 = Fn$1(() => {
	warn("TSL: \"transformedNormalWorld\" is deprecated. Use \"normalWorld\" instead.");
	return normalWorld$1;
}).once(["NORMAL", "VERTEX"])();
/**
* TSL object that represents the transformed clearcoat vertex normal of the current rendered object in view space.
*
* @tsl
* @type {Node<vec3>}
* @deprecated since r178. Use `clearcoatNormalView` instead.
*/
var transformedClearcoatNormalView$1 = Fn$1(() => {
	warn("TSL: \"transformedClearcoatNormalView\" is deprecated. Use \"clearcoatNormalView\" instead.");
	return clearcoatNormalView$1;
}).once(["NORMAL", "VERTEX"])();
var _e1$1$1 = /* @__PURE__ */ new Euler();
var _m1$1$1 = /* @__PURE__ */ new Matrix4();
/**
* TSL object that represents the refraction ratio of the material used for rendering the current object.
*
* @tsl
* @type {UniformNode<float>}
*/
var materialRefractionRatio$1 = /* @__PURE__ */ uniform$1(0).onReference(({ material }) => material).onObjectUpdate(({ material }) => material.refractionRatio);
/**
* TSL object that represents the intensity of environment maps of PBR materials.
* When `material.envMap` is set, the value is `material.envMapIntensity` otherwise `scene.environmentIntensity`.
*
* @tsl
* @type {Node<float>}
*/
var materialEnvIntensity$1 = /* @__PURE__ */ uniform$1(1).onReference(({ material }) => material).onObjectUpdate(function({ material, scene }) {
	return material.envMap ? material.envMapIntensity : scene.environmentIntensity;
});
/**
* TSL object that represents the rotation of environment maps.
* When `material.envMap` is set, the value is `material.envMapRotation`. `scene.environmentRotation` controls the
* rotation of `scene.environment` instead.
*
* @tsl
* @type {Node<mat4>}
*/
var materialEnvRotation$1 = /* @__PURE__ */ uniform$1(new Matrix4()).onReference(function(frame) {
	return frame.material;
}).onObjectUpdate(function({ material, scene }) {
	const rotation = scene.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
	if (rotation) {
		_e1$1$1.copy(rotation);
		_m1$1$1.makeRotationFromEuler(_e1$1$1);
	} else _m1$1$1.identity();
	return _m1$1$1;
});
/**
* The reflect vector in view space.
*
* @tsl
* @type {Node<vec3>}
*/
var reflectView$1 = /* @__PURE__ */ positionViewDirection$1.negate().reflect(normalView$1);
/**
* The refract vector in view space.
*
* @tsl
* @type {Node<vec3>}
*/
var refractView$1 = /* @__PURE__ */ positionViewDirection$1.negate().refract(normalView$1, materialRefractionRatio$1);
/**
* Used for sampling cube maps when using cube reflection mapping.
*
* @tsl
* @type {Node<vec3>}
*/
var reflectVector$1 = /* @__PURE__ */ reflectView$1.transformDirection(cameraViewMatrix$1).toVar("reflectVector");
/**
* Used for sampling cube maps when using cube refraction mapping.
*
* @tsl
* @type {Node<vec3>}
*/
var refractVector$1 = /* @__PURE__ */ refractView$1.transformDirection(cameraViewMatrix$1).toVar("reflectVector");
var EmptyTexture = /* @__PURE__ */ new CubeTexture();
/**
* This type of uniform node represents a cube texture.
*
* @augments TextureNode
*/
var CubeTextureNode = class extends TextureNode {
	static get type() {
		return "CubeTextureNode";
	}
	/**
	* Constructs a new cube texture node.
	*
	* @param {CubeTexture} value - The cube texture.
	* @param {?Node<vec3>} [uvNode=null] - The uv node.
	* @param {?Node<int>} [levelNode=null] - The level node.
	* @param {?Node<float>} [biasNode=null] - The bias node.
	*/
	constructor(value, uvNode = null, levelNode = null, biasNode = null) {
		super(value, uvNode, levelNode, biasNode);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isCubeTextureNode = true;
	}
	/**
	* Overwrites the default implementation to return a fixed value `'cubeTexture'`.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType() {
		return "cubeTexture";
	}
	/**
	* Returns a default uvs based on the mapping type of the cube texture.
	*
	* @return {Node<vec3>} The default uv attribute.
	*/
	getDefaultUV() {
		const texture$2 = this.value;
		if (texture$2.mapping === CubeReflectionMapping) return reflectVector$1;
		else if (texture$2.mapping === CubeRefractionMapping) return refractVector$1;
		else {
			error("CubeTextureNode: Mapping \"%s\" not supported.", texture$2.mapping);
			return vec3$1(0, 0, 0);
		}
	}
	/**
	* Overwritten with an empty implementation since the `updateMatrix` flag is ignored
	* for cube textures. The uv transformation matrix is not applied to cube textures.
	*
	* @param {boolean} value - The update toggle.
	*/
	setUpdateMatrix() {}
	/**
	* Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
	* to modify the uv node for correct sampling.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node} uvNode - The uv node to setup.
	* @return {Node} The updated uv node.
	*/
	setupUV(builder, uvNode) {
		const texture$2 = this.value;
		if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture$2.isRenderTargetTexture) uvNode = vec3$1(uvNode.x.negate(), uvNode.yz);
		return materialEnvRotation$1.mul(uvNode);
	}
	/**
	* Generates the uv code snippet.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node} cubeUV - The uv node to generate code for.
	* @return {string} The generated code snippet.
	*/
	generateUV(builder, cubeUV) {
		return cubeUV.build(builder, this.sampler === true ? "vec3" : "ivec3");
	}
};
/**
* TSL function for creating a cube texture node.
*
* @tsl
* @function
* @param {CubeTexture} value - The cube texture.
* @param {?Node<vec3>} [uvNode=null] - The uv node.
* @param {?Node<int>} [levelNode=null] - The level node.
* @param {?Node<float>} [biasNode=null] - The bias node.
* @returns {CubeTextureNode}
*/
var cubeTextureBase$1 = /* @__PURE__ */ nodeProxy$1(CubeTextureNode).setParameterLength(1, 4).setName("cubeTexture");
/**
* TSL function for creating a cube texture uniform node.
*
* @tsl
* @function
* @param {?(CubeTexture|CubeTextureNode)} [value=EmptyTexture] - The cube texture.
* @param {?Node<vec3>} [uvNode=null] - The uv node.
* @param {?Node<int>} [levelNode=null] - The level node.
* @param {?Node<float>} [biasNode=null] - The bias node.
* @returns {CubeTextureNode}
*/
var cubeTexture$1 = (value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null) => {
	let textureNode;
	if (value && value.isCubeTextureNode === true) {
		textureNode = nodeObject$1(value.clone());
		textureNode.referenceNode = value;
		if (uvNode !== null) textureNode.uvNode = nodeObject$1(uvNode);
		if (levelNode !== null) textureNode.levelNode = nodeObject$1(levelNode);
		if (biasNode !== null) textureNode.biasNode = nodeObject$1(biasNode);
	} else textureNode = cubeTextureBase$1(value, uvNode, levelNode, biasNode);
	return textureNode;
};
/**
* TSL function for creating a uniform cube texture node.
*
* @tsl
* @function
* @param {?CubeTexture} [value=EmptyTexture] - The cube texture.
* @returns {CubeTextureNode}
*/
var uniformCubeTexture$1 = (value = EmptyTexture) => cubeTextureBase$1(value);
/**
* This class is only relevant if the referenced property is array-like.
* In this case, `ReferenceElementNode` allows to refer to a specific
* element inside the data structure via an index.
*
* @augments ArrayElementNode
*/
var ReferenceElementNode = class extends ArrayElementNode {
	static get type() {
		return "ReferenceElementNode";
	}
	/**
	* Constructs a new reference element node.
	*
	* @param {?ReferenceNode} referenceNode - The reference node.
	* @param {Node} indexNode - The index node that defines the element access.
	*/
	constructor(referenceNode, indexNode) {
		super(referenceNode, indexNode);
		/**
		* Similar to {@link ReferenceNode#reference}, an additional
		* property references to the current node.
		*
		* @type {?ReferenceNode}
		* @default null
		*/
		this.referenceNode = referenceNode;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isReferenceElementNode = true;
	}
	/**
	* This method is overwritten since the node type is inferred from
	* the uniform type of the reference node.
	*
	* @return {string} The node type.
	*/
	getNodeType() {
		return this.referenceNode.uniformType;
	}
	generate(builder) {
		const snippet = super.generate(builder);
		const arrayType = this.referenceNode.getNodeType();
		const elementType = this.getNodeType();
		return builder.format(snippet, arrayType, elementType);
	}
};
/**
* This type of node establishes a reference to a property of another object.
* In this way, the value of the node is automatically linked to the value of
* referenced object. Reference nodes internally represent the linked value
* as a uniform.
*
* @augments Node
*/
var ReferenceNode = class extends Node {
	static get type() {
		return "ReferenceNode";
	}
	/**
	* Constructs a new reference node.
	*
	* @param {string} property - The name of the property the node refers to.
	* @param {string} uniformType - The uniform type that should be used to represent the property value.
	* @param {?Object} [object=null] - The object the property belongs to.
	* @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
	*/
	constructor(property$2, uniformType, object = null, count = null) {
		super();
		/**
		* The name of the property the node refers to.
		*
		* @type {string}
		*/
		this.property = property$2;
		/**
		* The uniform type that should be used to represent the property value.
		*
		* @type {string}
		*/
		this.uniformType = uniformType;
		/**
		* The object the property belongs to.
		*
		* @type {?Object}
		* @default null
		*/
		this.object = object;
		/**
		* When the linked property is an array, this parameter defines its length.
		*
		* @type {?number}
		* @default null
		*/
		this.count = count;
		/**
		* The property name might have dots so nested properties can be referred.
		* The hierarchy of the names is stored inside this array.
		*
		* @type {Array<string>}
		*/
		this.properties = property$2.split(".");
		/**
		* Points to the current referred object. This property exists next to {@link ReferenceNode#object}
		* since the final reference might be updated from calling code.
		*
		* @type {?Object}
		* @default null
		*/
		this.reference = object;
		/**
		* The uniform node that holds the value of the reference node.
		*
		* @type {UniformNode}
		* @default null
		*/
		this.node = null;
		/**
		* The uniform group of the internal uniform.
		*
		* @type {UniformGroupNode}
		* @default null
		*/
		this.group = null;
		/**
		* An optional label of the internal uniform node.
		*
		* @type {?string}
		* @default null
		*/
		this.name = null;
		/**
		* Overwritten since reference nodes are updated per object.
		*
		* @type {string}
		* @default 'object'
		*/
		this.updateType = NodeUpdateType$1.OBJECT;
	}
	/**
	* When the referred property is array-like, this method can be used
	* to access elements via an index node.
	*
	* @param {IndexNode} indexNode - indexNode.
	* @return {ReferenceElementNode} A reference to an element.
	*/
	element(indexNode) {
		return nodeObject$1(new ReferenceElementNode(this, nodeObject$1(indexNode)));
	}
	/**
	* Sets the uniform group for this reference node.
	*
	* @param {UniformGroupNode} group - The uniform group to set.
	* @return {ReferenceNode} A reference to this node.
	*/
	setGroup(group) {
		this.group = group;
		return this;
	}
	/**
	* Sets the name for the internal uniform.
	*
	* @param {string} name - The label to set.
	* @return {ReferenceNode} A reference to this node.
	*/
	setName(name) {
		this.name = name;
		return this;
	}
	/**
	* Sets the label for the internal uniform.
	*
	* @deprecated
	* @param {string} name - The label to set.
	* @return {ReferenceNode} A reference to this node.
	*/
	label(name) {
		warn("TSL: \"label()\" has been deprecated. Use \"setName()\" instead.");
		return this.setName(name);
	}
	/**
	* Sets the node type which automatically defines the internal
	* uniform type.
	*
	* @param {string} uniformType - The type to set.
	*/
	setNodeType(uniformType) {
		let node = null;
		if (this.count !== null) node = buffer$1(null, uniformType, this.count);
		else if (Array.isArray(this.getValueFromReference())) node = uniformArray$1(null, uniformType);
		else if (uniformType === "texture") node = texture$1(null);
		else if (uniformType === "cubeTexture") node = cubeTexture$1(null);
		else node = uniform$1(null, uniformType);
		if (this.group !== null) node.setGroup(this.group);
		if (this.name !== null) node.setName(this.name);
		this.node = node;
	}
	/**
	* This method is overwritten since the node type is inferred from
	* the type of the reference node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		if (this.node === null) {
			this.updateReference(builder);
			this.updateValue();
		}
		return this.node.getNodeType(builder);
	}
	/**
	* Returns the property value from the given referred object.
	*
	* @param {Object} [object=this.reference] - The object to retrieve the property value from.
	* @return {any} The value.
	*/
	getValueFromReference(object = this.reference) {
		const { properties } = this;
		let value = object[properties[0]];
		for (let i = 1; i < properties.length; i++) value = value[properties[i]];
		return value;
	}
	/**
	* Allows to update the reference based on the given state. The state is only
	* evaluated {@link ReferenceNode#object} is not set.
	*
	* @param {(NodeFrame|NodeBuilder)} state - The current state.
	* @return {Object} The updated reference.
	*/
	updateReference(state) {
		this.reference = this.object !== null ? this.object : state.object;
		return this.reference;
	}
	/**
	* The output of the reference node is the internal uniform node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {UniformNode} The output node.
	*/
	setup() {
		this.updateValue();
		return this.node;
	}
	/**
	* Overwritten to update the internal uniform value.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update() {
		this.updateValue();
	}
	/**
	* Retrieves the value from the referred object property and uses it
	* to updated the internal uniform.
	*/
	updateValue() {
		if (this.node === null) this.setNodeType(this.uniformType);
		const value = this.getValueFromReference();
		if (Array.isArray(value)) this.node.array = value;
		else this.node.value = value;
	}
};
/**
* TSL function for creating a reference node.
*
* @tsl
* @function
* @param {string} name - The name of the property the node refers to.
* @param {string} type - The uniform type that should be used to represent the property value.
* @param {?Object} [object] - The object the property belongs to.
* @returns {ReferenceNode}
*/
var reference$2 = (name, type$1, object) => nodeObject$1(new ReferenceNode(name, type$1, object));
/**
* TSL function for creating a reference node. Use this function if you want need a reference
* to an array-like property that should be represented as a uniform buffer.
*
* @tsl
* @function
* @param {string} name - The name of the property the node refers to.
* @param {string} type - The uniform type that should be used to represent the property value.
* @param {number} count - The number of value inside the array-like object.
* @param {Object} object - An array-like object the property belongs to.
* @returns {ReferenceNode}
*/
var referenceBuffer$1 = (name, type$1, count, object) => nodeObject$1(new ReferenceNode(name, type$1, object, count));
/**
* This node is a special type of reference node which is intended
* for linking material properties with node values.
* ```js
* const opacityNode = materialReference( 'opacity', 'float', material );
* ```
* When changing `material.opacity`, the node value of `opacityNode` will
* automatically be updated.
*
* @augments ReferenceNode
*/
var MaterialReferenceNode = class extends ReferenceNode {
	static get type() {
		return "MaterialReferenceNode";
	}
	/**
	* Constructs a new material reference node.
	*
	* @param {string} property - The name of the property the node refers to.
	* @param {string} inputType - The uniform type that should be used to represent the property value.
	* @param {?Material} [material=null] - The material the property belongs to. When no material is set,
	* the node refers to the material of the current rendered object.
	*/
	constructor(property$2, inputType, material = null) {
		super(property$2, inputType, material);
		/**
		* The material the property belongs to. When no material is set,
		* the node refers to the material of the current rendered object.
		*
		* @type {?Material}
		* @default null
		*/
		this.material = material;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMaterialReferenceNode = true;
	}
	/**
	* Updates the reference based on the given state. The state is only evaluated
	* {@link MaterialReferenceNode#material} is not set.
	*
	* @param {(NodeFrame|NodeBuilder)} state - The current state.
	* @return {Object} The updated reference.
	*/
	updateReference(state) {
		this.reference = this.material !== null ? this.material : state.material;
		return this.reference;
	}
};
/**
* TSL function for creating a material reference node.
*
* @tsl
* @function
* @param {string} name - The name of the property the node refers to.
* @param {string} type - The uniform type that should be used to represent the property value.
* @param {?Material} [material=null] - The material the property belongs to.
* When no material is set, the node refers to the material of the current rendered object.
* @returns {MaterialReferenceNode}
*/
var materialReference$1 = (name, type$1, material = null) => nodeObject$1(new MaterialReferenceNode(name, type$1, material));
var uv$2 = uv$1$1();
var q0 = positionView$1.dFdx();
var q1 = positionView$1.dFdy();
var st0 = uv$2.dFdx();
var st1 = uv$2.dFdy();
var N = normalView$1;
var q1perp = q1.cross(N);
var q0perp = N.cross(q0);
var T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
var B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
var det = T.dot(T).max(B.dot(B));
var scale$1 = det.equal(0).select(0, det.inverseSqrt());
/**
* Tangent vector in view space, computed dynamically from geometry and UV derivatives.
* Useful for normal mapping without precomputed tangents.
*
* Reference: http://www.thetenthplanet.de/archives/1180
*
* @tsl
* @type {Node<vec3>}
*/
var tangentViewFrame = /* @__PURE__ */ T.mul(scale$1).toVar("tangentViewFrame");
/**
* Bitangent vector in view space, computed dynamically from geometry and UV derivatives.
* Complements the tangentViewFrame for constructing the tangent space basis.
*
* Reference: http://www.thetenthplanet.de/archives/1180
*
* @tsl
* @type {Node<vec3>}
*/
var bitangentViewFrame = /* @__PURE__ */ B.mul(scale$1).toVar("bitangentViewFrame");
/**
* TSL object that represents the tangent attribute of the current rendered object.
*
* @tsl
* @type {Node<vec4>}
*/
var tangentGeometry$1 = /* @__PURE__ */ Fn$1((builder) => {
	if (builder.geometry.hasAttribute("tangent") === false) builder.geometry.computeTangents();
	return attribute$1("tangent", "vec4");
})();
/**
* TSL object that represents the vertex tangent in local space of the current rendered object.
*
* @tsl
* @type {Node<vec3>}
*/
var tangentLocal$1 = /* @__PURE__ */ tangentGeometry$1.xyz.toVar("tangentLocal");
/**
* TSL object that represents the vertex tangent in view space of the current rendered object.
*
* @tsl
* @type {Node<vec3>}
*/
var tangentView$1 = /* @__PURE__ */ Fn$1(({ subBuildFn, geometry, material }) => {
	let node;
	if (subBuildFn === "VERTEX" || geometry.hasAttribute("tangent")) node = modelViewMatrix$1.mul(vec4$1(tangentLocal$1, 0)).xyz.toVarying("v_tangentView").normalize();
	else node = tangentViewFrame;
	if (material.flatShading !== true) node = directionToFaceDirection$1(node);
	return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("tangentView");
/**
* TSL object that represents the vertex tangent in world space of the current rendered object.
*
* @tsl
* @type {Node<vec3>}
*/
var tangentWorld$1 = /* @__PURE__ */ tangentView$1.transformDirection(cameraViewMatrix$1).toVarying("v_tangentWorld").normalize().toVar("tangentWorld");
/**
* Returns the bitangent node and assigns it to a varying if the material is not flat shaded.
*
* @tsl
* @private
* @param {Node<vec3>} crossNormalTangent - The cross product of the normal and tangent vectors.
* @param {string} varyingName - The name of the varying to assign the bitangent to.
* @returns {Node<vec3>} The bitangent node.
*/
var getBitangent = /* @__PURE__ */ Fn$1(([crossNormalTangent, varyingName], { subBuildFn, material }) => {
	let bitangent = crossNormalTangent.mul(tangentGeometry$1.w).xyz;
	if (subBuildFn === "NORMAL" && material.flatShading !== true) bitangent = bitangent.toVarying(varyingName);
	return bitangent;
}).once(["NORMAL"]);
/**
* TSL object that represents the bitangent attribute of the current rendered object.
*
* @tsl
* @type {Node<vec3>}
*/
var bitangentGeometry$1 = /* @__PURE__ */ getBitangent(normalGeometry$1.cross(tangentGeometry$1), "v_bitangentGeometry").normalize().toVar("bitangentGeometry");
/**
* TSL object that represents the vertex bitangent in local space of the current rendered object.
*
* @tsl
* @type {Node<vec3>}
*/
var bitangentLocal$1 = /* @__PURE__ */ getBitangent(normalLocal$1.cross(tangentLocal$1), "v_bitangentLocal").normalize().toVar("bitangentLocal");
/**
* TSL object that represents the vertex bitangent in view space of the current rendered object.
*
* @tsl
* @type {Node<vec3>}
*/
var bitangentView$1 = /* @__PURE__ */ Fn$1(({ subBuildFn, geometry, material }) => {
	let node;
	if (subBuildFn === "VERTEX" || geometry.hasAttribute("tangent")) node = getBitangent(normalView$1.cross(tangentView$1), "v_bitangentView").normalize();
	else node = bitangentViewFrame;
	if (material.flatShading !== true) node = directionToFaceDirection$1(node);
	return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("bitangentView");
/**
* TSL object that represents the vertex bitangent in world space of the current rendered object.
*
* @tsl
* @type {Node<vec3>}
*/
var bitangentWorld$1 = /* @__PURE__ */ getBitangent(normalWorld$1.cross(tangentWorld$1), "v_bitangentWorld").normalize().toVar("bitangentWorld");
/**
* TSL object that represents the TBN matrix in view space.
*
* @tsl
* @type {Node<mat3>}
*/
var TBNViewMatrix$1 = /* @__PURE__ */ mat3$1(tangentView$1, bitangentView$1, normalView$1).toVar("TBNViewMatrix");
/**
* TSL object that represents the parallax direction.
*
* @tsl
* @type {Node<mat3>}
*/
var parallaxDirection$1 = /* @__PURE__ */ positionViewDirection$1.mul(TBNViewMatrix$1);
/**
* TSL function for computing parallax uv coordinates.
*
* @tsl
* @function
* @param {Node<vec2>} uv - A uv node.
* @param {Node<vec2>} scale - A scale node.
* @returns {Node<vec2>} Parallax uv coordinates.
*/
var parallaxUV$1 = (uv$3, scale$3) => uv$3.sub(parallaxDirection$1.mul(scale$3));
/**
* TSL function for computing bent normals.
*
* @tsl
* @function
* @returns {Node<vec3>} Bent normals.
*/
var bentNormalView$1 = /* @__PURE__ */ Fn$1(() => {
	let bentNormal = anisotropyB$1.cross(positionViewDirection$1);
	bentNormal = bentNormal.cross(anisotropyB$1).normalize();
	bentNormal = mix$2(bentNormal, normalView$1, anisotropy$1.mul(roughness$1.oneMinus()).oneMinus().pow2().pow2()).normalize();
	return bentNormal;
}).once()();
/**
* This class can be used for applying normals maps to materials.
*
* ```js
* material.normalNode = normalMap( texture( normalTex ) );
* ```
*
* @augments TempNode
*/
var NormalMapNode = class extends TempNode {
	static get type() {
		return "NormalMapNode";
	}
	/**
	* Constructs a new normal map node.
	*
	* @param {Node<vec3>} node - Represents the normal map data.
	* @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.
	*/
	constructor(node, scaleNode = null) {
		super("vec3");
		/**
		* Represents the normal map data.
		*
		* @type {Node<vec3>}
		*/
		this.node = node;
		/**
		* Controls the intensity of the effect.
		*
		* @type {?Node<vec2>}
		* @default null
		*/
		this.scaleNode = scaleNode;
		/**
		* The normal map type.
		*
		* @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		* @default TangentSpaceNormalMap
		*/
		this.normalMapType = TangentSpaceNormalMap;
	}
	setup({ material }) {
		const { normalMapType, scaleNode } = this;
		let normalMap$2 = this.node.mul(2).sub(1);
		if (scaleNode !== null) {
			let scale$3 = scaleNode;
			if (material.flatShading === true) scale$3 = directionToFaceDirection$1(scale$3);
			normalMap$2 = vec3$1(normalMap$2.xy.mul(scale$3), normalMap$2.z);
		}
		let output$2 = null;
		if (normalMapType === ObjectSpaceNormalMap) output$2 = transformNormalToView$1(normalMap$2);
		else if (normalMapType === TangentSpaceNormalMap) output$2 = TBNViewMatrix$1.mul(normalMap$2).normalize();
		else {
			error(`NodeMaterial: Unsupported normal map type: ${normalMapType}`);
			output$2 = normalView$1;
		}
		return output$2;
	}
};
/**
* TSL function for creating a normal map node.
*
* @tsl
* @function
* @param {Node<vec3>} node - Represents the normal map data.
* @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.
* @returns {NormalMapNode}
*/
var normalMap$1 = /* @__PURE__ */ nodeProxy$1(NormalMapNode).setParameterLength(1, 2);
var dHdxy_fwd = Fn$1(({ textureNode, bumpScale }) => {
	const sampleTexture = (callback) => textureNode.isolate().context({
		getUV: (texNode) => callback(texNode.uvNode || uv$1$1()),
		forceUVContext: true
	});
	const Hll = float$1(sampleTexture((uvNode) => uvNode));
	return vec2$1(float$1(sampleTexture((uvNode) => uvNode.add(uvNode.dFdx()))).sub(Hll), float$1(sampleTexture((uvNode) => uvNode.add(uvNode.dFdy()))).sub(Hll)).mul(bumpScale);
});
var perturbNormalArb = Fn$1((inputs) => {
	const { surf_pos, surf_norm, dHdxy } = inputs;
	const vSigmaX = surf_pos.dFdx().normalize();
	const vSigmaY = surf_pos.dFdy().normalize();
	const vN = surf_norm;
	const R1 = vSigmaY.cross(vN);
	const R2 = vN.cross(vSigmaX);
	const fDet = vSigmaX.dot(R1).mul(faceDirection$1);
	const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
	return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
});
/**
* This class can be used for applying bump maps to materials.
*
* ```js
* material.normalNode = bumpMap( texture( bumpTex ) );
* ```
*
* @augments TempNode
*/
var BumpMapNode = class extends TempNode {
	static get type() {
		return "BumpMapNode";
	}
	/**
	* Constructs a new bump map node.
	*
	* @param {Node<float>} textureNode - Represents the bump map data.
	* @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.
	*/
	constructor(textureNode, scaleNode = null) {
		super("vec3");
		/**
		* Represents the bump map data.
		*
		* @type {Node<float>}
		*/
		this.textureNode = textureNode;
		/**
		* Controls the intensity of the bump effect.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.scaleNode = scaleNode;
	}
	setup() {
		const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
		const dHdxy = dHdxy_fwd({
			textureNode: this.textureNode,
			bumpScale
		});
		return perturbNormalArb({
			surf_pos: positionView$1,
			surf_norm: normalView$1,
			dHdxy
		});
	}
};
/**
* TSL function for creating a bump map node.
*
* @tsl
* @function
* @param {Node<float>} textureNode - Represents the bump map data.
* @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.
* @returns {BumpMapNode}
*/
var bumpMap$1 = /* @__PURE__ */ nodeProxy$1(BumpMapNode).setParameterLength(1, 2);
var _propertyCache = /* @__PURE__ */ new Map();
/**
* This class should simplify the node access to material properties.
* It internal uses reference nodes to make sure  changes to material
* properties are automatically reflected to predefined TSL objects
* like e.g. `materialColor`.
*
* @augments Node
*/
var MaterialNode = class MaterialNode extends Node {
	static get type() {
		return "MaterialNode";
	}
	/**
	* Constructs a new material node.
	*
	* @param {string} scope - The scope defines what kind of material property is referred by the node.
	*/
	constructor(scope) {
		super();
		/**
		* The scope defines what material property is referred by the node.
		*
		* @type {string}
		*/
		this.scope = scope;
	}
	/**
	* Returns a cached reference node for the given property and type.
	*
	* @param {string} property - The name of the material property.
	* @param {string} type - The uniform type of the property.
	* @return {MaterialReferenceNode} A material reference node representing the property access.
	*/
	getCache(property$2, type$1) {
		let node = _propertyCache.get(property$2);
		if (node === void 0) {
			node = materialReference$1(property$2, type$1);
			_propertyCache.set(property$2, node);
		}
		return node;
	}
	/**
	* Returns a float-typed material reference node for the given property name.
	*
	* @param {string} property - The name of the material property.
	* @return {MaterialReferenceNode<float>} A material reference node representing the property access.
	*/
	getFloat(property$2) {
		return this.getCache(property$2, "float");
	}
	/**
	* Returns a color-typed material reference node for the given property name.
	*
	* @param {string} property - The name of the material property.
	* @return {MaterialReferenceNode<color>} A material reference node representing the property access.
	*/
	getColor(property$2) {
		return this.getCache(property$2, "color");
	}
	/**
	* Returns a texture-typed material reference node for the given property name.
	*
	* @param {string} property - The name of the material property.
	* @return {MaterialReferenceNode} A material reference node representing the property access.
	*/
	getTexture(property$2) {
		return this.getCache(property$2 === "map" ? "map" : property$2 + "Map", "texture");
	}
	/**
	* The node setup is done depending on the selected scope. Multiple material properties
	* might be grouped into a single node composition if they logically belong together.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node} The node representing the selected scope.
	*/
	setup(builder) {
		const material = builder.context.material;
		const scope = this.scope;
		let node = null;
		if (scope === MaterialNode.COLOR) {
			const colorNode = material.color !== void 0 ? this.getColor(scope) : vec3$1();
			if (material.map && material.map.isTexture === true) node = colorNode.mul(this.getTexture("map"));
			else node = colorNode;
		} else if (scope === MaterialNode.OPACITY) {
			const opacityNode = this.getFloat(scope);
			if (material.alphaMap && material.alphaMap.isTexture === true) node = opacityNode.mul(this.getTexture("alpha"));
			else node = opacityNode;
		} else if (scope === MaterialNode.SPECULAR_STRENGTH) if (material.specularMap && material.specularMap.isTexture === true) node = this.getTexture("specular").r;
		else node = float$1(1);
		else if (scope === MaterialNode.SPECULAR_INTENSITY) {
			const specularIntensityNode = this.getFloat(scope);
			if (material.specularIntensityMap && material.specularIntensityMap.isTexture === true) node = specularIntensityNode.mul(this.getTexture(scope).a);
			else node = specularIntensityNode;
		} else if (scope === MaterialNode.SPECULAR_COLOR) {
			const specularColorNode = this.getColor(scope);
			if (material.specularColorMap && material.specularColorMap.isTexture === true) node = specularColorNode.mul(this.getTexture(scope).rgb);
			else node = specularColorNode;
		} else if (scope === MaterialNode.ROUGHNESS) {
			const roughnessNode = this.getFloat(scope);
			if (material.roughnessMap && material.roughnessMap.isTexture === true) node = roughnessNode.mul(this.getTexture(scope).g);
			else node = roughnessNode;
		} else if (scope === MaterialNode.METALNESS) {
			const metalnessNode = this.getFloat(scope);
			if (material.metalnessMap && material.metalnessMap.isTexture === true) node = metalnessNode.mul(this.getTexture(scope).b);
			else node = metalnessNode;
		} else if (scope === MaterialNode.EMISSIVE) {
			const emissiveIntensityNode = this.getFloat("emissiveIntensity");
			const emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);
			if (material.emissiveMap && material.emissiveMap.isTexture === true) node = emissiveNode.mul(this.getTexture(scope));
			else node = emissiveNode;
		} else if (scope === MaterialNode.NORMAL) if (material.normalMap) {
			node = normalMap$1(this.getTexture("normal"), this.getCache("normalScale", "vec2"));
			node.normalMapType = material.normalMapType;
		} else if (material.bumpMap) node = bumpMap$1(this.getTexture("bump").r, this.getFloat("bumpScale"));
		else node = normalView$1;
		else if (scope === MaterialNode.CLEARCOAT) {
			const clearcoatNode = this.getFloat(scope);
			if (material.clearcoatMap && material.clearcoatMap.isTexture === true) node = clearcoatNode.mul(this.getTexture(scope).r);
			else node = clearcoatNode;
		} else if (scope === MaterialNode.CLEARCOAT_ROUGHNESS) {
			const clearcoatRoughnessNode = this.getFloat(scope);
			if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
			else node = clearcoatRoughnessNode;
		} else if (scope === MaterialNode.CLEARCOAT_NORMAL) if (material.clearcoatNormalMap) node = normalMap$1(this.getTexture(scope), this.getCache(scope + "Scale", "vec2"));
		else node = normalView$1;
		else if (scope === MaterialNode.SHEEN) {
			const sheenNode = this.getColor("sheenColor").mul(this.getFloat("sheen"));
			if (material.sheenColorMap && material.sheenColorMap.isTexture === true) node = sheenNode.mul(this.getTexture("sheenColor").rgb);
			else node = sheenNode;
		} else if (scope === MaterialNode.SHEEN_ROUGHNESS) {
			const sheenRoughnessNode = this.getFloat(scope);
			if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) node = sheenRoughnessNode.mul(this.getTexture(scope).a);
			else node = sheenRoughnessNode;
			node = node.clamp(.07, 1);
		} else if (scope === MaterialNode.ANISOTROPY) if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {
			const anisotropyPolar = this.getTexture(scope);
			node = mat2$1(materialAnisotropyVector$1.x, materialAnisotropyVector$1.y, materialAnisotropyVector$1.y.negate(), materialAnisotropyVector$1.x).mul(anisotropyPolar.rg.mul(2).sub(vec2$1(1)).normalize().mul(anisotropyPolar.b));
		} else node = materialAnisotropyVector$1;
		else if (scope === MaterialNode.IRIDESCENCE_THICKNESS) {
			const iridescenceThicknessMaximum = reference$2("1", "float", material.iridescenceThicknessRange);
			if (material.iridescenceThicknessMap) {
				const iridescenceThicknessMinimum = reference$2("0", "float", material.iridescenceThicknessRange);
				node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);
			} else node = iridescenceThicknessMaximum;
		} else if (scope === MaterialNode.TRANSMISSION) {
			const transmissionNode = this.getFloat(scope);
			if (material.transmissionMap) node = transmissionNode.mul(this.getTexture(scope).r);
			else node = transmissionNode;
		} else if (scope === MaterialNode.THICKNESS) {
			const thicknessNode = this.getFloat(scope);
			if (material.thicknessMap) node = thicknessNode.mul(this.getTexture(scope).g);
			else node = thicknessNode;
		} else if (scope === MaterialNode.IOR) node = this.getFloat(scope);
		else if (scope === MaterialNode.LIGHT_MAP) node = this.getTexture(scope).rgb.mul(this.getFloat("lightMapIntensity"));
		else if (scope === MaterialNode.AO) node = this.getTexture(scope).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
		else if (scope === MaterialNode.LINE_DASH_OFFSET) node = material.dashOffset ? this.getFloat(scope) : float$1(0);
		else {
			const outputType = this.getNodeType(builder);
			node = this.getCache(scope, outputType);
		}
		return node;
	}
};
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR = "specular";
MaterialNode.SPECULAR_STRENGTH = "specularStrength";
MaterialNode.SPECULAR_INTENSITY = "specularIntensity";
MaterialNode.SPECULAR_COLOR = "specularColor";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.NORMAL = "normal";
MaterialNode.CLEARCOAT = "clearcoat";
MaterialNode.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
MaterialNode.CLEARCOAT_NORMAL = "clearcoatNormal";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.SHEEN = "sheen";
MaterialNode.SHEEN_ROUGHNESS = "sheenRoughness";
MaterialNode.ANISOTROPY = "anisotropy";
MaterialNode.IRIDESCENCE = "iridescence";
MaterialNode.IRIDESCENCE_IOR = "iridescenceIOR";
MaterialNode.IRIDESCENCE_THICKNESS = "iridescenceThickness";
MaterialNode.IOR = "ior";
MaterialNode.TRANSMISSION = "transmission";
MaterialNode.THICKNESS = "thickness";
MaterialNode.ATTENUATION_DISTANCE = "attenuationDistance";
MaterialNode.ATTENUATION_COLOR = "attenuationColor";
MaterialNode.LINE_SCALE = "scale";
MaterialNode.LINE_DASH_SIZE = "dashSize";
MaterialNode.LINE_GAP_SIZE = "gapSize";
MaterialNode.LINE_WIDTH = "linewidth";
MaterialNode.LINE_DASH_OFFSET = "dashOffset";
MaterialNode.POINT_SIZE = "size";
MaterialNode.DISPERSION = "dispersion";
MaterialNode.LIGHT_MAP = "light";
MaterialNode.AO = "ao";
/**
* TSL object that represents alpha test of the current material.
*
* @tsl
* @type {Node<float>}
*/
var materialAlphaTest$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.ALPHA_TEST);
/**
* TSL object that represents the diffuse color of the current material.
* The value is composed via `color` * `map`.
*
* @tsl
* @type {Node<vec3>}
*/
var materialColor$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.COLOR);
/**
* TSL object that represents the shininess of the current material.
*
* @tsl
* @type {Node<float>}
*/
var materialShininess$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.SHININESS);
/**
* TSL object that represents the emissive color of the current material.
* The value is composed via `emissive` * `emissiveIntensity` * `emissiveMap`.
*
* @tsl
* @type {Node<vec3>}
*/
var materialEmissive$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.EMISSIVE);
/**
* TSL object that represents the opacity of the current material.
* The value is composed via `opacity` * `alphaMap`.
*
* @tsl
* @type {Node<float>}
*/
var materialOpacity$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.OPACITY);
/**
* TSL object that represents the specular of the current material.
*
* @tsl
* @type {Node<vec3>}
*/
var materialSpecular$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.SPECULAR);
/**
* TSL object that represents the specular intensity of the current material.
* The value is composed via `specularIntensity` * `specularMap.a`.
*
* @tsl
* @type {Node<float>}
*/
var materialSpecularIntensity$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.SPECULAR_INTENSITY);
/**
* TSL object that represents the specular color of the current material.
* The value is composed via `specularColor` * `specularMap.rgb`.
*
* @tsl
* @type {Node<vec3>}
*/
var materialSpecularColor$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.SPECULAR_COLOR);
/**
* TSL object that represents the specular strength of the current material.
* The value is composed via `specularMap.r`.
*
* @tsl
* @type {Node<float>}
*/
var materialSpecularStrength$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.SPECULAR_STRENGTH);
/**
* TSL object that represents the reflectivity of the current material.
*
* @tsl
* @type {Node<float>}
*/
var materialReflectivity$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.REFLECTIVITY);
/**
* TSL object that represents the roughness of the current material.
* The value is composed via `roughness` * `roughnessMap.g`.
*
* @tsl
* @type {Node<float>}
*/
var materialRoughness$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.ROUGHNESS);
/**
* TSL object that represents the metalness of the current material.
* The value is composed via `metalness` * `metalnessMap.b`.
*
* @tsl
* @type {Node<float>}
*/
var materialMetalness$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.METALNESS);
/**
* TSL object that represents the normal of the current material.
* The value will be either `normalMap` * `normalScale`, `bumpMap` * `bumpScale` or `normalView`.
*
* @tsl
* @type {Node<vec3>}
*/
var materialNormal$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.NORMAL);
/**
* TSL object that represents the clearcoat of the current material.
* The value is composed via `clearcoat` * `clearcoatMap.r`
*
* @tsl
* @type {Node<float>}
*/
var materialClearcoat$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.CLEARCOAT);
/**
* TSL object that represents the clearcoat roughness of the current material.
* The value is composed via `clearcoatRoughness` * `clearcoatRoughnessMap.r`.
*
* @tsl
* @type {Node<float>}
*/
var materialClearcoatRoughness$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);
/**
* TSL object that represents the clearcoat normal of the current material.
* The value will be either `clearcoatNormalMap` or `normalView`.
*
* @tsl
* @type {Node<vec3>}
*/
var materialClearcoatNormal$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.CLEARCOAT_NORMAL);
/**
* TSL object that represents the rotation of the current sprite material.
*
* @tsl
* @type {Node<float>}
*/
var materialRotation$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.ROTATION);
/**
* TSL object that represents the sheen color of the current material.
* The value is composed via `sheen` * `sheenColor` * `sheenColorMap`.
*
* @tsl
* @type {Node<vec3>}
*/
var materialSheen$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.SHEEN);
/**
* TSL object that represents the sheen roughness of the current material.
* The value is composed via `sheenRoughness` * `sheenRoughnessMap.a`.
*
* @tsl
* @type {Node<float>}
*/
var materialSheenRoughness$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);
/**
* TSL object that represents the anisotropy of the current material.
*
* @tsl
* @type {Node<vec2>}
*/
var materialAnisotropy$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.ANISOTROPY);
/**
* TSL object that represents the iridescence of the current material.
*
* @tsl
* @type {Node<float>}
*/
var materialIridescence$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.IRIDESCENCE);
/**
* TSL object that represents the iridescence IOR of the current material.
*
* @tsl
* @type {Node<float>}
*/
var materialIridescenceIOR$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.IRIDESCENCE_IOR);
/**
* TSL object that represents the iridescence thickness of the current material.
*
* @tsl
* @type {Node<float>}
*/
var materialIridescenceThickness$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);
/**
* TSL object that represents the transmission of the current material.
* The value is composed via `transmission` * `transmissionMap.r`.
*
* @tsl
* @type {Node<float>}
*/
var materialTransmission$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.TRANSMISSION);
/**
* TSL object that represents the thickness of the current material.
* The value is composed via `thickness` * `thicknessMap.g`.
*
* @tsl
* @type {Node<float>}
*/
var materialThickness$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.THICKNESS);
/**
* TSL object that represents the IOR of the current material.
*
* @tsl
* @type {Node<float>}
*/
var materialIOR$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.IOR);
/**
* TSL object that represents the attenuation distance of the current material.
*
* @tsl
* @type {Node<float>}
*/
var materialAttenuationDistance$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);
/**
* TSL object that represents the attenuation color of the current material.
*
* @tsl
* @type {Node<vec3>}
*/
var materialAttenuationColor$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.ATTENUATION_COLOR);
/**
* TSL object that represents the scale of the current dashed line material.
*
* @tsl
* @type {Node<float>}
*/
var materialLineScale$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.LINE_SCALE);
/**
* TSL object that represents the dash size of the current dashed line material.
*
* @tsl
* @type {Node<float>}
*/
var materialLineDashSize$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.LINE_DASH_SIZE);
/**
* TSL object that represents the gap size of the current dashed line material.
*
* @tsl
* @type {Node<float>}
*/
var materialLineGapSize$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.LINE_GAP_SIZE);
/**
* TSL object that represents the line width of the current line material.
*
* @tsl
* @type {Node<float>}
*/
var materialLineWidth$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.LINE_WIDTH);
/**
* TSL object that represents the dash offset of the current line material.
*
* @tsl
* @type {Node<float>}
*/
var materialLineDashOffset$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.LINE_DASH_OFFSET);
/**
* TSL object that represents the point size of the current points material.
*
* @tsl
* @type {Node<float>}
*/
var materialPointSize$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.POINT_SIZE);
/**
* TSL object that represents the dispersion of the current material.
*
* @tsl
* @type {Node<float>}
*/
var materialDispersion$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.DISPERSION);
/**
* TSL object that represents the light map of the current material.
* The value is composed via `lightMapIntensity` * `lightMap.rgb`.
*
* @tsl
* @type {Node<vec3>}
*/
var materialLightMap$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.LIGHT_MAP);
/**
* TSL object that represents the ambient occlusion map of the current material.
* The value is composed via `aoMap.r` - 1 * `aoMapIntensity` + 1.
*
* @tsl
* @type {Node<float>}
*/
var materialAO$1 = /* @__PURE__ */ nodeImmutable$1(MaterialNode, MaterialNode.AO);
/**
* TSL object that represents the anisotropy vector of the current material.
*
* @tsl
* @type {Node<vec2>}
*/
var materialAnisotropyVector$1 = /* @__PURE__ */ uniform$1(new Vector2()).onReference(function(frame) {
	return frame.material;
}).onRenderUpdate(function({ material }) {
	this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
});
/**
* TSL object that represents the position in clip space after the model-view-projection transform of the current rendered object.
*
* @tsl
* @type {VaryingNode<vec4>}
*/
var modelViewProjection$1 = /* @__PURE__ */ Fn$1((builder) => {
	return builder.context.setupModelViewProjection();
}, "vec4").once()().toVarying("v_modelViewProjection");
/**
* This class represents shader indices of different types. The following predefined node
* objects cover frequent use cases:
*
* - `vertexIndex`: The index of a vertex within a mesh.
* - `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.
* - `drawIndex`: The index of a draw call.
* - `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.
* - `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.
* - `subgroupIndex`: The index of a compute invocation's subgroup within its workgroup.
*
* @augments Node
*/
var IndexNode = class IndexNode extends Node {
	static get type() {
		return "IndexNode";
	}
	/**
	* Constructs a new index node.
	*
	* @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationGlobal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.
	*/
	constructor(scope) {
		super("uint");
		/**
		* The scope of the index node.
		*
		* @type {string}
		*/
		this.scope = scope;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isIndexNode = true;
	}
	generate(builder) {
		const nodeType = this.getNodeType(builder);
		const scope = this.scope;
		let propertyName;
		if (scope === IndexNode.VERTEX) propertyName = builder.getVertexIndex();
		else if (scope === IndexNode.INSTANCE) propertyName = builder.getInstanceIndex();
		else if (scope === IndexNode.DRAW) propertyName = builder.getDrawIndex();
		else if (scope === IndexNode.INVOCATION_LOCAL) propertyName = builder.getInvocationLocalIndex();
		else if (scope === IndexNode.INVOCATION_SUBGROUP) propertyName = builder.getInvocationSubgroupIndex();
		else if (scope === IndexNode.SUBGROUP) propertyName = builder.getSubgroupIndex();
		else throw new Error("THREE.IndexNode: Unknown scope: " + scope);
		let output$2;
		if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") output$2 = propertyName;
		else output$2 = varying$1(this).build(builder, nodeType);
		return output$2;
	}
};
IndexNode.VERTEX = "vertex";
IndexNode.INSTANCE = "instance";
IndexNode.SUBGROUP = "subgroup";
IndexNode.INVOCATION_LOCAL = "invocationLocal";
IndexNode.INVOCATION_SUBGROUP = "invocationSubgroup";
IndexNode.DRAW = "draw";
/**
* TSL object that represents the index of a vertex within a mesh.
*
* @tsl
* @type {IndexNode}
*/
var vertexIndex$1 = /* @__PURE__ */ nodeImmutable$1(IndexNode, IndexNode.VERTEX);
/**
* TSL object that represents the index of either a mesh instance or an invocation of a compute shader.
*
* @tsl
* @type {IndexNode}
*/
var instanceIndex$1 = /* @__PURE__ */ nodeImmutable$1(IndexNode, IndexNode.INSTANCE);
/**
* TSL object that represents the index of the subgroup the current compute invocation belongs to.
*
* @tsl
* @type {IndexNode}
*/
var subgroupIndex$1 = /* @__PURE__ */ nodeImmutable$1(IndexNode, IndexNode.SUBGROUP);
/**
* TSL object that represents the index of a compute invocation within the scope of a subgroup.
*
* @tsl
* @type {IndexNode}
*/
var invocationSubgroupIndex$1 = /* @__PURE__ */ nodeImmutable$1(IndexNode, IndexNode.INVOCATION_SUBGROUP);
/**
* TSL object that represents the index of a compute invocation within the scope of a workgroup load.
*
* @tsl
* @type {IndexNode}
*/
var invocationLocalIndex$1 = /* @__PURE__ */ nodeImmutable$1(IndexNode, IndexNode.INVOCATION_LOCAL);
/**
* TSL object that represents the index of a draw call.
*
* @tsl
* @type {IndexNode}
*/
var drawIndex$1 = /* @__PURE__ */ nodeImmutable$1(IndexNode, IndexNode.DRAW);
/**
* This node implements the vertex shader logic which is required
* when rendering 3D objects via instancing. The code makes sure
* vertex positions, normals and colors can be modified via instanced
* data.
*
* @augments Node
*/
var InstanceNode = class extends Node {
	static get type() {
		return "InstanceNode";
	}
	/**
	* Constructs a new instance node.
	*
	* @param {number} count - The number of instances.
	* @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
	* @param {?InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
	*/
	constructor(count, instanceMatrix, instanceColor = null) {
		super("void");
		/**
		* The number of instances.
		*
		* @type {number}
		*/
		this.count = count;
		/**
		* Instanced buffer attribute representing the transformation of instances.
		*
		* @type {InstancedBufferAttribute}
		*/
		this.instanceMatrix = instanceMatrix;
		/**
		* Instanced buffer attribute representing the color of instances.
		*
		* @type {InstancedBufferAttribute}
		*/
		this.instanceColor = instanceColor;
		/**
		* The node that represents the instance matrix data.
		*
		* @type {?Node}
		*/
		this.instanceMatrixNode = null;
		/**
		* The node that represents the instance color data.
		*
		* @type {?Node}
		* @default null
		*/
		this.instanceColorNode = null;
		/**
		* The update type is set to `frame` since an update
		* of instanced buffer data must be checked per frame.
		*
		* @type {string}
		* @default 'frame'
		*/
		this.updateType = NodeUpdateType$1.FRAME;
		/**
		* A reference to a buffer that is used by `instanceMatrixNode`.
		*
		* @type {?InstancedInterleavedBuffer}
		*/
		this.buffer = null;
		/**
		* A reference to a buffer that is used by `instanceColorNode`.
		*
		* @type {?InstancedBufferAttribute}
		*/
		this.bufferColor = null;
	}
	/**
	* Setups the internal buffers and nodes and assigns the transformed vertex data
	* to predefined node variables for accumulation. That follows the same patterns
	* like with morph and skinning nodes.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setup(builder) {
		const { instanceMatrix, instanceColor } = this;
		const { count } = instanceMatrix;
		let { instanceMatrixNode, instanceColorNode } = this;
		if (instanceMatrixNode === null) {
			if (count <= 1e3) instanceMatrixNode = buffer$1(instanceMatrix.array, "mat4", Math.max(count, 1)).element(instanceIndex$1);
			else {
				const buffer$2 = new InstancedInterleavedBuffer(instanceMatrix.array, 16, 1);
				this.buffer = buffer$2;
				const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute$1 : instancedBufferAttribute$1;
				const instanceBuffers = [
					bufferFn(buffer$2, "vec4", 16, 0),
					bufferFn(buffer$2, "vec4", 16, 4),
					bufferFn(buffer$2, "vec4", 16, 8),
					bufferFn(buffer$2, "vec4", 16, 12)
				];
				instanceMatrixNode = mat4$1(...instanceBuffers);
			}
			this.instanceMatrixNode = instanceMatrixNode;
		}
		if (instanceColor && instanceColorNode === null) {
			const buffer$2 = new InstancedBufferAttribute(instanceColor.array, 3);
			const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute$1 : instancedBufferAttribute$1;
			this.bufferColor = buffer$2;
			instanceColorNode = vec3$1(bufferFn(buffer$2, "vec3", 3, 0));
			this.instanceColorNode = instanceColorNode;
		}
		const instancePosition = instanceMatrixNode.mul(positionLocal$1).xyz;
		positionLocal$1.assign(instancePosition);
		if (builder.hasGeometryAttribute("normal")) {
			const instanceNormal = transformNormal$1(normalLocal$1, instanceMatrixNode);
			normalLocal$1.assign(instanceNormal);
		}
		if (this.instanceColorNode !== null) varyingProperty$1("vec3", "vInstanceColor").assign(this.instanceColorNode);
	}
	/**
	* Checks if the internal buffers required an update.
	*
	* @param {NodeFrame} frame - The current node frame.
	*/
	update() {
		if (this.buffer !== null) {
			this.buffer.clearUpdateRanges();
			this.buffer.updateRanges.push(...this.instanceMatrix.updateRanges);
			if (this.instanceMatrix.usage !== DynamicDrawUsage && this.instanceMatrix.version !== this.buffer.version) this.buffer.version = this.instanceMatrix.version;
		}
		if (this.instanceColor && this.bufferColor !== null) {
			this.bufferColor.clearUpdateRanges();
			this.bufferColor.updateRanges.push(...this.instanceColor.updateRanges);
			if (this.instanceColor.usage !== DynamicDrawUsage && this.instanceColor.version !== this.bufferColor.version) this.bufferColor.version = this.instanceColor.version;
		}
	}
};
/**
* TSL function for creating an instance node.
*
* @tsl
* @function
* @param {number} count - The number of instances.
* @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
* @param {?InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
* @returns {InstanceNode}
*/
var instance$1 = /* @__PURE__ */ nodeProxy$1(InstanceNode).setParameterLength(2, 3);
/**
* This is a special version of `InstanceNode` which requires the usage of {@link InstancedMesh}.
* It allows an easier setup of the instance node.
*
* @augments InstanceNode
*/
var InstancedMeshNode = class extends InstanceNode {
	static get type() {
		return "InstancedMeshNode";
	}
	/**
	* Constructs a new instanced mesh node.
	*
	* @param {InstancedMesh} instancedMesh - The instanced mesh.
	*/
	constructor(instancedMesh$2) {
		const { count, instanceMatrix, instanceColor } = instancedMesh$2;
		super(count, instanceMatrix, instanceColor);
		/**
		* A reference to the instanced mesh.
		*
		* @type {InstancedMesh}
		*/
		this.instancedMesh = instancedMesh$2;
	}
};
/**
* TSL function for creating an instanced mesh node.
*
* @tsl
* @function
* @param {InstancedMesh} instancedMesh - The instancedMesh.
* @returns {InstancedMeshNode}
*/
var instancedMesh$1 = /* @__PURE__ */ nodeProxy$1(InstancedMeshNode).setParameterLength(1);
/**
* This node implements the vertex shader logic which is required
* when rendering 3D objects via batching. `BatchNode` must be used
* with instances of {@link BatchedMesh}.
*
* @augments Node
*/
var BatchNode = class extends Node {
	static get type() {
		return "BatchNode";
	}
	/**
	* Constructs a new batch node.
	*
	* @param {BatchedMesh} batchMesh - A reference to batched mesh.
	*/
	constructor(batchMesh) {
		super("void");
		/**
		* A reference to batched mesh.
		*
		* @type {BatchedMesh}
		*/
		this.batchMesh = batchMesh;
		/**
		* The batching index node.
		*
		* @type {?IndexNode}
		* @default null
		*/
		this.batchingIdNode = null;
	}
	/**
	* Setups the internal buffers and nodes and assigns the transformed vertex data
	* to predefined node variables for accumulation. That follows the same patterns
	* like with morph and skinning nodes.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setup(builder) {
		if (this.batchingIdNode === null) if (builder.getDrawIndex() === null) this.batchingIdNode = instanceIndex$1;
		else this.batchingIdNode = drawIndex$1;
		const indirectId = Fn$1(([id]) => {
			const size$1 = int$1(textureSize$1(textureLoad$1(this.batchMesh._indirectTexture), 0).x);
			const x$1 = int$1(id).mod(size$1);
			const y$1 = int$1(id).div(size$1);
			return textureLoad$1(this.batchMesh._indirectTexture, ivec2$1(x$1, y$1)).x;
		}).setLayout({
			name: "getIndirectIndex",
			type: "uint",
			inputs: [{
				name: "id",
				type: "int"
			}]
		})(int$1(this.batchingIdNode));
		const matricesTexture = this.batchMesh._matricesTexture;
		const size = int$1(textureSize$1(textureLoad$1(matricesTexture), 0).x);
		const j = float$1(indirectId).mul(4).toInt().toVar();
		const x = j.mod(size);
		const y = j.div(size);
		const batchingMatrix = mat4$1(textureLoad$1(matricesTexture, ivec2$1(x, y)), textureLoad$1(matricesTexture, ivec2$1(x.add(1), y)), textureLoad$1(matricesTexture, ivec2$1(x.add(2), y)), textureLoad$1(matricesTexture, ivec2$1(x.add(3), y)));
		const colorsTexture = this.batchMesh._colorsTexture;
		if (colorsTexture !== null) {
			const color$2 = Fn$1(([id]) => {
				const size$1 = int$1(textureSize$1(textureLoad$1(colorsTexture), 0).x);
				const j$1 = id;
				const x$1 = j$1.mod(size$1);
				const y$1 = j$1.div(size$1);
				return textureLoad$1(colorsTexture, ivec2$1(x$1, y$1)).rgb;
			}).setLayout({
				name: "getBatchingColor",
				type: "vec3",
				inputs: [{
					name: "id",
					type: "int"
				}]
			})(indirectId);
			varyingProperty$1("vec3", "vBatchColor").assign(color$2);
		}
		const bm = mat3$1(batchingMatrix);
		positionLocal$1.assign(batchingMatrix.mul(positionLocal$1));
		const transformedNormal = normalLocal$1.div(vec3$1(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));
		const batchingNormal = bm.mul(transformedNormal).xyz;
		normalLocal$1.assign(batchingNormal);
		if (builder.hasGeometryAttribute("tangent")) tangentLocal$1.mulAssign(bm);
	}
};
/**
* TSL function for creating a batch node.
*
* @tsl
* @function
* @param {BatchedMesh} batchMesh - A reference to batched mesh.
* @returns {BatchNode}
*/
var batch$1 = /* @__PURE__ */ nodeProxy$1(BatchNode).setParameterLength(1);
/**
* This class enables element access on instances of {@link StorageBufferNode}.
* In most cases, it is indirectly used when accessing elements with the
* {@link StorageBufferNode#element} method.
*
* ```js
* const position = positionStorage.element( instanceIndex );
* ```
*
* @augments ArrayElementNode
*/
var StorageArrayElementNode = class extends ArrayElementNode {
	static get type() {
		return "StorageArrayElementNode";
	}
	/**
	* Constructs storage buffer element node.
	*
	* @param {StorageBufferNode} storageBufferNode - The storage buffer node.
	* @param {Node} indexNode - The index node that defines the element access.
	*/
	constructor(storageBufferNode, indexNode) {
		super(storageBufferNode, indexNode);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isStorageArrayElementNode = true;
	}
	/**
	* The storage buffer node.
	*
	* @param {Node} value
	* @type {StorageBufferNode}
	*/
	set storageBufferNode(value) {
		this.node = value;
	}
	get storageBufferNode() {
		return this.node;
	}
	getMemberType(builder, name) {
		const structTypeNode = this.storageBufferNode.structTypeNode;
		if (structTypeNode) return structTypeNode.getMemberType(builder, name);
		return "void";
	}
	setup(builder) {
		if (builder.isAvailable("storageBuffer") === false) {
			if (this.node.isPBO === true) builder.setupPBO(this.node);
		}
		return super.setup(builder);
	}
	generate(builder, output$2) {
		let snippet;
		const isAssignContext = builder.context.assign;
		if (builder.isAvailable("storageBuffer") === false) if (this.node.isPBO === true && isAssignContext !== true && (this.node.value.isInstancedBufferAttribute || builder.shaderStage !== "compute")) snippet = builder.generatePBO(this);
		else snippet = this.node.build(builder);
		else snippet = super.generate(builder);
		if (isAssignContext !== true) {
			const type$1 = this.getNodeType(builder);
			snippet = builder.format(snippet, type$1, output$2);
		}
		return snippet;
	}
};
/**
* TSL function for creating a storage element node.
*
* @tsl
* @function
* @param {StorageBufferNode} storageBufferNode - The storage buffer node.
* @param {Node} indexNode - The index node that defines the element access.
* @returns {StorageArrayElementNode}
*/
var storageElement = /* @__PURE__ */ nodeProxy$1(StorageArrayElementNode).setParameterLength(2);
/**
* This node is used in context of compute shaders and allows to define a
* storage buffer for data. A typical workflow is to create instances of
* this node with the convenience functions `attributeArray()` or `instancedArray()`,
* setup up a compute shader that writes into the buffers and then convert
* the storage buffers to attribute nodes for rendering.
*
* ```js
* const positionBuffer = instancedArray( particleCount, 'vec3' ); // the storage buffer node
*
* const computeInit = Fn( () => { // the compute shader
*
* 	const position = positionBuffer.element( instanceIndex );
*
* 	// compute position data
*
* 	position.x = 1;
* 	position.y = 1;
* 	position.z = 1;
*
* } )().compute( particleCount );
*
* const particleMaterial = new THREE.SpriteNodeMaterial();
* particleMaterial.positionNode = positionBuffer.toAttribute();
*
* renderer.computeAsync( computeInit );
*
* ```
*
* @augments BufferNode
*/
var StorageBufferNode = class extends BufferNode {
	static get type() {
		return "StorageBufferNode";
	}
	/**
	* Constructs a new storage buffer node.
	*
	* @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.
	* @param {?(string|Struct)} [bufferType=null] - The buffer type (e.g. `'vec3'`).
	* @param {number} [bufferCount=0] - The buffer count.
	*/
	constructor(value, bufferType = null, bufferCount = 0) {
		let nodeType, structTypeNode = null;
		if (bufferType && bufferType.isStruct) {
			nodeType = "struct";
			structTypeNode = bufferType.layout;
			if (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute) bufferCount = value.count;
		} else if (bufferType === null && (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute)) {
			nodeType = getTypeFromLength(value.itemSize);
			bufferCount = value.count;
		} else nodeType = bufferType;
		super(value, nodeType, bufferCount);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isStorageBufferNode = true;
		/**
		* The buffer struct type.
		*
		* @type {?StructTypeNode}
		* @default null
		*/
		this.structTypeNode = structTypeNode;
		/**
		* The access type of the texture node.
		*
		* @type {string}
		* @default 'readWrite'
		*/
		this.access = NodeAccess$1.READ_WRITE;
		/**
		* Whether the node is atomic or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.isAtomic = false;
		/**
		* Whether the node represents a PBO or not.
		* Only relevant for WebGL.
		*
		* @type {boolean}
		* @default false
		*/
		this.isPBO = false;
		/**
		* A reference to the internal buffer attribute node.
		*
		* @type {?BufferAttributeNode}
		* @default null
		*/
		this._attribute = null;
		/**
		* A reference to the internal varying node.
		*
		* @type {?VaryingNode}
		* @default null
		*/
		this._varying = null;
		/**
		* `StorageBufferNode` sets this property to `true` by default.
		*
		* @type {boolean}
		* @default true
		*/
		this.global = true;
		if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;
		else value.isStorageBufferAttribute = true;
	}
	/**
	* This method is overwritten since the buffer data might be shared
	* and thus the hash should be shared as well.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The hash.
	*/
	getHash(builder) {
		if (this.bufferCount === 0) {
			let bufferData = builder.globalCache.getData(this.value);
			if (bufferData === void 0) {
				bufferData = { node: this };
				builder.globalCache.setData(this.value, bufferData);
			}
			return bufferData.node.uuid;
		}
		return this.uuid;
	}
	/**
	* Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType() {
		return this.value.isIndirectStorageBufferAttribute ? "indirectStorageBuffer" : "storageBuffer";
	}
	/**
	* Enables element access with the given index node.
	*
	* @param {IndexNode} indexNode - The index node.
	* @return {StorageArrayElementNode} A node representing the element access.
	*/
	element(indexNode) {
		return storageElement(this, indexNode);
	}
	/**
	* Defines whether this node is a PBO or not. Only relevant for WebGL.
	*
	* @param {boolean} value - The value so set.
	* @return {StorageBufferNode} A reference to this node.
	*/
	setPBO(value) {
		this.isPBO = value;
		return this;
	}
	/**
	* Returns the `isPBO` value.
	*
	* @return {boolean} Whether the node represents a PBO or not.
	*/
	getPBO() {
		return this.isPBO;
	}
	/**
	* Defines the node access.
	*
	* @param {string} value - The node access.
	* @return {StorageBufferNode} A reference to this node.
	*/
	setAccess(value) {
		this.access = value;
		return this;
	}
	/**
	* Convenience method for configuring a read-only node access.
	*
	* @return {StorageBufferNode} A reference to this node.
	*/
	toReadOnly() {
		return this.setAccess(NodeAccess$1.READ_ONLY);
	}
	/**
	* Defines whether the node is atomic or not.
	*
	* @param {boolean} value - The atomic flag.
	* @return {StorageBufferNode} A reference to this node.
	*/
	setAtomic(value) {
		this.isAtomic = value;
		return this;
	}
	/**
	* Convenience method for making this node atomic.
	*
	* @return {StorageBufferNode} A reference to this node.
	*/
	toAtomic() {
		return this.setAtomic(true);
	}
	/**
	* Returns attribute data for this storage buffer node.
	*
	* @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.
	*/
	getAttributeData() {
		if (this._attribute === null) {
			this._attribute = bufferAttribute$1(this.value);
			this._varying = varying$1(this._attribute);
		}
		return {
			attribute: this._attribute,
			varying: this._varying
		};
	}
	/**
	* This method is overwritten since the node type from the availability of storage buffers
	* and the attribute data.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		if (this.structTypeNode !== null) return this.structTypeNode.getNodeType(builder);
		if (builder.isAvailable("storageBuffer") || builder.isAvailable("indirectStorageBuffer")) return super.getNodeType(builder);
		const { attribute: attribute$2 } = this.getAttributeData();
		return attribute$2.getNodeType(builder);
	}
	/**
	* Returns the type of a member of the struct.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} name - The name of the member.
	* @return {string} The type of the member.
	*/
	getMemberType(builder, name) {
		if (this.structTypeNode !== null) return this.structTypeNode.getMemberType(builder, name);
		return "void";
	}
	/**
	* Generates the code snippet of the storage buffer node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The generated code snippet.
	*/
	generate(builder) {
		if (this.structTypeNode !== null) this.structTypeNode.build(builder);
		if (builder.isAvailable("storageBuffer") || builder.isAvailable("indirectStorageBuffer")) return super.generate(builder);
		const { attribute: attribute$2, varying: varying$2 } = this.getAttributeData();
		const output$2 = varying$2.build(builder);
		builder.registerTransform(output$2, attribute$2);
		return output$2;
	}
};
/**
* TSL function for creating a storage buffer node.
*
* @tsl
* @function
* @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.
* @param {?(string|Struct)} [type=null] - The buffer type (e.g. `'vec3'`).
* @param {number} [count=0] - The buffer count.
* @returns {StorageBufferNode}
*/
var storage$1 = (value, type$1 = null, count = 0) => nodeObject$1(new StorageBufferNode(value, type$1, count));
/**
* @tsl
* @function
* @deprecated since r171. Use `storage().setPBO( true )` instead.
*
* @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.
* @param {?string} type - The buffer type (e.g. `'vec3'`).
* @param {number} count - The buffer count.
* @returns {StorageBufferNode}
*/
var storageObject$1 = (value, type$1, count) => {
	warn("TSL: \"storageObject()\" is deprecated. Use \"storage().setPBO( true )\" instead.");
	return storage$1(value, type$1, count).setPBO(true);
};
var _frameId = /* @__PURE__ */ new WeakMap();
/**
* This node implements the vertex transformation shader logic which is required
* for skinning/skeletal animation.
*
* @augments Node
*/
var SkinningNode = class extends Node {
	static get type() {
		return "SkinningNode";
	}
	/**
	* Constructs a new skinning node.
	*
	* @param {SkinnedMesh} skinnedMesh - The skinned mesh.
	*/
	constructor(skinnedMesh) {
		super("void");
		/**
		* The skinned mesh.
		*
		* @type {SkinnedMesh}
		*/
		this.skinnedMesh = skinnedMesh;
		/**
		* The update type overwritten since skinning nodes are updated per object.
		*
		* @type {string}
		*/
		this.updateType = NodeUpdateType$1.OBJECT;
		/**
		* The skin index attribute.
		*
		* @type {AttributeNode}
		*/
		this.skinIndexNode = attribute$1("skinIndex", "uvec4");
		/**
		* The skin weight attribute.
		*
		* @type {AttributeNode}
		*/
		this.skinWeightNode = attribute$1("skinWeight", "vec4");
		/**
		* The bind matrix node.
		*
		* @type {Node<mat4>}
		*/
		this.bindMatrixNode = reference$2("bindMatrix", "mat4");
		/**
		* The bind matrix inverse node.
		*
		* @type {Node<mat4>}
		*/
		this.bindMatrixInverseNode = reference$2("bindMatrixInverse", "mat4");
		/**
		* The bind matrices as a uniform buffer node.
		*
		* @type {Node}
		*/
		this.boneMatricesNode = referenceBuffer$1("skeleton.boneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
		/**
		* The current vertex position in local space.
		*
		* @type {Node<vec3>}
		*/
		this.positionNode = positionLocal$1;
		/**
		* The result of vertex position in local space.
		*
		* @type {Node<vec3>}
		*/
		this.toPositionNode = positionLocal$1;
		/**
		* The previous bind matrices as a uniform buffer node.
		* Required for computing motion vectors.
		*
		* @type {?Node}
		* @default null
		*/
		this.previousBoneMatricesNode = null;
	}
	/**
	* Transforms the given vertex position via skinning.
	*
	* @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
	* @param {Node<vec3>} [position=this.positionNode] - The vertex position in local space.
	* @return {Node<vec3>} The transformed vertex position.
	*/
	getSkinnedPosition(boneMatrices = this.boneMatricesNode, position = this.positionNode) {
		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
		const boneMatX = boneMatrices.element(skinIndexNode.x);
		const boneMatY = boneMatrices.element(skinIndexNode.y);
		const boneMatZ = boneMatrices.element(skinIndexNode.z);
		const boneMatW = boneMatrices.element(skinIndexNode.w);
		const skinVertex = bindMatrixNode.mul(position);
		const skinned = add$1(boneMatX.mul(skinWeightNode.x).mul(skinVertex), boneMatY.mul(skinWeightNode.y).mul(skinVertex), boneMatZ.mul(skinWeightNode.z).mul(skinVertex), boneMatW.mul(skinWeightNode.w).mul(skinVertex));
		return bindMatrixInverseNode.mul(skinned).xyz;
	}
	/**
	* Transforms the given vertex normal via skinning.
	*
	* @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
	* @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.
	* @return {Node<vec3>} The transformed vertex normal.
	*/
	getSkinnedNormal(boneMatrices = this.boneMatricesNode, normal$1 = normalLocal$1) {
		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
		const boneMatX = boneMatrices.element(skinIndexNode.x);
		const boneMatY = boneMatrices.element(skinIndexNode.y);
		const boneMatZ = boneMatrices.element(skinIndexNode.z);
		const boneMatW = boneMatrices.element(skinIndexNode.w);
		let skinMatrix = add$1(skinWeightNode.x.mul(boneMatX), skinWeightNode.y.mul(boneMatY), skinWeightNode.z.mul(boneMatZ), skinWeightNode.w.mul(boneMatW));
		skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
		return skinMatrix.transformDirection(normal$1).xyz;
	}
	/**
	* Computes the transformed/skinned vertex position of the previous frame.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node<vec3>} The skinned position from the previous frame.
	*/
	getPreviousSkinnedPosition(builder) {
		const skinnedMesh = builder.object;
		if (this.previousBoneMatricesNode === null) {
			skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(skinnedMesh.skeleton.boneMatrices);
			this.previousBoneMatricesNode = referenceBuffer$1("skeleton.previousBoneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
		}
		return this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious$1);
	}
	/**
	* Returns `true` if bone matrices from the previous frame are required. Relevant
	* when computing motion vectors with {@link VelocityNode}.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {boolean} Whether bone matrices from the previous frame are required or not.
	*/
	needsPreviousBoneMatrices(builder) {
		const mrt$2 = builder.renderer.getMRT();
		return mrt$2 && mrt$2.has("velocity") || getDataFromObject(builder.object).useVelocity === true;
	}
	/**
	* Setups the skinning node by assigning the transformed vertex data to predefined node variables.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node<vec3>} The transformed vertex position.
	*/
	setup(builder) {
		if (this.needsPreviousBoneMatrices(builder)) positionPrevious$1.assign(this.getPreviousSkinnedPosition(builder));
		const skinPosition = this.getSkinnedPosition();
		if (this.toPositionNode) this.toPositionNode.assign(skinPosition);
		if (builder.hasGeometryAttribute("normal")) {
			const skinNormal = this.getSkinnedNormal();
			normalLocal$1.assign(skinNormal);
			if (builder.hasGeometryAttribute("tangent")) tangentLocal$1.assign(skinNormal);
		}
		return skinPosition;
	}
	/**
	* Generates the code snippet of the skinning node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} output - The current output.
	* @return {string} The generated code snippet.
	*/
	generate(builder, output$2) {
		if (output$2 !== "void") return super.generate(builder, output$2);
	}
	/**
	* Updates the state of the skinned mesh by updating the skeleton once per frame.
	*
	* @param {NodeFrame} frame - The current node frame.
	*/
	update(frame) {
		const skeleton = frame.object && frame.object.skeleton ? frame.object.skeleton : this.skinnedMesh.skeleton;
		if (_frameId.get(skeleton) === frame.frameId) return;
		_frameId.set(skeleton, frame.frameId);
		if (this.previousBoneMatricesNode !== null) skeleton.previousBoneMatrices.set(skeleton.boneMatrices);
		skeleton.update();
	}
};
/**
* TSL function for creating a skinning node.
*
* @tsl
* @function
* @param {SkinnedMesh} skinnedMesh - The skinned mesh.
* @returns {SkinningNode}
*/
var skinning$1 = (skinnedMesh) => nodeObject$1(new SkinningNode(skinnedMesh));
/**
* TSL function for computing skinning.
*
* @tsl
* @function
* @param {SkinnedMesh} skinnedMesh - The skinned mesh.
* @param {Node<vec3>} [toPosition=null] - The target position.
* @returns {SkinningNode}
*/
var computeSkinning$1 = (skinnedMesh, toPosition = null) => {
	const node = new SkinningNode(skinnedMesh);
	node.positionNode = storage$1(new InstancedBufferAttribute(skinnedMesh.geometry.getAttribute("position").array, 3), "vec3").setPBO(true).toReadOnly().element(instanceIndex$1).toVar();
	node.skinIndexNode = storage$1(new InstancedBufferAttribute(new Uint32Array(skinnedMesh.geometry.getAttribute("skinIndex").array), 4), "uvec4").setPBO(true).toReadOnly().element(instanceIndex$1).toVar();
	node.skinWeightNode = storage$1(new InstancedBufferAttribute(skinnedMesh.geometry.getAttribute("skinWeight").array, 4), "vec4").setPBO(true).toReadOnly().element(instanceIndex$1).toVar();
	node.bindMatrixNode = uniform$1(skinnedMesh.bindMatrix, "mat4");
	node.bindMatrixInverseNode = uniform$1(skinnedMesh.bindMatrixInverse, "mat4");
	node.boneMatricesNode = buffer$1(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
	node.toPositionNode = toPosition;
	return nodeObject$1(node);
};
/**
* This module offers a variety of ways to implement loops in TSL. In it's basic form it's:
* ```js
* Loop( count, ( { i } ) => {
*
* } );
* ```
* However, it is also possible to define a start and end ranges, data types and loop conditions:
* ```js
* Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {
*
* } );
*```
* Nested loops can be defined in a compacted form:
* ```js
* Loop( 10, 5, ( { i, j } ) => {
*
* } );
* ```
* Loops that should run backwards can be defined like so:
* ```js
* Loop( { start: 10 }, () => {} );
* ```
* It is possible to execute with boolean values, similar to the `while` syntax.
* ```js
* const value = float( 0 ).toVar();
*
* Loop( value.lessThan( 10 ), () => {
*
* 	value.addAssign( 1 );
*
* } );
* ```
* The module also provides `Break()` and `Continue()` TSL expression for loop control.
* @augments Node
*/
var LoopNode = class extends Node {
	static get type() {
		return "LoopNode";
	}
	/**
	* Constructs a new loop node.
	*
	* @param {Array<any>} params - Depending on the loop type, array holds different parameterization values for the loop.
	*/
	constructor(params = []) {
		super("void");
		this.params = params;
	}
	/**
	* Returns a loop variable name based on an index. The pattern is
	* `0` = `i`, `1`= `j`, `2`= `k` and so on.
	*
	* @param {number} index - The index.
	* @return {string} The loop variable name.
	*/
	getVarName(index) {
		return String.fromCharCode("i".charCodeAt(0) + index);
	}
	/**
	* Returns properties about this node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Object} The node properties.
	*/
	getProperties(builder) {
		const properties = builder.getNodeProperties(this);
		if (properties.stackNode !== void 0) return properties;
		const inputs = {};
		for (let i = 0, l = this.params.length - 1; i < l; i++) {
			const param = this.params[i];
			const name = param.isNode !== true && param.name || this.getVarName(i);
			const type$1 = param.isNode !== true && param.type || "int";
			inputs[name] = expression$1(name, type$1);
		}
		const stack$2 = builder.addStack();
		const fnCall = this.params[this.params.length - 1](inputs);
		properties.returnsNode = fnCall.context({ nodeLoop: fnCall });
		properties.stackNode = stack$2;
		const baseParam = this.params[0];
		if (baseParam.isNode !== true && typeof baseParam.update === "function") {
			const fnUpdateCall = Fn$1(this.params[0].update)(inputs);
			properties.updateNode = fnUpdateCall.context({ nodeLoop: fnUpdateCall });
		}
		builder.removeStack();
		return properties;
	}
	setup(builder) {
		this.getProperties(builder);
		if (builder.fnCall) {
			const shaderNodeData = builder.getDataFromNode(builder.fnCall.shaderNode);
			shaderNodeData.hasLoop = true;
		}
	}
	generate(builder) {
		const properties = this.getProperties(builder);
		const params = this.params;
		const stackNode = properties.stackNode;
		for (let i = 0, l = params.length - 1; i < l; i++) {
			const param = params[i];
			let isWhile = false, start = null, end = null, name = null, type$1 = null, condition = null, update = null;
			if (param.isNode) if (param.getNodeType(builder) === "bool") {
				isWhile = true;
				type$1 = "bool";
				end = param.build(builder, type$1);
			} else {
				type$1 = "int";
				name = this.getVarName(i);
				start = "0";
				end = param.build(builder, type$1);
				condition = "<";
			}
			else {
				type$1 = param.type || "int";
				name = param.name || this.getVarName(i);
				start = param.start;
				end = param.end;
				condition = param.condition;
				update = param.update;
				if (typeof start === "number") start = builder.generateConst(type$1, start);
				else if (start && start.isNode) start = start.build(builder, type$1);
				if (typeof end === "number") end = builder.generateConst(type$1, end);
				else if (end && end.isNode) end = end.build(builder, type$1);
				if (start !== void 0 && end === void 0) {
					start = start + " - 1";
					end = "0";
					condition = ">=";
				} else if (end !== void 0 && start === void 0) {
					start = "0";
					condition = "<";
				}
				if (condition === void 0) if (Number(start) > Number(end)) condition = ">=";
				else condition = "<";
			}
			let loopSnippet;
			if (isWhile) loopSnippet = `while ( ${end} )`;
			else {
				const internalParam = {
					start,
					end
				};
				const startSnippet = internalParam.start;
				const endSnippet = internalParam.end;
				let updateSnippet;
				const deltaOperator = () => condition.includes("<") ? "+=" : "-=";
				if (update !== void 0 && update !== null) switch (typeof update) {
					case "function":
						updateSnippet = builder.flowStagesNode(properties.updateNode, "void").code.replace(/\t|;/g, "");
						break;
					case "number":
						updateSnippet = name + " " + deltaOperator() + " " + builder.generateConst(type$1, update);
						break;
					case "string":
						updateSnippet = name + " " + update;
						break;
					default: if (update.isNode) updateSnippet = name + " " + deltaOperator() + " " + update.build(builder);
					else {
						error("TSL: 'Loop( { update: ... } )' is not a function, string or number.");
						updateSnippet = "break /* invalid update */";
					}
				}
				else {
					if (type$1 === "int" || type$1 === "uint") update = condition.includes("<") ? "++" : "--";
					else update = deltaOperator() + " 1.";
					updateSnippet = name + " " + update;
				}
				const declarationSnippet = builder.getVar(type$1, name) + " = " + startSnippet;
				const conditionalSnippet = name + " " + condition + " " + endSnippet;
				loopSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
			}
			builder.addFlowCode((i === 0 ? "\n" : "") + builder.tab + loopSnippet + " {\n\n").addFlowTab();
		}
		const stackSnippet = stackNode.build(builder, "void");
		properties.returnsNode.build(builder, "void");
		builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
		for (let i = 0, l = this.params.length - 1; i < l; i++) builder.addFlowCode((i === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
		builder.addFlowTab();
	}
};
/**
* TSL function for creating a loop node.
*
* @tsl
* @function
* @param {...any} params - A list of parameters.
* @returns {LoopNode}
*/
var Loop$1 = (...params) => new LoopNode(nodeArray$1(params, "int")).toStack();
/**
* TSL function for creating a `Continue()` expression.
*
* @tsl
* @function
* @returns {ExpressionNode}
*/
var Continue$1 = () => expression$1("continue").toStack();
/**
* TSL function for creating a `Break()` expression.
*
* @tsl
* @function
* @returns {ExpressionNode}
*/
var Break$1 = () => expression$1("break").toStack();
var _morphTextures = /* @__PURE__ */ new WeakMap();
var _morphVec4 = /* @__PURE__ */ new Vector4();
var getMorph = /* @__PURE__ */ Fn$1(({ bufferMap, influence, stride, width, depth: depth$2, offset }) => {
	const texelIndex = int$1(vertexIndex$1).mul(stride).add(offset);
	const y = texelIndex.div(width);
	const x = texelIndex.sub(y.mul(width));
	return textureLoad$1(bufferMap, ivec2$1(x, y)).depth(depth$2).xyz.mul(influence);
});
function getEntry(geometry) {
	const hasMorphPosition = geometry.morphAttributes.position !== void 0;
	const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
	const hasMorphColors = geometry.morphAttributes.color !== void 0;
	const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
	const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
	let entry = _morphTextures.get(geometry);
	if (entry === void 0 || entry.count !== morphTargetsCount) {
		if (entry !== void 0) entry.texture.dispose();
		const morphTargets = geometry.morphAttributes.position || [];
		const morphNormals = geometry.morphAttributes.normal || [];
		const morphColors = geometry.morphAttributes.color || [];
		let vertexDataCount = 0;
		if (hasMorphPosition === true) vertexDataCount = 1;
		if (hasMorphNormals === true) vertexDataCount = 2;
		if (hasMorphColors === true) vertexDataCount = 3;
		let width = geometry.attributes.position.count * vertexDataCount;
		let height = 1;
		const maxTextureSize = 4096;
		if (width > maxTextureSize) {
			height = Math.ceil(width / maxTextureSize);
			width = maxTextureSize;
		}
		const buffer$2 = new Float32Array(width * height * 4 * morphTargetsCount);
		const bufferTexture = new DataArrayTexture(buffer$2, width, height, morphTargetsCount);
		bufferTexture.type = FloatType;
		bufferTexture.needsUpdate = true;
		const vertexDataStride = vertexDataCount * 4;
		for (let i = 0; i < morphTargetsCount; i++) {
			const morphTarget = morphTargets[i];
			const morphNormal = morphNormals[i];
			const morphColor = morphColors[i];
			const offset = width * height * 4 * i;
			for (let j = 0; j < morphTarget.count; j++) {
				const stride = j * vertexDataStride;
				if (hasMorphPosition === true) {
					_morphVec4.fromBufferAttribute(morphTarget, j);
					buffer$2[offset + stride + 0] = _morphVec4.x;
					buffer$2[offset + stride + 1] = _morphVec4.y;
					buffer$2[offset + stride + 2] = _morphVec4.z;
					buffer$2[offset + stride + 3] = 0;
				}
				if (hasMorphNormals === true) {
					_morphVec4.fromBufferAttribute(morphNormal, j);
					buffer$2[offset + stride + 4] = _morphVec4.x;
					buffer$2[offset + stride + 5] = _morphVec4.y;
					buffer$2[offset + stride + 6] = _morphVec4.z;
					buffer$2[offset + stride + 7] = 0;
				}
				if (hasMorphColors === true) {
					_morphVec4.fromBufferAttribute(morphColor, j);
					buffer$2[offset + stride + 8] = _morphVec4.x;
					buffer$2[offset + stride + 9] = _morphVec4.y;
					buffer$2[offset + stride + 10] = _morphVec4.z;
					buffer$2[offset + stride + 11] = morphColor.itemSize === 4 ? _morphVec4.w : 1;
				}
			}
		}
		entry = {
			count: morphTargetsCount,
			texture: bufferTexture,
			stride: vertexDataCount,
			size: new Vector2(width, height)
		};
		_morphTextures.set(geometry, entry);
		function disposeTexture() {
			bufferTexture.dispose();
			_morphTextures.delete(geometry);
			geometry.removeEventListener("dispose", disposeTexture);
		}
		geometry.addEventListener("dispose", disposeTexture);
	}
	return entry;
}
/**
* This node implements the vertex transformation shader logic which is required
* for morph target animation.
*
* @augments Node
*/
var MorphNode = class extends Node {
	static get type() {
		return "MorphNode";
	}
	/**
	* Constructs a new morph node.
	*
	* @param {Mesh} mesh - The mesh holding the morph targets.
	*/
	constructor(mesh) {
		super("void");
		/**
		* The mesh holding the morph targets.
		*
		* @type {Mesh}
		*/
		this.mesh = mesh;
		/**
		* A uniform node which represents the morph base influence value.
		*
		* @type {UniformNode<float>}
		*/
		this.morphBaseInfluence = uniform$1(1);
		/**
		* The update type overwritten since morph nodes are updated per object.
		*
		* @type {string}
		*/
		this.updateType = NodeUpdateType$1.OBJECT;
	}
	/**
	* Setups the morph node by assigning the transformed vertex data to predefined node variables.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setup(builder) {
		const { geometry } = builder;
		const hasMorphPosition = geometry.morphAttributes.position !== void 0;
		const hasMorphNormals = geometry.hasAttribute("normal") && geometry.morphAttributes.normal !== void 0;
		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
		const { texture: bufferMap, stride, size } = getEntry(geometry);
		if (hasMorphPosition === true) positionLocal$1.mulAssign(this.morphBaseInfluence);
		if (hasMorphNormals === true) normalLocal$1.mulAssign(this.morphBaseInfluence);
		const width = int$1(size.width);
		Loop$1(morphTargetsCount, ({ i }) => {
			const influence = float$1(0).toVar();
			if (this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0) influence.assign(textureLoad$1(this.mesh.morphTexture, ivec2$1(int$1(i).add(1), int$1(instanceIndex$1))).r);
			else influence.assign(reference$2("morphTargetInfluences", "float").element(i).toVar());
			If$1(influence.notEqual(0), () => {
				if (hasMorphPosition === true) positionLocal$1.addAssign(getMorph({
					bufferMap,
					influence,
					stride,
					width,
					depth: i,
					offset: int$1(0)
				}));
				if (hasMorphNormals === true) normalLocal$1.addAssign(getMorph({
					bufferMap,
					influence,
					stride,
					width,
					depth: i,
					offset: int$1(1)
				}));
			});
		});
	}
	/**
	* Updates the state of the morphed mesh by updating the base influence.
	*
	* @param {NodeFrame} frame - The current node frame.
	*/
	update() {
		const morphBaseInfluence = this.morphBaseInfluence;
		if (this.mesh.geometry.morphTargetsRelative) morphBaseInfluence.value = 1;
		else morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a$1, b$2) => a$1 + b$2, 0);
	}
};
/**
* TSL function for creating a morph node.
*
* @tsl
* @function
* @param {Mesh} mesh - The mesh holding the morph targets.
* @returns {MorphNode}
*/
var morphReference$1 = /* @__PURE__ */ nodeProxy$1(MorphNode).setParameterLength(1);
/**
* Base class for lighting nodes.
*
* @augments Node
*/
var LightingNode = class extends Node {
	static get type() {
		return "LightingNode";
	}
	/**
	* Constructs a new lighting node.
	*/
	constructor() {
		super("vec3");
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isLightingNode = true;
	}
};
/**
* A generic class that can be used by nodes which contribute
* ambient occlusion to the scene. E.g. an ambient occlusion map
* node can be used as input for this module. Used in {@link NodeMaterial}.
*
* @augments LightingNode
*/
var AONode = class extends LightingNode {
	static get type() {
		return "AONode";
	}
	/**
	* Constructs a new AO node.
	*
	* @param {?Node<float>} [aoNode=null] - The ambient occlusion node.
	*/
	constructor(aoNode = null) {
		super();
		/**
		* The ambient occlusion node.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.aoNode = aoNode;
	}
	setup(builder) {
		builder.context.ambientOcclusion.mulAssign(this.aoNode);
	}
};
/**
* `LightingContextNode` represents an extension of the {@link ContextNode} module
* by adding lighting specific context data. It represents the runtime context of
* {@link LightsNode}.
*
* @augments ContextNode
*/
var LightingContextNode = class extends ContextNode {
	static get type() {
		return "LightingContextNode";
	}
	/**
	* Constructs a new lighting context node.
	*
	* @param {LightsNode} lightsNode - The lights node.
	* @param {?LightingModel} [lightingModel=null] - The current lighting model.
	* @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
	* @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
	*/
	constructor(lightsNode, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
		super(lightsNode);
		/**
		* The current lighting model.
		*
		* @type {?LightingModel}
		* @default null
		*/
		this.lightingModel = lightingModel;
		/**
		* A backdrop node.
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.backdropNode = backdropNode;
		/**
		* A backdrop alpha node.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.backdropAlphaNode = backdropAlphaNode;
		this._value = null;
	}
	/**
	* Returns a lighting context object.
	*
	* @return {{
	* radiance: Node<vec3>,
	* irradiance: Node<vec3>,
	* iblIrradiance: Node<vec3>,
	* ambientOcclusion: Node<float>,
	* reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},
	* backdrop: Node<vec3>,
	* backdropAlpha: Node<float>
	* }} The lighting context object.
	*/
	getContext() {
		const { backdropNode, backdropAlphaNode } = this;
		const directDiffuse = vec3$1().toVar("directDiffuse"), directSpecular = vec3$1().toVar("directSpecular"), indirectDiffuse = vec3$1().toVar("indirectDiffuse"), indirectSpecular = vec3$1().toVar("indirectSpecular");
		const reflectedLight = {
			directDiffuse,
			directSpecular,
			indirectDiffuse,
			indirectSpecular
		};
		return {
			radiance: vec3$1().toVar("radiance"),
			irradiance: vec3$1().toVar("irradiance"),
			iblIrradiance: vec3$1().toVar("iblIrradiance"),
			ambientOcclusion: float$1(1).toVar("ambientOcclusion"),
			reflectedLight,
			backdrop: backdropNode,
			backdropAlpha: backdropAlphaNode
		};
	}
	setup(builder) {
		this.value = this._value || (this._value = this.getContext());
		this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
		return super.setup(builder);
	}
};
var lightingContext$1 = /* @__PURE__ */ nodeProxy$1(LightingContextNode);
/**
* A generic class that can be used by nodes which contribute
* irradiance to the scene. E.g. a light map node can be used
* as input for this module. Used in {@link NodeMaterial}.
*
* @augments LightingNode
*/
var IrradianceNode = class extends LightingNode {
	static get type() {
		return "IrradianceNode";
	}
	/**
	* Constructs a new irradiance node.
	*
	* @param {Node<vec3>} node - A node contributing irradiance.
	*/
	constructor(node) {
		super();
		/**
		* A node contributing irradiance.
		*
		* @type {Node<vec3>}
		*/
		this.node = node;
	}
	setup(builder) {
		builder.context.irradiance.addAssign(this.node);
	}
};
var _size$5 = /* @__PURE__ */ new Vector2();
/**
* A special type of texture node which represents the data of the current viewport
* as a texture. The module extracts data from the current bound framebuffer with
* a copy operation so no extra render pass is required to produce the texture data
* (which is good for performance). `ViewportTextureNode` can be used as an input for a
* variety of effects like refractive or transmissive materials.
*
* @augments TextureNode
*/
var ViewportTextureNode = class extends TextureNode {
	static get type() {
		return "ViewportTextureNode";
	}
	/**
	* Constructs a new viewport texture node.
	*
	* @param {Node} [uvNode=screenUV] - The uv node.
	* @param {?Node} [levelNode=null] - The level node.
	* @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
	*/
	constructor(uvNode = screenUV$1, levelNode = null, framebufferTexture = null) {
		let defaultFramebuffer = null;
		if (framebufferTexture === null) {
			defaultFramebuffer = new FramebufferTexture();
			defaultFramebuffer.minFilter = LinearMipmapLinearFilter;
			framebufferTexture = defaultFramebuffer;
		} else defaultFramebuffer = framebufferTexture;
		super(framebufferTexture, uvNode, levelNode);
		/**
		* Whether to generate mipmaps or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.generateMipmaps = false;
		/**
		* The reference framebuffer texture. This is used to store the framebuffer texture
		* for the current render target. If the render target changes, a new framebuffer texture
		* is created automatically.
		*
		* @type {FramebufferTexture}
		* @default null
		*/
		this.defaultFramebuffer = defaultFramebuffer;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isOutputTextureNode = true;
		/**
		* The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
		* scene once per frame in its {@link ViewportTextureNode#updateBefore} method.
		*
		* @type {string}
		* @default 'frame'
		*/
		this.updateBeforeType = NodeUpdateType$1.FRAME;
		/**
		* The framebuffer texture for the current renderer context.
		*
		* @type {WeakMap<RenderTarget, FramebufferTexture>}
		* @private
		*/
		this._cacheTextures = /* @__PURE__ */ new WeakMap();
	}
	/**
	* This methods returns a texture for the given render target reference.
	*
	* To avoid rendering errors, `ViewportTextureNode` must use unique framebuffer textures
	* for different render contexts.
	*
	* @param {?RenderTarget} [reference=null] - The render target reference.
	* @return {Texture} The framebuffer texture.
	*/
	getTextureForReference(reference$3 = null) {
		let defaultFramebuffer;
		let cacheTextures;
		if (this.referenceNode) {
			defaultFramebuffer = this.referenceNode.defaultFramebuffer;
			cacheTextures = this.referenceNode._cacheTextures;
		} else {
			defaultFramebuffer = this.defaultFramebuffer;
			cacheTextures = this._cacheTextures;
		}
		if (reference$3 === null) return defaultFramebuffer;
		if (cacheTextures.has(reference$3) === false) {
			const framebufferTexture = defaultFramebuffer.clone();
			cacheTextures.set(reference$3, framebufferTexture);
		}
		return cacheTextures.get(reference$3);
	}
	updateReference(frame) {
		const renderTarget = frame.renderer.getRenderTarget();
		this.value = this.getTextureForReference(renderTarget);
		return this.value;
	}
	updateBefore(frame) {
		const renderer = frame.renderer;
		const renderTarget = renderer.getRenderTarget();
		if (renderTarget === null) renderer.getDrawingBufferSize(_size$5);
		else _size$5.set(renderTarget.width, renderTarget.height);
		const framebufferTexture = this.getTextureForReference(renderTarget);
		if (framebufferTexture.image.width !== _size$5.width || framebufferTexture.image.height !== _size$5.height) {
			framebufferTexture.image.width = _size$5.width;
			framebufferTexture.image.height = _size$5.height;
			framebufferTexture.needsUpdate = true;
		}
		const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
		framebufferTexture.generateMipmaps = this.generateMipmaps;
		renderer.copyFramebufferToTexture(framebufferTexture);
		framebufferTexture.generateMipmaps = currentGenerateMipmaps;
	}
	clone() {
		const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);
		viewportTextureNode.generateMipmaps = this.generateMipmaps;
		return viewportTextureNode;
	}
};
/**
* TSL function for creating a viewport texture node.
*
* @tsl
* @function
* @param {?Node} [uvNode=screenUV] - The uv node.
* @param {?Node} [levelNode=null] - The level node.
* @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
* @returns {ViewportTextureNode}
*/
var viewportTexture$1 = /* @__PURE__ */ nodeProxy$1(ViewportTextureNode).setParameterLength(0, 3);
/**
* TSL function for creating a viewport texture node with enabled mipmap generation.
*
* @tsl
* @function
* @param {?Node} [uvNode=screenUV] - The uv node.
* @param {?Node} [levelNode=null] - The level node.
* @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
* @returns {ViewportTextureNode}
*/
var viewportMipTexture$1 = /* @__PURE__ */ nodeProxy$1(ViewportTextureNode, null, null, { generateMipmaps: true }).setParameterLength(0, 3);
var _sharedDepthbuffer = null;
/**
* Represents the depth of the current viewport as a texture. This module
* can be used in combination with viewport texture to achieve effects
* that require depth evaluation.
*
* @augments ViewportTextureNode
*/
var ViewportDepthTextureNode = class extends ViewportTextureNode {
	static get type() {
		return "ViewportDepthTextureNode";
	}
	/**
	* Constructs a new viewport depth texture node.
	*
	* @param {Node} [uvNode=screenUV] - The uv node.
	* @param {?Node} [levelNode=null] - The level node.
	*/
	constructor(uvNode = screenUV$1, levelNode = null) {
		if (_sharedDepthbuffer === null) _sharedDepthbuffer = new DepthTexture();
		super(uvNode, levelNode, _sharedDepthbuffer);
	}
	/**
	* Overwritten so the method always returns the unique shared
	* depth texture.
	*
	* @return {DepthTexture} The shared depth texture.
	*/
	getTextureForReference() {
		return _sharedDepthbuffer;
	}
};
/**
* TSL function for a viewport depth texture node.
*
* @tsl
* @function
* @param {?Node} [uvNode=screenUV] - The uv node.
* @param {?Node} [levelNode=null] - The level node.
* @returns {ViewportDepthTextureNode}
*/
var viewportDepthTexture$1 = /* @__PURE__ */ nodeProxy$1(ViewportDepthTextureNode).setParameterLength(0, 2);
/**
* This node offers a collection of features in context of the depth logic in the fragment shader.
* Depending on {@link ViewportDepthNode#scope}, it can be used to define a depth value for the current
* fragment or for depth evaluation purposes.
*
* @augments Node
*/
var ViewportDepthNode = class ViewportDepthNode extends Node {
	static get type() {
		return "ViewportDepthNode";
	}
	/**
	* Constructs a new viewport depth node.
	*
	* @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.
	* @param {?Node} [valueNode=null] - The value node.
	*/
	constructor(scope, valueNode = null) {
		super("float");
		/**
		* The node behaves differently depending on which scope is selected.
		*
		* - `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.
		* - `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).
		* - `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.
		* If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.
		*
		* @type {('depth'|'depthBase'|'linearDepth')}
		*/
		this.scope = scope;
		/**
		* Can be used to define a custom depth value.
		* The property is ignored in the `ViewportDepthNode.DEPTH` scope.
		*
		* @type {?Node}
		* @default null
		*/
		this.valueNode = valueNode;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isViewportDepthNode = true;
	}
	generate(builder) {
		const { scope } = this;
		if (scope === ViewportDepthNode.DEPTH_BASE) return builder.getFragDepth();
		return super.generate(builder);
	}
	setup({ camera }) {
		const { scope } = this;
		const value = this.valueNode;
		let node = null;
		if (scope === ViewportDepthNode.DEPTH_BASE) {
			if (value !== null) node = depthBase().assign(value);
		} else if (scope === ViewportDepthNode.DEPTH) if (camera.isPerspectiveCamera) node = viewZToPerspectiveDepth$1(positionView$1.z, cameraNear$1, cameraFar$1);
		else node = viewZToOrthographicDepth$1(positionView$1.z, cameraNear$1, cameraFar$1);
		else if (scope === ViewportDepthNode.LINEAR_DEPTH) if (value !== null) if (camera.isPerspectiveCamera) {
			const viewZ = perspectiveDepthToViewZ$1(value, cameraNear$1, cameraFar$1);
			node = viewZToOrthographicDepth$1(viewZ, cameraNear$1, cameraFar$1);
		} else node = value;
		else node = viewZToOrthographicDepth$1(positionView$1.z, cameraNear$1, cameraFar$1);
		return node;
	}
};
ViewportDepthNode.DEPTH_BASE = "depthBase";
ViewportDepthNode.DEPTH = "depth";
ViewportDepthNode.LINEAR_DEPTH = "linearDepth";
/**
* TSL function for converting a viewZ value to an orthographic depth value.
*
* @tsl
* @function
* @param {Node<float>} viewZ - The viewZ node.
* @param {Node<float>} near - The camera's near value.
* @param {Node<float>} far - The camera's far value.
* @returns {Node<float>}
*/
var viewZToOrthographicDepth$1 = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));
/**
* TSL function for converting an orthographic depth value to a viewZ value.
*
* @tsl
* @function
* @param {Node<float>} depth - The orthographic depth.
* @param {Node<float>} near - The camera's near value.
* @param {Node<float>} far - The camera's far value.
* @returns {Node<float>}
*/
var orthographicDepthToViewZ$1 = (depth$2, near, far) => near.sub(far).mul(depth$2).sub(near);
/**
* TSL function for converting a viewZ value to a perspective depth value.
*
* Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.
*
* @tsl
* @function
* @param {Node<float>} viewZ - The viewZ node.
* @param {Node<float>} near - The camera's near value.
* @param {Node<float>} far - The camera's far value.
* @returns {Node<float>}
*/
var viewZToPerspectiveDepth$1 = (viewZ, near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));
/**
* TSL function for converting a perspective depth value to a viewZ value.
*
* @tsl
* @function
* @param {Node<float>} depth - The perspective depth.
* @param {Node<float>} near - The camera's near value.
* @param {Node<float>} far - The camera's far value.
* @returns {Node<float>}
*/
var perspectiveDepthToViewZ$1 = (depth$2, near, far) => near.mul(far).div(far.sub(near).mul(depth$2).sub(far));
/**
* TSL function for converting a viewZ value to a logarithmic depth value.
*
* @tsl
* @function
* @param {Node<float>} viewZ - The viewZ node.
* @param {Node<float>} near - The camera's near value.
* @param {Node<float>} far - The camera's far value.
* @returns {Node<float>}
*/
var viewZToLogarithmicDepth$1 = (viewZ, near, far) => {
	near = near.max(1e-6).toVar();
	const numerator = log2$1(viewZ.negate().div(near));
	const denominator = log2$1(far.div(near));
	return numerator.div(denominator);
};
/**
* TSL function for converting a logarithmic depth value to a viewZ value.
*
* @tsl
* @function
* @param {Node<float>} depth - The logarithmic depth.
* @param {Node<float>} near - The camera's near value.
* @param {Node<float>} far - The camera's far value.
* @returns {Node<float>}
*/
var logarithmicDepthToViewZ$1 = (depth$2, near, far) => {
	const exponent = depth$2.mul(log$2(far.div(near)));
	return float$1(Math.E).pow(exponent).mul(near).negate();
};
/**
* TSL function for defining a value for the current fragment's depth.
*
* @tsl
* @function
* @param {Node<float>} value - The depth value to set.
* @returns {ViewportDepthNode<float>}
*/
var depthBase = /* @__PURE__ */ nodeProxy$1(ViewportDepthNode, ViewportDepthNode.DEPTH_BASE);
/**
* TSL object that represents the depth value for the current fragment.
*
* @tsl
* @type {ViewportDepthNode}
*/
var depth$1 = /* @__PURE__ */ nodeImmutable$1(ViewportDepthNode, ViewportDepthNode.DEPTH);
/**
* TSL function for converting a perspective depth value to linear depth.
*
* @tsl
* @function
* @param {?Node<float>} [value=null] - The perspective depth. If `null` is provided, the current fragment's depth is used.
* @returns {ViewportDepthNode<float>}
*/
var linearDepth$1 = /* @__PURE__ */ nodeProxy$1(ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH).setParameterLength(0, 1);
/**
* TSL object that represents the linear (orthographic) depth value of the current fragment
*
* @tsl
* @type {ViewportDepthNode}
*/
var viewportLinearDepth$1 = /* @__PURE__ */ linearDepth$1(viewportDepthTexture$1());
depth$1.assign = (value) => depthBase(value);
/**
* This node is used in {@link NodeMaterial} to setup the clipping
* which can happen hardware-accelerated (if supported) and optionally
* use alpha-to-coverage for anti-aliasing clipped edges.
*
* @augments Node
*/
var ClippingNode = class ClippingNode extends Node {
	static get type() {
		return "ClippingNode";
	}
	/**
	* Constructs a new clipping node.
	*
	* @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,
	* the selected scope influences the behavior of the node and what type of code is generated.
	*/
	constructor(scope = ClippingNode.DEFAULT) {
		super();
		/**
		* The node's scope. Similar to other nodes, the selected scope influences
		* the behavior of the node and what type of code is generated.
		*
		* @type {('default'|'hardware'|'alphaToCoverage')}
		*/
		this.scope = scope;
	}
	/**
	* Setups the node depending on the selected scope.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node} The result node.
	*/
	setup(builder) {
		super.setup(builder);
		const { intersectionPlanes, unionPlanes } = builder.clippingContext;
		this.hardwareClipping = builder.material.hardwareClipping;
		if (this.scope === ClippingNode.ALPHA_TO_COVERAGE) return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);
		else if (this.scope === ClippingNode.HARDWARE) return this.setupHardwareClipping(unionPlanes, builder);
		else return this.setupDefault(intersectionPlanes, unionPlanes);
	}
	/**
	* Setups alpha to coverage.
	*
	* @param {Array<Vector4>} intersectionPlanes - The intersection planes.
	* @param {Array<Vector4>} unionPlanes - The union planes.
	* @return {Node} The result node.
	*/
	setupAlphaToCoverage(intersectionPlanes, unionPlanes) {
		return Fn$1(() => {
			const distanceToPlane = float$1().toVar("distanceToPlane");
			const distanceGradient = float$1().toVar("distanceToGradient");
			const clipOpacity = float$1(1).toVar("clipOpacity");
			const numUnionPlanes = unionPlanes.length;
			if (this.hardwareClipping === false && numUnionPlanes > 0) {
				const clippingPlanes = uniformArray$1(unionPlanes).setGroup(renderGroup$1);
				Loop$1(numUnionPlanes, ({ i }) => {
					const plane = clippingPlanes.element(i);
					distanceToPlane.assign(positionView$1.dot(plane.xyz).negate().add(plane.w));
					distanceGradient.assign(distanceToPlane.fwidth().div(2));
					clipOpacity.mulAssign(smoothstep$1(distanceGradient.negate(), distanceGradient, distanceToPlane));
				});
			}
			const numIntersectionPlanes = intersectionPlanes.length;
			if (numIntersectionPlanes > 0) {
				const clippingPlanes = uniformArray$1(intersectionPlanes).setGroup(renderGroup$1);
				const intersectionClipOpacity = float$1(1).toVar("intersectionClipOpacity");
				Loop$1(numIntersectionPlanes, ({ i }) => {
					const plane = clippingPlanes.element(i);
					distanceToPlane.assign(positionView$1.dot(plane.xyz).negate().add(plane.w));
					distanceGradient.assign(distanceToPlane.fwidth().div(2));
					intersectionClipOpacity.mulAssign(smoothstep$1(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());
				});
				clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());
			}
			diffuseColor$1.a.mulAssign(clipOpacity);
			diffuseColor$1.a.equal(0).discard();
		})();
	}
	/**
	* Setups the default clipping.
	*
	* @param {Array<Vector4>} intersectionPlanes - The intersection planes.
	* @param {Array<Vector4>} unionPlanes - The union planes.
	* @return {Node} The result node.
	*/
	setupDefault(intersectionPlanes, unionPlanes) {
		return Fn$1(() => {
			const numUnionPlanes = unionPlanes.length;
			if (this.hardwareClipping === false && numUnionPlanes > 0) {
				const clippingPlanes = uniformArray$1(unionPlanes).setGroup(renderGroup$1);
				Loop$1(numUnionPlanes, ({ i }) => {
					const plane = clippingPlanes.element(i);
					positionView$1.dot(plane.xyz).greaterThan(plane.w).discard();
				});
			}
			const numIntersectionPlanes = intersectionPlanes.length;
			if (numIntersectionPlanes > 0) {
				const clippingPlanes = uniformArray$1(intersectionPlanes).setGroup(renderGroup$1);
				const clipped = bool$1(true).toVar("clipped");
				Loop$1(numIntersectionPlanes, ({ i }) => {
					const plane = clippingPlanes.element(i);
					clipped.assign(positionView$1.dot(plane.xyz).greaterThan(plane.w).and(clipped));
				});
				clipped.discard();
			}
		})();
	}
	/**
	* Setups hardware clipping.
	*
	* @param {Array<Vector4>} unionPlanes - The union planes.
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node} The result node.
	*/
	setupHardwareClipping(unionPlanes, builder) {
		const numUnionPlanes = unionPlanes.length;
		builder.enableHardwareClipping(numUnionPlanes);
		return Fn$1(() => {
			const clippingPlanes = uniformArray$1(unionPlanes).setGroup(renderGroup$1);
			const hw_clip_distances = builtin$1(builder.getClipDistance());
			Loop$1(numUnionPlanes, ({ i }) => {
				const plane = clippingPlanes.element(i);
				const distance$3 = positionView$1.dot(plane.xyz).sub(plane.w).negate();
				hw_clip_distances.element(i).assign(distance$3);
			});
		})();
	}
};
ClippingNode.ALPHA_TO_COVERAGE = "alphaToCoverage";
ClippingNode.DEFAULT = "default";
ClippingNode.HARDWARE = "hardware";
/**
* TSL function for setting up the default clipping logic.
*
* @tsl
* @function
* @returns {ClippingNode}
*/
var clipping = () => nodeObject$1(new ClippingNode());
/**
* TSL function for setting up alpha to coverage.
*
* @tsl
* @function
* @returns {ClippingNode}
*/
var clippingAlpha = () => nodeObject$1(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));
/**
* TSL function for setting up hardware-based clipping.
*
* @tsl
* @function
* @returns {ClippingNode}
*/
var hardwareClipping = () => nodeObject$1(new ClippingNode(ClippingNode.HARDWARE));
var ALPHA_HASH_SCALE = .05;
var hash2D = /* @__PURE__ */ Fn$1(([value]) => {
	return fract$1(mul$1(1e4, sin$1(mul$1(17, value.x).add(mul$1(.1, value.y)))).mul(add$1(.1, abs$1(sin$1(mul$1(13, value.y).add(value.x))))));
});
var hash3D = /* @__PURE__ */ Fn$1(([value]) => {
	return hash2D(vec2$1(hash2D(value.xy), value.z));
});
var getAlphaHashThreshold = /* @__PURE__ */ Fn$1(([position]) => {
	const maxDeriv = max$1$1(length$1(dFdx$1(position.xyz)), length$1(dFdy$1(position.xyz)));
	const pixScale = float$1(1).div(float$1(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar("pixScale");
	const pixScales = vec2$1(exp2$1(floor$1(log2$1(pixScale))), exp2$1(ceil$1(log2$1(pixScale))));
	const alpha = vec2$1(hash3D(floor$1(pixScales.x.mul(position.xyz))), hash3D(floor$1(pixScales.y.mul(position.xyz))));
	const lerpFactor = fract$1(log2$1(pixScale));
	const x = add$1(mul$1(lerpFactor.oneMinus(), alpha.x), mul$1(lerpFactor, alpha.y));
	const a$1 = min$1(lerpFactor, lerpFactor.oneMinus());
	const cases = vec3$1(x.mul(x).div(mul$1(2, a$1).mul(sub$1(1, a$1))), x.sub(mul$1(.5, a$1)).div(sub$1(1, a$1)), sub$1(1, sub$1(1, x).mul(sub$1(1, x)).div(mul$1(2, a$1).mul(sub$1(1, a$1)))));
	const threshold = x.lessThan(a$1.oneMinus()).select(x.lessThan(a$1).select(cases.x, cases.y), cases.z);
	return clamp$2(threshold, 1e-6, 1);
}).setLayout({
	name: "getAlphaHashThreshold",
	type: "float",
	inputs: [{
		name: "position",
		type: "vec3"
	}]
});
/**
* An attribute node for representing vertex colors.
*
* @augments AttributeNode
*/
var VertexColorNode = class extends AttributeNode {
	static get type() {
		return "VertexColorNode";
	}
	/**
	* Constructs a new vertex color node.
	*
	* @param {number} index - The attribute index.
	*/
	constructor(index) {
		super(null, "vec4");
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isVertexColorNode = true;
		/**
		* The attribute index to enable more than one sets of vertex colors.
		*
		* @type {number}
		* @default 0
		*/
		this.index = index;
	}
	/**
	* Overwrites the default implementation by honoring the attribute index.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The attribute name.
	*/
	getAttributeName() {
		const index = this.index;
		return "color" + (index > 0 ? index : "");
	}
	generate(builder) {
		const attributeName = this.getAttributeName(builder);
		const geometryAttribute = builder.hasGeometryAttribute(attributeName);
		let result;
		if (geometryAttribute === true) result = super.generate(builder);
		else result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));
		return result;
	}
	serialize(data) {
		super.serialize(data);
		data.index = this.index;
	}
	deserialize(data) {
		super.deserialize(data);
		this.index = data.index;
	}
};
/**
* TSL function for creating a reference node.
*
* @tsl
* @function
* @param {number} [index=0] - The attribute index.
* @returns {VertexColorNode}
*/
var vertexColor$1 = (index = 0) => nodeObject$1(new VertexColorNode(index));
/**
* Represents a "Color Burn" blend mode.
*
* It's designed to darken the base layer's colors based on the color of the blend layer.
* It significantly increases the contrast of the base layer, making the colors more vibrant and saturated.
* The darker the color in the blend layer, the stronger the darkening and contrast effect on the base layer.
*
* @tsl
* @function
* @param {Node<vec3>} base - The base color.
* @param {Node<vec3>} blend - The blend color. A white (#ffffff) blend color does not alter the base color.
* @return {Node<vec3>} The result.
*/
var blendBurn$1 = /* @__PURE__ */ Fn$1(([base, blend]) => {
	return min$1(1, base.oneMinus().div(blend)).oneMinus();
}).setLayout({
	name: "blendBurn",
	type: "vec3",
	inputs: [{
		name: "base",
		type: "vec3"
	}, {
		name: "blend",
		type: "vec3"
	}]
});
/**
* Represents a "Color Dodge" blend mode.
*
* It's designed to lighten the base layer's colors based on the color of the blend layer.
* It significantly increases the brightness of the base layer, making the colors lighter and more vibrant.
* The brighter the color in the blend layer, the stronger the lightening and contrast effect on the base layer.
*
* @tsl
* @function
* @param {Node<vec3>} base - The base color.
* @param {Node<vec3>} blend - The blend color. A black (#000000) blend color does not alter the base color.
* @return {Node<vec3>} The result.
*/
var blendDodge$1 = /* @__PURE__ */ Fn$1(([base, blend]) => {
	return min$1(base.div(blend.oneMinus()), 1);
}).setLayout({
	name: "blendDodge",
	type: "vec3",
	inputs: [{
		name: "base",
		type: "vec3"
	}, {
		name: "blend",
		type: "vec3"
	}]
});
/**
* Represents a "Screen" blend mode.
*
* Similar to `blendDodge()`, this mode also lightens the base layer's colors based on the color of the blend layer.
* The "Screen" blend mode is better for general brightening whereas the "Dodge" results in more subtle and nuanced
* effects.
*
* @tsl
* @function
* @param {Node<vec3>} base - The base color.
* @param {Node<vec3>} blend - The blend color. A black (#000000) blend color does not alter the base color.
* @return {Node<vec3>} The result.
*/
var blendScreen$1 = /* @__PURE__ */ Fn$1(([base, blend]) => {
	return base.oneMinus().mul(blend.oneMinus()).oneMinus();
}).setLayout({
	name: "blendScreen",
	type: "vec3",
	inputs: [{
		name: "base",
		type: "vec3"
	}, {
		name: "blend",
		type: "vec3"
	}]
});
/**
* Represents a "Overlay" blend mode.
*
* It's designed to increase the contrast of the base layer based on the color of the blend layer.
* It amplifies the existing colors and contrast in the base layer, making lighter areas lighter and darker areas darker.
* The color of the blend layer significantly influences the resulting contrast and color shift in the base layer.
*
* @tsl
* @function
* @param {Node<vec3>} base - The base color.
* @param {Node<vec3>} blend - The blend color
* @return {Node<vec3>} The result.
*/
var blendOverlay$1 = /* @__PURE__ */ Fn$1(([base, blend]) => {
	return mix$2(base.mul(2).mul(blend), base.oneMinus().mul(2).mul(blend.oneMinus()).oneMinus(), step$1(.5, base));
}).setLayout({
	name: "blendOverlay",
	type: "vec3",
	inputs: [{
		name: "base",
		type: "vec3"
	}, {
		name: "blend",
		type: "vec3"
	}]
});
/**
* This function blends two color based on their alpha values by replicating the behavior of `THREE.NormalBlending`.
* It assumes both input colors have non-premultiplied alpha.
*
* @tsl
* @function
* @param {Node<vec4>} base - The base color.
* @param {Node<vec4>} blend - The blend color
* @return {Node<vec4>} The result.
*/
var blendColor$1 = /* @__PURE__ */ Fn$1(([base, blend]) => {
	const outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));
	return vec4$1(blend.rgb.mul(blend.a).add(base.rgb.mul(base.a).mul(blend.a.oneMinus())).div(outAlpha), outAlpha);
}).setLayout({
	name: "blendColor",
	type: "vec4",
	inputs: [{
		name: "base",
		type: "vec4"
	}, {
		name: "blend",
		type: "vec4"
	}]
});
/**
* Premultiplies the RGB channels of a color by its alpha channel.
*
* This function is useful for converting a non-premultiplied alpha color
* into a premultiplied alpha format, where the RGB values are scaled
* by the alpha value. Premultiplied alpha is often used in graphics
* rendering for certain operations, such as compositing and image processing.
*
* @tsl
* @function
* @param {Node<vec4>} color - The input color with non-premultiplied alpha.
* @return {Node<vec4>} The color with premultiplied alpha.
*/
var premultiplyAlpha$1 = /* @__PURE__ */ Fn$1(([color$2]) => {
	return vec4$1(color$2.rgb.mul(color$2.a), color$2.a);
}, {
	color: "vec4",
	return: "vec4"
});
/**
* Unpremultiplies the RGB channels of a color by its alpha channel.
*
* This function is useful for converting a premultiplied alpha color
* back into a non-premultiplied alpha format, where the RGB values are
* divided by the alpha value. Unpremultiplied alpha is often used in graphics
* rendering for certain operations, such as compositing and image processing.
*
* @tsl
* @function
* @param {Node<vec4>} color - The input color with premultiplied alpha.
* @return {Node<vec4>} The color with non-premultiplied alpha.
*/
var unpremultiplyAlpha$1 = /* @__PURE__ */ Fn$1(([color$2]) => {
	If$1(color$2.a.equal(0), () => vec4$1(0));
	return vec4$1(color$2.rgb.div(color$2.a), color$2.a);
}, {
	color: "vec4",
	return: "vec4"
});
/**
* @tsl
* @function
* @deprecated since r171. Use {@link blendBurn} instead.
*
* @param {...any} params
* @returns {Function}
*/
var burn$1 = (...params) => {
	warn("TSL: \"burn\" has been renamed. Use \"blendBurn\" instead.");
	return blendBurn$1(params);
};
/**
* @tsl
* @function
* @deprecated since r171. Use {@link blendDodge} instead.
*
* @param {...any} params
* @returns {Function}
*/
var dodge$1 = (...params) => {
	warn("TSL: \"dodge\" has been renamed. Use \"blendDodge\" instead.");
	return blendDodge$1(params);
};
/**
* @tsl
* @function
* @deprecated since r171. Use {@link blendScreen} instead.
*
* @param {...any} params
* @returns {Function}
*/
var screen$1 = (...params) => {
	warn("TSL: \"screen\" has been renamed. Use \"blendScreen\" instead.");
	return blendScreen$1(params);
};
/**
* @tsl
* @function
* @deprecated since r171. Use {@link blendOverlay} instead.
*
* @param {...any} params
* @returns {Function}
*/
var overlay$1 = (...params) => {
	warn("TSL: \"overlay\" has been renamed. Use \"blendOverlay\" instead.");
	return blendOverlay$1(params);
};
/**
* Base class for all node materials.
*
* @augments Material
*/
var NodeMaterial = class extends Material {
	static get type() {
		return "NodeMaterial";
	}
	/**
	* Represents the type of the node material.
	*
	* @type {string}
	*/
	get type() {
		return this.constructor.type;
	}
	set type(_value) {}
	/**
	* Constructs a new node material.
	*/
	constructor() {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isNodeMaterial = true;
		/**
		* Whether this material is affected by fog or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.fog = true;
		/**
		* Whether this material is affected by lights or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.lights = false;
		/**
		* Whether this material uses hardware clipping or not.
		* This property is managed by the engine and should not be
		* modified by apps.
		*
		* @type {boolean}
		* @default false
		*/
		this.hardwareClipping = false;
		/**
		* Node materials which set their `lights` property to `true`
		* are affected by all lights of the scene. Sometimes selective
		* lighting is wanted which means only _some_ lights in the scene
		* affect a material. This can be achieved by creating an instance
		* of {@link LightsNode} with a list of selective
		* lights and assign the node to this property.
		*
		* ```js
		* const customLightsNode = lights( [ light1, light2 ] );
		* material.lightsNode = customLightsNode;
		* ```
		*
		* @type {?LightsNode}
		* @default null
		*/
		this.lightsNode = null;
		/**
		* The environment of node materials can be defined by an environment
		* map assigned to the `envMap` property or by `Scene.environment`
		* if the node material is a PBR material. This node property allows to overwrite
		* the default behavior and define the environment with a custom node.
		*
		* ```js
		* material.envNode = pmremTexture( renderTarget.texture );
		* ```
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.envNode = null;
		/**
		* The lighting of node materials might be influenced by ambient occlusion.
		* The default AO is inferred from an ambient occlusion map assigned to `aoMap`
		* and the respective `aoMapIntensity`. This node property allows to overwrite
		* the default and define the ambient occlusion with a custom node instead.
		*
		* If you don't want to overwrite the diffuse color but modify the existing
		* values instead, use {@link materialAO}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.aoNode = null;
		/**
		* The diffuse color of node materials is by default inferred from the
		* `color` and `map` properties. This node property allows to overwrite the default
		* and define the diffuse color with a node instead.
		*
		* ```js
		* material.colorNode = color( 0xff0000 ); // define red color
		* ```
		*
		* If you don't want to overwrite the diffuse color but modify the existing
		* values instead, use {@link materialColor}.
		*
		* ```js
		* material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint
		* ```
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.colorNode = null;
		/**
		* The normals of node materials are by default inferred from the `normalMap`/`normalScale`
		* or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default
		* and define the normals with a node instead.
		*
		* If you don't want to overwrite the normals but modify the existing values instead,
		* use {@link materialNormal}.
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.normalNode = null;
		/**
		* The opacity of node materials is by default inferred from the `opacity`
		* and `alphaMap` properties. This node property allows to overwrite the default
		* and define the opacity with a node instead.
		*
		* If you don't want to overwrite the opacity but modify the existing
		* value instead, use {@link materialOpacity}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.opacityNode = null;
		/**
		* This node can be used to implement a variety of filter-like effects. The idea is
		* to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it
		* to create an arbitrary effect and then assign the node composition to this property.
		* Everything behind the object using this material will now be affected by a filter.
		*
		* ```js
		* const material = new NodeMaterial()
		* material.transparent = true;
		*
		* // everything behind the object will be monochromatic
		* material.backdropNode = saturation( viewportSharedTexture().rgb, 0 );
		* ```
		*
		* Backdrop computations are part of the lighting so only lit materials can use this property.
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.backdropNode = null;
		/**
		* This node allows to modulate the influence of `backdropNode` to the outgoing light.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.backdropAlphaNode = null;
		/**
		* The alpha test of node materials is by default inferred from the `alphaTest`
		* property. This node property allows to overwrite the default and define the
		* alpha test with a node instead.
		*
		* If you don't want to overwrite the alpha test but modify the existing
		* value instead, use {@link materialAlphaTest}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.alphaTestNode = null;
		/**
		* Discards the fragment if the mask value is `false`.
		*
		* @type {?Node<bool>}
		* @default null
		*/
		this.maskNode = null;
		/**
		* The local vertex positions are computed based on multiple factors like the
		* attribute data, morphing or skinning. This node property allows to overwrite
		* the default and define local vertex positions with nodes instead.
		*
		* If you don't want to overwrite the vertex positions but modify the existing
		* values instead, use {@link positionLocal}.
		*
		*```js
		* material.positionNode = positionLocal.add( displace );
		* ```
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.positionNode = null;
		/**
		* This node property is intended for logic which modifies geometry data once or per animation step.
		* Apps usually place such logic randomly in initialization routines or in the animation loop.
		* `geometryNode` is intended as a dedicated API so there is an intended spot where geometry modifications
		* can be implemented.
		*
		* The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example
		* would be a GPU based particle system that provides a node material for usage on app level. The particle
		* simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is
		* eventually assigned to `geometryNode`.
		*
		* @type {?Function}
		* @default null
		*/
		this.geometryNode = null;
		/**
		* Allows to overwrite depth values in the fragment shader.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.depthNode = null;
		/**
		* Allows to overwrite the position used for shadow map rendering which
		* is by default {@link positionWorld}, the vertex position
		* in world space.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.receivedShadowPositionNode = null;
		/**
		* Allows to overwrite the geometry position used for shadow map projection which
		* is by default {@link positionLocal}, the vertex position in local space.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.castShadowPositionNode = null;
		/**
		* This node can be used to influence how an object using this node material
		* receive shadows.
		*
		* ```js
		* const totalShadows = float( 1 ).toVar();
		* material.receivedShadowNode = Fn( ( [ shadow ] ) => {
		* 	totalShadows.mulAssign( shadow );
		* 	//return float( 1 ); // bypass received shadows
		* 	return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color
		* } );
		*
		* @type {?(Function|FunctionNode<vec4>)}
		* @default null
		*/
		this.receivedShadowNode = null;
		/**
		* This node can be used to influence how an object using this node material
		* casts shadows. To apply a color to shadows, you can simply do:
		*
		* ```js
		* material.castShadowNode = vec4( 1, 0, 0, 1 );
		* ```
		*
		* Which can be nice to fake colored shadows of semi-transparent objects. It
		* is also common to use the property with `Fn` function so checks are performed
		* per fragment.
		*
		* ```js
		* materialCustomShadow.castShadowNode = Fn( () => {
		* 	hash( vertexIndex ).greaterThan( 0.5 ).discard();
		* 	return materialColor;
		* } )();
		*  ```
		*
		* @type {?Node<vec4>}
		* @default null
		*/
		this.castShadowNode = null;
		/**
		* This node can be used to define the final output of the material.
		*
		* TODO: Explain the differences to `fragmentNode`.
		*
		* @type {?Node<vec4>}
		* @default null
		*/
		this.outputNode = null;
		/**
		* MRT configuration is done on renderer or pass level. This node allows to
		* overwrite what values are written into MRT targets on material level. This
		* can be useful for implementing selective FX features that should only affect
		* specific objects.
		*
		* @type {?MRTNode}
		* @default null
		*/
		this.mrtNode = null;
		/**
		* This node property can be used if you need complete freedom in implementing
		* the fragment shader. Assigning a node will replace the built-in material
		* logic used in the fragment stage.
		*
		* @type {?Node<vec4>}
		* @default null
		*/
		this.fragmentNode = null;
		/**
		* This node property can be used if you need complete freedom in implementing
		* the vertex shader. Assigning a node will replace the built-in material logic
		* used in the vertex stage.
		*
		* @type {?Node<vec4>}
		* @default null
		*/
		this.vertexNode = null;
		Object.defineProperty(this, "shadowPositionNode", {
			get: () => {
				return this.receivedShadowPositionNode;
			},
			set: (value) => {
				warn("NodeMaterial: \".shadowPositionNode\" was renamed to \".receivedShadowPositionNode\".");
				this.receivedShadowPositionNode = value;
			}
		});
	}
	/**
	* Returns an array of child nodes for this material.
	*
	* @private
	* @returns {Array<{property: string, childNode: Node}>}
	*/
	_getNodeChildren() {
		const children = [];
		for (const property$2 of Object.getOwnPropertyNames(this)) {
			if (property$2.startsWith("_") === true) continue;
			const object = this[property$2];
			if (object && object.isNode === true) children.push({
				property: property$2,
				childNode: object
			});
		}
		return children;
	}
	/**
	* Allows to define a custom cache key that influence the material key computation
	* for render objects.
	*
	* @return {string} The custom cache key.
	*/
	customProgramCacheKey() {
		const values = [];
		for (const { property: property$2, childNode } of this._getNodeChildren()) values.push(hashString(property$2.slice(0, -4)), childNode.getCacheKey());
		return this.type + hashArray(values);
	}
	/**
	* Builds this material with the given node builder.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	build(builder) {
		this.setup(builder);
	}
	/**
	* Setups a node material observer with the given builder.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {NodeMaterialObserver} The node material observer.
	*/
	setupObserver(builder) {
		return new NodeMaterialObserver(builder);
	}
	/**
	* Setups the vertex and fragment stage of this node material.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setup(builder) {
		builder.context.setupNormal = () => subBuild$1(this.setupNormal(builder), "NORMAL", "vec3");
		builder.context.setupPositionView = () => this.setupPositionView(builder);
		builder.context.setupModelViewProjection = () => this.setupModelViewProjection(builder);
		const renderer = builder.renderer;
		const renderTarget = renderer.getRenderTarget();
		builder.addStack();
		const mvp = subBuild$1(this.setupVertex(builder), "VERTEX");
		const vertexNode = this.vertexNode || mvp;
		builder.stack.outputNode = vertexNode;
		this.setupHardwareClipping(builder);
		if (this.geometryNode !== null) builder.stack.outputNode = builder.stack.outputNode.bypass(this.geometryNode);
		builder.addFlow("vertex", builder.removeStack());
		builder.addStack();
		let resultNode;
		const clippingNode = this.setupClipping(builder);
		if (this.depthWrite === true || this.depthTest === true) {
			if (renderTarget !== null) {
				if (renderTarget.depthBuffer === true) this.setupDepth(builder);
			} else if (renderer.depth === true) this.setupDepth(builder);
		}
		if (this.fragmentNode === null) {
			this.setupDiffuseColor(builder);
			this.setupVariants(builder);
			const outgoingLightNode = this.setupLighting(builder);
			if (clippingNode !== null) builder.stack.addToStack(clippingNode);
			const basicOutput = vec4$1(outgoingLightNode, diffuseColor$1.a).max(0);
			resultNode = this.setupOutput(builder, basicOutput);
			output$1.assign(resultNode);
			const isCustomOutput = this.outputNode !== null;
			if (isCustomOutput) resultNode = this.outputNode;
			if (renderTarget !== null) {
				const mrt$2 = renderer.getMRT();
				const materialMRT = this.mrtNode;
				if (mrt$2 !== null) {
					if (isCustomOutput) output$1.assign(resultNode);
					resultNode = mrt$2;
					if (materialMRT !== null) resultNode = mrt$2.merge(materialMRT);
				} else if (materialMRT !== null) resultNode = materialMRT;
			}
		} else {
			let fragmentNode = this.fragmentNode;
			if (fragmentNode.isOutputStructNode !== true) fragmentNode = vec4$1(fragmentNode);
			resultNode = this.setupOutput(builder, fragmentNode);
		}
		builder.stack.outputNode = resultNode;
		builder.addFlow("fragment", builder.removeStack());
		builder.observer = this.setupObserver(builder);
	}
	/**
	* Setups the clipping node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {ClippingNode} The clipping node.
	*/
	setupClipping(builder) {
		if (builder.clippingContext === null) return null;
		const { unionPlanes, intersectionPlanes } = builder.clippingContext;
		let result = null;
		if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {
			const samples = builder.renderer.currentSamples;
			if (this.alphaToCoverage && samples > 1) result = clippingAlpha();
			else builder.stack.addToStack(clipping());
		}
		return result;
	}
	/**
	* Setups the hardware clipping if available on the current device.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setupHardwareClipping(builder) {
		this.hardwareClipping = false;
		if (builder.clippingContext === null) return;
		const candidateCount = builder.clippingContext.unionPlanes.length;
		if (candidateCount > 0 && candidateCount <= 8 && builder.isAvailable("clipDistance")) {
			builder.stack.addToStack(hardwareClipping());
			this.hardwareClipping = true;
		}
	}
	/**
	* Setups the depth of this material.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setupDepth(builder) {
		const { renderer, camera } = builder;
		let depthNode = this.depthNode;
		if (depthNode === null) {
			const mrt$2 = renderer.getMRT();
			if (mrt$2 && mrt$2.has("depth")) depthNode = mrt$2.get("depth");
			else if (renderer.logarithmicDepthBuffer === true) if (camera.isPerspectiveCamera) depthNode = viewZToLogarithmicDepth$1(positionView$1.z, cameraNear$1, cameraFar$1);
			else depthNode = viewZToOrthographicDepth$1(positionView$1.z, cameraNear$1, cameraFar$1);
		}
		if (depthNode !== null) depth$1.assign(depthNode).toStack();
	}
	/**
	* Setups the position node in view space. This method exists
	* so derived node materials can modify the implementation e.g. sprite materials.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node<vec3>} The position in view space.
	*/
	setupPositionView() {
		return modelViewMatrix$1.mul(positionLocal$1).xyz;
	}
	/**
	* Setups the position in clip space.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node<vec4>} The position in view space.
	*/
	setupModelViewProjection() {
		return cameraProjectionMatrix$1.mul(positionView$1);
	}
	/**
	* Setups the logic for the vertex stage.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node<vec4>} The position in clip space.
	*/
	setupVertex(builder) {
		builder.addStack();
		this.setupPosition(builder);
		builder.context.vertex = builder.removeStack();
		return modelViewProjection$1;
	}
	/**
	* Setups the computation of the position in local space.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node<vec3>} The position in local space.
	*/
	setupPosition(builder) {
		const { object, geometry } = builder;
		if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) morphReference$1(object).toStack();
		if (object.isSkinnedMesh === true) skinning$1(object).toStack();
		if (this.displacementMap) {
			const displacementMap = materialReference$1("displacementMap", "texture");
			const displacementScale = materialReference$1("displacementScale", "float");
			const displacementBias = materialReference$1("displacementBias", "float");
			positionLocal$1.addAssign(normalLocal$1.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));
		}
		if (object.isBatchedMesh) batch$1(object).toStack();
		if (object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true) instancedMesh$1(object).toStack();
		if (this.positionNode !== null) positionLocal$1.assign(subBuild$1(this.positionNode, "POSITION", "vec3"));
		return positionLocal$1;
	}
	/**
	* Setups the computation of the material's diffuse color.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {BufferGeometry} geometry - The geometry.
	*/
	setupDiffuseColor(builder) {
		const { object, geometry } = builder;
		if (this.maskNode !== null) bool$1(this.maskNode).not().discard();
		let colorNode = this.colorNode ? vec4$1(this.colorNode) : materialColor$1;
		if (this.vertexColors === true && geometry.hasAttribute("color")) colorNode = colorNode.mul(vertexColor$1());
		if (object.instanceColor) colorNode = varyingProperty$1("vec3", "vInstanceColor").mul(colorNode);
		if (object.isBatchedMesh && object._colorsTexture) colorNode = varyingProperty$1("vec3", "vBatchColor").mul(colorNode);
		diffuseColor$1.assign(colorNode);
		const opacityNode = this.opacityNode ? float$1(this.opacityNode) : materialOpacity$1;
		diffuseColor$1.a.assign(diffuseColor$1.a.mul(opacityNode));
		let alphaTestNode = null;
		if (this.alphaTestNode !== null || this.alphaTest > 0) {
			alphaTestNode = this.alphaTestNode !== null ? float$1(this.alphaTestNode) : materialAlphaTest$1;
			if (this.alphaToCoverage === true) {
				diffuseColor$1.a = smoothstep$1(alphaTestNode, alphaTestNode.add(fwidth$1(diffuseColor$1.a)), diffuseColor$1.a);
				diffuseColor$1.a.lessThanEqual(0).discard();
			} else diffuseColor$1.a.lessThanEqual(alphaTestNode).discard();
		}
		if (this.alphaHash === true) diffuseColor$1.a.lessThan(getAlphaHashThreshold(positionLocal$1)).discard();
		if (builder.isOpaque()) diffuseColor$1.a.assign(1);
	}
	/**
	* Abstract interface method that can be implemented by derived materials
	* to setup material-specific node variables.
	*
	* @abstract
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setupVariants() {}
	/**
	* Setups the outgoing light node variable
	*
	* @return {Node<vec3>} The outgoing light node.
	*/
	setupOutgoingLight() {
		return this.lights === true ? vec3$1(0) : diffuseColor$1.rgb;
	}
	/**
	* Setups the normal node from the material.
	*
	* @return {Node<vec3>} The normal node.
	*/
	setupNormal() {
		return this.normalNode ? vec3$1(this.normalNode) : materialNormal$1;
	}
	/**
	* Setups the environment node from the material.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node<vec4>} The environment node.
	*/
	setupEnvironment() {
		let node = null;
		if (this.envNode) node = this.envNode;
		else if (this.envMap) node = this.envMap.isCubeTexture ? materialReference$1("envMap", "cubeTexture") : materialReference$1("envMap", "texture");
		return node;
	}
	/**
	* Setups the light map node from the material.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node<vec3>} The light map node.
	*/
	setupLightMap(builder) {
		let node = null;
		if (builder.material.lightMap) node = new IrradianceNode(materialLightMap$1);
		return node;
	}
	/**
	* Setups the lights node based on the scene, environment and material.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {LightsNode} The lights node.
	*/
	setupLights(builder) {
		const materialLightsNode = [];
		const envNode = this.setupEnvironment(builder);
		if (envNode && envNode.isLightingNode) materialLightsNode.push(envNode);
		const lightMapNode = this.setupLightMap(builder);
		if (lightMapNode && lightMapNode.isLightingNode) materialLightsNode.push(lightMapNode);
		if (this.aoNode !== null || builder.material.aoMap) {
			const aoNode = this.aoNode !== null ? this.aoNode : materialAO$1;
			materialLightsNode.push(new AONode(aoNode));
		}
		let lightsN = this.lightsNode || builder.lightsNode;
		if (materialLightsNode.length > 0) lightsN = builder.renderer.lighting.createNode([...lightsN.getLights(), ...materialLightsNode]);
		return lightsN;
	}
	/**
	* This method should be implemented by most derived materials
	* since it defines the material's lighting model.
	*
	* @abstract
	* @param {NodeBuilder} builder - The current node builder.
	* @return {LightingModel} The lighting model.
	*/
	setupLightingModel() {}
	/**
	* Setups the outgoing light node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node<vec3>} The outgoing light node.
	*/
	setupLighting(builder) {
		const { material } = builder;
		const { backdropNode, backdropAlphaNode, emissiveNode } = this;
		const lightsNode = this.lights === true || this.lightsNode !== null ? this.setupLights(builder) : null;
		let outgoingLightNode = this.setupOutgoingLight(builder);
		if (lightsNode && lightsNode.getScope().hasLights) {
			const lightingModel = this.setupLightingModel(builder) || null;
			outgoingLightNode = lightingContext$1(lightsNode, lightingModel, backdropNode, backdropAlphaNode);
		} else if (backdropNode !== null) outgoingLightNode = vec3$1(backdropAlphaNode !== null ? mix$2(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
		if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
			emissive$1.assign(vec3$1(emissiveNode ? emissiveNode : materialEmissive$1));
			outgoingLightNode = outgoingLightNode.add(emissive$1);
		}
		return outgoingLightNode;
	}
	/**
	* Setup the fog.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node<vec4>} outputNode - The existing output node.
	* @return {Node<vec4>} The output node.
	*/
	setupFog(builder, outputNode) {
		const fogNode = builder.fogNode;
		if (fogNode) {
			output$1.assign(outputNode);
			outputNode = vec4$1(fogNode.toVar());
		}
		return outputNode;
	}
	/**
	* Setups premultiplied alpha.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node<vec4>} outputNode - The existing output node.
	* @return {Node<vec4>} The output node.
	*/
	setupPremultipliedAlpha(builder, outputNode) {
		return premultiplyAlpha$1(outputNode);
	}
	/**
	* Setups the output node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node<vec4>} outputNode - The existing output node.
	* @return {Node<vec4>} The output node.
	*/
	setupOutput(builder, outputNode) {
		if (this.fog === true) outputNode = this.setupFog(builder, outputNode);
		if (this.premultipliedAlpha === true) outputNode = this.setupPremultipliedAlpha(builder, outputNode);
		return outputNode;
	}
	/**
	* Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
	* there is `MeshBasicNodeMaterial`. This utility method is intended for
	* defining all material properties of the classic type in the node type.
	*
	* @param {Material} material - The material to copy properties with their values to this node material.
	*/
	setDefaultValues(material) {
		for (const property$2 in material) {
			const value = material[property$2];
			if (this[property$2] === void 0) {
				this[property$2] = value;
				if (value && value.clone) this[property$2] = value.clone();
			}
		}
		const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
		for (const key in descriptors) if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 && descriptors[key].get !== void 0) Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
	}
	/**
	* Serializes this material to JSON.
	*
	* @param {?(Object|string)} meta - The meta information for serialization.
	* @return {Object} The serialized node.
	*/
	toJSON(meta) {
		const isRoot = meta === void 0 || typeof meta === "string";
		if (isRoot) meta = {
			textures: {},
			images: {},
			nodes: {}
		};
		const data = Material.prototype.toJSON.call(this, meta);
		data.inputNodes = {};
		for (const { property: property$2, childNode } of this._getNodeChildren()) data.inputNodes[property$2] = childNode.toJSON(meta).uuid;
		function extractFromCache(cache$2) {
			const values = [];
			for (const key in cache$2) {
				const data$1 = cache$2[key];
				delete data$1.metadata;
				values.push(data$1);
			}
			return values;
		}
		if (isRoot) {
			const textures = extractFromCache(meta.textures);
			const images = extractFromCache(meta.images);
			const nodes = extractFromCache(meta.nodes);
			if (textures.length > 0) data.textures = textures;
			if (images.length > 0) data.images = images;
			if (nodes.length > 0) data.nodes = nodes;
		}
		return data;
	}
	/**
	* Copies the properties of the given node material to this instance.
	*
	* @param {NodeMaterial} source - The material to copy.
	* @return {NodeMaterial} A reference to this node material.
	*/
	copy(source) {
		this.lightsNode = source.lightsNode;
		this.envNode = source.envNode;
		this.aoNode = source.aoNode;
		this.colorNode = source.colorNode;
		this.normalNode = source.normalNode;
		this.opacityNode = source.opacityNode;
		this.backdropNode = source.backdropNode;
		this.backdropAlphaNode = source.backdropAlphaNode;
		this.alphaTestNode = source.alphaTestNode;
		this.maskNode = source.maskNode;
		this.positionNode = source.positionNode;
		this.geometryNode = source.geometryNode;
		this.depthNode = source.depthNode;
		this.receivedShadowPositionNode = source.receivedShadowPositionNode;
		this.castShadowPositionNode = source.castShadowPositionNode;
		this.receivedShadowNode = source.receivedShadowNode;
		this.castShadowNode = source.castShadowNode;
		this.outputNode = source.outputNode;
		this.mrtNode = source.mrtNode;
		this.fragmentNode = source.fragmentNode;
		this.vertexNode = source.vertexNode;
		return super.copy(source);
	}
};
var _defaultValues$d = /* @__PURE__ */ new LineBasicMaterial();
/**
* Node material version of {@link LineBasicMaterial}.
*
* @augments NodeMaterial
*/
var LineBasicNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "LineBasicNodeMaterial";
	}
	/**
	* Constructs a new line basic node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isLineBasicNodeMaterial = true;
		this.setDefaultValues(_defaultValues$d);
		this.setValues(parameters);
	}
};
var _defaultValues$c = /* @__PURE__ */ new LineDashedMaterial();
/**
* Node material version of  {@link LineDashedMaterial}.
*
* @augments NodeMaterial
*/
var LineDashedNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "LineDashedNodeMaterial";
	}
	/**
	* Constructs a new line dashed node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isLineDashedNodeMaterial = true;
		this.setDefaultValues(_defaultValues$c);
		/**
		* The dash offset.
		*
		* @type {number}
		* @default 0
		*/
		this.dashOffset = 0;
		/**
		* The offset of dash materials is by default inferred from the `dashOffset`
		* property. This node property allows to overwrite the default
		* and define the offset with a node instead.
		*
		* If you don't want to overwrite the offset but modify the existing
		* value instead, use {@link materialLineDashOffset}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.offsetNode = null;
		/**
		* The scale of dash materials is by default inferred from the `scale`
		* property. This node property allows to overwrite the default
		* and define the scale with a node instead.
		*
		* If you don't want to overwrite the scale but modify the existing
		* value instead, use {@link materialLineScale}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.dashScaleNode = null;
		/**
		* The dash size of dash materials is by default inferred from the `dashSize`
		* property. This node property allows to overwrite the default
		* and define the dash size with a node instead.
		*
		* If you don't want to overwrite the dash size but modify the existing
		* value instead, use {@link materialLineDashSize}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.dashSizeNode = null;
		/**
		* The gap size of dash materials is by default inferred from the `gapSize`
		* property. This node property allows to overwrite the default
		* and define the gap size with a node instead.
		*
		* If you don't want to overwrite the gap size but modify the existing
		* value instead, use {@link materialLineGapSize}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.gapSizeNode = null;
		this.setValues(parameters);
	}
	/**
	* Setups the dash specific node variables.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setupVariants() {
		const offsetNode = this.offsetNode ? float$1(this.offsetNode) : materialLineDashOffset$1;
		const dashScaleNode = this.dashScaleNode ? float$1(this.dashScaleNode) : materialLineScale$1;
		const dashSizeNode = this.dashSizeNode ? float$1(this.dashSizeNode) : materialLineDashSize$1;
		const gapSizeNode = this.gapSizeNode ? float$1(this.gapSizeNode) : materialLineGapSize$1;
		dashSize$1.assign(dashSizeNode);
		gapSize$1.assign(gapSizeNode);
		const vLineDistance = varying$1(attribute$1("lineDistance").mul(dashScaleNode));
		(offsetNode ? vLineDistance.add(offsetNode) : vLineDistance).mod(dashSize$1.add(gapSize$1)).greaterThan(dashSize$1).discard();
	}
};
var _sharedFramebuffer = null;
/**
* `ViewportTextureNode` creates an internal texture for each node instance. This module
* shares a texture across all instances of `ViewportSharedTextureNode`. It should
* be the first choice when using data of the default/screen framebuffer for performance reasons.
*
* @augments ViewportTextureNode
*/
var ViewportSharedTextureNode = class extends ViewportTextureNode {
	static get type() {
		return "ViewportSharedTextureNode";
	}
	/**
	* Constructs a new viewport shared texture node.
	*
	* @param {Node} [uvNode=screenUV] - The uv node.
	* @param {?Node} [levelNode=null] - The level node.
	*/
	constructor(uvNode = screenUV$1, levelNode = null) {
		if (_sharedFramebuffer === null) _sharedFramebuffer = new FramebufferTexture();
		super(uvNode, levelNode, _sharedFramebuffer);
	}
	/**
	* Overwritten so the method always returns the unique shared
	* framebuffer texture.
	*
	* @return {FramebufferTexture} The shared framebuffer texture.
	*/
	getTextureForReference() {
		return _sharedFramebuffer;
	}
	updateReference() {
		return this;
	}
};
/**
* TSL function for creating a shared viewport texture node.
*
* @tsl
* @function
* @param {?Node} [uvNode=screenUV] - The uv node.
* @param {?Node} [levelNode=null] - The level node.
* @returns {ViewportSharedTextureNode}
*/
var viewportSharedTexture$1 = /* @__PURE__ */ nodeProxy$1(ViewportSharedTextureNode).setParameterLength(0, 2);
/**
* Packs a direction vector into a color value.
*
* @tsl
* @function
* @param {Node<vec3>} node - The direction to pack.
* @return {Node<vec3>} The color.
*/
var directionToColor$1 = (node) => nodeObject$1(node).mul(.5).add(.5);
/**
* Unpacks a color value into a direction vector.
*
* @tsl
* @function
* @param {Node<vec3>} node - The color to unpack.
* @return {Node<vec3>} The direction.
*/
var colorToDirection$1 = (node) => nodeObject$1(node).mul(2).sub(1);
var _defaultValues$a = /* @__PURE__ */ new MeshNormalMaterial();
/**
* Node material version of {@link MeshNormalMaterial}.
*
* @augments NodeMaterial
*/
var MeshNormalNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "MeshNormalNodeMaterial";
	}
	/**
	* Constructs a new mesh normal node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshNormalNodeMaterial = true;
		this.setDefaultValues(_defaultValues$a);
		this.setValues(parameters);
	}
	/**
	* Overwrites the default implementation by computing the diffuse color
	* based on the normal data.
	*/
	setupDiffuseColor() {
		const opacityNode = this.opacityNode ? float$1(this.opacityNode) : materialOpacity$1;
		diffuseColor$1.assign(colorSpaceToWorking$1(vec4$1(directionToColor$1(normalView$1), opacityNode), SRGBColorSpace));
	}
};
/**
* TSL function for creating an equirect uv node.
*
* Can be used to compute texture coordinates for projecting an
* equirectangular texture onto a mesh for using it as the scene's
* background.
*
* ```js
* scene.backgroundNode = texture( equirectTexture, equirectUV() );
* ```
*
* @tsl
* @function
* @param {?Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.
* @returns {Node<vec2>}
*/
var equirectUV$1 = /* @__PURE__ */ Fn$1(([dir = positionWorldDirection$1]) => {
	const u = dir.z.atan(dir.x).mul(1 / (Math.PI * 2)).add(.5);
	const v = dir.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(.5);
	return vec2$1(u, v);
});
/**
* This class represents a cube render target. It is a special version
* of `WebGLCubeRenderTarget` which is compatible with `WebGPURenderer`.
*
* @augments WebGLCubeRenderTarget
*/
var CubeRenderTarget = class extends WebGLCubeRenderTarget {
	/**
	* Constructs a new cube render target.
	*
	* @param {number} [size=1] - The size of the render target.
	* @param {RenderTarget~Options} [options] - The configuration object.
	*/
	constructor(size = 1, options = {}) {
		super(size, options);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isCubeRenderTarget = true;
	}
	/**
	* Converts the given equirectangular texture to a cube map.
	*
	* @param {Renderer} renderer - The renderer.
	* @param {Texture} texture - The equirectangular texture.
	* @return {CubeRenderTarget} A reference to this cube render target.
	*/
	fromEquirectangularTexture(renderer, texture$1$1) {
		const currentMinFilter = texture$1$1.minFilter;
		const currentGenerateMipmaps = texture$1$1.generateMipmaps;
		texture$1$1.generateMipmaps = true;
		this.texture.type = texture$1$1.type;
		this.texture.colorSpace = texture$1$1.colorSpace;
		this.texture.generateMipmaps = texture$1$1.generateMipmaps;
		this.texture.minFilter = texture$1$1.minFilter;
		this.texture.magFilter = texture$1$1.magFilter;
		const geometry = new BoxGeometry(5, 5, 5);
		const uvNode = equirectUV$1(positionWorldDirection$1);
		const material = new NodeMaterial();
		material.colorNode = texture$1(texture$1$1, uvNode, 0);
		material.side = BackSide;
		material.blending = NoBlending;
		const mesh = new Mesh(geometry, material);
		const scene = new Scene();
		scene.add(mesh);
		if (texture$1$1.minFilter === LinearMipmapLinearFilter) texture$1$1.minFilter = LinearFilter;
		const camera = new CubeCamera(1, 10, this);
		const currentMRT = renderer.getMRT();
		renderer.setMRT(null);
		camera.update(renderer, scene);
		renderer.setMRT(currentMRT);
		texture$1$1.minFilter = currentMinFilter;
		texture$1$1.currentGenerateMipmaps = currentGenerateMipmaps;
		mesh.geometry.dispose();
		mesh.material.dispose();
		return this;
	}
};
var _cache$1 = /* @__PURE__ */ new WeakMap();
/**
* This node can be used to automatically convert environment maps in the
* equirectangular format into the cube map format.
*
* @augments TempNode
*/
var CubeMapNode = class extends TempNode {
	static get type() {
		return "CubeMapNode";
	}
	/**
	* Constructs a new cube map node.
	*
	* @param {Node} envNode - The node representing the environment map.
	*/
	constructor(envNode) {
		super("vec3");
		/**
		* The node representing the environment map.
		*
		* @type {Node}
		*/
		this.envNode = envNode;
		/**
		* A reference to the internal cube texture.
		*
		* @private
		* @type {?CubeTexture}
		* @default null
		*/
		this._cubeTexture = null;
		/**
		* A reference to the internal cube texture node.
		*
		* @private
		* @type {CubeTextureNode}
		*/
		this._cubeTextureNode = cubeTexture$1(null);
		const defaultTexture = new CubeTexture();
		defaultTexture.isRenderTargetTexture = true;
		/**
		* A default cube texture that acts as a placeholder.
		* It is used when the conversion from equirectangular to cube
		* map has not finished yet for a given texture.
		*
		* @private
		* @type {CubeTexture}
		*/
		this._defaultTexture = defaultTexture;
		/**
		* The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
		* the texture once per render in its {@link CubeMapNode#updateBefore} method.
		*
		* @type {string}
		* @default 'render'
		*/
		this.updateBeforeType = NodeUpdateType$1.RENDER;
	}
	updateBefore(frame) {
		const { renderer, material } = frame;
		const envNode = this.envNode;
		if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
			const texture$2 = envNode.isTextureNode ? envNode.value : material[envNode.property];
			if (texture$2 && texture$2.isTexture) {
				const mapping = texture$2.mapping;
				if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
					if (_cache$1.has(texture$2)) {
						const cubeMap = _cache$1.get(texture$2);
						mapTextureMapping(cubeMap, texture$2.mapping);
						this._cubeTexture = cubeMap;
					} else {
						const image = texture$2.image;
						if (isEquirectangularMapReady$1(image)) {
							const renderTarget = new CubeRenderTarget(image.height);
							renderTarget.fromEquirectangularTexture(renderer, texture$2);
							mapTextureMapping(renderTarget.texture, texture$2.mapping);
							this._cubeTexture = renderTarget.texture;
							_cache$1.set(texture$2, renderTarget.texture);
							texture$2.addEventListener("dispose", onTextureDispose);
						} else this._cubeTexture = this._defaultTexture;
					}
					this._cubeTextureNode.value = this._cubeTexture;
				} else this._cubeTextureNode = this.envNode;
			}
		}
	}
	setup(builder) {
		this.updateBefore(builder);
		return this._cubeTextureNode;
	}
};
/**
* Returns true if the given equirectangular image has been fully loaded
* and is ready for further processing.
*
* @private
* @param {Image} image - The equirectangular image to check.
* @return {boolean} Whether the image is ready or not.
*/
function isEquirectangularMapReady$1(image) {
	if (image === null || image === void 0) return false;
	return image.height > 0;
}
/**
* This function is executed when `dispose()` is called on the equirectangular
* texture. In this case, the generated cube map with its render target
* is deleted as well.
*
* @private
* @param {Object} event - The event object.
*/
function onTextureDispose(event) {
	const texture$2 = event.target;
	texture$2.removeEventListener("dispose", onTextureDispose);
	const renderTarget = _cache$1.get(texture$2);
	if (renderTarget !== void 0) {
		_cache$1.delete(texture$2);
		renderTarget.dispose();
	}
}
/**
* This function makes sure the generated cube map uses the correct
* texture mapping that corresponds to the equirectangular original.
*
* @private
* @param {Texture} texture - The cube texture.
* @param {number} mapping - The original texture mapping.
*/
function mapTextureMapping(texture$2, mapping) {
	if (mapping === EquirectangularReflectionMapping) texture$2.mapping = CubeReflectionMapping;
	else if (mapping === EquirectangularRefractionMapping) texture$2.mapping = CubeRefractionMapping;
}
/**
* TSL function for creating a cube map node.
*
* @tsl
* @function
* @param {Node} envNode - The node representing the environment map.
* @returns {CubeMapNode}
*/
var cubeMapNode = /* @__PURE__ */ nodeProxy$1(CubeMapNode).setParameterLength(1);
/**
* Represents a basic model for Image-based lighting (IBL). The environment
* is defined via environment maps in the equirectangular or cube map format.
* `BasicEnvironmentNode` is intended for non-PBR materials like {@link MeshBasicNodeMaterial}
* or {@link MeshPhongNodeMaterial}.
*
* @augments LightingNode
*/
var BasicEnvironmentNode = class extends LightingNode {
	static get type() {
		return "BasicEnvironmentNode";
	}
	/**
	* Constructs a new basic environment node.
	*
	* @param {Node} [envNode=null] - A node representing the environment.
	*/
	constructor(envNode = null) {
		super();
		/**
		* A node representing the environment.
		*
		* @type {Node}
		* @default null
		*/
		this.envNode = envNode;
	}
	setup(builder) {
		builder.context.environment = cubeMapNode(this.envNode);
	}
};
/**
* A specific version of {@link IrradianceNode} that is only relevant
* for {@link MeshBasicNodeMaterial}. Since the material is unlit, it
* requires a special scaling factor for the light map.
*
* @augments LightingNode
*/
var BasicLightMapNode = class extends LightingNode {
	static get type() {
		return "BasicLightMapNode";
	}
	/**
	* Constructs a new basic light map node.
	*
	* @param {?Node<vec3>} [lightMapNode=null] - The light map node.
	*/
	constructor(lightMapNode = null) {
		super();
		/**
		* The light map node.
		*
		* @type {?Node<vec3>}
		*/
		this.lightMapNode = lightMapNode;
	}
	setup(builder) {
		const RECIPROCAL_PI$1 = float$1(1 / Math.PI);
		builder.context.irradianceLightMap = this.lightMapNode.mul(RECIPROCAL_PI$1);
	}
};
/**
* Abstract class for implementing lighting models. The module defines
* multiple methods that concrete lighting models can implement. These
* methods are executed at different points during the light evaluation
* process.
*/
var LightingModel = class {
	/**
	* This method is intended for setting up lighting model and context data
	* which are later used in the evaluation process.
	*
	* @abstract
	* @param {NodeBuilder} builder - The current node builder.
	*/
	start(builder) {
		builder.lightsNode.setupLights(builder, builder.lightsNode.getLightNodes(builder));
		this.indirect(builder);
	}
	/**
	* This method is intended for executing final tasks like final updates
	* to the outgoing light.
	*
	* @abstract
	* @param {NodeBuilder} builder - The current node builder.
	*/
	finish() {}
	/**
	* This method is intended for implementing the direct light term and
	* executed during the build process of directional, point and spot light nodes.
	*
	* @abstract
	* @param {Object} lightData - The light data.
	* @param {NodeBuilder} builder - The current node builder.
	*/
	direct() {}
	/**
	* This method is intended for implementing the direct light term for
	* rect area light nodes.
	*
	* @abstract
	* @param {Object} lightData - The light data.
	* @param {NodeBuilder} builder - The current node builder.
	*/
	directRectArea() {}
	/**
	* This method is intended for implementing the indirect light term.
	*
	* @abstract
	* @param {NodeBuilder} builder - The current node builder.
	*/
	indirect() {}
	/**
	* This method is intended for implementing the ambient occlusion term.
	* Unlike other methods, this method must be called manually by the lighting
	* model in its indirect term.
	*
	* @abstract
	* @param {NodeBuilder} builder - The current node builder.
	*/
	ambientOcclusion() {}
};
/**
* Represents the lighting model for unlit materials. The only light contribution
* is baked indirect lighting modulated with ambient occlusion and the material's
* diffuse color. Environment mapping is supported. Used in {@link MeshBasicNodeMaterial}.
*
* @augments LightingModel
*/
var BasicLightingModel = class extends LightingModel {
	/**
	* Constructs a new basic lighting model.
	*/
	constructor() {
		super();
	}
	/**
	* Implements the baked indirect lighting with its modulation.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	indirect({ context: context$2 }) {
		const ambientOcclusion = context$2.ambientOcclusion;
		const reflectedLight = context$2.reflectedLight;
		const irradianceLightMap = context$2.irradianceLightMap;
		reflectedLight.indirectDiffuse.assign(vec4$1(0));
		if (irradianceLightMap) reflectedLight.indirectDiffuse.addAssign(irradianceLightMap);
		else reflectedLight.indirectDiffuse.addAssign(vec4$1(1, 1, 1, 0));
		reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
		reflectedLight.indirectDiffuse.mulAssign(diffuseColor$1.rgb);
	}
	/**
	* Implements the environment mapping.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	finish(builder) {
		const { material, context: context$2 } = builder;
		const outgoingLight = context$2.outgoingLight;
		const envNode = builder.context.environment;
		if (envNode) switch (material.combine) {
			case MultiplyOperation:
				outgoingLight.rgb.assign(mix$2(outgoingLight.rgb, outgoingLight.rgb.mul(envNode.rgb), materialSpecularStrength$1.mul(materialReflectivity$1)));
				break;
			case MixOperation:
				outgoingLight.rgb.assign(mix$2(outgoingLight.rgb, envNode.rgb, materialSpecularStrength$1.mul(materialReflectivity$1)));
				break;
			case AddOperation:
				outgoingLight.rgb.addAssign(envNode.rgb.mul(materialSpecularStrength$1.mul(materialReflectivity$1)));
				break;
			default:
				warn("BasicLightingModel: Unsupported .combine value:", material.combine);
				break;
		}
	}
};
var _defaultValues$9 = /* @__PURE__ */ new MeshBasicMaterial();
/**
* Node material version of {@link MeshBasicMaterial}.
*
* @augments NodeMaterial
*/
var MeshBasicNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "MeshBasicNodeMaterial";
	}
	/**
	* Constructs a new mesh basic node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshBasicNodeMaterial = true;
		/**
		* Although the basic material is by definition unlit, we set
		* this property to `true` since we use a lighting model to compute
		* the outgoing light of the fragment shader.
		*
		* @type {boolean}
		* @default true
		*/
		this.lights = true;
		this.setDefaultValues(_defaultValues$9);
		this.setValues(parameters);
	}
	/**
	* Basic materials are not affected by normal and bump maps so we
	* return by default {@link normalViewGeometry}.
	*
	* @return {Node<vec3>} The normal node.
	*/
	setupNormal() {
		return directionToFaceDirection$1(normalViewGeometry$1);
	}
	/**
	* Overwritten since this type of material uses {@link BasicEnvironmentNode}
	* to implement the default environment mapping.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {?BasicEnvironmentNode<vec3>} The environment node.
	*/
	setupEnvironment(builder) {
		const envNode = super.setupEnvironment(builder);
		return envNode ? new BasicEnvironmentNode(envNode) : null;
	}
	/**
	* This method must be overwritten since light maps are evaluated
	* with a special scaling factor for basic materials.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {?BasicLightMapNode<vec3>} The light map node.
	*/
	setupLightMap(builder) {
		let node = null;
		if (builder.material.lightMap) node = new BasicLightMapNode(materialLightMap$1);
		return node;
	}
	/**
	* The material overwrites this method because `lights` is set to `true` but
	* we still want to return the diffuse color as the outgoing light.
	*
	* @return {Node<vec3>} The outgoing light node.
	*/
	setupOutgoingLight() {
		return diffuseColor$1.rgb;
	}
	/**
	* Setups the lighting model.
	*
	* @return {BasicLightingModel} The lighting model.
	*/
	setupLightingModel() {
		return new BasicLightingModel();
	}
};
var F_Schlick$1 = /* @__PURE__ */ Fn$1(({ f0, f90, dotVH }) => {
	const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
	return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
var BRDF_Lambert$1 = /* @__PURE__ */ Fn$1((inputs) => {
	return inputs.diffuseColor.mul(1 / Math.PI);
});
var G_BlinnPhong_Implicit = () => float$1(.25);
var D_BlinnPhong = /* @__PURE__ */ Fn$1(({ dotNH }) => {
	return shininess$1.mul(float$1(.5)).add(1).mul(float$1(1 / Math.PI)).mul(dotNH.pow(shininess$1));
});
var BRDF_BlinnPhong = /* @__PURE__ */ Fn$1(({ lightDirection }) => {
	const halfDir = lightDirection.add(positionViewDirection$1).normalize();
	const dotNH = normalView$1.dot(halfDir).clamp();
	const dotVH = positionViewDirection$1.dot(halfDir).clamp();
	const F = F_Schlick$1({
		f0: specularColor$1,
		f90: 1,
		dotVH
	});
	const G = G_BlinnPhong_Implicit();
	const D = D_BlinnPhong({ dotNH });
	return F.mul(G).mul(D);
});
/**
* Represents the lighting model for a phong material. Used in {@link MeshPhongNodeMaterial}.
*
* @augments BasicLightingModel
*/
var PhongLightingModel = class extends BasicLightingModel {
	/**
	* Constructs a new phong lighting model.
	*
	* @param {boolean} [specular=true] - Whether specular is supported or not.
	*/
	constructor(specular = true) {
		super();
		/**
		* Whether specular is supported or not. Set this to `false` if you are
		* looking for a Lambert-like material meaning a material for non-shiny
		* surfaces, without specular highlights.
		*
		* @type {boolean}
		* @default true
		*/
		this.specular = specular;
	}
	/**
	* Implements the direct lighting. The specular portion is optional an can be controlled
	* with the {@link PhongLightingModel#specular} flag.
	*
	* @param {Object} lightData - The light data.
	*/
	direct({ lightDirection, lightColor, reflectedLight }) {
		const irradiance = normalView$1.dot(lightDirection).clamp().mul(lightColor);
		reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert$1({ diffuseColor: diffuseColor$1.rgb })));
		if (this.specular === true) reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({ lightDirection })).mul(materialSpecularStrength$1));
	}
	/**
	* Implements the indirect lighting.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	indirect(builder) {
		const { ambientOcclusion, irradiance, reflectedLight } = builder.context;
		reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert$1({ diffuseColor: diffuseColor$1 })));
		reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
	}
};
var _defaultValues$8 = /* @__PURE__ */ new MeshLambertMaterial();
/**
* Node material version of {@link MeshLambertMaterial}.
*
* @augments NodeMaterial
*/
var MeshLambertNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "MeshLambertNodeMaterial";
	}
	/**
	* Constructs a new mesh lambert node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshLambertNodeMaterial = true;
		/**
		* Set to `true` because lambert materials react on lights.
		*
		* @type {boolean}
		* @default true
		*/
		this.lights = true;
		this.setDefaultValues(_defaultValues$8);
		this.setValues(parameters);
	}
	/**
	* Overwritten since this type of material uses {@link BasicEnvironmentNode}
	* to implement the default environment mapping.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {?BasicEnvironmentNode<vec3>} The environment node.
	*/
	setupEnvironment(builder) {
		const envNode = super.setupEnvironment(builder);
		return envNode ? new BasicEnvironmentNode(envNode) : null;
	}
	/**
	* Setups the lighting model.
	*
	* @return {PhongLightingModel} The lighting model.
	*/
	setupLightingModel() {
		return new PhongLightingModel(false);
	}
};
var _defaultValues$7 = /* @__PURE__ */ new MeshPhongMaterial();
/**
* Node material version of {@link MeshPhongMaterial}.
*
* @augments NodeMaterial
*/
var MeshPhongNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "MeshPhongNodeMaterial";
	}
	/**
	* Constructs a new mesh lambert node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshPhongNodeMaterial = true;
		/**
		* Set to `true` because phong materials react on lights.
		*
		* @type {boolean}
		* @default true
		*/
		this.lights = true;
		/**
		* The shininess of phong materials is by default inferred from the `shininess`
		* property. This node property allows to overwrite the default
		* and define the shininess with a node instead.
		*
		* If you don't want to overwrite the shininess but modify the existing
		* value instead, use {@link materialShininess}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.shininessNode = null;
		/**
		* The specular color of phong materials is by default inferred from the
		* `specular` property. This node property allows to overwrite the default
		* and define the specular color with a node instead.
		*
		* If you don't want to overwrite the specular color but modify the existing
		* value instead, use {@link materialSpecular}.
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.specularNode = null;
		this.setDefaultValues(_defaultValues$7);
		this.setValues(parameters);
	}
	/**
	* Overwritten since this type of material uses {@link BasicEnvironmentNode}
	* to implement the default environment mapping.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {?BasicEnvironmentNode<vec3>} The environment node.
	*/
	setupEnvironment(builder) {
		const envNode = super.setupEnvironment(builder);
		return envNode ? new BasicEnvironmentNode(envNode) : null;
	}
	/**
	* Setups the lighting model.
	*
	* @return {PhongLightingModel} The lighting model.
	*/
	setupLightingModel() {
		return new PhongLightingModel();
	}
	/**
	* Setups the phong specific node variables.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setupVariants() {
		const shininessNode = (this.shininessNode ? float$1(this.shininessNode) : materialShininess$1).max(1e-4);
		shininess$1.assign(shininessNode);
		const specularNode = this.specularNode || materialSpecular$1;
		specularColor$1.assign(specularNode);
	}
	copy(source) {
		this.shininessNode = source.shininessNode;
		this.specularNode = source.specularNode;
		return super.copy(source);
	}
};
var getGeometryRoughness$1 = /* @__PURE__ */ Fn$1((builder) => {
	if (builder.geometry.hasAttribute("normal") === false) return float$1(0);
	const dxy = normalViewGeometry$1.dFdx().abs().max(normalViewGeometry$1.dFdy().abs());
	return dxy.x.max(dxy.y).max(dxy.z);
});
var getRoughness$1 = /* @__PURE__ */ Fn$1((inputs) => {
	const { roughness: roughness$2 } = inputs;
	const geometryRoughness = getGeometryRoughness$1();
	let roughnessFactor = roughness$2.max(.0525);
	roughnessFactor = roughnessFactor.add(geometryRoughness);
	roughnessFactor = roughnessFactor.min(1);
	return roughnessFactor;
});
var V_GGX_SmithCorrelated$1 = /* @__PURE__ */ Fn$1(({ alpha, dotNL, dotNV }) => {
	const a2 = alpha.pow2();
	const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
	const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
	return div$1(.5, gv.add(gl).max(EPSILON$1));
}).setLayout({
	name: "V_GGX_SmithCorrelated",
	type: "float",
	inputs: [
		{
			name: "alpha",
			type: "float"
		},
		{
			name: "dotNL",
			type: "float"
		},
		{
			name: "dotNV",
			type: "float"
		}
	]
});
var V_GGX_SmithCorrelated_Anisotropic = /* @__PURE__ */ Fn$1(({ alphaT: alphaT$2, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL }) => {
	const gv = dotNL.mul(vec3$1(alphaT$2.mul(dotTV), alphaB.mul(dotBV), dotNV).length());
	const gl = dotNV.mul(vec3$1(alphaT$2.mul(dotTL), alphaB.mul(dotBL), dotNL).length());
	return div$1(.5, gv.add(gl)).saturate();
}).setLayout({
	name: "V_GGX_SmithCorrelated_Anisotropic",
	type: "float",
	inputs: [
		{
			name: "alphaT",
			type: "float",
			qualifier: "in"
		},
		{
			name: "alphaB",
			type: "float",
			qualifier: "in"
		},
		{
			name: "dotTV",
			type: "float",
			qualifier: "in"
		},
		{
			name: "dotBV",
			type: "float",
			qualifier: "in"
		},
		{
			name: "dotTL",
			type: "float",
			qualifier: "in"
		},
		{
			name: "dotBL",
			type: "float",
			qualifier: "in"
		},
		{
			name: "dotNV",
			type: "float",
			qualifier: "in"
		},
		{
			name: "dotNL",
			type: "float",
			qualifier: "in"
		}
	]
});
var D_GGX$1 = /* @__PURE__ */ Fn$1(({ alpha, dotNH }) => {
	const a2 = alpha.pow2();
	const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();
	return a2.div(denom.pow2()).mul(1 / Math.PI);
}).setLayout({
	name: "D_GGX",
	type: "float",
	inputs: [{
		name: "alpha",
		type: "float"
	}, {
		name: "dotNH",
		type: "float"
	}]
});
var RECIPROCAL_PI = /* @__PURE__ */ float$1(1 / Math.PI);
var D_GGX_Anisotropic = /* @__PURE__ */ Fn$1(({ alphaT: alphaT$2, alphaB, dotNH, dotTH, dotBH }) => {
	const a2 = alphaT$2.mul(alphaB);
	const v = vec3$1(alphaB.mul(dotTH), alphaT$2.mul(dotBH), a2.mul(dotNH));
	const v2 = v.dot(v);
	const w2$1 = a2.div(v2);
	return RECIPROCAL_PI.mul(a2.mul(w2$1.pow2()));
}).setLayout({
	name: "D_GGX_Anisotropic",
	type: "float",
	inputs: [
		{
			name: "alphaT",
			type: "float",
			qualifier: "in"
		},
		{
			name: "alphaB",
			type: "float",
			qualifier: "in"
		},
		{
			name: "dotNH",
			type: "float",
			qualifier: "in"
		},
		{
			name: "dotTH",
			type: "float",
			qualifier: "in"
		},
		{
			name: "dotBH",
			type: "float",
			qualifier: "in"
		}
	]
});
var BRDF_GGX$1 = /* @__PURE__ */ Fn$1(({ lightDirection, f0, f90, roughness: roughness$2, f, normalView: normalView$1$1 = normalView$1, USE_IRIDESCENCE, USE_ANISOTROPY }) => {
	const alpha = roughness$2.pow2();
	const halfDir = lightDirection.add(positionViewDirection$1).normalize();
	const dotNL = normalView$1$1.dot(lightDirection).clamp();
	const dotNV = normalView$1$1.dot(positionViewDirection$1).clamp();
	const dotNH = normalView$1$1.dot(halfDir).clamp();
	const dotVH = positionViewDirection$1.dot(halfDir).clamp();
	let F = F_Schlick$1({
		f0,
		f90,
		dotVH
	});
	let V, D;
	if (defined$1(USE_IRIDESCENCE)) F = iridescence$1.mix(F, f);
	if (defined$1(USE_ANISOTROPY)) {
		const dotTL = anisotropyT$1.dot(lightDirection);
		const dotTV = anisotropyT$1.dot(positionViewDirection$1);
		const dotTH = anisotropyT$1.dot(halfDir);
		const dotBL = anisotropyB$1.dot(lightDirection);
		const dotBV = anisotropyB$1.dot(positionViewDirection$1);
		const dotBH = anisotropyB$1.dot(halfDir);
		V = V_GGX_SmithCorrelated_Anisotropic({
			alphaT: alphaT$1,
			alphaB: alpha,
			dotTV,
			dotBV,
			dotTL,
			dotBL,
			dotNV,
			dotNL
		});
		D = D_GGX_Anisotropic({
			alphaT: alphaT$1,
			alphaB: alpha,
			dotNH,
			dotTH,
			dotBH
		});
	} else {
		V = V_GGX_SmithCorrelated$1({
			alpha,
			dotNL,
			dotNV
		});
		D = D_GGX$1({
			alpha,
			dotNH
		});
	}
	return F.mul(V).mul(D);
});
/**
* Precomputed DFG LUT for Image-Based Lighting
* Resolution: 32x32
* Samples: 4096 per texel
* Format: RG16F (2 half floats per texel: scale, bias)
*/
var DATA$1 = new Uint16Array([
	11481,
	15204,
	11534,
	15171,
	11808,
	15015,
	12385,
	14843,
	12894,
	14716,
	13396,
	14600,
	13693,
	14483,
	13976,
	14366,
	14237,
	14171,
	14405,
	13961,
	14511,
	13770,
	14605,
	13598,
	14687,
	13444,
	14760,
	13305,
	14822,
	13066,
	14876,
	12857,
	14923,
	12675,
	14963,
	12517,
	14997,
	12379,
	15025,
	12230,
	15049,
	12023,
	15070,
	11843,
	15086,
	11687,
	15100,
	11551,
	15111,
	11433,
	15120,
	11330,
	15127,
	11217,
	15132,
	11060,
	15135,
	10922,
	15138,
	10801,
	15139,
	10695,
	15139,
	10600,
	13012,
	14923,
	13020,
	14917,
	13064,
	14886,
	13176,
	14800,
	13349,
	14666,
	13513,
	14526,
	13724,
	14398,
	13960,
	14230,
	14200,
	14020,
	14383,
	13827,
	14488,
	13651,
	14583,
	13491,
	14667,
	13348,
	14740,
	13132,
	14803,
	12908,
	14856,
	12713,
	14901,
	12542,
	14938,
	12394,
	14968,
	12241,
	14992,
	12017,
	15010,
	11822,
	15024,
	11654,
	15034,
	11507,
	15041,
	11380,
	15044,
	11269,
	15044,
	11081,
	15042,
	10913,
	15037,
	10764,
	15031,
	10635,
	15023,
	10520,
	15014,
	10419,
	15003,
	10330,
	13657,
	14676,
	13658,
	14673,
	13670,
	14660,
	13698,
	14622,
	13750,
	14547,
	13834,
	14442,
	13956,
	14317,
	14112,
	14093,
	14291,
	13889,
	14407,
	13704,
	14499,
	13538,
	14586,
	13389,
	14664,
	13201,
	14733,
	12966,
	14792,
	12758,
	14842,
	12577,
	14882,
	12418,
	14915,
	12272,
	14940,
	12033,
	14959,
	11826,
	14972,
	11646,
	14980,
	11490,
	14983,
	11355,
	14983,
	11212,
	14979,
	11008,
	14971,
	10830,
	14961,
	10675,
	14950,
	10540,
	14936,
	10420,
	14923,
	10315,
	14909,
	10204,
	14894,
	10041,
	14089,
	14460,
	14090,
	14459,
	14096,
	14452,
	14112,
	14431,
	14141,
	14388,
	14186,
	14305,
	14252,
	14130,
	14341,
	13941,
	14399,
	13756,
	14467,
	13585,
	14539,
	13430,
	14610,
	13272,
	14677,
	13026,
	14737,
	12808,
	14790,
	12617,
	14833,
	12449,
	14869,
	12303,
	14896,
	12065,
	14916,
	11845,
	14929,
	11655,
	14937,
	11490,
	14939,
	11347,
	14936,
	11184,
	14930,
	10970,
	14921,
	10783,
	14912,
	10621,
	14900,
	10480,
	14885,
	10356,
	14867,
	10247,
	14848,
	10062,
	14827,
	9894,
	14805,
	9745,
	14400,
	14208,
	14400,
	14206,
	14402,
	14198,
	14406,
	14174,
	14415,
	14122,
	14427,
	14035,
	14444,
	13913,
	14469,
	13767,
	14504,
	13613,
	14548,
	13463,
	14598,
	13324,
	14651,
	13082,
	14704,
	12858,
	14752,
	12658,
	14795,
	12483,
	14831,
	12330,
	14860,
	12106,
	14881,
	11875,
	14895,
	11675,
	14903,
	11501,
	14905,
	11351,
	14903,
	11178,
	14900,
	10953,
	14892,
	10757,
	14880,
	10589,
	14865,
	10442,
	14847,
	10313,
	14827,
	10162,
	14805,
	9965,
	14782,
	9792,
	14757,
	9642,
	14731,
	9507,
	14562,
	13883,
	14562,
	13883,
	14563,
	13877,
	14566,
	13862,
	14570,
	13830,
	14576,
	13773,
	14584,
	13689,
	14595,
	13582,
	14613,
	13461,
	14637,
	13336,
	14668,
	13120,
	14704,
	12897,
	14741,
	12695,
	14776,
	12516,
	14808,
	12358,
	14835,
	12150,
	14856,
	11910,
	14870,
	11701,
	14878,
	11519,
	14882,
	11361,
	14884,
	11187,
	14880,
	10951,
	14871,
	10748,
	14858,
	10572,
	14842,
	10418,
	14823,
	10286,
	14801,
	10099,
	14777,
	9897,
	14751,
	9722,
	14725,
	9567,
	14696,
	9430,
	14666,
	9309,
	14702,
	13604,
	14702,
	13604,
	14702,
	13600,
	14703,
	13591,
	14705,
	13570,
	14707,
	13533,
	14709,
	13477,
	14712,
	13400,
	14718,
	13305,
	14727,
	13106,
	14743,
	12907,
	14762,
	12716,
	14784,
	12539,
	14807,
	12380,
	14827,
	12190,
	14844,
	11943,
	14855,
	11727,
	14863,
	11539,
	14870,
	11376,
	14871,
	11204,
	14868,
	10960,
	14858,
	10748,
	14845,
	10565,
	14829,
	10406,
	14809,
	10269,
	14786,
	10058,
	14761,
	9852,
	14734,
	9671,
	14705,
	9512,
	14674,
	9374,
	14641,
	9253,
	14608,
	9076,
	14821,
	13366,
	14821,
	13365,
	14821,
	13364,
	14821,
	13358,
	14821,
	13344,
	14821,
	13320,
	14819,
	13252,
	14817,
	13145,
	14815,
	13011,
	14814,
	12858,
	14817,
	12698,
	14823,
	12539,
	14832,
	12389,
	14841,
	12214,
	14850,
	11968,
	14856,
	11750,
	14861,
	11558,
	14866,
	11390,
	14867,
	11226,
	14862,
	10972,
	14853,
	10754,
	14840,
	10565,
	14823,
	10401,
	14803,
	10259,
	14780,
	10032,
	14754,
	9820,
	14725,
	9635,
	14694,
	9473,
	14661,
	9333,
	14627,
	9203,
	14593,
	8988,
	14557,
	8798,
	14923,
	13014,
	14922,
	13014,
	14922,
	13012,
	14922,
	13004,
	14920,
	12987,
	14919,
	12957,
	14915,
	12907,
	14909,
	12834,
	14902,
	12738,
	14894,
	12623,
	14888,
	12498,
	14883,
	12370,
	14880,
	12203,
	14878,
	11970,
	14875,
	11759,
	14873,
	11569,
	14874,
	11401,
	14872,
	11243,
	14865,
	10986,
	14855,
	10762,
	14842,
	10568,
	14825,
	10401,
	14804,
	10255,
	14781,
	10017,
	14754,
	9799,
	14725,
	9611,
	14692,
	9445,
	14658,
	9301,
	14623,
	9139,
	14587,
	8920,
	14548,
	8729,
	14509,
	8562,
	15008,
	12672,
	15008,
	12672,
	15008,
	12671,
	15007,
	12667,
	15005,
	12656,
	15001,
	12637,
	14997,
	12605,
	14989,
	12556,
	14978,
	12490,
	14966,
	12407,
	14953,
	12313,
	14940,
	12136,
	14927,
	11934,
	14914,
	11742,
	14903,
	11563,
	14896,
	11401,
	14889,
	11247,
	14879,
	10992,
	14866,
	10767,
	14851,
	10570,
	14833,
	10400,
	14812,
	10252,
	14789,
	10007,
	14761,
	9784,
	14731,
	9592,
	14698,
	9424,
	14663,
	9279,
	14627,
	9088,
	14588,
	8868,
	14548,
	8676,
	14508,
	8508,
	14467,
	8360,
	15080,
	12386,
	15080,
	12386,
	15079,
	12385,
	15078,
	12383,
	15076,
	12378,
	15072,
	12367,
	15066,
	12347,
	15057,
	12315,
	15045,
	12253,
	15030,
	12138,
	15012,
	11998,
	14993,
	11845,
	14972,
	11685,
	14951,
	11530,
	14935,
	11383,
	14920,
	11228,
	14904,
	10981,
	14887,
	10762,
	14870,
	10567,
	14850,
	10397,
	14827,
	10248,
	14803,
	9997,
	14774,
	9771,
	14743,
	9578,
	14710,
	9407,
	14674,
	9259,
	14637,
	9048,
	14596,
	8826,
	14555,
	8632,
	14514,
	8464,
	14471,
	8317,
	14427,
	8182,
	15139,
	12008,
	15139,
	12008,
	15138,
	12008,
	15137,
	12007,
	15135,
	12003,
	15130,
	11990,
	15124,
	11969,
	15115,
	11929,
	15102,
	11872,
	15086,
	11794,
	15064,
	11693,
	15041,
	11581,
	15013,
	11459,
	14987,
	11336,
	14966,
	11170,
	14944,
	10944,
	14921,
	10738,
	14898,
	10552,
	14875,
	10387,
	14850,
	10239,
	14824,
	9983,
	14794,
	9758,
	14762,
	9563,
	14728,
	9392,
	14692,
	9244,
	14653,
	9014,
	14611,
	8791,
	14569,
	8597,
	14526,
	8427,
	14481,
	8281,
	14436,
	8110,
	14391,
	7885,
	15188,
	11617,
	15188,
	11617,
	15187,
	11617,
	15186,
	11618,
	15183,
	11617,
	15179,
	11612,
	15173,
	11601,
	15163,
	11581,
	15150,
	11546,
	15133,
	11495,
	15110,
	11427,
	15083,
	11346,
	15051,
	11246,
	15024,
	11057,
	14996,
	10868,
	14967,
	10687,
	14938,
	10517,
	14911,
	10362,
	14882,
	10206,
	14853,
	9956,
	14821,
	9737,
	14787,
	9543,
	14752,
	9375,
	14715,
	9228,
	14675,
	8980,
	14632,
	8760,
	14589,
	8565,
	14544,
	8395,
	14498,
	8248,
	14451,
	8049,
	14404,
	7824,
	14357,
	7630,
	15228,
	11298,
	15228,
	11298,
	15227,
	11299,
	15226,
	11301,
	15223,
	11303,
	15219,
	11302,
	15213,
	11299,
	15204,
	11290,
	15191,
	11271,
	15174,
	11217,
	15150,
	11129,
	15119,
	11015,
	15087,
	10886,
	15057,
	10744,
	15024,
	10599,
	14990,
	10455,
	14957,
	10318,
	14924,
	10143,
	14891,
	9911,
	14856,
	9701,
	14820,
	9516,
	14782,
	9352,
	14744,
	9200,
	14703,
	8946,
	14659,
	8725,
	14615,
	8533,
	14568,
	8366,
	14521,
	8220,
	14472,
	7992,
	14423,
	7770,
	14374,
	7578,
	14315,
	7408,
	15260,
	10819,
	15260,
	10819,
	15259,
	10822,
	15258,
	10826,
	15256,
	10832,
	15251,
	10836,
	15246,
	10841,
	15237,
	10838,
	15225,
	10821,
	15207,
	10788,
	15183,
	10734,
	15151,
	10660,
	15120,
	10571,
	15087,
	10469,
	15049,
	10359,
	15012,
	10249,
	14974,
	10041,
	14937,
	9837,
	14900,
	9647,
	14860,
	9475,
	14820,
	9320,
	14779,
	9147,
	14736,
	8902,
	14691,
	8688,
	14646,
	8499,
	14598,
	8335,
	14549,
	8189,
	14499,
	7940,
	14448,
	7720,
	14397,
	7529,
	14347,
	7363,
	14256,
	7218,
	15285,
	10410,
	15285,
	10411,
	15285,
	10413,
	15284,
	10418,
	15282,
	10425,
	15278,
	10434,
	15272,
	10442,
	15264,
	10449,
	15252,
	10445,
	15235,
	10433,
	15210,
	10403,
	15179,
	10358,
	15149,
	10301,
	15113,
	10218,
	15073,
	10059,
	15033,
	9894,
	14991,
	9726,
	14951,
	9565,
	14909,
	9413,
	14865,
	9273,
	14822,
	9073,
	14777,
	8845,
	14730,
	8641,
	14682,
	8459,
	14633,
	8300,
	14583,
	8129,
	14531,
	7883,
	14479,
	7670,
	14426,
	7482,
	14373,
	7321,
	14305,
	7176,
	14201,
	6939,
	15305,
	9939,
	15305,
	9940,
	15305,
	9945,
	15304,
	9955,
	15302,
	9967,
	15298,
	9989,
	15293,
	10010,
	15286,
	10033,
	15274,
	10044,
	15258,
	10045,
	15233,
	10022,
	15205,
	9975,
	15174,
	9903,
	15136,
	9808,
	15095,
	9697,
	15053,
	9578,
	15009,
	9451,
	14965,
	9327,
	14918,
	9198,
	14871,
	8973,
	14825,
	8766,
	14775,
	8579,
	14725,
	8408,
	14675,
	8259,
	14622,
	8058,
	14569,
	7821,
	14515,
	7615,
	14460,
	7435,
	14405,
	7276,
	14350,
	7108,
	14256,
	6866,
	14149,
	6653,
	15321,
	9444,
	15321,
	9445,
	15321,
	9448,
	15320,
	9458,
	15317,
	9470,
	15314,
	9490,
	15310,
	9515,
	15302,
	9540,
	15292,
	9562,
	15276,
	9579,
	15251,
	9577,
	15226,
	9559,
	15195,
	9519,
	15156,
	9463,
	15116,
	9389,
	15071,
	9304,
	15025,
	9208,
	14978,
	9023,
	14927,
	8838,
	14878,
	8661,
	14827,
	8496,
	14774,
	8344,
	14722,
	8206,
	14667,
	7973,
	14612,
	7749,
	14556,
	7555,
	14499,
	7382,
	14443,
	7229,
	14385,
	7025,
	14322,
	6791,
	14210,
	6588,
	14100,
	6409,
	15333,
	8920,
	15333,
	8921,
	15332,
	8927,
	15332,
	8943,
	15329,
	8965,
	15326,
	9002,
	15322,
	9048,
	15316,
	9106,
	15307,
	9162,
	15291,
	9204,
	15267,
	9221,
	15244,
	9221,
	15212,
	9196,
	15175,
	9134,
	15133,
	9043,
	15088,
	8930,
	15040,
	8801,
	14990,
	8665,
	14938,
	8526,
	14886,
	8391,
	14830,
	8261,
	14775,
	8087,
	14719,
	7866,
	14661,
	7664,
	14603,
	7482,
	14544,
	7322,
	14485,
	7178,
	14426,
	6936,
	14367,
	6713,
	14281,
	6517,
	14166,
	6348,
	14054,
	6198,
	15341,
	8360,
	15341,
	8361,
	15341,
	8366,
	15341,
	8379,
	15339,
	8399,
	15336,
	8431,
	15332,
	8473,
	15326,
	8527,
	15318,
	8585,
	15302,
	8632,
	15281,
	8670,
	15258,
	8690,
	15227,
	8690,
	15191,
	8664,
	15149,
	8612,
	15104,
	8543,
	15055,
	8456,
	15001,
	8360,
	14948,
	8259,
	14892,
	8122,
	14834,
	7923,
	14776,
	7734,
	14716,
	7558,
	14656,
	7397,
	14595,
	7250,
	14534,
	7070,
	14472,
	6835,
	14410,
	6628,
	14350,
	6443,
	14243,
	6283,
	14125,
	6135,
	14010,
	5889,
	15348,
	7715,
	15348,
	7717,
	15348,
	7725,
	15347,
	7745,
	15345,
	7780,
	15343,
	7836,
	15339,
	7905,
	15334,
	8e3,
	15326,
	8103,
	15310,
	8193,
	15293,
	8239,
	15270,
	8270,
	15240,
	8287,
	15204,
	8283,
	15163,
	8260,
	15118,
	8223,
	15067,
	8143,
	15014,
	8014,
	14958,
	7873,
	14899,
	7723,
	14839,
	7573,
	14778,
	7430,
	14715,
	7293,
	14652,
	7164,
	14588,
	6931,
	14524,
	6720,
	14460,
	6531,
	14396,
	6362,
	14330,
	6210,
	14207,
	6015,
	14086,
	5781,
	13969,
	5576,
	15352,
	7114,
	15352,
	7116,
	15352,
	7128,
	15352,
	7159,
	15350,
	7195,
	15348,
	7237,
	15345,
	7299,
	15340,
	7374,
	15332,
	7457,
	15317,
	7544,
	15301,
	7633,
	15280,
	7703,
	15251,
	7754,
	15216,
	7775,
	15176,
	7767,
	15131,
	7733,
	15079,
	7670,
	15026,
	7588,
	14967,
	7492,
	14906,
	7387,
	14844,
	7278,
	14779,
	7171,
	14714,
	6965,
	14648,
	6770,
	14581,
	6587,
	14515,
	6420,
	14448,
	6269,
	14382,
	6123,
	14299,
	5881,
	14172,
	5665,
	14049,
	5477,
	13929,
	5310,
	15355,
	6329,
	15355,
	6330,
	15355,
	6339,
	15355,
	6362,
	15353,
	6410,
	15351,
	6472,
	15349,
	6572,
	15344,
	6688,
	15337,
	6835,
	15323,
	6985,
	15309,
	7142,
	15287,
	7220,
	15260,
	7277,
	15226,
	7310,
	15188,
	7326,
	15142,
	7318,
	15090,
	7285,
	15036,
	7239,
	14976,
	7177,
	14914,
	7045,
	14849,
	6892,
	14782,
	6736,
	14714,
	6581,
	14645,
	6433,
	14576,
	6293,
	14506,
	6164,
	14438,
	5946,
	14369,
	5733,
	14270,
	5540,
	14140,
	5369,
	14014,
	5216,
	13892,
	5043,
	15357,
	5483,
	15357,
	5484,
	15357,
	5496,
	15357,
	5528,
	15356,
	5597,
	15354,
	5692,
	15351,
	5835,
	15347,
	6011,
	15339,
	6195,
	15328,
	6317,
	15314,
	6446,
	15293,
	6566,
	15268,
	6668,
	15235,
	6746,
	15197,
	6796,
	15152,
	6811,
	15101,
	6790,
	15046,
	6748,
	14985,
	6673,
	14921,
	6583,
	14854,
	6479,
	14785,
	6371,
	14714,
	6259,
	14643,
	6149,
	14571,
	5946,
	14499,
	5750,
	14428,
	5567,
	14358,
	5401,
	14242,
	5250,
	14109,
	5111,
	13980,
	4870,
	13856,
	4657,
	15359,
	4555,
	15359,
	4557,
	15358,
	4573,
	15358,
	4633,
	15357,
	4715,
	15355,
	4841,
	15353,
	5061,
	15349,
	5216,
	15342,
	5391,
	15331,
	5577,
	15318,
	5770,
	15299,
	5967,
	15274,
	6150,
	15243,
	6223,
	15206,
	6280,
	15161,
	6310,
	15111,
	6317,
	15055,
	6300,
	14994,
	6262,
	14928,
	6208,
	14860,
	6141,
	14788,
	5994,
	14715,
	5838,
	14641,
	5684,
	14566,
	5529,
	14492,
	5384,
	14418,
	5247,
	14346,
	5121,
	14216,
	4892,
	14079,
	4682,
	13948,
	4496,
	13822,
	4330,
	15359,
	3498,
	15359,
	3501,
	15359,
	3520,
	15359,
	3598,
	15358,
	3719,
	15356,
	3860,
	15355,
	4137,
	15351,
	4305,
	15344,
	4563,
	15334,
	4809,
	15321,
	5116,
	15303,
	5273,
	15280,
	5418,
	15250,
	5547,
	15214,
	5653,
	15170,
	5722,
	15120,
	5761,
	15064,
	5763,
	15002,
	5733,
	14935,
	5673,
	14865,
	5597,
	14792,
	5504,
	14716,
	5400,
	14640,
	5294,
	14563,
	5185,
	14486,
	5041,
	14410,
	4841,
	14335,
	4655,
	14191,
	4482,
	14051,
	4325,
	13918,
	4183,
	13790,
	4012,
	15360,
	2282,
	15360,
	2285,
	15360,
	2306,
	15360,
	2401,
	15359,
	2547,
	15357,
	2748,
	15355,
	3103,
	15352,
	3349,
	15345,
	3675,
	15336,
	4020,
	15324,
	4272,
	15307,
	4496,
	15285,
	4716,
	15255,
	4908,
	15220,
	5086,
	15178,
	5170,
	15128,
	5214,
	15072,
	5234,
	15010,
	5231,
	14943,
	5206,
	14871,
	5166,
	14796,
	5102,
	14718,
	4971,
	14639,
	4833,
	14559,
	4687,
	14480,
	4541,
	14402,
	4401,
	14315,
	4268,
	14167,
	4142,
	14025,
	3958,
	13888,
	3747,
	13759,
	3556,
	15360,
	923,
	15360,
	925,
	15360,
	946,
	15360,
	1052,
	15359,
	1214,
	15357,
	1494,
	15356,
	1892,
	15352,
	2274,
	15346,
	2663,
	15338,
	3099,
	15326,
	3393,
	15309,
	3679,
	15288,
	3980,
	15260,
	4183,
	15226,
	4325,
	15185,
	4437,
	15136,
	4517,
	15080,
	4570,
	15018,
	4591,
	14950,
	4581,
	14877,
	4545,
	14800,
	4485,
	14720,
	4411,
	14638,
	4325,
	14556,
	4231,
	14475,
	4136,
	14395,
	3988,
	14297,
	3803,
	14145,
	3628,
	13999,
	3465,
	13861,
	3314,
	13729,
	3177,
	15360,
	263,
	15360,
	264,
	15360,
	272,
	15360,
	325,
	15359,
	407,
	15358,
	548,
	15356,
	780,
	15352,
	1144,
	15347,
	1580,
	15339,
	2099,
	15328,
	2425,
	15312,
	2795,
	15292,
	3133,
	15264,
	3329,
	15232,
	3517,
	15191,
	3689,
	15143,
	3819,
	15088,
	3923,
	15025,
	3978,
	14956,
	3999,
	14882,
	3979,
	14804,
	3931,
	14722,
	3855,
	14639,
	3756,
	14554,
	3645,
	14470,
	3529,
	14388,
	3409,
	14279,
	3289,
	14124,
	3173,
	13975,
	3055,
	13834,
	2848,
	13701,
	2658,
	15360,
	49,
	15360,
	49,
	15360,
	52,
	15360,
	75,
	15359,
	111,
	15358,
	201,
	15356,
	283,
	15353,
	519,
	15348,
	726,
	15340,
	1045,
	15329,
	1415,
	15314,
	1795,
	15295,
	2173,
	15269,
	2410,
	15237,
	2649,
	15197,
	2866,
	15150,
	3054,
	15095,
	3140,
	15032,
	3196,
	14963,
	3228,
	14888,
	3236,
	14808,
	3224,
	14725,
	3191,
	14639,
	3146,
	14553,
	3088,
	14466,
	2976,
	14382,
	2836,
	14262,
	2692,
	14103,
	2549,
	13952,
	2409,
	13808,
	2278,
	13674,
	2154,
	15360,
	4,
	15360,
	4,
	15360,
	4,
	15360,
	13,
	15359,
	33,
	15358,
	59,
	15357,
	112,
	15353,
	199,
	15348,
	302,
	15341,
	456,
	15331,
	628,
	15316,
	827,
	15297,
	1082,
	15272,
	1332,
	15241,
	1601,
	15202,
	1851,
	15156,
	2069,
	15101,
	2172,
	15039,
	2256,
	14970,
	2314,
	14894,
	2348,
	14813,
	2358,
	14728,
	2344,
	14640,
	2311,
	14551,
	2263,
	14463,
	2203,
	14376,
	2133,
	14247,
	2059,
	14084,
	1915,
	13930,
	1761,
	13784,
	1609,
	13648,
	1464,
	15360,
	0,
	15360,
	0,
	15360,
	0,
	15360,
	3,
	15359,
	18,
	15358,
	26,
	15357,
	53,
	15354,
	80,
	15348,
	97,
	15341,
	165,
	15332,
	238,
	15318,
	326,
	15299,
	427,
	15275,
	529,
	15245,
	654,
	15207,
	771,
	15161,
	885,
	15108,
	994,
	15046,
	1089,
	14976,
	1170,
	14900,
	1229,
	14817,
	1266,
	14731,
	1284,
	14641,
	1282,
	14550,
	1260,
	14460,
	1223,
	14370,
	1174,
	14232,
	1116,
	14066,
	1050,
	13909,
	981,
	13761,
	910,
	13623,
	839
]);
var lut$1 = null;
var DFGApprox$1 = /* @__PURE__ */ Fn$1(({ roughness: roughness$2, dotNV }) => {
	if (lut$1 === null) {
		lut$1 = new DataTexture(DATA$1, 32, 32, RGFormat, HalfFloatType);
		lut$1.minFilter = LinearFilter;
		lut$1.magFilter = LinearFilter;
		lut$1.wrapS = ClampToEdgeWrapping;
		lut$1.wrapT = ClampToEdgeWrapping;
		lut$1.generateMipmaps = false;
		lut$1.needsUpdate = true;
	}
	const uv$3 = vec2$1(roughness$2, dotNV);
	return texture$1(lut$1, uv$3).rg;
});
var BRDF_GGX_Multiscatter = /* @__PURE__ */ Fn$1(({ lightDirection, f0, f90, roughness: _roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY }) => {
	const singleScatter = BRDF_GGX$1({
		lightDirection,
		f0,
		f90,
		roughness: _roughness,
		f,
		USE_IRIDESCENCE,
		USE_ANISOTROPY
	});
	const dotNL = normalView$1.dot(lightDirection).clamp();
	const dotNV = normalView$1.dot(positionViewDirection$1).clamp();
	const dfgV = DFGApprox$1({
		roughness: _roughness,
		dotNV
	});
	const dfgL = DFGApprox$1({
		roughness: _roughness,
		dotNV: dotNL
	});
	const FssEss_V = f0.mul(dfgV.x).add(f90.mul(dfgV.y));
	const FssEss_L = f0.mul(dfgL.x).add(f90.mul(dfgL.y));
	const Ess_V = dfgV.x.add(dfgV.y);
	const Ess_L = dfgL.x.add(dfgL.y);
	const Ems_V = float$1(1).sub(Ess_V);
	const Ems_L = float$1(1).sub(Ess_L);
	const Favg = f0.add(f0.oneMinus().mul(.047619));
	const Fms = FssEss_V.mul(FssEss_L).mul(Favg).div(float$1(1).sub(Ems_V.mul(Ems_L).mul(Favg).mul(Favg)).add(EPSILON$1));
	const compensationFactor = Ems_V.mul(Ems_L);
	const multiScatter = Fms.mul(compensationFactor);
	return singleScatter.add(multiScatter);
});
var EnvironmentBRDF = /* @__PURE__ */ Fn$1((inputs) => {
	const { dotNV, specularColor: specularColor$2, specularF90: specularF90$2, roughness: roughness$2 } = inputs;
	const fab = DFGApprox$1({
		dotNV,
		roughness: roughness$2
	});
	return specularColor$2.mul(fab.x).add(specularF90$2.mul(fab.y));
});
var Schlick_to_F0$1 = /* @__PURE__ */ Fn$1(({ f, f90, dotVH }) => {
	const x = dotVH.oneMinus().saturate();
	const x2 = x.mul(x);
	const x5 = x.mul(x2, x2).clamp(0, .9999);
	return f.sub(vec3$1(f90).mul(x5)).div(x5.oneMinus());
}).setLayout({
	name: "Schlick_to_F0",
	type: "vec3",
	inputs: [
		{
			name: "f",
			type: "vec3"
		},
		{
			name: "f90",
			type: "float"
		},
		{
			name: "dotVH",
			type: "float"
		}
	]
});
var D_Charlie = /* @__PURE__ */ Fn$1(({ roughness: roughness$2, dotNH }) => {
	const alpha = roughness$2.pow2();
	const invAlpha = float$1(1).div(alpha);
	const sin2h = dotNH.pow2().oneMinus().max(.0078125);
	return float$1(2).add(invAlpha).mul(sin2h.pow(invAlpha.mul(.5))).div(2 * Math.PI);
}).setLayout({
	name: "D_Charlie",
	type: "float",
	inputs: [{
		name: "roughness",
		type: "float"
	}, {
		name: "dotNH",
		type: "float"
	}]
});
var V_Neubelt = /* @__PURE__ */ Fn$1(({ dotNV, dotNL }) => {
	return float$1(1).div(float$1(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
}).setLayout({
	name: "V_Neubelt",
	type: "float",
	inputs: [{
		name: "dotNV",
		type: "float"
	}, {
		name: "dotNL",
		type: "float"
	}]
});
var BRDF_Sheen = /* @__PURE__ */ Fn$1(({ lightDirection }) => {
	const halfDir = lightDirection.add(positionViewDirection$1).normalize();
	const dotNL = normalView$1.dot(lightDirection).clamp();
	const dotNV = normalView$1.dot(positionViewDirection$1).clamp();
	const dotNH = normalView$1.dot(halfDir).clamp();
	const D = D_Charlie({
		roughness: sheenRoughness$1,
		dotNH
	});
	const V = V_Neubelt({
		dotNV,
		dotNL
	});
	return sheen$1.mul(D).mul(V);
});
var LTC_Uv = /* @__PURE__ */ Fn$1(({ N: N$1, V, roughness: roughness$2 }) => {
	const LUT_SIZE = 64;
	const LUT_SCALE = (LUT_SIZE - 1) / LUT_SIZE;
	const LUT_BIAS = .5 / LUT_SIZE;
	const dotNV = N$1.dot(V).saturate();
	const uv$3 = vec2$1(roughness$2, dotNV.oneMinus().sqrt());
	uv$3.assign(uv$3.mul(LUT_SCALE).add(LUT_BIAS));
	return uv$3;
}).setLayout({
	name: "LTC_Uv",
	type: "vec2",
	inputs: [
		{
			name: "N",
			type: "vec3"
		},
		{
			name: "V",
			type: "vec3"
		},
		{
			name: "roughness",
			type: "float"
		}
	]
});
var LTC_ClippedSphereFormFactor = /* @__PURE__ */ Fn$1(({ f }) => {
	const l = f.length();
	return max$1$1(l.mul(l).add(f.z).div(l.add(1)), 0);
}).setLayout({
	name: "LTC_ClippedSphereFormFactor",
	type: "float",
	inputs: [{
		name: "f",
		type: "vec3"
	}]
});
var LTC_EdgeVectorFormFactor = /* @__PURE__ */ Fn$1(({ v1, v2 }) => {
	const x = v1.dot(v2);
	const y = x.abs().toVar();
	const a$1 = y.mul(.0145206).add(.4965155).mul(y).add(.8543985).toVar();
	const b$2 = y.add(4.1616724).mul(y).add(3.417594).toVar();
	const v = a$1.div(b$2);
	const theta_sintheta = x.greaterThan(0).select(v, max$1$1(x.mul(x).oneMinus(), 1e-7).inverseSqrt().mul(.5).sub(v));
	return v1.cross(v2).mul(theta_sintheta);
}).setLayout({
	name: "LTC_EdgeVectorFormFactor",
	type: "vec3",
	inputs: [{
		name: "v1",
		type: "vec3"
	}, {
		name: "v2",
		type: "vec3"
	}]
});
var LTC_Evaluate = /* @__PURE__ */ Fn$1(({ N: N$1, V, P, mInv, p0, p1, p2, p3 }) => {
	const v1 = p1.sub(p0).toVar();
	const v2 = p3.sub(p0).toVar();
	const lightNormal = v1.cross(v2);
	const result = vec3$1().toVar();
	If$1(lightNormal.dot(P.sub(p0)).greaterThanEqual(0), () => {
		const T1 = V.sub(N$1.mul(V.dot(N$1))).normalize();
		const T2 = N$1.cross(T1).negate();
		const mat = mInv.mul(mat3$1(T1, T2, N$1).transpose()).toVar();
		const coords0 = mat.mul(p0.sub(P)).normalize().toVar();
		const coords1 = mat.mul(p1.sub(P)).normalize().toVar();
		const coords2 = mat.mul(p2.sub(P)).normalize().toVar();
		const coords3 = mat.mul(p3.sub(P)).normalize().toVar();
		const vectorFormFactor = vec3$1(0).toVar();
		vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({
			v1: coords0,
			v2: coords1
		}));
		vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({
			v1: coords1,
			v2: coords2
		}));
		vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({
			v1: coords2,
			v2: coords3
		}));
		vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({
			v1: coords3,
			v2: coords0
		}));
		result.assign(vec3$1(LTC_ClippedSphereFormFactor({ f: vectorFormFactor })));
	});
	return result;
}).setLayout({
	name: "LTC_Evaluate",
	type: "vec3",
	inputs: [
		{
			name: "N",
			type: "vec3"
		},
		{
			name: "V",
			type: "vec3"
		},
		{
			name: "P",
			type: "vec3"
		},
		{
			name: "mInv",
			type: "mat3"
		},
		{
			name: "p0",
			type: "vec3"
		},
		{
			name: "p1",
			type: "vec3"
		},
		{
			name: "p2",
			type: "vec3"
		},
		{
			name: "p3",
			type: "vec3"
		}
	]
});
var bC = 1 / 6;
var w0 = (a$1) => mul$1(bC, mul$1(a$1, mul$1(a$1, a$1.negate().add(3)).sub(3)).add(1));
var w1 = (a$1) => mul$1(bC, mul$1(a$1, mul$1(a$1, mul$1(3, a$1).sub(6))).add(4));
var w2 = (a$1) => mul$1(bC, mul$1(a$1, mul$1(a$1, mul$1(-3, a$1).add(3)).add(3)).add(1));
var w3 = (a$1) => mul$1(bC, pow$1(a$1, 3));
var g0 = (a$1) => w0(a$1).add(w1(a$1));
var g1 = (a$1) => w2(a$1).add(w3(a$1));
var h0 = (a$1) => add$1(-1, w1(a$1).div(w0(a$1).add(w1(a$1))));
var h1 = (a$1) => add$1(1, w3(a$1).div(w2(a$1).add(w3(a$1))));
var bicubic = (textureNode, texelSize, lod) => {
	const uv$3 = textureNode.uvNode;
	const uvScaled = mul$1(uv$3, texelSize.zw).add(.5);
	const iuv = floor$1(uvScaled);
	const fuv = fract$1(uvScaled);
	const g0x = g0(fuv.x);
	const g1x = g1(fuv.x);
	const h0x = h0(fuv.x);
	const h1x = h1(fuv.x);
	const h0y = h0(fuv.y);
	const h1y = h1(fuv.y);
	const p0 = vec2$1(iuv.x.add(h0x), iuv.y.add(h0y)).sub(.5).mul(texelSize.xy);
	const p1 = vec2$1(iuv.x.add(h1x), iuv.y.add(h0y)).sub(.5).mul(texelSize.xy);
	const p2 = vec2$1(iuv.x.add(h0x), iuv.y.add(h1y)).sub(.5).mul(texelSize.xy);
	const p3 = vec2$1(iuv.x.add(h1x), iuv.y.add(h1y)).sub(.5).mul(texelSize.xy);
	const a$1 = g0(fuv.y).mul(add$1(g0x.mul(textureNode.sample(p0).level(lod)), g1x.mul(textureNode.sample(p1).level(lod))));
	const b$2 = g1(fuv.y).mul(add$1(g0x.mul(textureNode.sample(p2).level(lod)), g1x.mul(textureNode.sample(p3).level(lod))));
	return a$1.add(b$2);
};
/**
* Applies mipped bicubic texture filtering to the given texture node.
*
* @tsl
* @function
* @param {TextureNode} textureNode - The texture node that should be filtered.
* @param {Node<float>} lodNode - Defines the LOD to sample from.
* @return {Node} The filtered texture sample.
*/
var textureBicubicLevel$1 = /* @__PURE__ */ Fn$1(([textureNode, lodNode]) => {
	const fLodSize = vec2$1(textureNode.size(int$1(lodNode)));
	const cLodSize = vec2$1(textureNode.size(int$1(lodNode.add(1))));
	const fLodSizeInv = div$1(1, fLodSize);
	const cLodSizeInv = div$1(1, cLodSize);
	const fSample = bicubic(textureNode, vec4$1(fLodSizeInv, fLodSize), floor$1(lodNode));
	const cSample = bicubic(textureNode, vec4$1(cLodSizeInv, cLodSize), ceil$1(lodNode));
	return fract$1(lodNode).mix(fSample, cSample);
});
/**
* Applies mipped bicubic texture filtering to the given texture node.
*
* @tsl
* @function
* @param {TextureNode} textureNode - The texture node that should be filtered.
* @param {Node<float>} [strength] - Defines the strength of the bicubic filtering.
* @return {Node} The filtered texture sample.
*/
var textureBicubic$1 = /* @__PURE__ */ Fn$1(([textureNode, strength]) => {
	const lod = strength.mul(maxMipLevel$1(textureNode));
	return textureBicubicLevel$1(textureNode, lod);
});
var getVolumeTransmissionRay = /* @__PURE__ */ Fn$1(([n$2, v, thickness$2, ior$2, modelMatrix]) => {
	const refractionVector = vec3$1(refract$1(v.negate(), normalize$1(n$2), div$1(1, ior$2)));
	const modelScale$2 = vec3$1(length$1(modelMatrix[0].xyz), length$1(modelMatrix[1].xyz), length$1(modelMatrix[2].xyz));
	return normalize$1(refractionVector).mul(thickness$2.mul(modelScale$2));
}).setLayout({
	name: "getVolumeTransmissionRay",
	type: "vec3",
	inputs: [
		{
			name: "n",
			type: "vec3"
		},
		{
			name: "v",
			type: "vec3"
		},
		{
			name: "thickness",
			type: "float"
		},
		{
			name: "ior",
			type: "float"
		},
		{
			name: "modelMatrix",
			type: "mat4"
		}
	]
});
var applyIorToRoughness = /* @__PURE__ */ Fn$1(([roughness$2, ior$2]) => {
	return roughness$2.mul(clamp$2(ior$2.mul(2).sub(2), 0, 1));
}).setLayout({
	name: "applyIorToRoughness",
	type: "float",
	inputs: [{
		name: "roughness",
		type: "float"
	}, {
		name: "ior",
		type: "float"
	}]
});
var viewportBackSideTexture = /* @__PURE__ */ viewportMipTexture$1();
var viewportFrontSideTexture = /* @__PURE__ */ viewportMipTexture$1();
var getTransmissionSample = /* @__PURE__ */ Fn$1(([fragCoord, roughness$2, ior$2], { material }) => {
	const transmissionSample = (material.side === BackSide ? viewportBackSideTexture : viewportFrontSideTexture).sample(fragCoord);
	const lod = log2$1(screenSize$1.x).mul(applyIorToRoughness(roughness$2, ior$2));
	return textureBicubicLevel$1(transmissionSample, lod);
});
var volumeAttenuation = /* @__PURE__ */ Fn$1(([transmissionDistance, attenuationColor$2, attenuationDistance$2]) => {
	If$1(attenuationDistance$2.notEqual(0), () => {
		const attenuationCoefficient = log$2(attenuationColor$2).negate().div(attenuationDistance$2);
		return exp$1(attenuationCoefficient.negate().mul(transmissionDistance));
	});
	return vec3$1(1);
}).setLayout({
	name: "volumeAttenuation",
	type: "vec3",
	inputs: [
		{
			name: "transmissionDistance",
			type: "float"
		},
		{
			name: "attenuationColor",
			type: "vec3"
		},
		{
			name: "attenuationDistance",
			type: "float"
		}
	]
});
var getIBLVolumeRefraction = /* @__PURE__ */ Fn$1(([n$2, v, roughness$2, diffuseColor$2, specularColor$2, specularF90$2, position, modelMatrix, viewMatrix, projMatrix, ior$2, thickness$2, attenuationColor$2, attenuationDistance$2, dispersion$2]) => {
	let transmittedLight, transmittance;
	if (dispersion$2) {
		transmittedLight = vec4$1().toVar();
		transmittance = vec3$1().toVar();
		const halfSpread = ior$2.sub(1).mul(dispersion$2.mul(.025));
		const iors = vec3$1(ior$2.sub(halfSpread), ior$2, ior$2.add(halfSpread));
		Loop$1({
			start: 0,
			end: 3
		}, ({ i }) => {
			const ior$3 = iors.element(i);
			const transmissionRay = getVolumeTransmissionRay(n$2, v, thickness$2, ior$3, modelMatrix);
			const refractedRayExit = position.add(transmissionRay);
			const ndcPos = projMatrix.mul(viewMatrix.mul(vec4$1(refractedRayExit, 1)));
			const refractionCoords = vec2$1(ndcPos.xy.div(ndcPos.w)).toVar();
			refractionCoords.addAssign(1);
			refractionCoords.divAssign(2);
			refractionCoords.assign(vec2$1(refractionCoords.x, refractionCoords.y.oneMinus()));
			const transmissionSample = getTransmissionSample(refractionCoords, roughness$2, ior$3);
			transmittedLight.element(i).assign(transmissionSample.element(i));
			transmittedLight.a.addAssign(transmissionSample.a);
			transmittance.element(i).assign(diffuseColor$2.element(i).mul(volumeAttenuation(length$1(transmissionRay), attenuationColor$2, attenuationDistance$2).element(i)));
		});
		transmittedLight.a.divAssign(3);
	} else {
		const transmissionRay = getVolumeTransmissionRay(n$2, v, thickness$2, ior$2, modelMatrix);
		const refractedRayExit = position.add(transmissionRay);
		const ndcPos = projMatrix.mul(viewMatrix.mul(vec4$1(refractedRayExit, 1)));
		const refractionCoords = vec2$1(ndcPos.xy.div(ndcPos.w)).toVar();
		refractionCoords.addAssign(1);
		refractionCoords.divAssign(2);
		refractionCoords.assign(vec2$1(refractionCoords.x, refractionCoords.y.oneMinus()));
		transmittedLight = getTransmissionSample(refractionCoords, roughness$2, ior$2);
		transmittance = diffuseColor$2.mul(volumeAttenuation(length$1(transmissionRay), attenuationColor$2, attenuationDistance$2));
	}
	const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);
	const dotNV = n$2.dot(v).clamp();
	const F = vec3$1(EnvironmentBRDF({
		dotNV,
		specularColor: specularColor$2,
		specularF90: specularF90$2,
		roughness: roughness$2
	}));
	const transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3);
	return vec4$1(F.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());
});
var XYZ_TO_REC709 = /* @__PURE__ */ mat3$1(3.2404542, -.969266, .0556434, -1.5371385, 1.8760108, -.2040259, -.4985314, .041556, 1.0572252);
var Fresnel0ToIor = (fresnel0) => {
	const sqrtF0 = fresnel0.sqrt();
	return vec3$1(1).add(sqrtF0).div(vec3$1(1).sub(sqrtF0));
};
var IorToFresnel0 = (transmittedIor, incidentIor) => {
	return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();
};
var evalSensitivity = (OPD, shift) => {
	const phase = OPD.mul(2 * Math.PI * 1e-9);
	const val = vec3$1(54856e-17, 44201e-17, 52481e-17);
	const pos = vec3$1(1681e3, 1795300, 2208400);
	const VAR = vec3$1(43278e5, 93046e5, 66121e5);
	const x = float$1(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(phase.mul(2239900).add(shift.x).cos()).mul(phase.pow2().mul(-45282e5).exp());
	let xyz = val.mul(VAR.mul(2 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());
	xyz = vec3$1(xyz.x.add(x), xyz.y, xyz.z).div(1.0685e-7);
	return XYZ_TO_REC709.mul(xyz);
};
var evalIridescence = /* @__PURE__ */ Fn$1(({ outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 }) => {
	const iridescenceIOR$2 = mix$2(outsideIOR, eta2, smoothstep$1(0, .03, thinFilmThickness));
	const cosTheta2Sq = outsideIOR.div(iridescenceIOR$2).pow2().mul(cosTheta1.pow2().oneMinus()).oneMinus();
	If$1(cosTheta2Sq.lessThan(0), () => {
		return vec3$1(1);
	});
	const cosTheta2 = cosTheta2Sq.sqrt();
	const R0 = IorToFresnel0(iridescenceIOR$2, outsideIOR);
	const R12 = F_Schlick$1({
		f0: R0,
		f90: 1,
		dotVH: cosTheta1
	});
	const T121 = R12.oneMinus();
	const phi12 = iridescenceIOR$2.lessThan(outsideIOR).select(Math.PI, 0);
	const phi21 = float$1(Math.PI).sub(phi12);
	const baseIOR = Fresnel0ToIor(baseF0.clamp(0, .9999));
	const R1 = IorToFresnel0(baseIOR, iridescenceIOR$2.toVec3());
	const R23 = F_Schlick$1({
		f0: R1,
		f90: 1,
		dotVH: cosTheta2
	});
	const phi23 = vec3$1(baseIOR.x.lessThan(iridescenceIOR$2).select(Math.PI, 0), baseIOR.y.lessThan(iridescenceIOR$2).select(Math.PI, 0), baseIOR.z.lessThan(iridescenceIOR$2).select(Math.PI, 0));
	const OPD = iridescenceIOR$2.mul(thinFilmThickness, cosTheta2, 2);
	const phi$1 = vec3$1(phi21).add(phi23);
	const R123 = R12.mul(R23).clamp(1e-5, .9999);
	const r123 = R123.sqrt();
	const Rs = T121.pow2().mul(R23).div(vec3$1(1).sub(R123));
	const I = R12.add(Rs).toVar();
	const Cm = Rs.sub(T121).toVar();
	Loop$1({
		start: 1,
		end: 2,
		condition: "<=",
		name: "m"
	}, ({ m: m$1 }) => {
		Cm.mulAssign(r123);
		const Sm = evalSensitivity(float$1(m$1).mul(OPD), float$1(m$1).mul(phi$1)).mul(2);
		I.addAssign(Cm.mul(Sm));
	});
	return I.max(vec3$1(0));
}).setLayout({
	name: "evalIridescence",
	type: "vec3",
	inputs: [
		{
			name: "outsideIOR",
			type: "float"
		},
		{
			name: "eta2",
			type: "float"
		},
		{
			name: "cosTheta1",
			type: "float"
		},
		{
			name: "thinFilmThickness",
			type: "float"
		},
		{
			name: "baseF0",
			type: "vec3"
		}
	]
});
var IBLSheenBRDF = /* @__PURE__ */ Fn$1(({ normal: normal$1, viewDir, roughness: roughness$2 }) => {
	const dotNV = normal$1.dot(viewDir).saturate();
	const r2 = roughness$2.pow2();
	const a$1 = select$1(roughness$2.lessThan(.25), float$1(-339.2).mul(r2).add(float$1(161.4).mul(roughness$2)).sub(25.9), float$1(-8.48).mul(r2).add(float$1(14.3).mul(roughness$2)).sub(9.95));
	const b$2 = select$1(roughness$2.lessThan(.25), float$1(44).mul(r2).sub(float$1(23.7).mul(roughness$2)).add(3.26), float$1(1.97).mul(r2).sub(float$1(3.27).mul(roughness$2)).add(.72));
	return select$1(roughness$2.lessThan(.25), 0, float$1(.1).mul(roughness$2).sub(.025)).add(a$1.mul(dotNV).add(b$2).exp()).mul(1 / Math.PI).saturate();
});
var clearcoatF0 = vec3$1(.04);
var clearcoatF90 = float$1(1);
/**
* Represents the lighting model for a PBR material.
*
* @augments LightingModel
*/
var PhysicalLightingModel = class extends LightingModel {
	/**
	* Constructs a new physical lighting model.
	*
	* @param {boolean} [clearcoat=false] - Whether clearcoat is supported or not.
	* @param {boolean} [sheen=false] - Whether sheen is supported or not.
	* @param {boolean} [iridescence=false] - Whether iridescence is supported or not.
	* @param {boolean} [anisotropy=false] - Whether anisotropy is supported or not.
	* @param {boolean} [transmission=false] - Whether transmission is supported or not.
	* @param {boolean} [dispersion=false] - Whether dispersion is supported or not.
	*/
	constructor(clearcoat$2 = false, sheen$2 = false, iridescence$2 = false, anisotropy$2 = false, transmission$2 = false, dispersion$2 = false) {
		super();
		/**
		* Whether clearcoat is supported or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.clearcoat = clearcoat$2;
		/**
		* Whether sheen is supported or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.sheen = sheen$2;
		/**
		* Whether iridescence is supported or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.iridescence = iridescence$2;
		/**
		* Whether anisotropy is supported or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.anisotropy = anisotropy$2;
		/**
		* Whether transmission is supported or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.transmission = transmission$2;
		/**
		* Whether dispersion is supported or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.dispersion = dispersion$2;
		/**
		* The clear coat radiance.
		*
		* @type {?Node}
		* @default null
		*/
		this.clearcoatRadiance = null;
		/**
		* The clear coat specular direct.
		*
		* @type {?Node}
		* @default null
		*/
		this.clearcoatSpecularDirect = null;
		/**
		* The clear coat specular indirect.
		*
		* @type {?Node}
		* @default null
		*/
		this.clearcoatSpecularIndirect = null;
		/**
		* The sheen specular direct.
		*
		* @type {?Node}
		* @default null
		*/
		this.sheenSpecularDirect = null;
		/**
		* The sheen specular indirect.
		*
		* @type {?Node}
		* @default null
		*/
		this.sheenSpecularIndirect = null;
		/**
		* The iridescence Fresnel.
		*
		* @type {?Node}
		* @default null
		*/
		this.iridescenceFresnel = null;
		/**
		* The iridescence F0.
		*
		* @type {?Node}
		* @default null
		*/
		this.iridescenceF0 = null;
	}
	/**
	* Depending on what features are requested, the method prepares certain node variables
	* which are later used for lighting computations.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	start(builder) {
		if (this.clearcoat === true) {
			this.clearcoatRadiance = vec3$1().toVar("clearcoatRadiance");
			this.clearcoatSpecularDirect = vec3$1().toVar("clearcoatSpecularDirect");
			this.clearcoatSpecularIndirect = vec3$1().toVar("clearcoatSpecularIndirect");
		}
		if (this.sheen === true) {
			this.sheenSpecularDirect = vec3$1().toVar("sheenSpecularDirect");
			this.sheenSpecularIndirect = vec3$1().toVar("sheenSpecularIndirect");
		}
		if (this.iridescence === true) {
			const dotNVi = normalView$1.dot(positionViewDirection$1).clamp();
			this.iridescenceFresnel = evalIridescence({
				outsideIOR: float$1(1),
				eta2: iridescenceIOR$1,
				cosTheta1: dotNVi,
				thinFilmThickness: iridescenceThickness$1,
				baseF0: specularColor$1
			});
			this.iridescenceF0 = Schlick_to_F0$1({
				f: this.iridescenceFresnel,
				f90: 1,
				dotVH: dotNVi
			});
		}
		if (this.transmission === true) {
			const position = positionWorld$1;
			const v = cameraPosition$1.sub(positionWorld$1).normalize();
			const n$2 = normalWorld$1;
			const context$2 = builder.context;
			context$2.backdrop = getIBLVolumeRefraction(n$2, v, roughness$1, diffuseColor$1, specularColor$1, specularF90$1, position, modelWorldMatrix$1, cameraViewMatrix$1, cameraProjectionMatrix$1, ior$1, thickness$1, attenuationColor$1, attenuationDistance$1, this.dispersion ? dispersion$1 : null);
			context$2.backdropAlpha = transmission$1;
			diffuseColor$1.a.mulAssign(mix$2(1, context$2.backdrop.a, transmission$1));
		}
		super.start(builder);
	}
	computeMultiscattering(singleScatter, multiScatter, specularF90$2) {
		const dotNV = normalView$1.dot(positionViewDirection$1).clamp();
		const fab = DFGApprox$1({
			roughness: roughness$1,
			dotNV
		});
		const Fr = this.iridescenceF0 ? iridescence$1.mix(specularColor$1, this.iridescenceF0) : specularColor$1;
		const FssEss = Fr.mul(fab.x).add(specularF90$2.mul(fab.y));
		const Ems = fab.x.add(fab.y).oneMinus();
		const Favg = Fr.add(Fr.oneMinus().mul(.047619));
		const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
		singleScatter.addAssign(FssEss);
		multiScatter.addAssign(Fms.mul(Ems));
	}
	/**
	* Implements the direct light.
	*
	* @param {Object} lightData - The light data.
	* @param {NodeBuilder} builder - The current node builder.
	*/
	direct({ lightDirection, lightColor, reflectedLight }) {
		const irradiance = normalView$1.dot(lightDirection).clamp().mul(lightColor);
		if (this.sheen === true) this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen({ lightDirection })));
		if (this.clearcoat === true) {
			const ccIrradiance = clearcoatNormalView$1.dot(lightDirection).clamp().mul(lightColor);
			this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX$1({
				lightDirection,
				f0: clearcoatF0,
				f90: clearcoatF90,
				roughness: clearcoatRoughness$1,
				normalView: clearcoatNormalView$1
			})));
		}
		reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert$1({ diffuseColor: diffuseColor$1.rgb })));
		reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX_Multiscatter({
			lightDirection,
			f0: specularColor$1,
			f90: 1,
			roughness: roughness$1,
			f: this.iridescenceFresnel,
			USE_IRIDESCENCE: this.iridescence,
			USE_ANISOTROPY: this.anisotropy
		})));
	}
	/**
	* This method is intended for implementing the direct light term for
	* rect area light nodes.
	*
	* @param {Object} input - The input data.
	* @param {NodeBuilder} builder - The current node builder.
	*/
	directRectArea({ lightColor, lightPosition: lightPosition$2, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 }) {
		const p0 = lightPosition$2.add(halfWidth).sub(halfHeight);
		const p1 = lightPosition$2.sub(halfWidth).sub(halfHeight);
		const p2 = lightPosition$2.sub(halfWidth).add(halfHeight);
		const p3 = lightPosition$2.add(halfWidth).add(halfHeight);
		const N$1 = normalView$1;
		const V = positionViewDirection$1;
		const P = positionView$1.toVar();
		const uv$3 = LTC_Uv({
			N: N$1,
			V,
			roughness: roughness$1
		});
		const t1 = ltc_1.sample(uv$3).toVar();
		const t2 = ltc_2.sample(uv$3).toVar();
		const mInv = mat3$1(vec3$1(t1.x, 0, t1.y), vec3$1(0, 1, 0), vec3$1(t1.z, 0, t1.w)).toVar();
		const fresnel = specularColor$1.mul(t2.x).add(specularColor$1.oneMinus().mul(t2.y)).toVar();
		reflectedLight.directSpecular.addAssign(lightColor.mul(fresnel).mul(LTC_Evaluate({
			N: N$1,
			V,
			P,
			mInv,
			p0,
			p1,
			p2,
			p3
		})));
		reflectedLight.directDiffuse.addAssign(lightColor.mul(diffuseColor$1).mul(LTC_Evaluate({
			N: N$1,
			V,
			P,
			mInv: mat3$1(1, 0, 0, 0, 1, 0, 0, 0, 1),
			p0,
			p1,
			p2,
			p3
		})));
	}
	/**
	* Implements the indirect lighting.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	indirect(builder) {
		this.indirectDiffuse(builder);
		this.indirectSpecular(builder);
		this.ambientOcclusion(builder);
	}
	/**
	* Implements the indirect diffuse term.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	indirectDiffuse(builder) {
		const { irradiance, reflectedLight } = builder.context;
		reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert$1({ diffuseColor: diffuseColor$1 })));
	}
	/**
	* Implements the indirect specular term.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	indirectSpecular(builder) {
		const { radiance, iblIrradiance, reflectedLight } = builder.context;
		if (this.sheen === true) this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(sheen$1, IBLSheenBRDF({
			normal: normalView$1,
			viewDir: positionViewDirection$1,
			roughness: sheenRoughness$1
		})));
		if (this.clearcoat === true) {
			const dotNVcc = clearcoatNormalView$1.dot(positionViewDirection$1).clamp();
			const clearcoatEnv = EnvironmentBRDF({
				dotNV: dotNVcc,
				specularColor: clearcoatF0,
				specularF90: clearcoatF90,
				roughness: clearcoatRoughness$1
			});
			this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));
		}
		const singleScattering = vec3$1().toVar("singleScattering");
		const multiScattering = vec3$1().toVar("multiScattering");
		const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
		this.computeMultiscattering(singleScattering, multiScattering, specularF90$1);
		const totalScattering = singleScattering.add(multiScattering);
		const diffuse = diffuseColor$1.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());
		reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));
		reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));
		reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));
	}
	/**
	* Implements the ambient occlusion term.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	ambientOcclusion(builder) {
		const { ambientOcclusion, reflectedLight } = builder.context;
		const aoNV = normalView$1.dot(positionViewDirection$1).clamp().add(ambientOcclusion);
		const aoExp = roughness$1.mul(-16).oneMinus().negate().exp2();
		const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
		if (this.clearcoat === true) this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);
		if (this.sheen === true) this.sheenSpecularIndirect.mulAssign(ambientOcclusion);
		reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
		reflectedLight.indirectSpecular.mulAssign(aoNode);
	}
	/**
	* Used for final lighting accumulations depending on the requested features.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	finish({ context: context$2 }) {
		const { outgoingLight } = context$2;
		if (this.clearcoat === true) {
			const dotNVcc = clearcoatNormalView$1.dot(positionViewDirection$1).clamp();
			const Fcc = F_Schlick$1({
				dotVH: dotNVcc,
				f0: clearcoatF0,
				f90: clearcoatF90
			});
			const clearcoatLight = outgoingLight.mul(clearcoat$1.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat$1));
			outgoingLight.assign(clearcoatLight);
		}
		if (this.sheen === true) {
			const sheenEnergyComp = sheen$1.r.max(sheen$1.g).max(sheen$1.b).mul(.157).oneMinus();
			const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
			outgoingLight.assign(sheenLight);
		}
	}
};
var cubeUV_r0 = /* @__PURE__ */ float$1(1);
var cubeUV_m0 = /* @__PURE__ */ float$1(-2);
var cubeUV_r1 = /* @__PURE__ */ float$1(.8);
var cubeUV_m1 = /* @__PURE__ */ float$1(-1);
var cubeUV_r4 = /* @__PURE__ */ float$1(.4);
var cubeUV_m4 = /* @__PURE__ */ float$1(2);
var cubeUV_r5 = /* @__PURE__ */ float$1(.305);
var cubeUV_m5 = /* @__PURE__ */ float$1(3);
var cubeUV_r6 = /* @__PURE__ */ float$1(.21);
var cubeUV_m6 = /* @__PURE__ */ float$1(4);
var cubeUV_minMipLevel = /* @__PURE__ */ float$1(4);
var cubeUV_minTileSize = /* @__PURE__ */ float$1(16);
var getFace = /* @__PURE__ */ Fn$1(([direction]) => {
	const absDirection = vec3$1(abs$1(direction)).toVar();
	const face = float$1(-1).toVar();
	If$1(absDirection.x.greaterThan(absDirection.z), () => {
		If$1(absDirection.x.greaterThan(absDirection.y), () => {
			face.assign(select$1(direction.x.greaterThan(0), 0, 3));
		}).Else(() => {
			face.assign(select$1(direction.y.greaterThan(0), 1, 4));
		});
	}).Else(() => {
		If$1(absDirection.z.greaterThan(absDirection.y), () => {
			face.assign(select$1(direction.z.greaterThan(0), 2, 5));
		}).Else(() => {
			face.assign(select$1(direction.y.greaterThan(0), 1, 4));
		});
	});
	return face;
}).setLayout({
	name: "getFace",
	type: "float",
	inputs: [{
		name: "direction",
		type: "vec3"
	}]
});
var getUV = /* @__PURE__ */ Fn$1(([direction, face]) => {
	const uv$3 = vec2$1().toVar();
	If$1(face.equal(0), () => {
		uv$3.assign(vec2$1(direction.z, direction.y).div(abs$1(direction.x)));
	}).ElseIf(face.equal(1), () => {
		uv$3.assign(vec2$1(direction.x.negate(), direction.z.negate()).div(abs$1(direction.y)));
	}).ElseIf(face.equal(2), () => {
		uv$3.assign(vec2$1(direction.x.negate(), direction.y).div(abs$1(direction.z)));
	}).ElseIf(face.equal(3), () => {
		uv$3.assign(vec2$1(direction.z.negate(), direction.y).div(abs$1(direction.x)));
	}).ElseIf(face.equal(4), () => {
		uv$3.assign(vec2$1(direction.x.negate(), direction.z).div(abs$1(direction.y)));
	}).Else(() => {
		uv$3.assign(vec2$1(direction.x, direction.y).div(abs$1(direction.z)));
	});
	return mul$1(.5, uv$3.add(1));
}).setLayout({
	name: "getUV",
	type: "vec2",
	inputs: [{
		name: "direction",
		type: "vec3"
	}, {
		name: "face",
		type: "float"
	}]
});
var roughnessToMip = /* @__PURE__ */ Fn$1(([roughness$2]) => {
	const mip = float$1(0).toVar();
	If$1(roughness$2.greaterThanEqual(cubeUV_r1), () => {
		mip.assign(cubeUV_r0.sub(roughness$2).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));
	}).ElseIf(roughness$2.greaterThanEqual(cubeUV_r4), () => {
		mip.assign(cubeUV_r1.sub(roughness$2).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));
	}).ElseIf(roughness$2.greaterThanEqual(cubeUV_r5), () => {
		mip.assign(cubeUV_r4.sub(roughness$2).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));
	}).ElseIf(roughness$2.greaterThanEqual(cubeUV_r6), () => {
		mip.assign(cubeUV_r5.sub(roughness$2).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));
	}).Else(() => {
		mip.assign(float$1(-2).mul(log2$1(mul$1(1.16, roughness$2))));
	});
	return mip;
}).setLayout({
	name: "roughnessToMip",
	type: "float",
	inputs: [{
		name: "roughness",
		type: "float"
	}]
});
var getDirection$1 = /* @__PURE__ */ Fn$1(([uv_immutable, face]) => {
	const uv$3 = uv_immutable.toVar();
	uv$3.assign(mul$1(2, uv$3).sub(1));
	const direction = vec3$1(uv$3, 1).toVar();
	If$1(face.equal(0), () => {
		direction.assign(direction.zyx);
	}).ElseIf(face.equal(1), () => {
		direction.assign(direction.xzy);
		direction.xz.mulAssign(-1);
	}).ElseIf(face.equal(2), () => {
		direction.x.mulAssign(-1);
	}).ElseIf(face.equal(3), () => {
		direction.assign(direction.zyx);
		direction.xz.mulAssign(-1);
	}).ElseIf(face.equal(4), () => {
		direction.assign(direction.xzy);
		direction.xy.mulAssign(-1);
	}).ElseIf(face.equal(5), () => {
		direction.z.mulAssign(-1);
	});
	return direction;
}).setLayout({
	name: "getDirection",
	type: "vec3",
	inputs: [{
		name: "uv",
		type: "vec2"
	}, {
		name: "face",
		type: "float"
	}]
});
var textureCubeUV$1 = /* @__PURE__ */ Fn$1(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
	const roughness$2 = float$1(roughness_immutable);
	const sampleDir = vec3$1(sampleDir_immutable);
	const mip = clamp$2(roughnessToMip(roughness$2), cubeUV_m0, CUBEUV_MAX_MIP);
	const mipF = fract$1(mip);
	const mipInt = floor$1(mip);
	const color0 = vec3$1(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
	If$1(mipF.notEqual(0), () => {
		const color1 = vec3$1(bilinearCubeUV(envMap, sampleDir, mipInt.add(1), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
		color0.assign(mix$2(color0, color1, mipF));
	});
	return color0;
});
var bilinearCubeUV = /* @__PURE__ */ Fn$1(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
	const mipInt = float$1(mipInt_immutable).toVar();
	const direction = vec3$1(direction_immutable);
	const face = float$1(getFace(direction)).toVar();
	const filterInt = float$1(max$1$1(cubeUV_minMipLevel.sub(mipInt), 0)).toVar();
	mipInt.assign(max$1$1(mipInt, cubeUV_minMipLevel));
	const faceSize = float$1(exp2$1(mipInt)).toVar();
	const uv$3 = vec2$1(getUV(direction, face).mul(faceSize.sub(2)).add(1)).toVar();
	If$1(face.greaterThan(2), () => {
		uv$3.y.addAssign(faceSize);
		face.subAssign(3);
	});
	uv$3.x.addAssign(face.mul(faceSize));
	uv$3.x.addAssign(filterInt.mul(mul$1(3, cubeUV_minTileSize)));
	uv$3.y.addAssign(mul$1(4, exp2$1(CUBEUV_MAX_MIP).sub(faceSize)));
	uv$3.x.mulAssign(CUBEUV_TEXEL_WIDTH);
	uv$3.y.mulAssign(CUBEUV_TEXEL_HEIGHT);
	return envMap.sample(uv$3).grad(vec2$1(), vec2$1());
});
var getSample = /* @__PURE__ */ Fn$1(({ envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
	const cosTheta = cos$1(theta);
	const sampleDirection = outputDirection.mul(cosTheta).add(axis.cross(outputDirection).mul(sin$1(theta))).add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));
	return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
});
var blur$1 = /* @__PURE__ */ Fn$1(({ n: n$2, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
	const axis = vec3$1(select$1(latitudinal, poleAxis, cross$1(poleAxis, outputDirection))).toVar();
	If$1(axis.equal(vec3$1(0)), () => {
		axis.assign(vec3$1(outputDirection.z, 0, outputDirection.x.negate()));
	});
	axis.assign(normalize$1(axis));
	const gl_FragColor = vec3$1().toVar();
	gl_FragColor.addAssign(weights.element(0).mul(getSample({
		theta: 0,
		axis,
		outputDirection,
		mipInt,
		envMap,
		CUBEUV_TEXEL_WIDTH,
		CUBEUV_TEXEL_HEIGHT,
		CUBEUV_MAX_MIP
	})));
	Loop$1({
		start: int$1(1),
		end: n$2
	}, ({ i }) => {
		If$1(i.greaterThanEqual(samples), () => {
			Break$1();
		});
		const theta = float$1(dTheta.mul(float$1(i))).toVar();
		gl_FragColor.addAssign(weights.element(i).mul(getSample({
			theta: theta.mul(-1),
			axis,
			outputDirection,
			mipInt,
			envMap,
			CUBEUV_TEXEL_WIDTH,
			CUBEUV_TEXEL_HEIGHT,
			CUBEUV_MAX_MIP
		})));
		gl_FragColor.addAssign(weights.element(i).mul(getSample({
			theta,
			axis,
			outputDirection,
			mipInt,
			envMap,
			CUBEUV_TEXEL_WIDTH,
			CUBEUV_TEXEL_HEIGHT,
			CUBEUV_MAX_MIP
		})));
	});
	return vec4$1(gl_FragColor, 1);
});
var radicalInverse_VdC = /* @__PURE__ */ Fn$1(([bits_immutable]) => {
	const bits = uint$1(bits_immutable).toVar();
	bits.assign(bits.shiftLeft(uint$1(16)).bitOr(bits.shiftRight(uint$1(16))));
	bits.assign(bits.bitAnd(uint$1(1431655765)).shiftLeft(uint$1(1)).bitOr(bits.bitAnd(uint$1(2863311530)).shiftRight(uint$1(1))));
	bits.assign(bits.bitAnd(uint$1(858993459)).shiftLeft(uint$1(2)).bitOr(bits.bitAnd(uint$1(3435973836)).shiftRight(uint$1(2))));
	bits.assign(bits.bitAnd(uint$1(252645135)).shiftLeft(uint$1(4)).bitOr(bits.bitAnd(uint$1(4042322160)).shiftRight(uint$1(4))));
	bits.assign(bits.bitAnd(uint$1(16711935)).shiftLeft(uint$1(8)).bitOr(bits.bitAnd(uint$1(4278255360)).shiftRight(uint$1(8))));
	return float$1(bits).mul(23283064365386963e-26);
});
var hammersley = /* @__PURE__ */ Fn$1(([i, N$1]) => {
	return vec2$1(float$1(i).div(float$1(N$1)), radicalInverse_VdC(i));
});
var importanceSampleGGX_VNDF = /* @__PURE__ */ Fn$1(([Xi, V_immutable, roughness_immutable]) => {
	const V = vec3$1(V_immutable).toVar();
	const roughness$2 = float$1(roughness_immutable);
	const alpha = roughness$2.mul(roughness$2).toVar();
	const Vh = normalize$1(vec3$1(alpha.mul(V.x), alpha.mul(V.y), V.z)).toVar();
	const lensq = Vh.x.mul(Vh.x).add(Vh.y.mul(Vh.y));
	const T1 = select$1(lensq.greaterThan(0), vec3$1(Vh.y.negate(), Vh.x, 0).div(sqrt$1(lensq)), vec3$1(1, 0, 0)).toVar();
	const T2 = cross$1(Vh, T1).toVar();
	const r = sqrt$1(Xi.x);
	const phi$1 = mul$1(2, 3.14159265359).mul(Xi.y);
	const t1 = r.mul(cos$1(phi$1)).toVar();
	const t2 = r.mul(sin$1(phi$1)).toVar();
	const s = mul$1(.5, Vh.z.add(1));
	t2.assign(s.oneMinus().mul(sqrt$1(t1.mul(t1).oneMinus())).add(s.mul(t2)));
	const Nh = T1.mul(t1).add(T2.mul(t2)).add(Vh.mul(sqrt$1(max$1$1(0, t1.mul(t1).add(t2.mul(t2)).oneMinus()))));
	return normalize$1(vec3$1(alpha.mul(Nh.x), alpha.mul(Nh.y), max$1$1(0, Nh.z)));
});
var ggxConvolution = /* @__PURE__ */ Fn$1(({ roughness: roughness$2, mipInt, envMap, N_immutable, GGX_SAMPLES: GGX_SAMPLES$2, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
	const N$1 = vec3$1(N_immutable).toVar();
	const prefilteredColor = vec3$1(0).toVar();
	const totalWeight = float$1(0).toVar();
	If$1(roughness$2.lessThan(.001), () => {
		prefilteredColor.assign(bilinearCubeUV(envMap, N$1, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP));
	}).Else(() => {
		const up = select$1(abs$1(N$1.z).lessThan(.999), vec3$1(0, 0, 1), vec3$1(1, 0, 0));
		const tangent = normalize$1(cross$1(up, N$1)).toVar();
		const bitangent = cross$1(N$1, tangent).toVar();
		Loop$1({
			start: uint$1(0),
			end: GGX_SAMPLES$2
		}, ({ i }) => {
			const Xi = hammersley(i, GGX_SAMPLES$2);
			const H_tangent = importanceSampleGGX_VNDF(Xi, vec3$1(0, 0, 1), roughness$2);
			const H = normalize$1(tangent.mul(H_tangent.x).add(bitangent.mul(H_tangent.y)).add(N$1.mul(H_tangent.z)));
			const L = normalize$1(H.mul(dot$1(N$1, H).mul(2)).sub(N$1));
			const NdotL = max$1$1(dot$1(N$1, L), 0);
			If$1(NdotL.greaterThan(0), () => {
				const sampleColor = bilinearCubeUV(envMap, L, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
				prefilteredColor.addAssign(sampleColor.mul(NdotL));
				totalWeight.addAssign(NdotL);
			});
		});
		If$1(totalWeight.greaterThan(0), () => {
			prefilteredColor.assign(prefilteredColor.div(totalWeight));
		});
	});
	return vec4$1(prefilteredColor, 1);
});
var LOD_MIN$1 = 4;
var EXTRA_LOD_SIGMA$1 = [
	.125,
	.215,
	.35,
	.446,
	.526,
	.582
];
var MAX_SAMPLES$1 = 20;
var GGX_SAMPLES$1 = 512;
var _flatCamera$1 = /* @__PURE__ */ new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _cubeCamera = /* @__PURE__ */ new PerspectiveCamera(90, 1);
var _clearColor$2 = /* @__PURE__ */ new Color$1();
var _oldTarget$1 = null;
var _oldActiveCubeFace$1 = 0;
var _oldActiveMipmapLevel$1 = 0;
var _origin$1 = /* @__PURE__ */ new Vector3();
var _uniformsMap = /* @__PURE__ */ new WeakMap();
var _faceLib = [
	3,
	1,
	5,
	0,
	4,
	2
];
var _direction = /* @__PURE__ */ getDirection$1(uv$1$1(), attribute$1("faceIndex")).normalize();
var _outputDirection = /* @__PURE__ */ vec3$1(_direction.x, _direction.y, _direction.z);
/**
* This class generates a Prefiltered, Mipmapped Radiance Environment Map
* (PMREM) from a cubeMap environment texture. This allows different levels of
* blur to be quickly accessed based on material roughness. It is packed into a
* special CubeUV format that allows us to perform custom interpolation so that
* we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
* chain, it only goes down to the LOD_MIN level (above), and then creates extra
* even more filtered 'mips' at the same LOD_MIN resolution, associated with
* higher roughness levels. In this way we maintain resolution to smoothly
* interpolate diffuse lighting while limiting sampling computation.
*
* The prefiltering uses GGX VNDF (Visible Normal Distribution Function)
* importance sampling based on "Sampling the GGX Distribution of Visible Normals"
* (Heitz, 2018) to generate environment maps that accurately match the GGX BRDF
* used in material rendering for physically-based image-based lighting.
*/
var PMREMGenerator$1 = class {
	/**
	* Constructs a new PMREM generator.
	*
	* @param {Renderer} renderer - The renderer.
	*/
	constructor(renderer) {
		this._renderer = renderer;
		this._pingPongRenderTarget = null;
		this._lodMax = 0;
		this._cubeSize = 0;
		this._sizeLods = [];
		this._sigmas = [];
		this._lodMeshes = [];
		this._blurMaterial = null;
		this._ggxMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;
		this._backgroundBox = null;
	}
	get _hasInitialized() {
		return this._renderer.hasInitialized();
	}
	/**
	* Generates a PMREM from a supplied Scene, which can be faster than using an
	* image if networking bandwidth is low. Optional sigma specifies a blur radius
	* in radians to be applied to the scene before PMREM generation. Optional near
	* and far planes ensure the scene is rendered in its entirety.
	*
	* @param {Scene} scene - The scene to be captured.
	* @param {number} [sigma=0] - The blur radius in radians.
	* @param {number} [near=0.1] - The near plane distance.
	* @param {number} [far=100] - The far plane distance.
	* @param {Object} [options={}] - The configuration options.
	* @param {number} [options.size=256] - The texture size of the PMREM.
	* @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
	* @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
	* @return {RenderTarget} The resulting PMREM.
	* @see {@link PMREMGenerator#fromScene}
	*/
	fromScene(scene, sigma = 0, near = .1, far = 100, options = {}) {
		const { size = 256, position = _origin$1, renderTarget = null } = options;
		this._setSize(size);
		if (this._hasInitialized === false) {
			warn("PMREMGenerator: \".fromScene()\" called before the backend is initialized. Try using \"await renderer.init()\" instead.");
			const cubeUVRenderTarget$1 = renderTarget || this._allocateTarget();
			options.renderTarget = cubeUVRenderTarget$1;
			this.fromSceneAsync(scene, sigma, near, far, options);
			return cubeUVRenderTarget$1;
		}
		_oldTarget$1 = this._renderer.getRenderTarget();
		_oldActiveCubeFace$1 = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel$1 = this._renderer.getActiveMipmapLevel();
		const cubeUVRenderTarget = renderTarget || this._allocateTarget();
		cubeUVRenderTarget.depthBuffer = true;
		this._init(cubeUVRenderTarget);
		this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position);
		if (sigma > 0) this._blur(cubeUVRenderTarget, 0, 0, sigma);
		this._applyPMREM(cubeUVRenderTarget);
		this._cleanup(cubeUVRenderTarget);
		return cubeUVRenderTarget;
	}
	/**
	* Generates a PMREM from a supplied Scene, which can be faster than using an
	* image if networking bandwidth is low. Optional sigma specifies a blur radius
	* in radians to be applied to the scene before PMREM generation. Optional near
	* and far planes ensure the scene is rendered in its entirety (the cubeCamera
	* is placed at the origin).
	*
	* @deprecated
	* @param {Scene} scene - The scene to be captured.
	* @param {number} [sigma=0] - The blur radius in radians.
	* @param {number} [near=0.1] - The near plane distance.
	* @param {number} [far=100] - The far plane distance.
	* @param {Object} [options={}] - The configuration options.
	* @param {number} [options.size=256] - The texture size of the PMREM.
	* @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.
	* @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
	* @return {Promise<RenderTarget>} A Promise that resolve with the PMREM when the generation has been finished.
	* @see {@link PMREMGenerator#fromScene}
	*/
	async fromSceneAsync(scene, sigma = 0, near = .1, far = 100, options = {}) {
		warnOnce("PMREMGenerator: \".fromSceneAsync()\" is deprecated. Use \"await renderer.init()\" instead.");
		await this._renderer.init();
		return this.fromScene(scene, sigma, near, far, options);
	}
	/**
	* Generates a PMREM from an equirectangular texture, which can be either LDR
	* or HDR. The ideal input image size is 1k (1024 x 512),
	* as this matches best with the 256 x 256 cubemap output.
	*
	* @param {Texture} equirectangular - The equirectangular texture to be converted.
	* @param {?RenderTarget} [renderTarget=null] - The render target to use.
	* @return {RenderTarget} The resulting PMREM.
	* @see {@link PMREMGenerator#fromEquirectangularAsync}
	*/
	fromEquirectangular(equirectangular, renderTarget = null) {
		if (this._hasInitialized === false) {
			warn("PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using \"await renderer.init()\" instead.");
			this._setSizeFromTexture(equirectangular);
			const cubeUVRenderTarget = renderTarget || this._allocateTarget();
			this.fromEquirectangularAsync(equirectangular, cubeUVRenderTarget);
			return cubeUVRenderTarget;
		}
		return this._fromTexture(equirectangular, renderTarget);
	}
	/**
	* Generates a PMREM from an equirectangular texture, which can be either LDR
	* or HDR. The ideal input image size is 1k (1024 x 512),
	* as this matches best with the 256 x 256 cubemap output.
	*
	* @deprecated
	* @param {Texture} equirectangular - The equirectangular texture to be converted.
	* @param {?RenderTarget} [renderTarget=null] - The render target to use.
	* @return {Promise<RenderTarget>} The resulting PMREM.
	* @see {@link PMREMGenerator#fromEquirectangular}
	*/
	async fromEquirectangularAsync(equirectangular, renderTarget = null) {
		warnOnce("PMREMGenerator: \".fromEquirectangularAsync()\" is deprecated. Use \"await renderer.init()\" instead.");
		await this._renderer.init();
		return this._fromTexture(equirectangular, renderTarget);
	}
	/**
	* Generates a PMREM from an cubemap texture, which can be either LDR
	* or HDR. The ideal input cube size is 256 x 256,
	* as this matches best with the 256 x 256 cubemap output.
	*
	* @param {Texture} cubemap - The cubemap texture to be converted.
	* @param {?RenderTarget} [renderTarget=null] - The render target to use.
	* @return {RenderTarget} The resulting PMREM.
	* @see {@link PMREMGenerator#fromCubemapAsync}
	*/
	fromCubemap(cubemap, renderTarget = null) {
		if (this._hasInitialized === false) {
			warn("PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.");
			this._setSizeFromTexture(cubemap);
			const cubeUVRenderTarget = renderTarget || this._allocateTarget();
			this.fromCubemapAsync(cubemap, renderTarget);
			return cubeUVRenderTarget;
		}
		return this._fromTexture(cubemap, renderTarget);
	}
	/**
	* Generates a PMREM from an cubemap texture, which can be either LDR
	* or HDR. The ideal input cube size is 256 x 256,
	* with the 256 x 256 cubemap output.
	*
	* @deprecated
	* @param {Texture} cubemap - The cubemap texture to be converted.
	* @param {?RenderTarget} [renderTarget=null] - The render target to use.
	* @return {Promise<RenderTarget>} The resulting PMREM.
	* @see {@link PMREMGenerator#fromCubemap}
	*/
	async fromCubemapAsync(cubemap, renderTarget = null) {
		warnOnce("PMREMGenerator: \".fromCubemapAsync()\" is deprecated. Use \"await renderer.init()\" instead.");
		await this._renderer.init();
		return this._fromTexture(cubemap, renderTarget);
	}
	/**
	* Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	* your texture's network fetch for increased concurrency.
	*
	* @returns {Promise}
	*/
	async compileCubemapShader() {
		if (this._cubemapMaterial === null) {
			this._cubemapMaterial = _getCubemapMaterial$1();
			await this._compileMaterial(this._cubemapMaterial);
		}
	}
	/**
	* Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	* your texture's network fetch for increased concurrency.
	*
	* @returns {Promise}
	*/
	async compileEquirectangularShader() {
		if (this._equirectMaterial === null) {
			this._equirectMaterial = _getEquirectMaterial$1();
			await this._compileMaterial(this._equirectMaterial);
		}
	}
	/**
	* Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	* so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	* one of them will cause any others to also become unusable.
	*/
	dispose() {
		this._dispose();
		if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
		if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
		if (this._backgroundBox !== null) {
			this._backgroundBox.geometry.dispose();
			this._backgroundBox.material.dispose();
		}
	}
	_setSizeFromTexture(texture$2) {
		if (texture$2.mapping === CubeReflectionMapping || texture$2.mapping === CubeRefractionMapping) this._setSize(texture$2.image.length === 0 ? 16 : texture$2.image[0].width || texture$2.image[0].image.width);
		else this._setSize(texture$2.image.width / 4);
	}
	_setSize(cubeSize) {
		this._lodMax = Math.floor(Math.log2(cubeSize));
		this._cubeSize = Math.pow(2, this._lodMax);
	}
	_dispose() {
		if (this._blurMaterial !== null) this._blurMaterial.dispose();
		if (this._ggxMaterial !== null) this._ggxMaterial.dispose();
		if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
		for (let i = 0; i < this._lodMeshes.length; i++) this._lodMeshes[i].geometry.dispose();
	}
	_cleanup(outputTarget) {
		this._renderer.setRenderTarget(_oldTarget$1, _oldActiveCubeFace$1, _oldActiveMipmapLevel$1);
		outputTarget.scissorTest = false;
		_setViewport$1(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
	}
	_fromTexture(texture$2, renderTarget) {
		this._setSizeFromTexture(texture$2);
		_oldTarget$1 = this._renderer.getRenderTarget();
		_oldActiveCubeFace$1 = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel$1 = this._renderer.getActiveMipmapLevel();
		const cubeUVRenderTarget = renderTarget || this._allocateTarget();
		this._init(cubeUVRenderTarget);
		this._textureToCubeUV(texture$2, cubeUVRenderTarget);
		this._applyPMREM(cubeUVRenderTarget);
		this._cleanup(cubeUVRenderTarget);
		return cubeUVRenderTarget;
	}
	_allocateTarget() {
		const width = 3 * Math.max(this._cubeSize, 112);
		const height = 4 * this._cubeSize;
		return _createRenderTarget$1(width, height);
	}
	_init(renderTarget) {
		if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== renderTarget.width || this._pingPongRenderTarget.height !== renderTarget.height) {
			if (this._pingPongRenderTarget !== null) this._dispose();
			this._pingPongRenderTarget = _createRenderTarget$1(renderTarget.width, renderTarget.height);
			const { _lodMax } = this;
			({lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas} = _createPlanes$1(_lodMax));
			this._blurMaterial = _getBlurShader$1(_lodMax, renderTarget.width, renderTarget.height);
			this._ggxMaterial = _getGGXShader$1(_lodMax, renderTarget.width, renderTarget.height);
		}
	}
	async _compileMaterial(material) {
		const mesh = new Mesh(new BufferGeometry(), material);
		await this._renderer.compile(mesh, _flatCamera$1);
	}
	_sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position) {
		const cubeCamera = _cubeCamera;
		cubeCamera.near = near;
		cubeCamera.far = far;
		const upSign = [
			1,
			1,
			1,
			1,
			-1,
			1
		];
		const forwardSign = [
			1,
			-1,
			1,
			-1,
			1,
			-1
		];
		const renderer = this._renderer;
		const originalAutoClear = renderer.autoClear;
		renderer.getClearColor(_clearColor$2);
		renderer.autoClear = false;
		if (this._backgroundBox === null) this._backgroundBox = new Mesh(new BoxGeometry(), new MeshBasicMaterial({
			name: "PMREM.Background",
			side: BackSide,
			depthWrite: false,
			depthTest: false
		}));
		const backgroundBox = this._backgroundBox;
		const backgroundMaterial = backgroundBox.material;
		let useSolidColor = false;
		const background = scene.background;
		if (background) {
			if (background.isColor) {
				backgroundMaterial.color.copy(background);
				scene.background = null;
				useSolidColor = true;
			}
		} else {
			backgroundMaterial.color.copy(_clearColor$2);
			useSolidColor = true;
		}
		renderer.setRenderTarget(cubeUVRenderTarget);
		renderer.clear();
		if (useSolidColor) renderer.render(backgroundBox, cubeCamera);
		for (let i = 0; i < 6; i++) {
			const col = i % 3;
			if (col === 0) {
				cubeCamera.up.set(0, upSign[i], 0);
				cubeCamera.position.set(position.x, position.y, position.z);
				cubeCamera.lookAt(position.x + forwardSign[i], position.y, position.z);
			} else if (col === 1) {
				cubeCamera.up.set(0, 0, upSign[i]);
				cubeCamera.position.set(position.x, position.y, position.z);
				cubeCamera.lookAt(position.x, position.y + forwardSign[i], position.z);
			} else {
				cubeCamera.up.set(0, upSign[i], 0);
				cubeCamera.position.set(position.x, position.y, position.z);
				cubeCamera.lookAt(position.x, position.y, position.z + forwardSign[i]);
			}
			const size = this._cubeSize;
			_setViewport$1(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
			renderer.render(scene, cubeCamera);
		}
		renderer.autoClear = originalAutoClear;
		scene.background = background;
	}
	_textureToCubeUV(texture$2, cubeUVRenderTarget) {
		const renderer = this._renderer;
		const isCubeTexture = texture$2.mapping === CubeReflectionMapping || texture$2.mapping === CubeRefractionMapping;
		if (isCubeTexture) {
			if (this._cubemapMaterial === null) this._cubemapMaterial = _getCubemapMaterial$1(texture$2);
		} else if (this._equirectMaterial === null) this._equirectMaterial = _getEquirectMaterial$1(texture$2);
		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		material.fragmentNode.value = texture$2;
		const mesh = this._lodMeshes[0];
		mesh.material = material;
		const size = this._cubeSize;
		_setViewport$1(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
		renderer.setRenderTarget(cubeUVRenderTarget);
		renderer.render(mesh, _flatCamera$1);
	}
	_applyPMREM(cubeUVRenderTarget) {
		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;
		const n$2 = this._lodMeshes.length;
		for (let i = 1; i < n$2; i++) this._applyGGXFilter(cubeUVRenderTarget, i - 1, i);
		renderer.autoClear = autoClear;
	}
	/**
	* Applies GGX VNDF importance sampling filter to generate a prefiltered environment map.
	* Uses Monte Carlo integration with VNDF importance sampling to accurately represent the
	* GGX BRDF for physically-based rendering. Reads from the previous LOD level and
	* applies incremental roughness filtering to avoid over-blurring.
	*
	* @private
	* @param {RenderTarget} cubeUVRenderTarget
	* @param {number} lodIn - Source LOD level to read from
	* @param {number} lodOut - Target LOD level to write to
	*/
	_applyGGXFilter(cubeUVRenderTarget, lodIn, lodOut) {
		const renderer = this._renderer;
		const pingPongRenderTarget = this._pingPongRenderTarget;
		const ggxMaterial = this._ggxMaterial;
		const ggxMesh = this._lodMeshes[lodOut];
		ggxMesh.material = ggxMaterial;
		const ggxUniforms = _uniformsMap.get(ggxMaterial);
		const targetRoughness = lodOut / (this._lodMeshes.length - 1);
		const sourceRoughness = lodIn / (this._lodMeshes.length - 1);
		const incrementalRoughness = Math.sqrt(targetRoughness * targetRoughness - sourceRoughness * sourceRoughness);
		const blurStrength = .05 + targetRoughness * .95;
		const adjustedRoughness = incrementalRoughness * blurStrength;
		const { _lodMax } = this;
		const outputSize = this._sizeLods[lodOut];
		const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN$1 ? lodOut - _lodMax + LOD_MIN$1 : 0);
		const y = 4 * (this._cubeSize - outputSize);
		cubeUVRenderTarget.texture.frame = (cubeUVRenderTarget.texture.frame || 0) + 1;
		ggxUniforms.envMap.value = cubeUVRenderTarget.texture;
		ggxUniforms.roughness.value = adjustedRoughness;
		ggxUniforms.mipInt.value = _lodMax - lodIn;
		_setViewport$1(pingPongRenderTarget, x, y, 3 * outputSize, 2 * outputSize);
		renderer.setRenderTarget(pingPongRenderTarget);
		renderer.render(ggxMesh, _flatCamera$1);
		pingPongRenderTarget.texture.frame = (pingPongRenderTarget.texture.frame || 0) + 1;
		ggxUniforms.envMap.value = pingPongRenderTarget.texture;
		ggxUniforms.roughness.value = 0;
		ggxUniforms.mipInt.value = _lodMax - lodOut;
		_setViewport$1(cubeUVRenderTarget, x, y, 3 * outputSize, 2 * outputSize);
		renderer.setRenderTarget(cubeUVRenderTarget);
		renderer.render(ggxMesh, _flatCamera$1);
	}
	/**
	* This is a two-pass Gaussian blur for a cubemap. Normally this is done
	* vertically and horizontally, but this breaks down on a cube. Here we apply
	* the blur latitudinally (around the poles), and then longitudinally (towards
	* the poles) to approximate the orthogonally-separable blur. It is least
	* accurate at the poles, but still does a decent job.
	*
	* Used for initial scene blur in fromScene() method when sigma > 0.
	*
	* @private
	* @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.
	* @param {number} lodIn - The input level-of-detail.
	* @param {number} lodOut - The output level-of-detail.
	* @param {number} sigma - The blur radius in radians.
	* @param {Vector3} [poleAxis] - The pole axis.
	*/
	_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
		const pingPongRenderTarget = this._pingPongRenderTarget;
		this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
		this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
	}
	_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;
		if (direction !== "latitudinal" && direction !== "longitudinal") error("blur direction must be either latitudinal or longitudinal!");
		const STANDARD_DEVIATIONS = 3;
		const blurMesh = this._lodMeshes[lodOut];
		blurMesh.material = blurMaterial;
		const blurUniforms = _uniformsMap.get(blurMaterial);
		const pixels = this._sizeLods[lodIn] - 1;
		const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES$1 - 1);
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES$1;
		if (samples > MAX_SAMPLES$1) warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES$1}`);
		const weights = [];
		let sum = 0;
		for (let i = 0; i < MAX_SAMPLES$1; ++i) {
			const x$1 = i / sigmaPixels;
			const weight = Math.exp(-x$1 * x$1 / 2);
			weights.push(weight);
			if (i === 0) sum += weight;
			else if (i < samples) sum += 2 * weight;
		}
		for (let i = 0; i < weights.length; i++) weights[i] = weights[i] / sum;
		targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;
		blurUniforms.envMap.value = targetIn.texture;
		blurUniforms.samples.value = samples;
		blurUniforms.weights.array = weights;
		blurUniforms.latitudinal.value = direction === "latitudinal" ? 1 : 0;
		if (poleAxis) blurUniforms.poleAxis.value = poleAxis;
		const { _lodMax } = this;
		blurUniforms.dTheta.value = radiansPerPixel;
		blurUniforms.mipInt.value = _lodMax - lodIn;
		const outputSize = this._sizeLods[lodOut];
		const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN$1 ? lodOut - _lodMax + LOD_MIN$1 : 0);
		const y = 4 * (this._cubeSize - outputSize);
		_setViewport$1(targetOut, x, y, 3 * outputSize, 2 * outputSize);
		renderer.setRenderTarget(targetOut);
		renderer.render(blurMesh, _flatCamera$1);
	}
};
function _createPlanes$1(lodMax) {
	const sizeLods = [];
	const sigmas = [];
	const lodMeshes = [];
	let lod = lodMax;
	const totalLods = lodMax - LOD_MIN$1 + 1 + EXTRA_LOD_SIGMA$1.length;
	for (let i = 0; i < totalLods; i++) {
		const sizeLod = Math.pow(2, lod);
		sizeLods.push(sizeLod);
		let sigma = 1 / sizeLod;
		if (i > lodMax - LOD_MIN$1) sigma = EXTRA_LOD_SIGMA$1[i - lodMax + LOD_MIN$1 - 1];
		else if (i === 0) sigma = 0;
		sigmas.push(sigma);
		const texelSize = 1 / (sizeLod - 2);
		const min$3 = -texelSize;
		const max$3 = 1 + texelSize;
		const uv1 = [
			min$3,
			min$3,
			max$3,
			min$3,
			max$3,
			max$3,
			min$3,
			min$3,
			max$3,
			max$3,
			min$3,
			max$3
		];
		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;
		const position = new Float32Array(positionSize * vertices * cubeFaces);
		const uv$3 = new Float32Array(uvSize * vertices * cubeFaces);
		const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
		for (let face = 0; face < cubeFaces; face++) {
			const x = face % 3 * 2 / 3 - 1;
			const y = face > 2 ? 0 : -1;
			const coordinates = [
				x,
				y,
				0,
				x + 2 / 3,
				y,
				0,
				x + 2 / 3,
				y + 1,
				0,
				x,
				y,
				0,
				x + 2 / 3,
				y + 1,
				0,
				x,
				y + 1,
				0
			];
			const faceIdx = _faceLib[face];
			position.set(coordinates, positionSize * vertices * faceIdx);
			uv$3.set(uv1, uvSize * vertices * faceIdx);
			const fill = [
				faceIdx,
				faceIdx,
				faceIdx,
				faceIdx,
				faceIdx,
				faceIdx
			];
			faceIndex.set(fill, faceIndexSize * vertices * faceIdx);
		}
		const planes = new BufferGeometry();
		planes.setAttribute("position", new BufferAttribute(position, positionSize));
		planes.setAttribute("uv", new BufferAttribute(uv$3, uvSize));
		planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
		lodMeshes.push(new Mesh(planes, null));
		if (lod > LOD_MIN$1) lod--;
	}
	return {
		lodMeshes,
		sizeLods,
		sigmas
	};
}
function _createRenderTarget$1(width, height) {
	const cubeUVRenderTarget = new RenderTarget(width, height, {
		magFilter: LinearFilter,
		minFilter: LinearFilter,
		generateMipmaps: false,
		type: HalfFloatType,
		format: RGBAFormat,
		colorSpace: LinearSRGBColorSpace
	});
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
	cubeUVRenderTarget.texture.isPMREMTexture = true;
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;
}
function _setViewport$1(target, x, y, width, height) {
	target.viewport.set(x, y, width, height);
	target.scissor.set(x, y, width, height);
}
function _getMaterial(type$1) {
	const material = new NodeMaterial();
	material.depthTest = false;
	material.depthWrite = false;
	material.blending = NoBlending;
	material.name = `PMREM_${type$1}`;
	return material;
}
function _getBlurShader$1(lodMax, width, height) {
	const weights = uniformArray$1(new Array(MAX_SAMPLES$1).fill(0));
	const poleAxis = uniform$1(new Vector3(0, 1, 0));
	const dTheta = uniform$1(0);
	const n$2 = float$1(MAX_SAMPLES$1);
	const latitudinal = uniform$1(0);
	const samples = uniform$1(1);
	const envMap = texture$1();
	const mipInt = uniform$1(0);
	const CUBEUV_TEXEL_WIDTH = float$1(1 / width);
	const CUBEUV_TEXEL_HEIGHT = float$1(1 / height);
	const CUBEUV_MAX_MIP = float$1(lodMax);
	const materialUniforms = {
		n: n$2,
		latitudinal,
		weights,
		poleAxis,
		outputDirection: _outputDirection,
		dTheta,
		samples,
		envMap,
		mipInt,
		CUBEUV_TEXEL_WIDTH,
		CUBEUV_TEXEL_HEIGHT,
		CUBEUV_MAX_MIP
	};
	const material = _getMaterial("blur");
	material.fragmentNode = blur$1({
		...materialUniforms,
		latitudinal: latitudinal.equal(1)
	});
	_uniformsMap.set(material, materialUniforms);
	return material;
}
function _getGGXShader$1(lodMax, width, height) {
	const envMap = texture$1();
	const roughness$2 = uniform$1(0);
	const mipInt = uniform$1(0);
	const CUBEUV_TEXEL_WIDTH = float$1(1 / width);
	const CUBEUV_TEXEL_HEIGHT = float$1(1 / height);
	const CUBEUV_MAX_MIP = float$1(lodMax);
	const materialUniforms = {
		envMap,
		roughness: roughness$2,
		mipInt,
		CUBEUV_TEXEL_WIDTH,
		CUBEUV_TEXEL_HEIGHT,
		CUBEUV_MAX_MIP
	};
	const material = _getMaterial("ggx");
	material.fragmentNode = ggxConvolution({
		...materialUniforms,
		N_immutable: _outputDirection,
		GGX_SAMPLES: uint$1(GGX_SAMPLES$1)
	});
	_uniformsMap.set(material, materialUniforms);
	return material;
}
function _getCubemapMaterial$1(envTexture) {
	const material = _getMaterial("cubemap");
	material.fragmentNode = cubeTexture$1(envTexture, _outputDirection);
	return material;
}
function _getEquirectMaterial$1(envTexture) {
	const material = _getMaterial("equirect");
	material.fragmentNode = texture$1(envTexture, equirectUV$1(_outputDirection), 0);
	return material;
}
var _cache = /* @__PURE__ */ new WeakMap();
/**
* Generates the cubeUV size based on the given image height.
*
* @private
* @param {number} imageHeight - The image height.
* @return {{texelWidth: number,texelHeight: number, maxMip: number}} The result object.
*/
function _generateCubeUVSize(imageHeight) {
	const maxMip = Math.log2(imageHeight) - 2;
	const texelHeight = 1 / imageHeight;
	return {
		texelWidth: 1 / (3 * Math.max(Math.pow(2, maxMip), 112)),
		texelHeight,
		maxMip
	};
}
/**
* Generates a PMREM from the given texture.
*
* @private
* @param {Texture} texture - The texture to create the PMREM for.
* @param {Renderer} renderer - The renderer.
* @param {PMREMGenerator} generator - The PMREM generator.
* @return {?Texture} The PMREM.
*/
function _getPMREMFromTexture(texture$2, renderer, generator) {
	const cache$2 = _getCache(renderer);
	let cacheTexture = cache$2.get(texture$2);
	if ((cacheTexture !== void 0 ? cacheTexture.pmremVersion : -1) !== texture$2.pmremVersion) {
		const image = texture$2.image;
		if (texture$2.isCubeTexture) if (isCubeMapReady(image)) cacheTexture = generator.fromCubemap(texture$2, cacheTexture);
		else return null;
		else if (isEquirectangularMapReady(image)) cacheTexture = generator.fromEquirectangular(texture$2, cacheTexture);
		else return null;
		cacheTexture.pmremVersion = texture$2.pmremVersion;
		cache$2.set(texture$2, cacheTexture);
	}
	return cacheTexture.texture;
}
/**
* Returns a cache that stores generated PMREMs for the respective textures.
* A cache must be maintained per renderer since PMREMs are render target textures
* which can't be shared across render contexts.
*
* @private
* @param {Renderer} renderer - The renderer.
* @return {WeakMap<Texture, Texture>} The PMREM cache.
*/
function _getCache(renderer) {
	let rendererCache$1 = _cache.get(renderer);
	if (rendererCache$1 === void 0) {
		rendererCache$1 = /* @__PURE__ */ new WeakMap();
		_cache.set(renderer, rendererCache$1);
	}
	return rendererCache$1;
}
/**
* This node represents a PMREM which is a special type of preprocessed
* environment map intended for PBR materials.
*
* ```js
* const material = new MeshStandardNodeMaterial();
* material.envNode = pmremTexture( envMap );
* ```
*
* @augments TempNode
*/
var PMREMNode = class extends TempNode {
	static get type() {
		return "PMREMNode";
	}
	/**
	* Constructs a new function overloading node.
	*
	* @param {Texture} value - The input texture.
	* @param {Node<vec2>} [uvNode=null] - The uv node.
	* @param {Node<float>} [levelNode=null] - The level node.
	*/
	constructor(value, uvNode = null, levelNode = null) {
		super("vec3");
		/**
		* Reference to the input texture.
		*
		* @private
		* @type {Texture}
		*/
		this._value = value;
		/**
		* Reference to the generated PMREM.
		*
		* @private
		* @type {Texture | null}
		* @default null
		*/
		this._pmrem = null;
		/**
		*  The uv node.
		*
		* @type {Node<vec2>}
		*/
		this.uvNode = uvNode;
		/**
		*  The level node.
		*
		* @type {Node<float>}
		*/
		this.levelNode = levelNode;
		/**
		* Reference to a PMREM generator.
		*
		* @private
		* @type {?PMREMGenerator}
		* @default null
		*/
		this._generator = null;
		const defaultTexture = new Texture();
		defaultTexture.isRenderTargetTexture = true;
		/**
		* The texture node holding the generated PMREM.
		*
		* @private
		* @type {TextureNode}
		*/
		this._texture = texture$1(defaultTexture);
		/**
		* A uniform representing the PMREM's width.
		*
		* @private
		* @type {UniformNode<float>}
		*/
		this._width = uniform$1(0);
		/**
		* A uniform representing the PMREM's height.
		*
		* @private
		* @type {UniformNode<float>}
		*/
		this._height = uniform$1(0);
		/**
		* A uniform representing the PMREM's max Mip.
		*
		* @private
		* @type {UniformNode<float>}
		*/
		this._maxMip = uniform$1(0);
		/**
		* The `updateBeforeType` is set to `NodeUpdateType.RENDER`.
		*
		* @type {string}
		* @default 'render'
		*/
		this.updateBeforeType = NodeUpdateType$1.RENDER;
	}
	set value(value) {
		this._value = value;
		this._pmrem = null;
	}
	/**
	* The node's texture value.
	*
	* @type {Texture}
	*/
	get value() {
		return this._value;
	}
	/**
	* Uses the given PMREM texture to update internal values.
	*
	* @param {Texture} texture - The PMREM texture.
	*/
	updateFromTexture(texture$2) {
		const cubeUVSize = _generateCubeUVSize(texture$2.image.height);
		this._texture.value = texture$2;
		this._width.value = cubeUVSize.texelWidth;
		this._height.value = cubeUVSize.texelHeight;
		this._maxMip.value = cubeUVSize.maxMip;
	}
	updateBefore(frame) {
		let pmrem = this._pmrem;
		const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
		const texture$2 = this._value;
		if (pmremVersion !== texture$2.pmremVersion) {
			if (texture$2.isPMREMTexture === true) pmrem = texture$2;
			else pmrem = _getPMREMFromTexture(texture$2, frame.renderer, this._generator);
			if (pmrem !== null) {
				this._pmrem = pmrem;
				this.updateFromTexture(pmrem);
			}
		}
	}
	setup(builder) {
		if (this._generator === null) this._generator = new PMREMGenerator$1(builder.renderer);
		this.updateBefore(builder);
		let uvNode = this.uvNode;
		if (uvNode === null && builder.context.getUV) uvNode = builder.context.getUV(this);
		uvNode = materialEnvRotation$1.mul(vec3$1(uvNode.x, uvNode.y.negate(), uvNode.z));
		let levelNode = this.levelNode;
		if (levelNode === null && builder.context.getTextureLevel) levelNode = builder.context.getTextureLevel(this);
		return textureCubeUV$1(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);
	}
	dispose() {
		super.dispose();
		if (this._generator !== null) this._generator.dispose();
	}
};
/**
* Returns `true` if the given cube map image has been fully loaded.
*
* @private
* @param {?Array<(Image|Object)>} [image] - The cube map image.
* @return {boolean} Whether the given cube map is ready or not.
*/
function isCubeMapReady(image) {
	if (image === null || image === void 0) return false;
	let count = 0;
	const length$2 = 6;
	for (let i = 0; i < length$2; i++) if (image[i] !== void 0) count++;
	return count === length$2;
}
/**
* Returns `true` if the given equirectangular image has been fully loaded.
*
* @private
* @param {(Image|Object)} image - The equirectangular image.
* @return {boolean} Whether the given cube map is ready or not.
*/
function isEquirectangularMapReady(image) {
	if (image === null || image === void 0) return false;
	return image.height > 0;
}
/**
* TSL function for creating a PMREM node.
*
* @tsl
* @function
* @param {Texture} value - The input texture.
* @param {?Node<vec2>} [uvNode=null] - The uv node.
* @param {?Node<float>} [levelNode=null] - The level node.
* @returns {PMREMNode}
*/
var pmremTexture$1 = /* @__PURE__ */ nodeProxy$1(PMREMNode).setParameterLength(1, 3);
var _envNodeCache = /* @__PURE__ */ new WeakMap();
/**
* Represents a physical model for Image-based lighting (IBL). The environment
* is defined via environment maps in the equirectangular, cube map or cubeUV (PMREM) format.
* `EnvironmentNode` is intended for PBR materials like {@link MeshStandardNodeMaterial}.
*
* @augments LightingNode
*/
var EnvironmentNode = class extends LightingNode {
	static get type() {
		return "EnvironmentNode";
	}
	/**
	* Constructs a new environment node.
	*
	* @param {Node} [envNode=null] - A node representing the environment.
	*/
	constructor(envNode = null) {
		super();
		/**
		* A node representing the environment.
		*
		* @type {?Node}
		* @default null
		*/
		this.envNode = envNode;
	}
	setup(builder) {
		const { material } = builder;
		let envNode = this.envNode;
		if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
			const value = envNode.isTextureNode ? envNode.value : material[envNode.property];
			let cacheEnvNode = _envNodeCache.get(value);
			if (cacheEnvNode === void 0) {
				cacheEnvNode = pmremTexture$1(value);
				_envNodeCache.set(value, cacheEnvNode);
			}
			envNode = cacheEnvNode;
		}
		const radianceNormalView = material.useAnisotropy === true || material.anisotropy > 0 ? bentNormalView$1 : normalView$1;
		const radiance = envNode.context(createRadianceContext(roughness$1, radianceNormalView)).mul(materialEnvIntensity$1);
		const irradiance = envNode.context(createIrradianceContext(normalWorld$1)).mul(Math.PI).mul(materialEnvIntensity$1);
		const isolateRadiance = isolate(radiance);
		const isolateIrradiance = isolate(irradiance);
		builder.context.radiance.addAssign(isolateRadiance);
		builder.context.iblIrradiance.addAssign(isolateIrradiance);
		const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;
		if (clearcoatRadiance) {
			const clearcoatRadianceContext = envNode.context(createRadianceContext(clearcoatRoughness$1, clearcoatNormalView$1)).mul(materialEnvIntensity$1);
			const isolateClearcoatRadiance = isolate(clearcoatRadianceContext);
			clearcoatRadiance.addAssign(isolateClearcoatRadiance);
		}
	}
};
var createRadianceContext = (roughnessNode, normalViewNode) => {
	let reflectVec = null;
	return {
		getUV: () => {
			if (reflectVec === null) {
				reflectVec = positionViewDirection$1.negate().reflect(normalViewNode);
				reflectVec = pow4$1(roughnessNode).mix(reflectVec, normalViewNode).normalize();
				reflectVec = reflectVec.transformDirection(cameraViewMatrix$1);
			}
			return reflectVec;
		},
		getTextureLevel: () => {
			return roughnessNode;
		}
	};
};
var createIrradianceContext = (normalWorldNode) => {
	return {
		getUV: () => {
			return normalWorldNode;
		},
		getTextureLevel: () => {
			return float$1(1);
		}
	};
};
var _defaultValues$6 = /* @__PURE__ */ new MeshStandardMaterial();
/**
* Node material version of {@link MeshStandardMaterial}.
*
* @augments NodeMaterial
*/
var MeshStandardNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "MeshStandardNodeMaterial";
	}
	/**
	* Constructs a new mesh standard node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshStandardNodeMaterial = true;
		/**
		* Set to `true` because standard materials react on lights.
		*
		* @type {boolean}
		* @default true
		*/
		this.lights = true;
		/**
		* The emissive color of standard materials is by default inferred from the `emissive`,
		* `emissiveIntensity` and `emissiveMap` properties. This node property allows to
		* overwrite the default and define the emissive color with a node instead.
		*
		* If you don't want to overwrite the emissive color but modify the existing
		* value instead, use {@link materialEmissive}.
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.emissiveNode = null;
		/**
		* The metalness of standard materials is by default inferred from the `metalness`,
		* and `metalnessMap` properties. This node property allows to
		* overwrite the default and define the metalness with a node instead.
		*
		* If you don't want to overwrite the metalness but modify the existing
		* value instead, use {@link materialMetalness}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.metalnessNode = null;
		/**
		* The roughness of standard materials is by default inferred from the `roughness`,
		* and `roughnessMap` properties. This node property allows to
		* overwrite the default and define the roughness with a node instead.
		*
		* If you don't want to overwrite the roughness but modify the existing
		* value instead, use {@link materialRoughness}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.roughnessNode = null;
		this.setDefaultValues(_defaultValues$6);
		this.setValues(parameters);
	}
	/**
	* Overwritten since this type of material uses {@link EnvironmentNode}
	* to implement the PBR (PMREM based) environment mapping. Besides, the
	* method honors `Scene.environment`.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {?EnvironmentNode<vec3>} The environment node.
	*/
	setupEnvironment(builder) {
		let envNode = super.setupEnvironment(builder);
		if (envNode === null && builder.environmentNode) envNode = builder.environmentNode;
		return envNode ? new EnvironmentNode(envNode) : null;
	}
	/**
	* Setups the lighting model.
	*
	* @return {PhysicalLightingModel} The lighting model.
	*/
	setupLightingModel() {
		return new PhysicalLightingModel();
	}
	/**
	* Setups the specular related node variables.
	*/
	setupSpecular() {
		const specularColorNode = mix$2(vec3$1(.04), diffuseColor$1.rgb, metalness$1);
		specularColor$1.assign(specularColorNode);
		specularF90$1.assign(1);
	}
	/**
	* Setups the standard specific node variables.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setupVariants() {
		const metalnessNode = this.metalnessNode ? float$1(this.metalnessNode) : materialMetalness$1;
		metalness$1.assign(metalnessNode);
		let roughnessNode = this.roughnessNode ? float$1(this.roughnessNode) : materialRoughness$1;
		roughnessNode = getRoughness$1({ roughness: roughnessNode });
		roughness$1.assign(roughnessNode);
		this.setupSpecular();
		diffuseColor$1.assign(vec4$1(diffuseColor$1.rgb.mul(metalnessNode.oneMinus()), diffuseColor$1.a));
	}
	copy(source) {
		this.emissiveNode = source.emissiveNode;
		this.metalnessNode = source.metalnessNode;
		this.roughnessNode = source.roughnessNode;
		return super.copy(source);
	}
};
var _defaultValues$5 = /* @__PURE__ */ new MeshPhysicalMaterial();
/**
* Node material version of {@link MeshPhysicalMaterial}.
*
* @augments MeshStandardNodeMaterial
*/
var MeshPhysicalNodeMaterial = class extends MeshStandardNodeMaterial {
	static get type() {
		return "MeshPhysicalNodeMaterial";
	}
	/**
	* Constructs a new mesh physical node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshPhysicalNodeMaterial = true;
		/**
		* The clearcoat of physical materials is by default inferred from the `clearcoat`
		* and `clearcoatMap` properties. This node property allows to overwrite the default
		* and define the clearcoat with a node instead.
		*
		* If you don't want to overwrite the clearcoat but modify the existing
		* value instead, use {@link materialClearcoat}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.clearcoatNode = null;
		/**
		* The clearcoat roughness of physical materials is by default inferred from the `clearcoatRoughness`
		* and `clearcoatRoughnessMap` properties. This node property allows to overwrite the default
		* and define the clearcoat roughness with a node instead.
		*
		* If you don't want to overwrite the clearcoat roughness but modify the existing
		* value instead, use {@link materialClearcoatRoughness}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.clearcoatRoughnessNode = null;
		/**
		* The clearcoat normal of physical materials is by default inferred from the `clearcoatNormalMap`
		* property. This node property allows to overwrite the default
		* and define the clearcoat normal with a node instead.
		*
		* If you don't want to overwrite the clearcoat normal but modify the existing
		* value instead, use {@link materialClearcoatNormal}.
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.clearcoatNormalNode = null;
		/**
		* The sheen of physical materials is by default inferred from the `sheen`, `sheenColor`
		* and `sheenColorMap` properties. This node property allows to overwrite the default
		* and define the sheen with a node instead.
		*
		* If you don't want to overwrite the sheen but modify the existing
		* value instead, use {@link materialSheen}.
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.sheenNode = null;
		/**
		* The sheen roughness of physical materials is by default inferred from the `sheenRoughness` and
		* `sheenRoughnessMap` properties. This node property allows to overwrite the default
		* and define the sheen roughness with a node instead.
		*
		* If you don't want to overwrite the sheen roughness but modify the existing
		* value instead, use {@link materialSheenRoughness}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.sheenRoughnessNode = null;
		/**
		* The iridescence of physical materials is by default inferred from the `iridescence`
		* property. This node property allows to overwrite the default
		* and define the iridescence with a node instead.
		*
		* If you don't want to overwrite the iridescence but modify the existing
		* value instead, use {@link materialIridescence}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.iridescenceNode = null;
		/**
		* The iridescence IOR of physical materials is by default inferred from the `iridescenceIOR`
		* property. This node property allows to overwrite the default
		* and define the iridescence IOR with a node instead.
		*
		* If you don't want to overwrite the iridescence IOR but modify the existing
		* value instead, use {@link materialIridescenceIOR}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.iridescenceIORNode = null;
		/**
		* The iridescence thickness of physical materials is by default inferred from the `iridescenceThicknessRange`
		* and `iridescenceThicknessMap` properties. This node property allows to overwrite the default
		* and define the iridescence thickness with a node instead.
		*
		* If you don't want to overwrite the iridescence thickness but modify the existing
		* value instead, use {@link materialIridescenceThickness}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.iridescenceThicknessNode = null;
		/**
		* The specular intensity of physical materials is by default inferred from the `specularIntensity`
		* and `specularIntensityMap` properties. This node property allows to overwrite the default
		* and define the specular intensity with a node instead.
		*
		* If you don't want to overwrite the specular intensity but modify the existing
		* value instead, use {@link materialSpecularIntensity}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.specularIntensityNode = null;
		/**
		* The specular color of physical materials is by default inferred from the `specularColor`
		* and `specularColorMap` properties. This node property allows to overwrite the default
		* and define the specular color with a node instead.
		*
		* If you don't want to overwrite the specular color but modify the existing
		* value instead, use {@link materialSpecularColor}.
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.specularColorNode = null;
		/**
		* The ior of physical materials is by default inferred from the `ior`
		* property. This node property allows to overwrite the default
		* and define the ior with a node instead.
		*
		* If you don't want to overwrite the ior but modify the existing
		* value instead, use {@link materialIOR}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.iorNode = null;
		/**
		* The transmission of physical materials is by default inferred from the `transmission` and
		* `transmissionMap` properties. This node property allows to overwrite the default
		* and define the transmission with a node instead.
		*
		* If you don't want to overwrite the transmission but modify the existing
		* value instead, use {@link materialTransmission}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.transmissionNode = null;
		/**
		* The thickness of physical materials is by default inferred from the `thickness` and
		* `thicknessMap` properties. This node property allows to overwrite the default
		* and define the thickness with a node instead.
		*
		* If you don't want to overwrite the thickness but modify the existing
		* value instead, use {@link materialThickness}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.thicknessNode = null;
		/**
		* The attenuation distance of physical materials is by default inferred from the
		* `attenuationDistance` property. This node property allows to overwrite the default
		* and define the attenuation distance with a node instead.
		*
		* If you don't want to overwrite the attenuation distance but modify the existing
		* value instead, use {@link materialAttenuationDistance}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.attenuationDistanceNode = null;
		/**
		* The attenuation color of physical materials is by default inferred from the
		* `attenuationColor` property. This node property allows to overwrite the default
		* and define the attenuation color with a node instead.
		*
		* If you don't want to overwrite the attenuation color but modify the existing
		* value instead, use {@link materialAttenuationColor}.
		*
		* @type {?Node<vec3>}
		* @default null
		*/
		this.attenuationColorNode = null;
		/**
		* The dispersion of physical materials is by default inferred from the
		* `dispersion` property. This node property allows to overwrite the default
		* and define the dispersion with a node instead.
		*
		* If you don't want to overwrite the dispersion but modify the existing
		* value instead, use {@link materialDispersion}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.dispersionNode = null;
		/**
		* The anisotropy of physical materials is by default inferred from the
		* `anisotropy` property. This node property allows to overwrite the default
		* and define the anisotropy with a node instead.
		*
		* If you don't want to overwrite the anisotropy but modify the existing
		* value instead, use {@link materialAnisotropy}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.anisotropyNode = null;
		this.setDefaultValues(_defaultValues$5);
		this.setValues(parameters);
	}
	/**
	* Whether the lighting model should use clearcoat or not.
	*
	* @type {boolean}
	* @default true
	*/
	get useClearcoat() {
		return this.clearcoat > 0 || this.clearcoatNode !== null;
	}
	/**
	* Whether the lighting model should use iridescence or not.
	*
	* @type {boolean}
	* @default true
	*/
	get useIridescence() {
		return this.iridescence > 0 || this.iridescenceNode !== null;
	}
	/**
	* Whether the lighting model should use sheen or not.
	*
	* @type {boolean}
	* @default true
	*/
	get useSheen() {
		return this.sheen > 0 || this.sheenNode !== null;
	}
	/**
	* Whether the lighting model should use anisotropy or not.
	*
	* @type {boolean}
	* @default true
	*/
	get useAnisotropy() {
		return this.anisotropy > 0 || this.anisotropyNode !== null;
	}
	/**
	* Whether the lighting model should use transmission or not.
	*
	* @type {boolean}
	* @default true
	*/
	get useTransmission() {
		return this.transmission > 0 || this.transmissionNode !== null;
	}
	/**
	* Whether the lighting model should use dispersion or not.
	*
	* @type {boolean}
	* @default true
	*/
	get useDispersion() {
		return this.dispersion > 0 || this.dispersionNode !== null;
	}
	/**
	* Setups the specular related node variables.
	*/
	setupSpecular() {
		const iorNode = this.iorNode ? float$1(this.iorNode) : materialIOR$1;
		ior$1.assign(iorNode);
		specularColor$1.assign(mix$2(min$1(pow2$1(ior$1.sub(1).div(ior$1.add(1))).mul(materialSpecularColor$1), vec3$1(1)).mul(materialSpecularIntensity$1), diffuseColor$1.rgb, metalness$1));
		specularF90$1.assign(mix$2(materialSpecularIntensity$1, 1, metalness$1));
	}
	/**
	* Setups the lighting model.
	*
	* @return {PhysicalLightingModel} The lighting model.
	*/
	setupLightingModel() {
		return new PhysicalLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
	}
	/**
	* Setups the physical specific node variables.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setupVariants(builder) {
		super.setupVariants(builder);
		if (this.useClearcoat) {
			const clearcoatNode = this.clearcoatNode ? float$1(this.clearcoatNode) : materialClearcoat$1;
			const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float$1(this.clearcoatRoughnessNode) : materialClearcoatRoughness$1;
			clearcoat$1.assign(clearcoatNode);
			clearcoatRoughness$1.assign(getRoughness$1({ roughness: clearcoatRoughnessNode }));
		}
		if (this.useSheen) {
			const sheenNode = this.sheenNode ? vec3$1(this.sheenNode) : materialSheen$1;
			const sheenRoughnessNode = this.sheenRoughnessNode ? float$1(this.sheenRoughnessNode) : materialSheenRoughness$1;
			sheen$1.assign(sheenNode);
			sheenRoughness$1.assign(sheenRoughnessNode);
		}
		if (this.useIridescence) {
			const iridescenceNode = this.iridescenceNode ? float$1(this.iridescenceNode) : materialIridescence$1;
			const iridescenceIORNode = this.iridescenceIORNode ? float$1(this.iridescenceIORNode) : materialIridescenceIOR$1;
			const iridescenceThicknessNode = this.iridescenceThicknessNode ? float$1(this.iridescenceThicknessNode) : materialIridescenceThickness$1;
			iridescence$1.assign(iridescenceNode);
			iridescenceIOR$1.assign(iridescenceIORNode);
			iridescenceThickness$1.assign(iridescenceThicknessNode);
		}
		if (this.useAnisotropy) {
			const anisotropyV = (this.anisotropyNode ? vec2$1(this.anisotropyNode) : materialAnisotropy$1).toVar();
			anisotropy$1.assign(anisotropyV.length());
			If$1(anisotropy$1.equal(0), () => {
				anisotropyV.assign(vec2$1(1, 0));
			}).Else(() => {
				anisotropyV.divAssign(vec2$1(anisotropy$1));
				anisotropy$1.assign(anisotropy$1.saturate());
			});
			alphaT$1.assign(anisotropy$1.pow2().mix(roughness$1.pow2(), 1));
			anisotropyT$1.assign(TBNViewMatrix$1[0].mul(anisotropyV.x).add(TBNViewMatrix$1[1].mul(anisotropyV.y)));
			anisotropyB$1.assign(TBNViewMatrix$1[1].mul(anisotropyV.x).sub(TBNViewMatrix$1[0].mul(anisotropyV.y)));
		}
		if (this.useTransmission) {
			const transmissionNode = this.transmissionNode ? float$1(this.transmissionNode) : materialTransmission$1;
			const thicknessNode = this.thicknessNode ? float$1(this.thicknessNode) : materialThickness$1;
			const attenuationDistanceNode = this.attenuationDistanceNode ? float$1(this.attenuationDistanceNode) : materialAttenuationDistance$1;
			const attenuationColorNode = this.attenuationColorNode ? vec3$1(this.attenuationColorNode) : materialAttenuationColor$1;
			transmission$1.assign(transmissionNode);
			thickness$1.assign(thicknessNode);
			attenuationDistance$1.assign(attenuationDistanceNode);
			attenuationColor$1.assign(attenuationColorNode);
			if (this.useDispersion) {
				const dispersionNode = this.dispersionNode ? float$1(this.dispersionNode) : materialDispersion$1;
				dispersion$1.assign(dispersionNode);
			}
		}
	}
	/**
	* Setups the clearcoat normal node.
	*
	* @return {Node<vec3>} The clearcoat normal.
	*/
	setupClearcoatNormal() {
		return this.clearcoatNormalNode ? vec3$1(this.clearcoatNormalNode) : materialClearcoatNormal$1;
	}
	setup(builder) {
		builder.context.setupClearcoatNormal = () => subBuild$1(this.setupClearcoatNormal(builder), "NORMAL", "vec3");
		super.setup(builder);
	}
	copy(source) {
		this.clearcoatNode = source.clearcoatNode;
		this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
		this.clearcoatNormalNode = source.clearcoatNormalNode;
		this.sheenNode = source.sheenNode;
		this.sheenRoughnessNode = source.sheenRoughnessNode;
		this.iridescenceNode = source.iridescenceNode;
		this.iridescenceIORNode = source.iridescenceIORNode;
		this.iridescenceThicknessNode = source.iridescenceThicknessNode;
		this.specularIntensityNode = source.specularIntensityNode;
		this.specularColorNode = source.specularColorNode;
		this.transmissionNode = source.transmissionNode;
		this.thicknessNode = source.thicknessNode;
		this.attenuationDistanceNode = source.attenuationDistanceNode;
		this.attenuationColorNode = source.attenuationColorNode;
		this.dispersionNode = source.dispersionNode;
		this.anisotropyNode = source.anisotropyNode;
		return super.copy(source);
	}
};
var getGradientIrradiance = /* @__PURE__ */ Fn$1(({ normal: normal$1, lightDirection, builder }) => {
	const dotNL = normal$1.dot(lightDirection);
	const coord = vec2$1(dotNL.mul(.5).add(.5), 0);
	if (builder.material.gradientMap) {
		const gradientMap = materialReference$1("gradientMap", "texture").context({ getUV: () => coord });
		return vec3$1(gradientMap.r);
	} else {
		const fw = coord.fwidth().mul(.5);
		return mix$2(vec3$1(.7), vec3$1(1), smoothstep$1(float$1(.7).sub(fw.x), float$1(.7).add(fw.x), coord.x));
	}
});
/**
* Represents the lighting model for a toon material. Used in {@link MeshToonNodeMaterial}.
*
* @augments LightingModel
*/
var ToonLightingModel = class extends LightingModel {
	/**
	* Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
	* reduced to a small number of discrete shades to create a comic-like, flat look.
	*
	* @param {Object} lightData - The light data.
	* @param {NodeBuilder} builder - The current node builder.
	*/
	direct({ lightDirection, lightColor, reflectedLight }, builder) {
		const irradiance = getGradientIrradiance({
			normal: normalGeometry$1,
			lightDirection,
			builder
		}).mul(lightColor);
		reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert$1({ diffuseColor: diffuseColor$1.rgb })));
	}
	/**
	* Implements the indirect lighting.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	indirect(builder) {
		const { ambientOcclusion, irradiance, reflectedLight } = builder.context;
		reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert$1({ diffuseColor: diffuseColor$1 })));
		reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
	}
};
var _defaultValues$4 = /* @__PURE__ */ new MeshToonMaterial();
/**
* Node material version of {@link MeshToonMaterial}.
*
* @augments NodeMaterial
*/
var MeshToonNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "MeshToonNodeMaterial";
	}
	/**
	* Constructs a new mesh toon node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshToonNodeMaterial = true;
		/**
		* Set to `true` because toon materials react on lights.
		*
		* @type {boolean}
		* @default true
		*/
		this.lights = true;
		this.setDefaultValues(_defaultValues$4);
		this.setValues(parameters);
	}
	/**
	* Setups the lighting model.
	*
	* @return {ToonLightingModel} The lighting model.
	*/
	setupLightingModel() {
		return new ToonLightingModel();
	}
};
/**
* TSL function for creating a matcap uv node.
*
* Can be used to compute texture coordinates for projecting a
* matcap onto a mesh. Used by {@link MeshMatcapNodeMaterial}.
*
* @tsl
* @function
* @returns {Node<vec2>} The matcap UV coordinates.
*/
var matcapUV$1 = /* @__PURE__ */ Fn$1(() => {
	const x = vec3$1(positionViewDirection$1.z, 0, positionViewDirection$1.x.negate()).normalize();
	const y = positionViewDirection$1.cross(x);
	return vec2$1(x.dot(normalView$1), y.dot(normalView$1)).mul(.495).add(.5);
}).once(["NORMAL", "VERTEX"])().toVar("matcapUV");
var _defaultValues$3 = /* @__PURE__ */ new MeshMatcapMaterial();
/**
* Node material version of {@link MeshMatcapMaterial}.
*
* @augments NodeMaterial
*/
var MeshMatcapNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "MeshMatcapNodeMaterial";
	}
	/**
	* Constructs a new mesh normal node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMeshMatcapNodeMaterial = true;
		this.setDefaultValues(_defaultValues$3);
		this.setValues(parameters);
	}
	/**
	* Setups the matcap specific node variables.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setupVariants(builder) {
		const uv$3 = matcapUV$1;
		let matcapColor;
		if (builder.material.matcap) matcapColor = materialReference$1("matcap", "texture").context({ getUV: () => uv$3 });
		else matcapColor = vec3$1(mix$2(.2, .8, uv$3.y));
		diffuseColor$1.rgb.mulAssign(matcapColor.rgb);
	}
};
/**
* Applies a rotation to the given position node.
*
* @augments TempNode
*/
var RotateNode = class extends TempNode {
	static get type() {
		return "RotateNode";
	}
	/**
	* Constructs a new rotate node.
	*
	* @param {Node} positionNode - The position node.
	* @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
	* on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
	*/
	constructor(positionNode, rotationNode) {
		super();
		/**
		* The position node.
		*
		* @type {Node}
		*/
		this.positionNode = positionNode;
		/**
		*  Represents the rotation that is applied to the position node.
		*  Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
		*
		* @type {Node}
		*/
		this.rotationNode = rotationNode;
	}
	/**
	* The type of the {@link RotateNode#positionNode} defines the node's type.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node's type.
	*/
	getNodeType(builder) {
		return this.positionNode.getNodeType(builder);
	}
	setup(builder) {
		const { rotationNode, positionNode } = this;
		if (this.getNodeType(builder) === "vec2") {
			const cosAngle = rotationNode.cos();
			const sinAngle = rotationNode.sin();
			return mat2$1(cosAngle, sinAngle, sinAngle.negate(), cosAngle).mul(positionNode);
		} else {
			const rotation = rotationNode;
			const rotationXMatrix = mat4$1(vec4$1(1, 0, 0, 0), vec4$1(0, cos$1(rotation.x), sin$1(rotation.x).negate(), 0), vec4$1(0, sin$1(rotation.x), cos$1(rotation.x), 0), vec4$1(0, 0, 0, 1));
			const rotationYMatrix = mat4$1(vec4$1(cos$1(rotation.y), 0, sin$1(rotation.y), 0), vec4$1(0, 1, 0, 0), vec4$1(sin$1(rotation.y).negate(), 0, cos$1(rotation.y), 0), vec4$1(0, 0, 0, 1));
			const rotationZMatrix = mat4$1(vec4$1(cos$1(rotation.z), sin$1(rotation.z).negate(), 0, 0), vec4$1(sin$1(rotation.z), cos$1(rotation.z), 0, 0), vec4$1(0, 0, 1, 0), vec4$1(0, 0, 0, 1));
			return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4$1(positionNode, 1)).xyz;
		}
	}
};
/**
* TSL function for creating a rotate node.
*
* @tsl
* @function
* @param {Node} positionNode - The position node.
* @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
* on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
* @returns {RotateNode}
*/
var rotate$1 = /* @__PURE__ */ nodeProxy$1(RotateNode).setParameterLength(2);
var _defaultValues$2 = /* @__PURE__ */ new SpriteMaterial();
/**
* Node material version of {@link SpriteMaterial}.
*
* @augments NodeMaterial
*/
var SpriteNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "SpriteNodeMaterial";
	}
	/**
	* Constructs a new sprite node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSpriteNodeMaterial = true;
		this._useSizeAttenuation = true;
		/**
		* This property makes it possible to define the position of the sprite with a
		* node. That can be useful when the material is used with instanced rendering
		* and node data are defined with an instanced attribute node:
		* ```js
		* const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 );
		* material.positionNode = instancedBufferAttribute( positionAttribute );
		* ```
		* Another possibility is to compute the instanced data with a compute shader:
		* ```js
		* const positionBuffer = instancedArray( particleCount, 'vec3' );
		* particleMaterial.positionNode = positionBuffer.toAttribute();
		* ```
		*
		* @type {?Node<vec2>}
		* @default null
		*/
		this.positionNode = null;
		/**
		* The rotation of sprite materials is by default inferred from the `rotation`,
		* property. This node property allows to overwrite the default and define
		* the rotation with a node instead.
		*
		* If you don't want to overwrite the rotation but modify the existing
		* value instead, use {@link materialRotation}.
		*
		* @type {?Node<float>}
		* @default null
		*/
		this.rotationNode = null;
		/**
		* This node property provides an additional way to scale sprites next to
		* `Object3D.scale`. The scale transformation based in `Object3D.scale`
		* is multiplied with the scale value of this node in the vertex shader.
		*
		* @type {?Node<vec2>}
		* @default null
		*/
		this.scaleNode = null;
		/**
		* In Sprites, the transparent property is enabled by default.
		*
		* @type {boolean}
		* @default true
		*/
		this.transparent = true;
		this.setDefaultValues(_defaultValues$2);
		this.setValues(parameters);
	}
	/**
	* Setups the position node in view space. This method implements
	* the sprite specific vertex shader.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node<vec3>} The position in view space.
	*/
	setupPositionView(builder) {
		const { object, camera } = builder;
		const { positionNode, rotationNode, scaleNode, sizeAttenuation } = this;
		const mvPosition = modelViewMatrix$1.mul(vec3$1(positionNode || 0));
		let scale$3 = vec2$1(modelWorldMatrix$1[0].xyz.length(), modelWorldMatrix$1[1].xyz.length());
		if (scaleNode !== null) scale$3 = scale$3.mul(vec2$1(scaleNode));
		if (camera.isPerspectiveCamera && sizeAttenuation === false) scale$3 = scale$3.mul(mvPosition.z.negate());
		let alignedPosition = positionGeometry$1.xy;
		if (object.center && object.center.isVector2 === true) {
			const center = reference$1("center", "vec2", object);
			alignedPosition = alignedPosition.sub(center.sub(.5));
		}
		alignedPosition = alignedPosition.mul(scale$3);
		const rotation = float$1(rotationNode || materialRotation$1);
		const rotatedPosition = rotate$1(alignedPosition, rotation);
		return vec4$1(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
	}
	copy(source) {
		this.positionNode = source.positionNode;
		this.rotationNode = source.rotationNode;
		this.scaleNode = source.scaleNode;
		return super.copy(source);
	}
	/**
	* Whether to use size attenuation or not.
	*
	* @type {boolean}
	* @default true
	*/
	get sizeAttenuation() {
		return this._useSizeAttenuation;
	}
	set sizeAttenuation(value) {
		if (this._useSizeAttenuation !== value) {
			this._useSizeAttenuation = value;
			this.needsUpdate = true;
		}
	}
};
var _defaultValues$1 = /* @__PURE__ */ new PointsMaterial();
var _size$4 = /* @__PURE__ */ new Vector2();
/**
* Node material version of {@link PointsMaterial}.
*
* This material can be used in two ways:
*
* - By rendering point primitives with {@link Points}. Since WebGPU only supports point primitives
* with a pixel size of `1`, it's not possible to define a size.
*
* ```js
* const pointCloud = new THREE.Points( geometry, new THREE.PointsNodeMaterial() );
* ```
*
* - By rendering point primitives with {@link Sprites}. In this case, size is honored,
* see {@link PointsNodeMaterial#sizeNode}.
*
* ```js
* const instancedPoints = new THREE.Sprite( new THREE.PointsNodeMaterial( { positionNode: instancedBufferAttribute( positionAttribute ) } ) );
* ```
*
* @augments SpriteNodeMaterial
*/
var PointsNodeMaterial = class extends SpriteNodeMaterial {
	static get type() {
		return "PointsNodeMaterial";
	}
	/**
	* Constructs a new points node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This node property provides an additional way to set the point size.
		*
		* Note that WebGPU only supports point primitives with 1 pixel size. Consequently,
		* this node has no effect when the material is used with {@link Points} and a WebGPU
		* backend. If an application wants to render points with a size larger than 1 pixel,
		* the material should be used with {@link Sprite} and instancing.
		*
		* @type {?Node<vec2>}
		* @default null
		*/
		this.sizeNode = null;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isPointsNodeMaterial = true;
		this.setDefaultValues(_defaultValues$1);
		this.setValues(parameters);
	}
	setupPositionView() {
		const { positionNode } = this;
		return modelViewMatrix$1.mul(vec3$1(positionNode || positionLocal$1)).xyz;
	}
	setupVertexSprite(builder) {
		const { material, camera } = builder;
		const { rotationNode, scaleNode, sizeNode, sizeAttenuation } = this;
		let mvp = super.setupVertex(builder);
		if (material.isNodeMaterial !== true) return mvp;
		let pointSize = sizeNode !== null ? vec2$1(sizeNode) : materialPointSize$1;
		pointSize = pointSize.mul(screenDPR$1);
		if (camera.isPerspectiveCamera && sizeAttenuation === true) pointSize = pointSize.mul(scale$2.div(positionView$1.z.negate()));
		if (scaleNode && scaleNode.isNode) pointSize = pointSize.mul(vec2$1(scaleNode));
		let offset = positionGeometry$1.xy;
		if (rotationNode && rotationNode.isNode) {
			const rotation = float$1(rotationNode);
			offset = rotate$1(offset, rotation);
		}
		offset = offset.mul(pointSize);
		offset = offset.div(viewportSize$1.div(2));
		offset = offset.mul(mvp.w);
		mvp = mvp.add(vec4$1(offset, 0, 0));
		return mvp;
	}
	setupVertex(builder) {
		if (builder.object.isPoints) return super.setupVertex(builder);
		else return this.setupVertexSprite(builder);
	}
	/**
	* Whether alpha to coverage should be used or not.
	*
	* @type {boolean}
	* @default true
	*/
	get alphaToCoverage() {
		return this._useAlphaToCoverage;
	}
	set alphaToCoverage(value) {
		if (this._useAlphaToCoverage !== value) {
			this._useAlphaToCoverage = value;
			this.needsUpdate = true;
		}
	}
};
var scale$2 = /* @__PURE__ */ uniform$1(1).onFrameUpdate(function({ renderer }) {
	this.value = .5 * renderer.getSize(_size$4).y;
});
/**
* Represents lighting model for a shadow material. Used in {@link ShadowNodeMaterial}.
*
* @augments LightingModel
*/
var ShadowMaskModel = class extends LightingModel {
	/**
	* Constructs a new shadow mask model.
	*/
	constructor() {
		super();
		/**
		* The shadow mask node.
		*
		* @type {Node}
		*/
		this.shadowNode = float$1(1).toVar("shadowMask");
	}
	/**
	* Only used to save the shadow mask.
	*
	* @param {Object} input - The input data.
	*/
	direct({ lightNode }) {
		if (lightNode.shadowNode !== null) this.shadowNode.mulAssign(lightNode.shadowNode);
	}
	/**
	* Uses the shadow mask to produce the final color.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	finish({ context: context$2 }) {
		diffuseColor$1.a.mulAssign(this.shadowNode.oneMinus());
		context$2.outgoingLight.rgb.assign(diffuseColor$1.rgb);
	}
};
var _defaultValues = /* @__PURE__ */ new ShadowMaterial();
/**
* Node material version of {@link ShadowMaterial}.
*
* @augments NodeMaterial
*/
var ShadowNodeMaterial = class extends NodeMaterial {
	static get type() {
		return "ShadowNodeMaterial";
	}
	/**
	* Constructs a new shadow node material.
	*
	* @param {Object} [parameters] - The configuration parameter.
	*/
	constructor(parameters) {
		super();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isShadowNodeMaterial = true;
		/**
		* Set to `true` because so it's possible to implement
		* the shadow mask effect.
		*
		* @type {boolean}
		* @default true
		*/
		this.lights = true;
		/**
		* Overwritten since shadow materials are transparent
		* by default.
		*
		* @type {boolean}
		* @default true
		*/
		this.transparent = true;
		this.setDefaultValues(_defaultValues);
		this.setValues(parameters);
	}
	/**
	* Setups the lighting model.
	*
	* @return {ShadowMaskModel} The lighting model.
	*/
	setupLightingModel() {
		return new ShadowMaskModel();
	}
};
var scatteringDensity = property$1("vec3");
var linearDepthRay = property$1("vec3");
var outgoingRayLight = property$1("vec3");
/**
* This module manages the internal animation loop of the renderer.
*
* @private
*/
var Animation = class {
	/**
	* Constructs a new animation loop management component.
	*
	* @param {Renderer} renderer - A reference to the main renderer.
	* @param {Nodes} nodes - Renderer component for managing nodes related logic.
	* @param {Info} info - Renderer component for managing metrics and monitoring data.
	*/
	constructor(renderer, nodes, info) {
		/**
		* A reference to the main renderer.
		*
		* @type {Renderer}
		*/
		this.renderer = renderer;
		/**
		* Renderer component for managing nodes related logic.
		*
		* @type {Nodes}
		*/
		this.nodes = nodes;
		/**
		* Renderer component for managing metrics and monitoring data.
		*
		* @type {Info}
		*/
		this.info = info;
		/**
		* A reference to the context from `requestAnimationFrame()` can
		* be called (usually `window`).
		*
		* @type {?(Window|XRSession)}
		*/
		this._context = typeof self !== "undefined" ? self : null;
		/**
		* The user-defined animation loop.
		*
		* @type {?Function}
		* @default null
		*/
		this._animationLoop = null;
		/**
		* The requestId which is returned from the `requestAnimationFrame()` call.
		* Can be used to cancel the stop the animation loop.
		*
		* @type {?number}
		* @default null
		*/
		this._requestId = null;
	}
	/**
	* Starts the internal animation loop.
	*/
	start() {
		const update = (time$2, xrFrame) => {
			this._requestId = this._context.requestAnimationFrame(update);
			if (this.info.autoReset === true) this.info.reset();
			this.nodes.nodeFrame.update();
			this.info.frame = this.nodes.nodeFrame.frameId;
			this.renderer._inspector.begin();
			if (this._animationLoop !== null) this._animationLoop(time$2, xrFrame);
			this.renderer._inspector.finish();
		};
		update();
	}
	/**
	* Stops the internal animation loop.
	*/
	stop() {
		this._context.cancelAnimationFrame(this._requestId);
		this._requestId = null;
	}
	/**
	* Returns the user-level animation loop.
	*
	* @return {?Function} The animation loop.
	*/
	getAnimationLoop() {
		return this._animationLoop;
	}
	/**
	* Defines the user-level animation loop.
	*
	* @param {?Function} callback - The animation loop.
	*/
	setAnimationLoop(callback) {
		this._animationLoop = callback;
	}
	/**
	* Returns the animation context.
	*
	* @return {Window|XRSession} The animation context.
	*/
	getContext() {
		return this._context;
	}
	/**
	* Defines the context in which `requestAnimationFrame()` is executed.
	*
	* @param {Window|XRSession} context - The context to set.
	*/
	setContext(context$2) {
		this._context = context$2;
	}
	/**
	* Frees all internal resources and stops the animation loop.
	*/
	dispose() {
		this.stop();
	}
};
/**
* Data structure for the renderer. It allows defining values
* with chained, hierarchical keys. Keys are meant to be
* objects since the module internally works with Weak Maps
* for performance reasons.
*
* @private
*/
var ChainMap = class {
	/**
	* Constructs a new Chain Map.
	*/
	constructor() {
		/**
		* The root Weak Map.
		*
		* @type {WeakMap<Object, WeakMap>}
		*/
		this.weakMap = /* @__PURE__ */ new WeakMap();
	}
	/**
	* Returns the value for the given array of keys.
	*
	* @param {Array<Object>} keys - List of keys.
	* @return {any} The value. Returns `undefined` if no value was found.
	*/
	get(keys) {
		let map = this.weakMap;
		for (let i = 0; i < keys.length - 1; i++) {
			map = map.get(keys[i]);
			if (map === void 0) return void 0;
		}
		return map.get(keys[keys.length - 1]);
	}
	/**
	* Sets the value for the given keys.
	*
	* @param {Array<Object>} keys - List of keys.
	* @param {any} value - The value to set.
	* @return {ChainMap} A reference to this Chain Map.
	*/
	set(keys, value) {
		let map = this.weakMap;
		for (let i = 0; i < keys.length - 1; i++) {
			const key = keys[i];
			if (map.has(key) === false) map.set(key, /* @__PURE__ */ new WeakMap());
			map = map.get(key);
		}
		map.set(keys[keys.length - 1], value);
		return this;
	}
	/**
	* Deletes a value for the given keys.
	*
	* @param {Array<Object>} keys - The keys.
	* @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
	*/
	delete(keys) {
		let map = this.weakMap;
		for (let i = 0; i < keys.length - 1; i++) {
			map = map.get(keys[i]);
			if (map === void 0) return false;
		}
		return map.delete(keys[keys.length - 1]);
	}
};
var _id$a = 0;
function getKeys(obj) {
	const keys = Object.keys(obj);
	let proto$1 = Object.getPrototypeOf(obj);
	while (proto$1) {
		const descriptors = Object.getOwnPropertyDescriptors(proto$1);
		for (const key in descriptors) if (descriptors[key] !== void 0) {
			const descriptor = descriptors[key];
			if (descriptor && typeof descriptor.get === "function") keys.push(key);
		}
		proto$1 = Object.getPrototypeOf(proto$1);
	}
	return keys;
}
/**
* A render object is the renderer's representation of single entity that gets drawn
* with a draw command. There is no unique mapping of render objects to 3D objects in the
* scene since render objects also depend from the used material, the current render context
* and the current scene's lighting.
*
* In general, the basic process of the renderer is:
*
* - Analyze the 3D objects in the scene and generate render lists containing render items.
* - Process the render lists by calling one or more render commands for each render item.
* - For each render command, request a render object and perform the draw.
*
* The module provides an interface to get data required for the draw command like the actual
* draw parameters or vertex buffers. It also holds a series of caching related methods since
* creating render objects should only be done when necessary.
*
* @private
*/
var RenderObject = class {
	/**
	* Constructs a new render object.
	*
	* @param {Nodes} nodes - Renderer component for managing nodes related logic.
	* @param {Geometries} geometries - Renderer component for managing geometries.
	* @param {Renderer} renderer - The renderer.
	* @param {Object3D} object - The 3D object.
	* @param {Material} material - The 3D object's material.
	* @param {Scene} scene - The scene the 3D object belongs to.
	* @param {Camera} camera - The camera the object should be rendered with.
	* @param {LightsNode} lightsNode - The lights node.
	* @param {RenderContext} renderContext - The render context.
	* @param {ClippingContext} clippingContext - The clipping context.
	*/
	constructor(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext) {
		this.id = _id$a++;
		/**
		* Renderer component for managing nodes related logic.
		*
		* @type {Nodes}
		* @private
		*/
		this._nodes = nodes;
		/**
		* Renderer component for managing geometries.
		*
		* @type {Geometries}
		* @private
		*/
		this._geometries = geometries;
		/**
		* The renderer.
		*
		* @type {Renderer}
		*/
		this.renderer = renderer;
		/**
		* The 3D object.
		*
		* @type {Object3D}
		*/
		this.object = object;
		/**
		* The 3D object's material.
		*
		* @type {Material}
		*/
		this.material = material;
		/**
		* The scene the 3D object belongs to.
		*
		* @type {Scene}
		*/
		this.scene = scene;
		/**
		* The camera the 3D object should be rendered with.
		*
		* @type {Camera}
		*/
		this.camera = camera;
		/**
		* The lights node.
		*
		* @type {LightsNode}
		*/
		this.lightsNode = lightsNode;
		/**
		* The render context.
		*
		* @type {RenderContext}
		*/
		this.context = renderContext;
		/**
		* The 3D object's geometry.
		*
		* @type {BufferGeometry}
		*/
		this.geometry = object.geometry;
		/**
		* The render object's version.
		*
		* @type {number}
		*/
		this.version = material.version;
		/**
		* The draw range of the geometry.
		*
		* @type {?Object}
		* @default null
		*/
		this.drawRange = null;
		/**
		* An array holding the buffer attributes
		* of the render object. This entails attribute
		* definitions on geometry and node level.
		*
		* @type {?Array<BufferAttribute>}
		* @default null
		*/
		this.attributes = null;
		/**
		* An object holding the version of the
		* attributes. The keys are the attribute names
		* and the values are the attribute versions.
		*
		* @type {?Object<string, number>}
		* @default null
		*/
		this.attributesId = null;
		/**
		* A reference to a render pipeline the render
		* object is processed with.
		*
		* @type {RenderPipeline}
		* @default null
		*/
		this.pipeline = null;
		/**
		* Only relevant for objects using
		* multiple materials. This represents a group entry
		* from the respective `BufferGeometry`.
		*
		* @type {?{start: number, count: number}}
		* @default null
		*/
		this.group = null;
		/**
		* An array holding the vertex buffers which can
		* be buffer attributes but also interleaved buffers.
		*
		* @type {?Array<BufferAttribute|InterleavedBuffer>}
		* @default null
		*/
		this.vertexBuffers = null;
		/**
		* The parameters for the draw command.
		*
		* @type {?Object}
		* @default null
		*/
		this.drawParams = null;
		/**
		* If this render object is used inside a render bundle,
		* this property points to the respective bundle group.
		*
		* @type {?BundleGroup}
		* @default null
		*/
		this.bundle = null;
		/**
		* The clipping context.
		*
		* @type {ClippingContext}
		*/
		this.clippingContext = clippingContext;
		/**
		* The clipping context's cache key.
		*
		* @type {string}
		*/
		this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : "";
		/**
		* The initial node cache key.
		*
		* @type {number}
		*/
		this.initialNodesCacheKey = this.getDynamicCacheKey();
		/**
		* The initial cache key.
		*
		* @type {number}
		*/
		this.initialCacheKey = this.getCacheKey();
		/**
		* The node builder state.
		*
		* @type {?NodeBuilderState}
		* @private
		* @default null
		*/
		this._nodeBuilderState = null;
		/**
		* An array of bindings.
		*
		* @type {?Array<BindGroup>}
		* @private
		* @default null
		*/
		this._bindings = null;
		/**
		* Reference to the node material observer.
		*
		* @type {?NodeMaterialObserver}
		* @private
		* @default null
		*/
		this._monitor = null;
		/**
		* An event listener which is defined by `RenderObjects`. It performs
		* clean up tasks when `dispose()` on this render object.
		*
		* @method
		*/
		this.onDispose = null;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isRenderObject = true;
		/**
		* An event listener which is executed when `dispose()` is called on
		* the material of this render object.
		*
		* @method
		*/
		this.onMaterialDispose = () => {
			this.dispose();
		};
		/**
		* An event listener which is executed when `dispose()` is called on
		* the geometry of this render object.
		*
		* @method
		*/
		this.onGeometryDispose = () => {
			this.attributes = null;
			this.attributesId = null;
		};
		this.material.addEventListener("dispose", this.onMaterialDispose);
		this.geometry.addEventListener("dispose", this.onGeometryDispose);
	}
	/**
	* Updates the clipping context.
	*
	* @param {ClippingContext} context - The clipping context to set.
	*/
	updateClipping(context$2) {
		this.clippingContext = context$2;
	}
	/**
	* Whether the clipping requires an update or not.
	*
	* @type {boolean}
	* @readonly
	*/
	get clippingNeedsUpdate() {
		if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey) return false;
		this.clippingContextCacheKey = this.clippingContext.cacheKey;
		return true;
	}
	/**
	* The number of clipping planes defined in context of hardware clipping.
	*
	* @type {number}
	* @readonly
	*/
	get hardwareClippingPlanes() {
		return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;
	}
	/**
	* Returns the node builder state of this render object.
	*
	* @return {NodeBuilderState} The node builder state.
	*/
	getNodeBuilderState() {
		return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
	}
	/**
	* Returns the node material observer of this render object.
	*
	* @return {NodeMaterialObserver} The node material observer.
	*/
	getMonitor() {
		return this._monitor || (this._monitor = this.getNodeBuilderState().observer);
	}
	/**
	* Returns an array of bind groups of this render object.
	*
	* @return {Array<BindGroup>} The bindings.
	*/
	getBindings() {
		return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
	}
	/**
	* Returns a binding group by group name of this render object.
	*
	* @param {string} name - The name of the binding group.
	* @return {?BindGroup} The bindings.
	*/
	getBindingGroup(name) {
		for (const bindingGroup of this.getBindings()) if (bindingGroup.name === name) return bindingGroup;
	}
	/**
	* Returns the index of the render object's geometry.
	*
	* @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
	*/
	getIndex() {
		return this._geometries.getIndex(this);
	}
	/**
	* Returns the indirect buffer attribute.
	*
	* @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
	*/
	getIndirect() {
		return this._geometries.getIndirect(this);
	}
	/**
	* Returns an array that acts as a key for identifying the render object in a chain map.
	*
	* @return {Array<Object>} An array with object references.
	*/
	getChainArray() {
		return [
			this.object,
			this.material,
			this.context,
			this.lightsNode
		];
	}
	/**
	* This method is used when the geometry of a 3D object has been exchanged and the
	* respective render object now requires an update.
	*
	* @param {BufferGeometry} geometry - The geometry to set.
	*/
	setGeometry(geometry) {
		this.geometry = geometry;
		this.attributes = null;
		this.attributesId = null;
	}
	/**
	* Returns the buffer attributes of the render object. The returned array holds
	* attribute definitions on geometry and node level.
	*
	* @return {Array<BufferAttribute>} An array with buffer attributes.
	*/
	getAttributes() {
		if (this.attributes !== null) return this.attributes;
		const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
		const geometry = this.geometry;
		const attributes = [];
		const vertexBuffers = /* @__PURE__ */ new Set();
		const attributesId = {};
		for (const nodeAttribute of nodeAttributes) {
			let attribute$2;
			if (nodeAttribute.node && nodeAttribute.node.attribute) attribute$2 = nodeAttribute.node.attribute;
			else {
				attribute$2 = geometry.getAttribute(nodeAttribute.name);
				attributesId[nodeAttribute.name] = attribute$2.version;
			}
			if (attribute$2 === void 0) continue;
			attributes.push(attribute$2);
			const bufferAttribute$2 = attribute$2.isInterleavedBufferAttribute ? attribute$2.data : attribute$2;
			vertexBuffers.add(bufferAttribute$2);
		}
		this.attributes = attributes;
		this.attributesId = attributesId;
		this.vertexBuffers = Array.from(vertexBuffers.values());
		return attributes;
	}
	/**
	* Returns the vertex buffers of the render object.
	*
	* @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.
	*/
	getVertexBuffers() {
		if (this.vertexBuffers === null) this.getAttributes();
		return this.vertexBuffers;
	}
	/**
	* Returns the draw parameters for the render object.
	*
	* @return {?{vertexCount: number, firstVertex: number, instanceCount: number, firstInstance: number}} The draw parameters.
	*/
	getDrawParameters() {
		const { object, material, geometry, group, drawRange } = this;
		const drawParams = this.drawParams || (this.drawParams = {
			vertexCount: 0,
			firstVertex: 0,
			instanceCount: 0,
			firstInstance: 0
		});
		const index = this.getIndex();
		const hasIndex = index !== null;
		let instanceCount = 1;
		if (geometry.isInstancedBufferGeometry === true) instanceCount = geometry.instanceCount;
		else if (object.count !== void 0) instanceCount = Math.max(0, object.count);
		if (instanceCount === 0) return null;
		drawParams.instanceCount = instanceCount;
		if (object.isBatchedMesh === true) return drawParams;
		let rangeFactor = 1;
		if (material.wireframe === true && !object.isPoints && !object.isLineSegments && !object.isLine && !object.isLineLoop) rangeFactor = 2;
		let firstVertex = drawRange.start * rangeFactor;
		let lastVertex = (drawRange.start + drawRange.count) * rangeFactor;
		if (group !== null) {
			firstVertex = Math.max(firstVertex, group.start * rangeFactor);
			lastVertex = Math.min(lastVertex, (group.start + group.count) * rangeFactor);
		}
		const position = geometry.attributes.position;
		let itemCount = Infinity;
		if (hasIndex) itemCount = index.count;
		else if (position !== void 0 && position !== null) itemCount = position.count;
		firstVertex = Math.max(firstVertex, 0);
		lastVertex = Math.min(lastVertex, itemCount);
		const count = lastVertex - firstVertex;
		if (count < 0 || count === Infinity) return null;
		drawParams.vertexCount = count;
		drawParams.firstVertex = firstVertex;
		return drawParams;
	}
	/**
	* Returns the render object's geometry cache key.
	*
	* The geometry cache key is part of the material cache key.
	*
	* @return {string} The geometry cache key.
	*/
	getGeometryCacheKey() {
		const { geometry } = this;
		let cacheKey = "";
		for (const name of Object.keys(geometry.attributes).sort()) {
			const attribute$2 = geometry.attributes[name];
			cacheKey += name + ",";
			if (attribute$2.data) cacheKey += attribute$2.data.stride + ",";
			if (attribute$2.offset) cacheKey += attribute$2.offset + ",";
			if (attribute$2.itemSize) cacheKey += attribute$2.itemSize + ",";
			if (attribute$2.normalized) cacheKey += "n,";
		}
		for (const name of Object.keys(geometry.morphAttributes).sort()) {
			const targets = geometry.morphAttributes[name];
			cacheKey += "morph-" + name + ",";
			for (let i = 0, l = targets.length; i < l; i++) {
				const attribute$2 = targets[i];
				cacheKey += attribute$2.id + ",";
			}
		}
		if (geometry.index) cacheKey += "index,";
		return cacheKey;
	}
	/**
	* Returns the render object's material cache key.
	*
	* The material cache key is part of the render object cache key.
	*
	* @return {number} The material cache key.
	*/
	getMaterialCacheKey() {
		const { object, material, renderer } = this;
		let cacheKey = material.customProgramCacheKey();
		for (const property$2 of getKeys(material)) {
			if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(property$2)) continue;
			const value = material[property$2];
			let valueKey;
			if (value !== null) {
				const type$1 = typeof value;
				if (type$1 === "number") valueKey = value !== 0 ? "1" : "0";
				else if (type$1 === "object") {
					valueKey = "{";
					if (value.isTexture) {
						valueKey += value.mapping;
						if (renderer.backend.isWebGPUBackend === true) {
							valueKey += value.magFilter;
							valueKey += value.minFilter;
							valueKey += value.wrapS;
							valueKey += value.wrapT;
							valueKey += value.wrapR;
						}
					}
					valueKey += "}";
				} else valueKey = String(value);
			} else valueKey = String(value);
			cacheKey += valueKey + ",";
		}
		cacheKey += this.clippingContextCacheKey + ",";
		if (object.geometry) cacheKey += this.getGeometryCacheKey();
		if (object.skeleton) cacheKey += object.skeleton.bones.length + ",";
		if (object.isBatchedMesh) {
			cacheKey += object._matricesTexture.uuid + ",";
			if (object._colorsTexture !== null) cacheKey += object._colorsTexture.uuid + ",";
		}
		if (object.isInstancedMesh || object.count > 1 || Array.isArray(object.morphTargetInfluences)) cacheKey += object.uuid + ",";
		cacheKey += object.receiveShadow + ",";
		return hashString(cacheKey);
	}
	/**
	* Whether the geometry requires an update or not.
	*
	* @type {boolean}
	* @readonly
	*/
	get needsGeometryUpdate() {
		if (this.geometry.id !== this.object.geometry.id) return true;
		if (this.attributes !== null) {
			const attributesId = this.attributesId;
			for (const name in attributesId) {
				const attribute$2 = this.geometry.getAttribute(name);
				if (attribute$2 === void 0 || attributesId[name] !== attribute$2.id) return true;
			}
		}
		return false;
	}
	/**
	* Whether the render object requires an update or not.
	*
	* Note: There are two distinct places where render objects are checked for an update.
	*
	* 1. In `RenderObjects.get()` which is executed when the render object is request. This
	* method checks the `needsUpdate` flag and recreates the render object if necessary.
	* 2. In `Renderer._renderObjectDirect()` right after getting the render object via
	* `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect
	* a need for a refresh due to material, geometry or object related value changes.
	*
	* TODO: Investigate if it's possible to merge both steps so there is only a single place
	* that performs the 'needsUpdate' check.
	*
	* @type {boolean}
	* @readonly
	*/
	get needsUpdate() {
		return this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate;
	}
	/**
	* Returns the dynamic cache key which represents a key that is computed per draw command.
	*
	* @return {number} The cache key.
	*/
	getDynamicCacheKey() {
		let cacheKey = 0;
		if (this.material.isShadowPassMaterial !== true) cacheKey = this._nodes.getCacheKey(this.scene, this.lightsNode);
		if (this.camera.isArrayCamera) cacheKey = hash$1(cacheKey, this.camera.cameras.length);
		if (this.object.receiveShadow) cacheKey = hash$1(cacheKey, 1);
		cacheKey = hash$1(cacheKey, this.camera.id);
		return cacheKey;
	}
	/**
	* Returns the render object's cache key.
	*
	* @return {number} The cache key.
	*/
	getCacheKey() {
		return this.getMaterialCacheKey() + this.getDynamicCacheKey();
	}
	/**
	* Frees internal resources.
	*/
	dispose() {
		this.material.removeEventListener("dispose", this.onMaterialDispose);
		this.geometry.removeEventListener("dispose", this.onGeometryDispose);
		this.onDispose();
	}
};
var _chainKeys$5 = [];
/**
* This module manages the render objects of the renderer.
*
* @private
*/
var RenderObjects = class {
	/**
	* Constructs a new render object management component.
	*
	* @param {Renderer} renderer - The renderer.
	* @param {Nodes} nodes - Renderer component for managing nodes related logic.
	* @param {Geometries} geometries - Renderer component for managing geometries.
	* @param {Pipelines} pipelines - Renderer component for managing pipelines.
	* @param {Bindings} bindings - Renderer component for managing bindings.
	* @param {Info} info - Renderer component for managing metrics and monitoring data.
	*/
	constructor(renderer, nodes, geometries, pipelines, bindings, info) {
		/**
		* The renderer.
		*
		* @type {Renderer}
		*/
		this.renderer = renderer;
		/**
		* Renderer component for managing nodes related logic.
		*
		* @type {Nodes}
		*/
		this.nodes = nodes;
		/**
		* Renderer component for managing geometries.
		*
		* @type {Geometries}
		*/
		this.geometries = geometries;
		/**
		* Renderer component for managing pipelines.
		*
		* @type {Pipelines}
		*/
		this.pipelines = pipelines;
		/**
		* Renderer component for managing bindings.
		*
		* @type {Bindings}
		*/
		this.bindings = bindings;
		/**
		* Renderer component for managing metrics and monitoring data.
		*
		* @type {Info}
		*/
		this.info = info;
		/**
		* A dictionary that manages render contexts in chain maps
		* for each pass ID.
		*
		* @type {Object<string,ChainMap>}
		*/
		this.chainMaps = {};
	}
	/**
	* Returns a render object for the given object and state data.
	*
	* @param {Object3D} object - The 3D object.
	* @param {Material} material - The 3D object's material.
	* @param {Scene} scene - The scene the 3D object belongs to.
	* @param {Camera} camera - The camera the 3D object should be rendered with.
	* @param {LightsNode} lightsNode - The lights node.
	* @param {RenderContext} renderContext - The render context.
	* @param {ClippingContext} clippingContext - The clipping context.
	* @param {string} [passId] - An optional ID for identifying the pass.
	* @return {RenderObject} The render object.
	*/
	get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
		const chainMap = this.getChainMap(passId);
		_chainKeys$5[0] = object;
		_chainKeys$5[1] = material;
		_chainKeys$5[2] = renderContext;
		_chainKeys$5[3] = lightsNode;
		let renderObject = chainMap.get(_chainKeys$5);
		if (renderObject === void 0) {
			renderObject = this.createRenderObject(this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);
			chainMap.set(_chainKeys$5, renderObject);
		} else {
			renderObject.updateClipping(clippingContext);
			if (renderObject.needsGeometryUpdate) renderObject.setGeometry(object.geometry);
			if (renderObject.version !== material.version || renderObject.needsUpdate) if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {
				renderObject.dispose();
				renderObject = this.get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);
			} else renderObject.version = material.version;
		}
		_chainKeys$5.length = 0;
		return renderObject;
	}
	/**
	* Returns a chain map for the given pass ID.
	*
	* @param {string} [passId='default'] - The pass ID.
	* @return {ChainMap} The chain map.
	*/
	getChainMap(passId = "default") {
		return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
	}
	/**
	* Frees internal resources.
	*/
	dispose() {
		this.chainMaps = {};
	}
	/**
	* Factory method for creating render objects with the given list of parameters.
	*
	* @param {Nodes} nodes - Renderer component for managing nodes related logic.
	* @param {Geometries} geometries - Renderer component for managing geometries.
	* @param {Renderer} renderer - The renderer.
	* @param {Object3D} object - The 3D object.
	* @param {Material} material - The object's material.
	* @param {Scene} scene - The scene the 3D object belongs to.
	* @param {Camera} camera - The camera the object should be rendered with.
	* @param {LightsNode} lightsNode - The lights node.
	* @param {RenderContext} renderContext - The render context.
	* @param {ClippingContext} clippingContext - The clipping context.
	* @param {string} [passId] - An optional ID for identifying the pass.
	* @return {RenderObject} The render object.
	*/
	createRenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
		const chainMap = this.getChainMap(passId);
		const renderObject = new RenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext);
		renderObject.onDispose = () => {
			this.pipelines.delete(renderObject);
			this.bindings.deleteForRender(renderObject);
			this.nodes.delete(renderObject);
			chainMap.delete(renderObject.getChainArray());
		};
		return renderObject;
	}
};
/**
* Data structure for the renderer. It is intended to manage
* data of objects in dictionaries.
*
* @private
*/
var DataMap = class {
	/**
	* Constructs a new data map.
	*/
	constructor() {
		/**
		* `DataMap` internally uses a weak map
		* to manage its data.
		*
		* @type {WeakMap<Object, Object>}
		*/
		this.data = /* @__PURE__ */ new WeakMap();
	}
	/**
	* Returns the dictionary for the given object.
	*
	* @param {Object} object - The object.
	* @return {Object} The dictionary.
	*/
	get(object) {
		let map = this.data.get(object);
		if (map === void 0) {
			map = {};
			this.data.set(object, map);
		}
		return map;
	}
	/**
	* Deletes the dictionary for the given object.
	*
	* @param {Object} object - The object.
	* @return {?Object} The deleted dictionary.
	*/
	delete(object) {
		let map = null;
		if (this.data.has(object)) {
			map = this.data.get(object);
			this.data.delete(object);
		}
		return map;
	}
	/**
	* Returns `true` if the given object has a dictionary defined.
	*
	* @param {Object} object - The object to test.
	* @return {boolean} Whether a dictionary is defined or not.
	*/
	has(object) {
		return this.data.has(object);
	}
	/**
	* Frees internal resources.
	*/
	dispose() {
		this.data = /* @__PURE__ */ new WeakMap();
	}
};
var AttributeType = {
	VERTEX: 1,
	INDEX: 2,
	STORAGE: 3,
	INDIRECT: 4
};
var GPU_CHUNK_BYTES = 16;
var BlendColorFactor = 211;
var OneMinusBlendColorFactor = 212;
/**
* This renderer module manages geometry attributes.
*
* @private
* @augments DataMap
*/
var Attributes = class extends DataMap {
	/**
	* Constructs a new attribute management component.
	*
	* @param {Backend} backend - The renderer's backend.
	*/
	constructor(backend) {
		super();
		/**
		* The renderer's backend.
		*
		* @type {Backend}
		*/
		this.backend = backend;
	}
	/**
	* Deletes the data for the given attribute.
	*
	* @param {BufferAttribute} attribute - The attribute.
	* @return {?Object} The deleted attribute data.
	*/
	delete(attribute$2) {
		const attributeData = super.delete(attribute$2);
		if (attributeData !== null) this.backend.destroyAttribute(attribute$2);
		return attributeData;
	}
	/**
	* Updates the given attribute. This method creates attribute buffers
	* for new attributes and updates data for existing ones.
	*
	* @param {BufferAttribute} attribute - The attribute to update.
	* @param {number} type - The attribute type.
	*/
	update(attribute$2, type$1) {
		const data = this.get(attribute$2);
		if (data.version === void 0) {
			if (type$1 === AttributeType.VERTEX) this.backend.createAttribute(attribute$2);
			else if (type$1 === AttributeType.INDEX) this.backend.createIndexAttribute(attribute$2);
			else if (type$1 === AttributeType.STORAGE) this.backend.createStorageAttribute(attribute$2);
			else if (type$1 === AttributeType.INDIRECT) this.backend.createIndirectStorageAttribute(attribute$2);
			data.version = this._getBufferAttribute(attribute$2).version;
		} else {
			const bufferAttribute$2 = this._getBufferAttribute(attribute$2);
			if (data.version < bufferAttribute$2.version || bufferAttribute$2.usage === DynamicDrawUsage) {
				this.backend.updateAttribute(attribute$2);
				data.version = bufferAttribute$2.version;
			}
		}
	}
	/**
	* Utility method for handling interleaved buffer attributes correctly.
	* To process them, their `InterleavedBuffer` is returned.
	*
	* @param {BufferAttribute} attribute - The attribute.
	* @return {BufferAttribute|InterleavedBuffer}
	*/
	_getBufferAttribute(attribute$2) {
		if (attribute$2.isInterleavedBufferAttribute) attribute$2 = attribute$2.data;
		return attribute$2;
	}
};
/**
* Returns the wireframe version for the given geometry.
*
* @private
* @function
* @param {BufferGeometry} geometry - The geometry.
* @return {number} The version.
*/
function getWireframeVersion(geometry) {
	return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
}
/**
* Returns a wireframe index attribute for the given geometry.
*
* @private
* @function
* @param {BufferGeometry} geometry - The geometry.
* @return {BufferAttribute} The wireframe index attribute.
*/
function getWireframeIndex(geometry) {
	const indices = [];
	const geometryIndex = geometry.index;
	const geometryPosition = geometry.attributes.position;
	if (geometryIndex !== null) {
		const array$2 = geometryIndex.array;
		for (let i = 0, l = array$2.length; i < l; i += 3) {
			const a$1 = array$2[i + 0];
			const b$2 = array$2[i + 1];
			const c$1 = array$2[i + 2];
			indices.push(a$1, b$2, b$2, c$1, c$1, a$1);
		}
	} else {
		const array$2 = geometryPosition.array;
		for (let i = 0, l = array$2.length / 3 - 1; i < l; i += 3) {
			const a$1 = i + 0;
			const b$2 = i + 1;
			const c$1 = i + 2;
			indices.push(a$1, b$2, b$2, c$1, c$1, a$1);
		}
	}
	const attribute$2 = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
	attribute$2.version = getWireframeVersion(geometry);
	return attribute$2;
}
/**
* This renderer module manages geometries.
*
* @private
* @augments DataMap
*/
var Geometries = class extends DataMap {
	/**
	* Constructs a new geometry management component.
	*
	* @param {Attributes} attributes - Renderer component for managing attributes.
	* @param {Info} info - Renderer component for managing metrics and monitoring data.
	*/
	constructor(attributes, info) {
		super();
		/**
		* Renderer component for managing attributes.
		*
		* @type {Attributes}
		*/
		this.attributes = attributes;
		/**
		* Renderer component for managing metrics and monitoring data.
		*
		* @type {Info}
		*/
		this.info = info;
		/**
		* Weak Map for managing attributes for wireframe rendering.
		*
		* @type {WeakMap<BufferGeometry,BufferAttribute>}
		*/
		this.wireframes = /* @__PURE__ */ new WeakMap();
		/**
		* This Weak Map is used to make sure buffer attributes are
		* updated only once per render call.
		*
		* @type {WeakMap<BufferAttribute,number>}
		*/
		this.attributeCall = /* @__PURE__ */ new WeakMap();
		/**
		* Stores the event listeners attached to geometries.
		*
		* @private
		* @type {Map<BufferGeometry,Function>}
		*/
		this._geometryDisposeListeners = /* @__PURE__ */ new Map();
	}
	/**
	* Returns `true` if the given render object has an initialized geometry.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {boolean} Whether if the given render object has an initialized geometry or not.
	*/
	has(renderObject) {
		const geometry = renderObject.geometry;
		return super.has(geometry) && this.get(geometry).initialized === true;
	}
	/**
	* Prepares the geometry of the given render object for rendering.
	*
	* @param {RenderObject} renderObject - The render object.
	*/
	updateForRender(renderObject) {
		if (this.has(renderObject) === false) this.initGeometry(renderObject);
		this.updateAttributes(renderObject);
	}
	/**
	* Initializes the geometry of the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	*/
	initGeometry(renderObject) {
		const geometry = renderObject.geometry;
		const geometryData = this.get(geometry);
		geometryData.initialized = true;
		this.info.memory.geometries++;
		const onDispose = () => {
			this.info.memory.geometries--;
			const index = geometry.index;
			const geometryAttributes = renderObject.getAttributes();
			if (index !== null) this.attributes.delete(index);
			for (const geometryAttribute of geometryAttributes) this.attributes.delete(geometryAttribute);
			const wireframeAttribute = this.wireframes.get(geometry);
			if (wireframeAttribute !== void 0) this.attributes.delete(wireframeAttribute);
			geometry.removeEventListener("dispose", onDispose);
			this._geometryDisposeListeners.delete(geometry);
		};
		geometry.addEventListener("dispose", onDispose);
		this._geometryDisposeListeners.set(geometry, onDispose);
	}
	/**
	* Updates the geometry attributes of the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	*/
	updateAttributes(renderObject) {
		const attributes = renderObject.getAttributes();
		for (const attribute$2 of attributes) if (attribute$2.isStorageBufferAttribute || attribute$2.isStorageInstancedBufferAttribute) this.updateAttribute(attribute$2, AttributeType.STORAGE);
		else this.updateAttribute(attribute$2, AttributeType.VERTEX);
		const index = this.getIndex(renderObject);
		if (index !== null) this.updateAttribute(index, AttributeType.INDEX);
		const indirect = renderObject.geometry.indirect;
		if (indirect !== null) this.updateAttribute(indirect, AttributeType.INDIRECT);
	}
	/**
	* Updates the given attribute.
	*
	* @param {BufferAttribute} attribute - The attribute to update.
	* @param {number} type - The attribute type.
	*/
	updateAttribute(attribute$2, type$1) {
		const callId = this.info.render.calls;
		if (!attribute$2.isInterleavedBufferAttribute) {
			if (this.attributeCall.get(attribute$2) !== callId) {
				this.attributes.update(attribute$2, type$1);
				this.attributeCall.set(attribute$2, callId);
			}
		} else if (this.attributeCall.get(attribute$2) === void 0) {
			this.attributes.update(attribute$2, type$1);
			this.attributeCall.set(attribute$2, callId);
		} else if (this.attributeCall.get(attribute$2.data) !== callId) {
			this.attributes.update(attribute$2, type$1);
			this.attributeCall.set(attribute$2.data, callId);
			this.attributeCall.set(attribute$2, callId);
		}
	}
	/**
	* Returns the indirect buffer attribute of the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
	*/
	getIndirect(renderObject) {
		return renderObject.geometry.indirect;
	}
	/**
	* Returns the index of the given render object's geometry. This is implemented
	* in a method to return a wireframe index if necessary.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
	*/
	getIndex(renderObject) {
		const { geometry, material } = renderObject;
		let index = geometry.index;
		if (material.wireframe === true) {
			const wireframes = this.wireframes;
			let wireframeAttribute = wireframes.get(geometry);
			if (wireframeAttribute === void 0) {
				wireframeAttribute = getWireframeIndex(geometry);
				wireframes.set(geometry, wireframeAttribute);
			} else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {
				this.attributes.delete(wireframeAttribute);
				wireframeAttribute = getWireframeIndex(geometry);
				wireframes.set(geometry, wireframeAttribute);
			}
			index = wireframeAttribute;
		}
		return index;
	}
	dispose() {
		for (const [geometry, onDispose] of this._geometryDisposeListeners.entries()) geometry.removeEventListener("dispose", onDispose);
		this._geometryDisposeListeners.clear();
	}
};
/**
* This renderer module provides a series of statistical information
* about the GPU memory and the rendering process. Useful for debugging
* and monitoring.
*/
var Info = class {
	/**
	* Constructs a new info component.
	*/
	constructor() {
		/**
		* Whether frame related metrics should automatically
		* be resetted or not. This property should be set to `false`
		* by apps which manage their own animation loop. They must
		* then call `renderer.info.reset()` once per frame manually.
		*
		* @type {boolean}
		* @default true
		*/
		this.autoReset = true;
		/**
		* The current frame ID. This ID is managed
		* by `NodeFrame`.
		*
		* @type {number}
		* @readonly
		* @default 0
		*/
		this.frame = 0;
		/**
		* The number of render calls since the
		* app has been started.
		*
		* @type {number}
		* @readonly
		* @default 0
		*/
		this.calls = 0;
		/**
		* Render related metrics.
		*
		* @type {Object}
		* @readonly
		* @property {number} calls - The number of render calls since the app has been started.
		* @property {number} frameCalls - The number of render calls of the current frame.
		* @property {number} drawCalls - The number of draw calls of the current frame.
		* @property {number} triangles - The number of rendered triangle primitives of the current frame.
		* @property {number} points - The number of rendered point primitives of the current frame.
		* @property {number} lines - The number of rendered line primitives of the current frame.
		* @property {number} timestamp - The timestamp of the frame.
		*/
		this.render = {
			calls: 0,
			frameCalls: 0,
			drawCalls: 0,
			triangles: 0,
			points: 0,
			lines: 0,
			timestamp: 0
		};
		/**
		* Compute related metrics.
		*
		* @type {Object}
		* @readonly
		* @property {number} calls - The number of compute calls since the app has been started.
		* @property {number} frameCalls - The number of compute calls of the current frame.
		* @property {number} timestamp - The timestamp of the frame when using `renderer.computeAsync()`.
		*/
		this.compute = {
			calls: 0,
			frameCalls: 0,
			timestamp: 0
		};
		/**
		* Memory related metrics.
		*
		* @type {Object}
		* @readonly
		* @property {number} geometries - The number of active geometries.
		* @property {number} frameCalls - The number of active textures.
		*/
		this.memory = {
			geometries: 0,
			textures: 0
		};
	}
	/**
	* This method should be executed per draw call and updates the corresponding metrics.
	*
	* @param {Object3D} object - The 3D object that is going to be rendered.
	* @param {number} count - The vertex or index count.
	* @param {number} instanceCount - The instance count.
	*/
	update(object, count, instanceCount) {
		this.render.drawCalls++;
		if (object.isMesh || object.isSprite) this.render.triangles += instanceCount * (count / 3);
		else if (object.isPoints) this.render.points += instanceCount * count;
		else if (object.isLineSegments) this.render.lines += instanceCount * (count / 2);
		else if (object.isLine) this.render.lines += instanceCount * (count - 1);
		else error("WebGPUInfo: Unknown object type.");
	}
	/**
	* Resets frame related metrics.
	*/
	reset() {
		this.render.drawCalls = 0;
		this.render.frameCalls = 0;
		this.compute.frameCalls = 0;
		this.render.triangles = 0;
		this.render.points = 0;
		this.render.lines = 0;
	}
	/**
	* Performs a complete reset of the object.
	*/
	dispose() {
		this.reset();
		this.calls = 0;
		this.render.calls = 0;
		this.compute.calls = 0;
		this.render.timestamp = 0;
		this.compute.timestamp = 0;
		this.memory.geometries = 0;
		this.memory.textures = 0;
	}
};
/**
* Abstract class for representing pipelines.
*
* @private
* @abstract
*/
var Pipeline = class {
	/**
	* Constructs a new pipeline.
	*
	* @param {string} cacheKey - The pipeline's cache key.
	*/
	constructor(cacheKey) {
		/**
		* The pipeline's cache key.
		*
		* @type {string}
		*/
		this.cacheKey = cacheKey;
		/**
		* How often the pipeline is currently in use.
		*
		* @type {number}
		* @default 0
		*/
		this.usedTimes = 0;
	}
};
/**
* Class for representing render pipelines.
*
* @private
* @augments Pipeline
*/
var RenderPipeline = class extends Pipeline {
	/**
	* Constructs a new render pipeline.
	*
	* @param {string} cacheKey - The pipeline's cache key.
	* @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
	* @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
	*/
	constructor(cacheKey, vertexProgram, fragmentProgram) {
		super(cacheKey);
		/**
		* The pipeline's vertex shader.
		*
		* @type {ProgrammableStage}
		*/
		this.vertexProgram = vertexProgram;
		/**
		* The pipeline's fragment shader.
		*
		* @type {ProgrammableStage}
		*/
		this.fragmentProgram = fragmentProgram;
	}
};
/**
* Class for representing compute pipelines.
*
* @private
* @augments Pipeline
*/
var ComputePipeline = class extends Pipeline {
	/**
	* Constructs a new render pipeline.
	*
	* @param {string} cacheKey - The pipeline's cache key.
	* @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
	*/
	constructor(cacheKey, computeProgram) {
		super(cacheKey);
		/**
		* The pipeline's compute shader.
		*
		* @type {ProgrammableStage}
		*/
		this.computeProgram = computeProgram;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isComputePipeline = true;
	}
};
var _id$9 = 0;
/**
* Class for representing programmable stages which are vertex,
* fragment or compute shaders. Unlike fixed-function states (like blending),
* they represent the programmable part of a pipeline.
*
* @private
*/
var ProgrammableStage = class {
	/**
	* Constructs a new programmable stage.
	*
	* @param {string} code - The shader code.
	* @param {('vertex'|'fragment'|'compute')} stage - The type of stage.
	* @param {string} name - The name of the shader.
	* @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
	* @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
	*/
	constructor(code$2, stage, name, transforms = null, attributes = null) {
		/**
		* The id of the programmable stage.
		*
		* @type {number}
		*/
		this.id = _id$9++;
		/**
		* The shader code.
		*
		* @type {string}
		*/
		this.code = code$2;
		/**
		* The type of stage.
		*
		* @type {string}
		*/
		this.stage = stage;
		/**
		* The name of the stage.
		* This is used for debugging purposes.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
		*
		* @type {?Array<Object>}
		*/
		this.transforms = transforms;
		/**
		* The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
		*
		* @type {?Array<Object>}
		*/
		this.attributes = attributes;
		/**
		* How often the programmable stage is currently in use.
		*
		* @type {number}
		* @default 0
		*/
		this.usedTimes = 0;
	}
};
/**
* This renderer module manages the pipelines of the renderer.
*
* @private
* @augments DataMap
*/
var Pipelines = class extends DataMap {
	/**
	* Constructs a new pipeline management component.
	*
	* @param {Backend} backend - The renderer's backend.
	* @param {Nodes} nodes - Renderer component for managing nodes related logic.
	*/
	constructor(backend, nodes) {
		super();
		/**
		* The renderer's backend.
		*
		* @type {Backend}
		*/
		this.backend = backend;
		/**
		* Renderer component for managing nodes related logic.
		*
		* @type {Nodes}
		*/
		this.nodes = nodes;
		/**
		* A references to the bindings management component.
		* This reference will be set inside the `Bindings`
		* constructor.
		*
		* @type {?Bindings}
		* @default null
		*/
		this.bindings = null;
		/**
		* Internal cache for maintaining pipelines.
		* The key of the map is a cache key, the value the pipeline.
		*
		* @type {Map<string,Pipeline>}
		*/
		this.caches = /* @__PURE__ */ new Map();
		/**
		* This dictionary maintains for each shader stage type (vertex,
		* fragment and compute) the programmable stage objects which
		* represent the actual shader code.
		*
		* @type {Object<string,Map<string, ProgrammableStage>>}
		*/
		this.programs = {
			vertex: /* @__PURE__ */ new Map(),
			fragment: /* @__PURE__ */ new Map(),
			compute: /* @__PURE__ */ new Map()
		};
	}
	/**
	* Returns a compute pipeline for the given compute node.
	*
	* @param {Node} computeNode - The compute node.
	* @param {Array<BindGroup>} bindings - The bindings.
	* @return {ComputePipeline} The compute pipeline.
	*/
	getForCompute(computeNode, bindings) {
		const { backend } = this;
		const data = this.get(computeNode);
		if (this._needsComputeUpdate(computeNode)) {
			const previousPipeline = data.pipeline;
			if (previousPipeline) {
				previousPipeline.usedTimes--;
				previousPipeline.computeProgram.usedTimes--;
			}
			const nodeBuilderState = this.nodes.getForCompute(computeNode);
			let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
			if (stageCompute === void 0) {
				if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0) this._releaseProgram(previousPipeline.computeProgram);
				stageCompute = new ProgrammableStage(nodeBuilderState.computeShader, "compute", computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes);
				this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
				backend.createProgram(stageCompute);
			}
			const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
			let pipeline = this.caches.get(cacheKey);
			if (pipeline === void 0) {
				if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
				pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);
			}
			pipeline.usedTimes++;
			stageCompute.usedTimes++;
			data.version = computeNode.version;
			data.pipeline = pipeline;
		}
		return data.pipeline;
	}
	/**
	* Returns a render pipeline for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	* @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
	* @return {RenderPipeline} The render pipeline.
	*/
	getForRender(renderObject, promises = null) {
		const { backend } = this;
		const data = this.get(renderObject);
		if (this._needsRenderUpdate(renderObject)) {
			const previousPipeline = data.pipeline;
			if (previousPipeline) {
				previousPipeline.usedTimes--;
				previousPipeline.vertexProgram.usedTimes--;
				previousPipeline.fragmentProgram.usedTimes--;
			}
			const nodeBuilderState = renderObject.getNodeBuilderState();
			const name = renderObject.material ? renderObject.material.name : "";
			let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
			if (stageVertex === void 0) {
				if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0) this._releaseProgram(previousPipeline.vertexProgram);
				stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, "vertex", name);
				this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
				backend.createProgram(stageVertex);
			}
			let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
			if (stageFragment === void 0) {
				if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(previousPipeline.fragmentProgram);
				stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, "fragment", name);
				this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
				backend.createProgram(stageFragment);
			}
			const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
			let pipeline = this.caches.get(cacheKey);
			if (pipeline === void 0) {
				if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
				pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises);
			} else renderObject.pipeline = pipeline;
			pipeline.usedTimes++;
			stageVertex.usedTimes++;
			stageFragment.usedTimes++;
			data.pipeline = pipeline;
		}
		return data.pipeline;
	}
	/**
	* Deletes the pipeline for the given render object.
	*
	* @param {RenderObject} object - The render object.
	* @return {?Object} The deleted dictionary.
	*/
	delete(object) {
		const pipeline = this.get(object).pipeline;
		if (pipeline) {
			pipeline.usedTimes--;
			if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);
			if (pipeline.isComputePipeline) {
				pipeline.computeProgram.usedTimes--;
				if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
			} else {
				pipeline.fragmentProgram.usedTimes--;
				pipeline.vertexProgram.usedTimes--;
				if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
				if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
			}
		}
		return super.delete(object);
	}
	/**
	* Frees internal resources.
	*/
	dispose() {
		super.dispose();
		this.caches = /* @__PURE__ */ new Map();
		this.programs = {
			vertex: /* @__PURE__ */ new Map(),
			fragment: /* @__PURE__ */ new Map(),
			compute: /* @__PURE__ */ new Map()
		};
	}
	/**
	* Updates the pipeline for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	*/
	updateForRender(renderObject) {
		this.getForRender(renderObject);
	}
	/**
	* Returns a compute pipeline for the given parameters.
	*
	* @private
	* @param {Node} computeNode - The compute node.
	* @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
	* @param {string} cacheKey - The cache key.
	* @param {Array<BindGroup>} bindings - The bindings.
	* @return {ComputePipeline} The compute pipeline.
	*/
	_getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
		cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
		let pipeline = this.caches.get(cacheKey);
		if (pipeline === void 0) {
			pipeline = new ComputePipeline(cacheKey, stageCompute);
			this.caches.set(cacheKey, pipeline);
			this.backend.createComputePipeline(pipeline, bindings);
		}
		return pipeline;
	}
	/**
	* Returns a render pipeline for the given parameters.
	*
	* @private
	* @param {RenderObject} renderObject - The render object.
	* @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
	* @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
	* @param {string} cacheKey - The cache key.
	* @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
	* @return {ComputePipeline} The compute pipeline.
	*/
	_getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
		cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
		let pipeline = this.caches.get(cacheKey);
		if (pipeline === void 0) {
			pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);
			this.caches.set(cacheKey, pipeline);
			renderObject.pipeline = pipeline;
			this.backend.createRenderPipeline(renderObject, promises);
		}
		return pipeline;
	}
	/**
	* Computes a cache key representing a compute pipeline.
	*
	* @private
	* @param {Node} computeNode - The compute node.
	* @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
	* @return {string} The cache key.
	*/
	_getComputeCacheKey(computeNode, stageCompute) {
		return computeNode.id + "," + stageCompute.id;
	}
	/**
	* Computes a cache key representing a render pipeline.
	*
	* @private
	* @param {RenderObject} renderObject - The render object.
	* @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
	* @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
	* @return {string} The cache key.
	*/
	_getRenderCacheKey(renderObject, stageVertex, stageFragment) {
		return stageVertex.id + "," + stageFragment.id + "," + this.backend.getRenderCacheKey(renderObject);
	}
	/**
	* Releases the given pipeline.
	*
	* @private
	* @param {Pipeline} pipeline - The pipeline to release.
	*/
	_releasePipeline(pipeline) {
		this.caches.delete(pipeline.cacheKey);
	}
	/**
	* Releases the shader program.
	*
	* @private
	* @param {Object} program - The shader program to release.
	*/
	_releaseProgram(program) {
		const code$2 = program.code;
		const stage = program.stage;
		this.programs[stage].delete(code$2);
	}
	/**
	* Returns `true` if the compute pipeline for the given compute node requires an update.
	*
	* @private
	* @param {Node} computeNode - The compute node.
	* @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.
	*/
	_needsComputeUpdate(computeNode) {
		const data = this.get(computeNode);
		return data.pipeline === void 0 || data.version !== computeNode.version;
	}
	/**
	* Returns `true` if the render pipeline for the given render object requires an update.
	*
	* @private
	* @param {RenderObject} renderObject - The render object.
	* @return {boolean} Whether the render object for the given render object requires an update or not.
	*/
	_needsRenderUpdate(renderObject) {
		return this.get(renderObject).pipeline === void 0 || this.backend.needsRenderUpdate(renderObject);
	}
};
/**
* This renderer module manages the bindings of the renderer.
*
* @private
* @augments DataMap
*/
var Bindings = class extends DataMap {
	/**
	* Constructs a new bindings management component.
	*
	* @param {Backend} backend - The renderer's backend.
	* @param {Nodes} nodes - Renderer component for managing nodes related logic.
	* @param {Textures} textures - Renderer component for managing textures.
	* @param {Attributes} attributes - Renderer component for managing attributes.
	* @param {Pipelines} pipelines - Renderer component for managing pipelines.
	* @param {Info} info - Renderer component for managing metrics and monitoring data.
	*/
	constructor(backend, nodes, textures, attributes, pipelines, info) {
		super();
		/**
		* The renderer's backend.
		*
		* @type {Backend}
		*/
		this.backend = backend;
		/**
		* Renderer component for managing textures.
		*
		* @type {Textures}
		*/
		this.textures = textures;
		/**
		* Renderer component for managing pipelines.
		*
		* @type {Pipelines}
		*/
		this.pipelines = pipelines;
		/**
		* Renderer component for managing attributes.
		*
		* @type {Attributes}
		*/
		this.attributes = attributes;
		/**
		* Renderer component for managing nodes related logic.
		*
		* @type {Nodes}
		*/
		this.nodes = nodes;
		/**
		* Renderer component for managing metrics and monitoring data.
		*
		* @type {Info}
		*/
		this.info = info;
		this.pipelines.bindings = this;
	}
	/**
	* Returns the bind groups for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {Array<BindGroup>} The bind groups.
	*/
	getForRender(renderObject) {
		const bindings = renderObject.getBindings();
		for (const bindGroup of bindings) {
			const groupData = this.get(bindGroup);
			if (groupData.bindGroup === void 0) {
				this._init(bindGroup);
				this.backend.createBindings(bindGroup, bindings, 0);
				groupData.bindGroup = bindGroup;
			}
		}
		return bindings;
	}
	/**
	* Returns the bind groups for the given compute node.
	*
	* @param {Node} computeNode - The compute node.
	* @return {Array<BindGroup>} The bind groups.
	*/
	getForCompute(computeNode) {
		const bindings = this.nodes.getForCompute(computeNode).bindings;
		for (const bindGroup of bindings) {
			const groupData = this.get(bindGroup);
			if (groupData.bindGroup === void 0) {
				this._init(bindGroup);
				this.backend.createBindings(bindGroup, bindings, 0);
				groupData.bindGroup = bindGroup;
			}
		}
		return bindings;
	}
	/**
	* Updates the bindings for the given compute node.
	*
	* @param {Node} computeNode - The compute node.
	*/
	updateForCompute(computeNode) {
		this._updateBindings(this.getForCompute(computeNode));
	}
	/**
	* Updates the bindings for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	*/
	updateForRender(renderObject) {
		this._updateBindings(this.getForRender(renderObject));
	}
	/**
	* Deletes the bindings for the given compute node.
	*
	* @param {Node} computeNode - The compute node.
	*/
	deleteForCompute(computeNode) {
		const bindings = this.nodes.getForCompute(computeNode).bindings;
		for (const bindGroup of bindings) this.delete(bindGroup);
	}
	/**
	* Deletes the bindings for the given renderObject node.
	*
	* @param {RenderObject} renderObject - The renderObject.
	*/
	deleteForRender(renderObject) {
		const bindings = renderObject.getBindings();
		for (const bindGroup of bindings) this.delete(bindGroup);
	}
	/**
	* Updates the given array of bindings.
	*
	* @param {Array<BindGroup>} bindings - The bind groups.
	*/
	_updateBindings(bindings) {
		for (const bindGroup of bindings) this._update(bindGroup, bindings);
	}
	/**
	* Initializes the given bind group.
	*
	* @param {BindGroup} bindGroup - The bind group to initialize.
	*/
	_init(bindGroup) {
		for (const binding of bindGroup.bindings) if (binding.isSampledTexture) this.textures.updateTexture(binding.texture);
		else if (binding.isSampler) this.textures.updateSampler(binding.texture);
		else if (binding.isStorageBuffer) {
			const attribute$2 = binding.attribute;
			const attributeType = attribute$2.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;
			this.attributes.update(attribute$2, attributeType);
		}
	}
	/**
	* Updates the given bind group.
	*
	* @param {BindGroup} bindGroup - The bind group to update.
	* @param {Array<BindGroup>} bindings - The bind groups.
	*/
	_update(bindGroup, bindings) {
		const { backend } = this;
		let needsBindingsUpdate = false;
		let cacheBindings = true;
		let cacheIndex = 0;
		let version = 0;
		for (const binding of bindGroup.bindings) {
			if (binding.isNodeUniformsGroup) {
				if (this.nodes.updateGroup(binding) === false) continue;
			}
			if (binding.isStorageBuffer) {
				const attribute$2 = binding.attribute;
				const attributeType = attribute$2.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;
				this.attributes.update(attribute$2, attributeType);
			}
			if (binding.isUniformBuffer) {
				if (binding.update()) backend.updateBinding(binding);
			} else if (binding.isSampledTexture) {
				const updated = binding.update();
				const texture$2 = binding.texture;
				const texturesTextureData = this.textures.get(texture$2);
				if (updated) {
					this.textures.updateTexture(texture$2);
					if (binding.generation !== texturesTextureData.generation) {
						binding.generation = texturesTextureData.generation;
						needsBindingsUpdate = true;
						cacheBindings = false;
					}
				}
				if (backend.get(texture$2).externalTexture !== void 0 || texturesTextureData.isDefaultTexture) cacheBindings = false;
				else {
					cacheIndex = cacheIndex * 10 + texture$2.id;
					version += texture$2.version;
				}
				if (texture$2.isStorageTexture === true && texture$2.mipmapsAutoUpdate === true) {
					const textureData = this.get(texture$2);
					if (binding.store === true) textureData.needsMipmap = true;
					else if (this.textures.needsMipmaps(texture$2) && textureData.needsMipmap === true) {
						this.backend.generateMipmaps(texture$2);
						textureData.needsMipmap = false;
					}
				}
			} else if (binding.isSampler) {
				if (binding.update()) {
					const samplerKey = this.textures.updateSampler(binding.texture);
					if (binding.samplerKey !== samplerKey) {
						binding.samplerKey = samplerKey;
						needsBindingsUpdate = true;
						cacheBindings = false;
					}
				}
			}
		}
		if (needsBindingsUpdate === true) this.backend.updateBindings(bindGroup, bindings, cacheBindings ? cacheIndex : 0, version);
	}
};
/**
* Default sorting function for opaque render items.
*
* @private
* @function
* @param {Object} a - The first render item.
* @param {Object} b - The second render item.
* @return {number} A numeric value which defines the sort order.
*/
function painterSortStable$1(a$1, b$2) {
	if (a$1.groupOrder !== b$2.groupOrder) return a$1.groupOrder - b$2.groupOrder;
	else if (a$1.renderOrder !== b$2.renderOrder) return a$1.renderOrder - b$2.renderOrder;
	else if (a$1.z !== b$2.z) return a$1.z - b$2.z;
	else return a$1.id - b$2.id;
}
/**
* Default sorting function for transparent render items.
*
* @private
* @function
* @param {Object} a - The first render item.
* @param {Object} b - The second render item.
* @return {number} A numeric value which defines the sort order.
*/
function reversePainterSortStable$1(a$1, b$2) {
	if (a$1.groupOrder !== b$2.groupOrder) return a$1.groupOrder - b$2.groupOrder;
	else if (a$1.renderOrder !== b$2.renderOrder) return a$1.renderOrder - b$2.renderOrder;
	else if (a$1.z !== b$2.z) return b$2.z - a$1.z;
	else return a$1.id - b$2.id;
}
/**
* Returns `true` if the given transparent material requires a double pass.
*
* @private
* @function
* @param {Material} material - The transparent material.
* @return {boolean} Whether the given material requires a double pass or not.
*/
function needsDoublePass(material) {
	return (material.transmission > 0 || material.transmissionNode && material.transmissionNode.isNode) && material.side === DoubleSide && material.forceSinglePass === false;
}
/**
* When the renderer analyzes the scene at the beginning of a render call,
* it stores 3D object for further processing in render lists. Depending on the
* properties of a 3D objects (like their transformation or material state), the
* objects are maintained in ordered lists for the actual rendering.
*
* Render lists are unique per scene and camera combination.
*
* @private
* @augments Pipeline
*/
var RenderList = class {
	/**
	* Constructs a render list.
	*
	* @param {Lighting} lighting - The lighting management component.
	* @param {Scene} scene - The scene.
	* @param {Camera} camera - The camera the scene is rendered with.
	*/
	constructor(lighting, scene, camera) {
		/**
		* 3D objects are transformed into render items and stored in this array.
		*
		* @type {Array<Object>}
		*/
		this.renderItems = [];
		/**
		* The current render items index.
		*
		* @type {number}
		* @default 0
		*/
		this.renderItemsIndex = 0;
		/**
		* A list with opaque render items.
		*
		* @type {Array<Object>}
		*/
		this.opaque = [];
		/**
		* A list with transparent render items which require
		* double pass rendering (e.g. transmissive objects).
		*
		* @type {Array<Object>}
		*/
		this.transparentDoublePass = [];
		/**
		* A list with transparent render items.
		*
		* @type {Array<Object>}
		*/
		this.transparent = [];
		/**
		* A list with transparent render bundle data.
		*
		* @type {Array<Object>}
		*/
		this.bundles = [];
		/**
		* The render list's lights node. This node is later
		* relevant for the actual analytical light nodes which
		* compute the scene's lighting in the shader.
		*
		* @type {LightsNode}
		*/
		this.lightsNode = lighting.getNode(scene, camera);
		/**
		* The scene's lights stored in an array. This array
		* is used to setup the lights node.
		*
		* @type {Array<Light>}
		*/
		this.lightsArray = [];
		/**
		* The scene.
		*
		* @type {Scene}
		*/
		this.scene = scene;
		/**
		* The camera the scene is rendered with.
		*
		* @type {Camera}
		*/
		this.camera = camera;
		/**
		* How many objects perform occlusion query tests.
		*
		* @type {number}
		* @default 0
		*/
		this.occlusionQueryCount = 0;
	}
	/**
	* This method is called right at the beginning of a render call
	* before the scene is analyzed. It prepares the internal data
	* structures for the upcoming render lists generation.
	*
	* @return {RenderList} A reference to this render list.
	*/
	begin() {
		this.renderItemsIndex = 0;
		this.opaque.length = 0;
		this.transparentDoublePass.length = 0;
		this.transparent.length = 0;
		this.bundles.length = 0;
		this.lightsArray.length = 0;
		this.occlusionQueryCount = 0;
		return this;
	}
	/**
	* Returns a render item for the giving render item state. The state is defined
	* by a series of object-related parameters.
	*
	* The method avoids object creation by holding render items and reusing them in
	* subsequent render calls (just with different property values).
	*
	* @param {Object3D} object - The 3D object.
	* @param {BufferGeometry} geometry - The 3D object's geometry.
	* @param {Material} material - The 3D object's material.
	* @param {number} groupOrder - The current group order.
	* @param {number} z - Th 3D object's depth value (z value in clip space).
	* @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
	* @param {ClippingContext} clippingContext - The current clipping context.
	* @return {Object} The render item.
	*/
	getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext) {
		let renderItem = this.renderItems[this.renderItemsIndex];
		if (renderItem === void 0) {
			renderItem = {
				id: object.id,
				object,
				geometry,
				material,
				groupOrder,
				renderOrder: object.renderOrder,
				z,
				group,
				clippingContext
			};
			this.renderItems[this.renderItemsIndex] = renderItem;
		} else {
			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;
			renderItem.clippingContext = clippingContext;
		}
		this.renderItemsIndex++;
		return renderItem;
	}
	/**
	* Pushes the given object as a render item to the internal render lists.
	* The selected lists depend on the object properties.
	*
	* @param {Object3D} object - The 3D object.
	* @param {BufferGeometry} geometry - The 3D object's geometry.
	* @param {Material} material - The 3D object's material.
	* @param {number} groupOrder - The current group order.
	* @param {number} z - Th 3D object's depth value (z value in clip space).
	* @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
	* @param {ClippingContext} clippingContext - The current clipping context.
	*/
	push(object, geometry, material, groupOrder, z, group, clippingContext) {
		const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
		if (object.occlusionTest === true) this.occlusionQueryCount++;
		if (material.transparent === true || material.transmission > 0 || material.transmissionNode && material.transmissionNode.isNode || material.backdropNode && material.backdropNode.isNode) {
			if (needsDoublePass(material)) this.transparentDoublePass.push(renderItem);
			this.transparent.push(renderItem);
		} else this.opaque.push(renderItem);
	}
	/**
	* Inserts the given object as a render item at the start of the internal render lists.
	* The selected lists depend on the object properties.
	*
	* @param {Object3D} object - The 3D object.
	* @param {BufferGeometry} geometry - The 3D object's geometry.
	* @param {Material} material - The 3D object's material.
	* @param {number} groupOrder - The current group order.
	* @param {number} z - Th 3D object's depth value (z value in clip space).
	* @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
	* @param {ClippingContext} clippingContext - The current clipping context.
	*/
	unshift(object, geometry, material, groupOrder, z, group, clippingContext) {
		const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
		if (material.transparent === true || material.transmission > 0 || material.transmissionNode && material.transmissionNode.isNode || material.backdropNode && material.backdropNode.isNode) {
			if (needsDoublePass(material)) this.transparentDoublePass.unshift(renderItem);
			this.transparent.unshift(renderItem);
		} else this.opaque.unshift(renderItem);
	}
	/**
	* Pushes render bundle group data into the render list.
	*
	* @param {Object} group - Bundle group data.
	*/
	pushBundle(group) {
		this.bundles.push(group);
	}
	/**
	* Pushes a light into the render list.
	*
	* @param {Light} light - The light.
	*/
	pushLight(light) {
		this.lightsArray.push(light);
	}
	/**
	* Sorts the internal render lists.
	*
	* @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.
	* @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.
	*/
	sort(customOpaqueSort, customTransparentSort) {
		if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable$1);
		if (this.transparentDoublePass.length > 1) this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable$1);
		if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable$1);
	}
	/**
	* This method performs finalizing tasks right after the render lists
	* have been generated.
	*/
	finish() {
		this.lightsNode.setLights(this.lightsArray);
		for (let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) {
			const renderItem = this.renderItems[i];
			if (renderItem.id === null) break;
			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.groupOrder = null;
			renderItem.renderOrder = null;
			renderItem.z = null;
			renderItem.group = null;
			renderItem.clippingContext = null;
		}
	}
};
var _chainKeys$4 = [];
/**
* This renderer module manages the render lists which are unique
* per scene and camera combination.
*
* @private
*/
var RenderLists = class {
	/**
	* Constructs a render lists management component.
	*
	* @param {Lighting} lighting - The lighting management component.
	*/
	constructor(lighting) {
		/**
		* The lighting management component.
		*
		* @type {Lighting}
		*/
		this.lighting = lighting;
		/**
		* The internal chain map which holds the render lists.
		*
		* @type {ChainMap}
		*/
		this.lists = new ChainMap();
	}
	/**
	* Returns a render list for the given scene and camera.
	*
	* @param {Scene} scene - The scene.
	* @param {Camera} camera - The camera.
	* @return {RenderList} The render list.
	*/
	get(scene, camera) {
		const lists = this.lists;
		_chainKeys$4[0] = scene;
		_chainKeys$4[1] = camera;
		let list = lists.get(_chainKeys$4);
		if (list === void 0) {
			list = new RenderList(this.lighting, scene, camera);
			lists.set(_chainKeys$4, list);
		}
		_chainKeys$4.length = 0;
		return list;
	}
	/**
	* Frees all internal resources.
	*/
	dispose() {
		this.lists = new ChainMap();
	}
};
var _id$8 = 0;
/**
* Any render or compute command is executed in a specific context that defines
* the state of the renderer and its backend. Typical examples for such context
* data are the current clear values or data from the active framebuffer. This
* module is used to represent these contexts as objects.
*
* @private
*/
var RenderContext = class {
	/**
	* Constructs a new render context.
	*/
	constructor() {
		/**
		* The context's ID.
		*
		* @type {number}
		*/
		this.id = _id$8++;
		/**
		* Whether the current active framebuffer has a color attachment.
		*
		* @type {boolean}
		* @default true
		*/
		this.color = true;
		/**
		* Whether the color attachment should be cleared or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.clearColor = true;
		/**
		* The clear color value.
		*
		* @type {Object}
		* @default true
		*/
		this.clearColorValue = {
			r: 0,
			g: 0,
			b: 0,
			a: 1
		};
		/**
		* Whether the current active framebuffer has a depth attachment.
		*
		* @type {boolean}
		* @default true
		*/
		this.depth = true;
		/**
		* Whether the depth attachment should be cleared or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.clearDepth = true;
		/**
		* The clear depth value.
		*
		* @type {number}
		* @default 1
		*/
		this.clearDepthValue = 1;
		/**
		* Whether the current active framebuffer has a stencil attachment.
		*
		* @type {boolean}
		* @default false
		*/
		this.stencil = false;
		/**
		* Whether the stencil attachment should be cleared or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.clearStencil = true;
		/**
		* The clear stencil value.
		*
		* @type {number}
		* @default 1
		*/
		this.clearStencilValue = 1;
		/**
		* By default the viewport encloses the entire framebuffer If a smaller
		* viewport is manually defined, this property is to `true` by the renderer.
		*
		* @type {boolean}
		* @default false
		*/
		this.viewport = false;
		/**
		* The viewport value. This value is in physical pixels meaning it incorporates
		* the renderer's pixel ratio. The viewport property of render targets or
		* the renderer is in logical pixels.
		*
		* @type {Vector4}
		*/
		this.viewportValue = new Vector4();
		/**
		* When the scissor test is active and scissor rectangle smaller than the
		* framebuffers dimensions, this property is to `true` by the renderer.
		*
		* @type {boolean}
		* @default false
		*/
		this.scissor = false;
		/**
		* The scissor rectangle.
		*
		* @type {Vector4}
		*/
		this.scissorValue = new Vector4();
		/**
		* The active render target.
		*
		* @type {?RenderTarget}
		* @default null
		*/
		this.renderTarget = null;
		/**
		* The textures of the active render target.
		* `null` when no render target is set.
		*
		* @type {?Array<Texture>}
		* @default null
		*/
		this.textures = null;
		/**
		* The depth texture of the active render target.
		* `null` when no render target is set.
		*
		* @type {?DepthTexture}
		* @default null
		*/
		this.depthTexture = null;
		/**
		* The active cube face.
		*
		* @type {number}
		* @default 0
		*/
		this.activeCubeFace = 0;
		/**
		* The active mipmap level.
		*
		* @type {number}
		* @default 0
		*/
		this.activeMipmapLevel = 0;
		/**
		* The number of MSAA samples. This value is always `1` when
		* MSAA isn't used.
		*
		* @type {number}
		* @default 1
		*/
		this.sampleCount = 1;
		/**
		* The active render target's width in physical pixels.
		*
		* @type {number}
		* @default 0
		*/
		this.width = 0;
		/**
		* The active render target's height in physical pixels.
		*
		* @type {number}
		* @default 0
		*/
		this.height = 0;
		/**
		* The occlusion query count.
		*
		* @type {number}
		* @default 0
		*/
		this.occlusionQueryCount = 0;
		/**
		* The current clipping context.
		*
		* @type {?ClippingContext}
		* @default null
		*/
		this.clippingContext = null;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isRenderContext = true;
	}
	/**
	* Returns the cache key of this render context.
	*
	* @return {number} The cache key.
	*/
	getCacheKey() {
		return getCacheKey(this);
	}
};
/**
* Computes a cache key for the given render context. This key
* should identify the render target state so it is possible to
* configure the correct attachments in the respective backend.
*
* @param {RenderContext} renderContext - The render context.
* @return {number} The cache key.
*/
function getCacheKey(renderContext) {
	const { textures, activeCubeFace, activeMipmapLevel } = renderContext;
	const values = [activeCubeFace, activeMipmapLevel];
	for (const texture$2 of textures) values.push(texture$2.id);
	return hashArray(values);
}
var _chainKeys$3 = [];
var _defaultScene = /* @__PURE__ */ new Scene();
var _defaultCamera = /* @__PURE__ */ new Camera();
/**
* This module manages the render contexts of the renderer.
*
* @private
*/
var RenderContexts = class {
	/**
	* Constructs a new render context management component.
	*/
	constructor() {
		/**
		* A dictionary that manages render contexts in chain maps
		* for each attachment state.
		*
		* @type {Object<string,ChainMap>}
		*/
		this.chainMaps = {};
	}
	/**
	* Returns a render context for the given scene, camera and render target.
	*
	* @param {Scene} scene - The scene.
	* @param {Camera} camera - The camera that is used to render the scene.
	* @param {?RenderTarget} [renderTarget=null] - The active render target.
	* @return {RenderContext} The render context.
	*/
	get(scene, camera, renderTarget = null) {
		_chainKeys$3[0] = scene;
		_chainKeys$3[1] = camera;
		let attachmentState;
		if (renderTarget === null) attachmentState = "default";
		else {
			const format = renderTarget.texture.format;
			attachmentState = `${renderTarget.textures.length}:${format}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;
		}
		const chainMap = this._getChainMap(attachmentState);
		let renderState = chainMap.get(_chainKeys$3);
		if (renderState === void 0) {
			renderState = new RenderContext();
			chainMap.set(_chainKeys$3, renderState);
		}
		_chainKeys$3.length = 0;
		if (renderTarget !== null) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
		return renderState;
	}
	/**
	* Returns a render context intended for clear operations.
	*
	* @param {?RenderTarget} [renderTarget=null] - The active render target.
	* @return {RenderContext} The render context.
	*/
	getForClear(renderTarget = null) {
		return this.get(_defaultScene, _defaultCamera, renderTarget);
	}
	/**
	* Returns a chain map for the given attachment state.
	*
	* @private
	* @param {string} attachmentState - The attachment state.
	* @return {ChainMap} The chain map.
	*/
	_getChainMap(attachmentState) {
		return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
	}
	/**
	* Frees internal resources.
	*/
	dispose() {
		this.chainMaps = {};
	}
};
var _size$3 = /* @__PURE__ */ new Vector3();
/**
* This module manages the textures of the renderer.
*
* @private
* @augments DataMap
*/
var Textures = class extends DataMap {
	/**
	* Constructs a new texture management component.
	*
	* @param {Renderer} renderer - The renderer.
	* @param {Backend} backend - The renderer's backend.
	* @param {Info} info - Renderer component for managing metrics and monitoring data.
	*/
	constructor(renderer, backend, info) {
		super();
		/**
		* The renderer.
		*
		* @type {Renderer}
		*/
		this.renderer = renderer;
		/**
		* The backend.
		*
		* @type {Backend}
		*/
		this.backend = backend;
		/**
		* Renderer component for managing metrics and monitoring data.
		*
		* @type {Info}
		*/
		this.info = info;
	}
	/**
	* Updates the given render target. Based on the given render target configuration,
	* it updates the texture states representing the attachments of the framebuffer.
	*
	* @param {RenderTarget} renderTarget - The render target to update.
	* @param {number} [activeMipmapLevel=0] - The active mipmap level.
	*/
	updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
		const renderTargetData = this.get(renderTarget);
		const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
		const depthTextureMips = renderTargetData.depthTextureMips || (renderTargetData.depthTextureMips = {});
		const textures = renderTarget.textures;
		const size = this.getSize(textures[0]);
		const mipWidth = size.width >> activeMipmapLevel;
		const mipHeight = size.height >> activeMipmapLevel;
		let depthTexture = renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];
		const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;
		let textureNeedsUpdate = false;
		if (depthTexture === void 0 && useDepthTexture) {
			depthTexture = new DepthTexture();
			depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;
			depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType;
			depthTexture.image.width = mipWidth;
			depthTexture.image.height = mipHeight;
			depthTexture.image.depth = size.depth;
			depthTexture.renderTarget = renderTarget;
			depthTexture.isArrayTexture = renderTarget.multiview === true && size.depth > 1;
			depthTextureMips[activeMipmapLevel] = depthTexture;
		}
		if (renderTargetData.width !== size.width || size.height !== renderTargetData.height) {
			textureNeedsUpdate = true;
			if (depthTexture) {
				depthTexture.needsUpdate = true;
				depthTexture.image.width = mipWidth;
				depthTexture.image.height = mipHeight;
				depthTexture.image.depth = depthTexture.isArrayTexture ? depthTexture.image.depth : 1;
			}
		}
		renderTargetData.width = size.width;
		renderTargetData.height = size.height;
		renderTargetData.textures = textures;
		renderTargetData.depthTexture = depthTexture || null;
		renderTargetData.depth = renderTarget.depthBuffer;
		renderTargetData.stencil = renderTarget.stencilBuffer;
		renderTargetData.renderTarget = renderTarget;
		if (renderTargetData.sampleCount !== sampleCount) {
			textureNeedsUpdate = true;
			if (depthTexture) depthTexture.needsUpdate = true;
			renderTargetData.sampleCount = sampleCount;
		}
		const options = { sampleCount };
		if (renderTarget.isXRRenderTarget !== true) {
			for (let i = 0; i < textures.length; i++) {
				const texture$2 = textures[i];
				if (textureNeedsUpdate) texture$2.needsUpdate = true;
				this.updateTexture(texture$2, options);
			}
			if (depthTexture) this.updateTexture(depthTexture, options);
		}
		if (renderTargetData.initialized !== true) {
			renderTargetData.initialized = true;
			renderTargetData.onDispose = () => {
				this._destroyRenderTarget(renderTarget);
			};
			renderTarget.addEventListener("dispose", renderTargetData.onDispose);
		}
	}
	/**
	* Updates the given texture. Depending on the texture state, this method
	* triggers the upload of texture data to the GPU memory. If the texture data are
	* not yet ready for the upload, it uses default texture data for as a placeholder.
	*
	* @param {Texture} texture - The texture to update.
	* @param {Object} [options={}] - The options.
	*/
	updateTexture(texture$2, options = {}) {
		const textureData = this.get(texture$2);
		if (textureData.initialized === true && textureData.version === texture$2.version) return;
		const isRenderTarget = texture$2.isRenderTargetTexture || texture$2.isDepthTexture || texture$2.isFramebufferTexture;
		const backend = this.backend;
		if (isRenderTarget && textureData.initialized === true) backend.destroyTexture(texture$2);
		if (texture$2.isFramebufferTexture) {
			const renderTarget = this.renderer.getRenderTarget();
			if (renderTarget) texture$2.type = renderTarget.texture.type;
			else texture$2.type = UnsignedByteType;
		}
		const { width, height, depth: depth$2 } = this.getSize(texture$2);
		options.width = width;
		options.height = height;
		options.depth = depth$2;
		options.needsMipmaps = this.needsMipmaps(texture$2);
		options.levels = options.needsMipmaps ? this.getMipLevels(texture$2, width, height) : 1;
		if (texture$2.isCubeTexture && texture$2.mipmaps.length > 0) options.levels++;
		if (isRenderTarget || texture$2.isStorageTexture === true || texture$2.isExternalTexture === true) {
			backend.createTexture(texture$2, options);
			textureData.generation = texture$2.version;
		} else if (texture$2.version > 0) {
			const image = texture$2.image;
			if (image === void 0) warn("Renderer: Texture marked for update but image is undefined.");
			else if (image.complete === false) warn("Renderer: Texture marked for update but image is incomplete.");
			else {
				if (texture$2.images) {
					const images = [];
					for (const image$1 of texture$2.images) images.push(image$1);
					options.images = images;
				} else options.image = image;
				if (textureData.isDefaultTexture === void 0 || textureData.isDefaultTexture === true) {
					backend.createTexture(texture$2, options);
					textureData.isDefaultTexture = false;
					textureData.generation = texture$2.version;
				}
				if (texture$2.source.dataReady === true) backend.updateTexture(texture$2, options);
				const skipAutoGeneration = texture$2.isStorageTexture === true && texture$2.mipmapsAutoUpdate === false;
				if (options.needsMipmaps && texture$2.mipmaps.length === 0 && !skipAutoGeneration) backend.generateMipmaps(texture$2);
				if (texture$2.onUpdate) texture$2.onUpdate(texture$2);
			}
		} else {
			backend.createDefaultTexture(texture$2);
			textureData.isDefaultTexture = true;
			textureData.generation = texture$2.version;
		}
		if (textureData.initialized !== true) {
			textureData.initialized = true;
			textureData.generation = texture$2.version;
			this.info.memory.textures++;
			if (texture$2.isVideoTexture && ColorManagement.getTransfer(texture$2.colorSpace) !== SRGBTransfer) warn("WebGPURenderer: Video textures must use a color space with a sRGB transfer function, e.g. SRGBColorSpace.");
			textureData.onDispose = () => {
				this._destroyTexture(texture$2);
			};
			texture$2.addEventListener("dispose", textureData.onDispose);
		}
		textureData.version = texture$2.version;
	}
	/**
	* Updates the sampler for the given texture. This method has no effect
	* for the WebGL backend since it has no concept of samplers. Texture
	* parameters are configured with the `texParameter()` command for each
	* texture.
	*
	* In WebGPU, samplers are objects like textures and it's possible to share
	* them when the texture parameters match.
	*
	* @param {Texture} texture - The texture to update the sampler for.
	* @return {string} The current sampler key.
	*/
	updateSampler(texture$2) {
		return this.backend.updateSampler(texture$2);
	}
	/**
	* Computes the size of the given texture and writes the result
	* into the target vector. This vector is also returned by the
	* method.
	*
	* If no texture data are available for the compute yet, the method
	* returns default size values.
	*
	* @param {Texture} texture - The texture to compute the size for.
	* @param {Vector3} target - The target vector.
	* @return {Vector3} The target vector.
	*/
	getSize(texture$2, target = _size$3) {
		let image = texture$2.images ? texture$2.images[0] : texture$2.image;
		if (image) {
			if (image.image !== void 0) image = image.image;
			if (typeof HTMLVideoElement !== "undefined" && image instanceof HTMLVideoElement) {
				target.width = image.videoWidth || 1;
				target.height = image.videoHeight || 1;
				target.depth = 1;
			} else if (typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
				target.width = image.displayWidth || 1;
				target.height = image.displayHeight || 1;
				target.depth = 1;
			} else {
				target.width = image.width || 1;
				target.height = image.height || 1;
				target.depth = texture$2.isCubeTexture ? 6 : image.depth || 1;
			}
		} else target.width = target.height = target.depth = 1;
		return target;
	}
	/**
	* Computes the number of mipmap levels for the given texture.
	*
	* @param {Texture} texture - The texture.
	* @param {number} width - The texture's width.
	* @param {number} height - The texture's height.
	* @return {number} The number of mipmap levels.
	*/
	getMipLevels(texture$2, width, height) {
		let mipLevelCount;
		if (texture$2.mipmaps.length > 0) mipLevelCount = texture$2.mipmaps.length;
		else if (texture$2.isCompressedTexture === true) mipLevelCount = 1;
		else mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
		return mipLevelCount;
	}
	/**
	* Returns `true` if the given texture makes use of mipmapping.
	*
	* @param {Texture} texture - The texture.
	* @return {boolean} Whether mipmaps are required or not.
	*/
	needsMipmaps(texture$2) {
		return texture$2.generateMipmaps === true || texture$2.mipmaps.length > 0;
	}
	/**
	* Frees internal resources when the given render target isn't
	* required anymore.
	*
	* @param {RenderTarget} renderTarget - The render target to destroy.
	*/
	_destroyRenderTarget(renderTarget) {
		if (this.has(renderTarget) === true) {
			const renderTargetData = this.get(renderTarget);
			const textures = renderTargetData.textures;
			const depthTexture = renderTargetData.depthTexture;
			renderTarget.removeEventListener("dispose", renderTargetData.onDispose);
			for (let i = 0; i < textures.length; i++) this._destroyTexture(textures[i]);
			if (depthTexture) this._destroyTexture(depthTexture);
			this.delete(renderTarget);
			this.backend.delete(renderTarget);
		}
	}
	/**
	* Frees internal resource when the given texture isn't
	* required anymore.
	*
	* @param {Texture} texture - The texture to destroy.
	*/
	_destroyTexture(texture$2) {
		if (this.has(texture$2) === true) {
			const textureData = this.get(texture$2);
			texture$2.removeEventListener("dispose", textureData.onDispose);
			const isDefaultTexture = textureData.isDefaultTexture;
			this.backend.destroyTexture(texture$2, isDefaultTexture);
			this.delete(texture$2);
			this.info.memory.textures--;
		}
	}
};
/**
* A four-component version of {@link Color} which is internally
* used by the renderer to represents clear color with alpha as
* one object.
*
* @private
* @augments Color
*/
var Color4 = class extends Color$1 {
	/**
	* Constructs a new four-component color.
	* You can also pass a single THREE.Color, hex or
	* string argument to this constructor.
	*
	* @param {number|string} [r=1] - The red value.
	* @param {number} [g=1] - The green value.
	* @param {number} [b=1] - The blue value.
	* @param {number} [a=1] - The alpha value.
	*/
	constructor(r, g$1, b$2, a$1 = 1) {
		super(r, g$1, b$2);
		this.a = a$1;
	}
	/**
	* Overwrites the default to honor alpha.
	* You can also pass a single THREE.Color, hex or
	* string argument to this method.
	*
	* @param {number|string|Color} r - The red value.
	* @param {number} [g] - The green value.
	* @param {number} [b] - The blue value.
	* @param {number} [a=1] - The alpha value.
	* @return {Color4} A reference to this object.
	*/
	set(r, g$1, b$2, a$1 = 1) {
		this.a = a$1;
		return super.set(r, g$1, b$2);
	}
	/**
	* Overwrites the default to honor alpha.
	*
	* @param {Color4} color - The color to copy.
	* @return {Color4} A reference to this object.
	*/
	copy(color$2) {
		if (color$2.a !== void 0) this.a = color$2.a;
		return super.copy(color$2);
	}
	/**
	* Overwrites the default to honor alpha.
	*
	* @return {Color4} The cloned color.
	*/
	clone() {
		return new this.constructor(this.r, this.g, this.b, this.a);
	}
};
/**
* Special version of {@link PropertyNode} which is used for parameters.
*
* @augments PropertyNode
*/
var ParameterNode = class extends PropertyNode {
	static get type() {
		return "ParameterNode";
	}
	/**
	* Constructs a new parameter node.
	*
	* @param {string} nodeType - The type of the node.
	* @param {?string} [name=null] - The name of the parameter in the shader.
	*/
	constructor(nodeType, name = null) {
		super(nodeType, name);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isParameterNode = true;
	}
	/**
	* Gets the type of a member variable in the parameter node.
	*
	* @param {NodeBuilder} builder - The node builder.
	* @param {string} name - The name of the member variable.
	* @returns {string}
	*/
	getMemberType(builder, name) {
		const type$1 = this.getNodeType(builder);
		const struct$2 = builder.getStructTypeNode(type$1);
		let memberType;
		if (struct$2 !== null) memberType = struct$2.getMemberType(builder, name);
		else {
			error(`TSL: Member "${name}" not found in struct "${type$1}".`);
			memberType = "float";
		}
		return memberType;
	}
	getHash() {
		return this.uuid;
	}
	generate() {
		return this.name;
	}
};
/**
* TSL function for creating a parameter node.
*
* @tsl
* @function
* @param {string} type - The type of the node.
* @param {?string} name - The name of the parameter in the shader.
* @returns {ParameterNode}
*/
var parameter$1 = (type$1, name) => nodeObject$1(new ParameterNode(type$1, name));
/**
* Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
* They are usually needed in cases like `If`, `Else`.
*
* @augments Node
*/
var StackNode = class extends Node {
	static get type() {
		return "StackNode";
	}
	/**
	* Constructs a new stack node.
	*
	* @param {?StackNode} [parent=null] - The parent stack node.
	*/
	constructor(parent = null) {
		super();
		/**
		* List of nodes.
		*
		* @type {Array<Node>}
		*/
		this.nodes = [];
		/**
		* The output node.
		*
		* @type {?Node}
		* @default null
		*/
		this.outputNode = null;
		/**
		* The parent stack node.
		*
		* @type {?StackNode}
		* @default null
		*/
		this.parent = parent;
		/**
		* The current conditional node.
		*
		* @private
		* @type {ConditionalNode}
		* @default null
		*/
		this._currentCond = null;
		/**
		* The expression node. Only
		* relevant for Switch/Case.
		*
		* @private
		* @type {Node}
		* @default null
		*/
		this._expressionNode = null;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isStackNode = true;
	}
	getElementType(builder) {
		return this.hasOutput ? this.outputNode.getElementType(builder) : "void";
	}
	getNodeType(builder) {
		return this.hasOutput ? this.outputNode.getNodeType(builder) : "void";
	}
	getMemberType(builder, name) {
		return this.hasOutput ? this.outputNode.getMemberType(builder, name) : "void";
	}
	/**
	* Adds a node to this stack.
	*
	* @param {Node} node - The node to add.
	* @return {StackNode} A reference to this stack node.
	*/
	addToStack(node) {
		if (node.isNode !== true) {
			error("TSL: Invalid node added to stack.");
			return this;
		}
		this.nodes.push(node);
		return this;
	}
	/**
	* Represent an `if` statement in TSL.
	*
	* @param {Node} boolNode - Represents the condition.
	* @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
	* @return {StackNode} A reference to this stack node.
	*/
	If(boolNode, method) {
		const methodNode = new ShaderNode$1(method);
		this._currentCond = select$1(boolNode, methodNode);
		return this.addToStack(this._currentCond);
	}
	/**
	* Represent an `elseif` statement in TSL.
	*
	* @param {Node} boolNode - Represents the condition.
	* @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
	* @return {StackNode} A reference to this stack node.
	*/
	ElseIf(boolNode, method) {
		const methodNode = new ShaderNode$1(method);
		const ifNode = select$1(boolNode, methodNode);
		this._currentCond.elseNode = ifNode;
		this._currentCond = ifNode;
		return this;
	}
	/**
	* Represent an `else` statement in TSL.
	*
	* @param {Function} method - TSL code which is executed in the `else` case.
	* @return {StackNode} A reference to this stack node.
	*/
	Else(method) {
		this._currentCond.elseNode = new ShaderNode$1(method);
		return this;
	}
	/**
	* Represents a `switch` statement in TSL.
	*
	* @param {any} expression - Represents the expression.
	* @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
	* @return {StackNode} A reference to this stack node.
	*/
	Switch(expression$2) {
		this._expressionNode = nodeObject$1(expression$2);
		return this;
	}
	/**
	* Represents a `case` statement in TSL. The TSL version accepts an arbitrary numbers of values.
	* The last parameter must be the callback method that should be executed in the `true` case.
	*
	* @param {...any} params - The values of the `Case()` statement as well as the callback method.
	* @return {StackNode} A reference to this stack node.
	*/
	Case(...params) {
		const caseNodes = [];
		if (params.length >= 2) for (let i = 0; i < params.length - 1; i++) caseNodes.push(this._expressionNode.equal(nodeObject$1(params[i])));
		else error("TSL: Invalid parameter length. Case() requires at least two parameters.");
		const method = params[params.length - 1];
		const methodNode = new ShaderNode$1(method);
		let caseNode = caseNodes[0];
		for (let i = 1; i < caseNodes.length; i++) caseNode = caseNode.or(caseNodes[i]);
		const condNode = select$1(caseNode, methodNode);
		if (this._currentCond === null) {
			this._currentCond = condNode;
			return this.addToStack(this._currentCond);
		} else {
			this._currentCond.elseNode = condNode;
			this._currentCond = condNode;
			return this;
		}
	}
	/**
	* Represents the default code block of a Switch/Case statement.
	*
	* @param {Function} method - TSL code which is executed in the `else` case.
	* @return {StackNode} A reference to this stack node.
	*/
	Default(method) {
		this.Else(method);
		return this;
	}
	setup(builder) {
		const nodeProperties = builder.getNodeProperties(this);
		let index = 0;
		for (const childNode of this.getChildren()) {
			if (childNode.isVarNode && childNode.intent === true) {
				if (childNode.isAssign(builder) !== true) continue;
			}
			nodeProperties["node" + index++] = childNode;
		}
		return nodeProperties.outputNode || null;
	}
	get hasOutput() {
		return this.outputNode && this.outputNode.isNode;
	}
	build(builder, ...params) {
		const previousStack = getCurrentStack$1();
		setCurrentStack$1(this);
		builder.setActiveStack(this);
		const buildStage = builder.buildStage;
		for (const node of this.nodes) {
			if (node.isVarNode && node.intent === true) {
				if (node.isAssign(builder) !== true) continue;
			}
			if (buildStage === "setup") node.build(builder);
			else if (buildStage === "analyze") node.build(builder, this);
			else if (buildStage === "generate") {
				const stages = builder.getDataFromNode(node, "any").stages;
				const parents = stages && stages[builder.shaderStage];
				if (node.isVarNode && parents && parents.length === 1 && parents[0] && parents[0].isStackNode) continue;
				node.build(builder, "void");
			}
		}
		let result;
		if (this.hasOutput) result = this.outputNode.build(builder, ...params);
		else result = super.build(builder, ...params);
		setCurrentStack$1(previousStack);
		builder.removeActiveStack(this);
		return result;
	}
};
/**
* TSL function for creating a stack node.
*
* @tsl
* @function
* @param {?StackNode} [parent=null] - The parent stack node.
* @returns {StackNode}
*/
var stack$1 = /* @__PURE__ */ nodeProxy$1(StackNode).setParameterLength(0, 1);
/**
* Generates a layout for struct members.
* This function takes an object representing struct members and returns an array of member layouts.
* Each member layout includes the member's name, type, and whether it is atomic.
*
* @param {Object.<string, string|Object>} members - An object where keys are member names and values are either types (as strings) or objects with type and atomic properties.
* @returns {Array.<{name: string, type: string, atomic: boolean}>} An array of member layouts.
*/
function getMembersLayout(members) {
	return Object.entries(members).map(([name, value]) => {
		if (typeof value === "string") return {
			name,
			type: value,
			atomic: false
		};
		return {
			name,
			type: value.type,
			atomic: value.atomic || false
		};
	});
}
/**
* Represents a struct type node in the node-based system.
* This class is used to define and manage the layout and types of struct members.
* It extends the base Node class and provides methods to get the length of the struct,
* retrieve member types, and generate the struct type for a builder.
*
* @augments Node
*/
var StructTypeNode = class extends Node {
	static get type() {
		return "StructTypeNode";
	}
	/**
	* Creates an instance of StructTypeNode.
	*
	* @param {Object} membersLayout - The layout of the members for the struct.
	* @param {?string} [name=null] - The optional name of the struct.
	*/
	constructor(membersLayout, name = null) {
		super("struct");
		/**
		* The layout of the members for the struct
		*
		* @type {Array.<{name: string, type: string, atomic: boolean}>}
		*/
		this.membersLayout = getMembersLayout(membersLayout);
		/**
		* The name of the struct.
		*
		* @type {?string}
		* @default null
		*/
		this.name = name;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isStructLayoutNode = true;
	}
	/**
	* Returns the length of the struct.
	* The length is calculated by summing the lengths of the struct's members.
	*
	* @returns {number} The length of the struct.
	*/
	getLength() {
		const GPU_CHUNK_BYTES$1 = 8;
		const BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;
		let offset = 0;
		for (const member of this.membersLayout) {
			const type$1 = member.type;
			const itemSize = getMemoryLengthFromType(type$1) * BYTES_PER_ELEMENT;
			const boundary = getByteBoundaryFromType(type$1);
			const chunkOffset = offset % GPU_CHUNK_BYTES$1;
			const chunkPadding = chunkOffset % boundary;
			const chunkStart = chunkOffset + chunkPadding;
			offset += chunkPadding;
			if (chunkStart !== 0 && GPU_CHUNK_BYTES$1 - chunkStart < itemSize) offset += GPU_CHUNK_BYTES$1 - chunkStart;
			offset += itemSize;
		}
		return Math.ceil(offset / GPU_CHUNK_BYTES$1) * GPU_CHUNK_BYTES$1 / BYTES_PER_ELEMENT;
	}
	getMemberType(builder, name) {
		const member = this.membersLayout.find((m$1) => m$1.name === name);
		return member ? member.type : "void";
	}
	getNodeType(builder) {
		return builder.getStructTypeFromNode(this, this.membersLayout, this.name).name;
	}
	setup(builder) {
		builder.getStructTypeFromNode(this, this.membersLayout, this.name);
		builder.addInclude(this);
	}
	generate(builder) {
		return this.getNodeType(builder);
	}
};
/**
* StructNode allows to create custom structures with multiple members.
* This can also be used to define structures in attribute and uniform data.
*
* ```js
* // Define a custom struct
* const BoundingBox = struct( { min: 'vec3', max: 'vec3' } );
*
* // Create a new instance of the struct
* const bb = BoundingBox( vec3( 0 ), vec3( 1 ) ); // style 1
* const bb = BoundingBox( { min: vec3( 0 ), max: vec3( 1 ) } ); // style 2
*
* // Access the struct members
* const min = bb.get( 'min' );
*
* // Assign a new value to a member
* min.assign( vec3() );
* ```
* @augments Node
*/
var StructNode = class extends Node {
	static get type() {
		return "StructNode";
	}
	constructor(structTypeNode, values) {
		super("vec3");
		this.structTypeNode = structTypeNode;
		this.values = values;
		this.isStructNode = true;
	}
	getNodeType(builder) {
		return this.structTypeNode.getNodeType(builder);
	}
	getMemberType(builder, name) {
		return this.structTypeNode.getMemberType(builder, name);
	}
	generate(builder) {
		const nodeVar = builder.getVarFromNode(this);
		const structType = nodeVar.type;
		const propertyName = builder.getPropertyName(nodeVar);
		builder.addLineFlowCode(`${propertyName} = ${builder.generateStruct(structType, this.structTypeNode.membersLayout, this.values)}`, this);
		return nodeVar.name;
	}
};
/**
* TSL function for creating a struct node.
*
* @tsl
* @function
* @param {Object} membersLayout - The layout of the struct members.
* @param {?string} [name=null] - The name of the struct.
* @returns {Function} The struct function.
*/
var struct$1 = (membersLayout, name = null) => {
	const structLayout = new StructTypeNode(membersLayout, name);
	const struct$2 = (...params) => {
		let values = null;
		if (params.length > 0) if (params[0].isNode) {
			values = {};
			const names = Object.keys(membersLayout);
			for (let i = 0; i < params.length; i++) values[names[i]] = params[i];
		} else values = params[0];
		return nodeObject$1(new StructNode(structLayout, values));
	};
	struct$2.layout = structLayout;
	struct$2.isStruct = true;
	return struct$2;
};
/**
* This node can be used to define multiple outputs in a shader programs.
*
* @augments Node
*/
var OutputStructNode = class extends Node {
	static get type() {
		return "OutputStructNode";
	}
	/**
	* Constructs a new output struct node. The constructor can be invoked with an
	* arbitrary number of nodes representing the members.
	*
	* @param {...Node} members - A parameter list of nodes.
	*/
	constructor(...members) {
		super();
		/**
		* An array of nodes which defines the output.
		*
		* @type {Array<Node>}
		*/
		this.members = members;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isOutputStructNode = true;
	}
	getNodeType(builder) {
		const properties = builder.getNodeProperties(this);
		if (properties.membersLayout === void 0) {
			const members = this.members;
			const membersLayout = [];
			for (let i = 0; i < members.length; i++) {
				const name = "m" + i;
				const type$1 = members[i].getNodeType(builder);
				membersLayout.push({
					name,
					type: type$1,
					index: i
				});
			}
			properties.membersLayout = membersLayout;
			properties.structType = builder.getOutputStructTypeFromNode(this, properties.membersLayout);
		}
		return properties.structType.name;
	}
	generate(builder) {
		const propertyName = builder.getOutputStructName();
		const members = this.members;
		const structPrefix = propertyName !== "" ? propertyName + "." : "";
		for (let i = 0; i < members.length; i++) {
			const snippet = members[i].build(builder);
			builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`, this);
		}
		return propertyName;
	}
};
/**
* TSL function for creating an output struct node.
*
* @tsl
* @function
* @param {...Node} members - A parameter list of nodes.
* @returns {OutputStructNode}
*/
var outputStruct$1 = /* @__PURE__ */ nodeProxy$1(OutputStructNode);
/**
* Returns the MRT texture index for the given name.
*
* @param {Array<Texture>} textures - The textures of a MRT-configured render target.
* @param {string} name - The name of the MRT texture which index is requested.
* @return {number} The texture index.
*/
function getTextureIndex$1(textures, name) {
	for (let i = 0; i < textures.length; i++) if (textures[i].name === name) return i;
	return -1;
}
/**
* This node can be used setup a MRT context for rendering. A typical MRT setup for
* post-processing is shown below:
* ```js
* const mrtNode = mrt( {
*   output: output,
*   normal: normalView
* } ) );
* ```
* The MRT output is defined as a dictionary.
*
* @augments OutputStructNode
*/
var MRTNode = class extends OutputStructNode {
	static get type() {
		return "MRTNode";
	}
	/**
	* Constructs a new output struct node.
	*
	* @param {Object<string, Node>} outputNodes - The MRT outputs.
	*/
	constructor(outputNodes) {
		super();
		/**
		* A dictionary representing the MRT outputs. The key
		* is the name of the output, the value the node which produces
		* the output result.
		*
		* @type {Object<string, Node>}
		*/
		this.outputNodes = outputNodes;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMRTNode = true;
	}
	/**
	* Returns `true` if the MRT node has an output with the given name.
	*
	* @param {string} name - The name of the output.
	* @return {NodeBuilder} Whether the MRT node has an output for the given name or not.
	*/
	has(name) {
		return this.outputNodes[name] !== void 0;
	}
	/**
	* Returns the output node for the given name.
	*
	* @param {string} name - The name of the output.
	* @return {Node} The output node.
	*/
	get(name) {
		return this.outputNodes[name];
	}
	/**
	* Merges the outputs of the given MRT node with the outputs of this node.
	*
	* @param {MRTNode} mrtNode - The MRT to merge.
	* @return {MRTNode} A new MRT node with merged outputs..
	*/
	merge(mrtNode) {
		const outputs = {
			...this.outputNodes,
			...mrtNode.outputNodes
		};
		return mrt$1(outputs);
	}
	setup(builder) {
		const outputNodes = this.outputNodes;
		const mrt$2 = builder.renderer.getRenderTarget();
		const members = [];
		const textures = mrt$2.textures;
		for (const name in outputNodes) {
			const index = getTextureIndex$1(textures, name);
			members[index] = vec4$1(outputNodes[name]);
		}
		this.members = members;
		return super.setup(builder);
	}
};
/**
* TSL function for creating a MRT node.
*
* @tsl
* @function
* @param {Object<string, Node>} outputNodes - The MRT outputs.
* @returns {MRTNode}
*/
var mrt$1 = /* @__PURE__ */ nodeProxy$1(MRTNode);
/**
* This node represents an operation that reinterprets the bit representation of a value
* in one type as a value in another type.
*
* @augments TempNode
*/
var BitcastNode = class extends TempNode {
	static get type() {
		return "BitcastNode";
	}
	/**
	* Constructs a new bitcast node.
	*
	* @param {Node} valueNode - The value to convert.
	* @param {string} conversionType - The type to convert to.
	* @param {?string} [inputType = null] - The expected input data type of the bitcast operation.
	*/
	constructor(valueNode, conversionType, inputType = null) {
		super();
		/**
		* The data to bitcast to a new type.
		*
		* @type {Node}
		*/
		this.valueNode = valueNode;
		/**
		* The type the value will be converted to.
		*
		* @type {string}
		*/
		this.conversionType = conversionType;
		/**
		* The expected input data type of the bitcast operation.
		*
		*
		* @type {string}
		* @default null
		*/
		this.inputType = inputType;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isBitcastNode = true;
	}
	getNodeType(builder) {
		if (this.inputType !== null) {
			const valueType = this.valueNode.getNodeType(builder);
			const valueLength = builder.getTypeLength(valueType);
			return builder.getTypeFromLength(valueLength, this.conversionType);
		}
		return this.conversionType;
	}
	generate(builder) {
		const type$1 = this.getNodeType(builder);
		let inputType = "";
		if (this.inputType !== null) {
			const valueType = this.valueNode.getNodeType(builder);
			inputType = builder.getTypeLength(valueType) === 1 ? this.inputType : builder.changeComponentType(valueType, this.inputType);
		} else inputType = this.valueNode.getNodeType(builder);
		return `${builder.getBitcastMethod(type$1, inputType)}( ${this.valueNode.build(builder, inputType)} )`;
	}
};
/**
* Reinterpret the bit representation of a value in one type as a value in another type.
*
* @tsl
* @function
* @param {Node | number} x - The parameter.
* @param {string} y - The new type.
* @returns {Node}
*/
var bitcast$1 = /* @__PURE__ */ nodeProxyIntent$1(BitcastNode).setParameterLength(2);
/**
* Bitcasts a float or a vector of floats to a corresponding integer type with the same element size.
*
* @tsl
* @function
* @param {Node<float>} value - The float or vector of floats to bitcast.
* @returns {BitcastNode}
*/
var floatBitsToInt$1 = (value) => new BitcastNode(value, "int", "float");
/**
* Bitcasts a float or a vector of floats to a corresponding unsigned integer type with the same element size.
*
* @tsl
* @function
* @param {Node<float>} value - The float or vector of floats to bitcast.
* @returns {BitcastNode}
*/
var floatBitsToUint$1 = (value) => new BitcastNode(value, "uint", "float");
/**
* Bitcasts an integer or a vector of integers to a corresponding float type with the same element size.
*
* @tsl
* @function
* @param {Node<int>} value - The integer or vector of integers to bitcast.
* @returns {BitcastNode}
*/
var intBitsToFloat$1 = (value) => new BitcastNode(value, "float", "int");
/**
* Bitcast an unsigned integer or a vector of unsigned integers to a corresponding float type with the same element size.
*
* @tsl
* @function
* @param {Node<uint>} value - The unsigned integer or vector of unsigned integers to bitcast.
* @returns {BitcastNode}
*/
var uintBitsToFloat$1 = (value) => new BitcastNode(value, "float", "uint");
/**
* Generates a hash value in the range `[0, 1]` from the given seed.
*
* @tsl
* @function
* @param {Node<float>} seed - The seed.
* @return {Node<float>} The hash value.
*/
var hash$2 = /* @__PURE__ */ Fn$1(([seed]) => {
	const state = seed.toUint().mul(747796405).add(2891336453);
	const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);
	return word.shiftRight(22).bitXor(word).toFloat().mul(1 / 2 ** 32);
});
/**
* A function that remaps the `[0,1]` interval into the `[0,1]` interval.
* The corners are mapped to `0` and the center to `1`.
* Reference: {@link https://iquilezles.org/articles/functions/}.
*
* @tsl
* @function
* @param {Node<float>} x - The value to remap.
* @param {Node<float>} k - Allows to control the remapping functions shape by rising the parabola to a power `k`.
* @return {Node<float>} The remapped value.
*/
var parabola$1 = (x, k) => pow$1(mul$1(4, x.mul(sub$1(1, x))), k);
/**
* A function that remaps the `[0,1]` interval into the `[0,1]` interval.
* Expands the sides and compresses the center, and keeps `0.5` mapped to `0.5`.
* Reference: {@link https://iquilezles.org/articles/functions/}.
*
* @tsl
* @function
* @param {Node<float>} x - The value to remap.
* @param {Node<float>} k - `k=1` is the identity curve,`k<1` produces the classic `gain()` shape, and `k>1` produces "s" shaped curves.
* @return {Node<float>} The remapped value.
*/
var gain$1 = (x, k) => x.lessThan(.5) ? parabola$1(x.mul(2), k).div(2) : sub$1(1, parabola$1(mul$1(sub$1(1, x), 2), k).div(2));
/**
* A function that remaps the `[0,1]` interval into the `[0,1]` interval.
* A generalization of the `parabola()`. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.
* Reference: {@link https://iquilezles.org/articles/functions/}.
*
* @tsl
* @function
* @param {Node<float>} x - The value to remap.
* @param {Node<float>} a - First control parameter.
* @param {Node<float>} b - Second control parameter.
* @return {Node<float>} The remapped value.
*/
var pcurve$1 = (x, a$1, b$2) => pow$1(div$1(pow$1(x, a$1), add$1(pow$1(x, a$1), pow$1(sub$1(1, x), b$2))), 1 / a$1);
/**
* A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.
* Reference: {@link https://iquilezles.org/articles/functions/}.
*
* @tsl
* @function
* @param {Node<float>} x - The value to compute the sin for.
* @param {Node<float>} k - Controls the amount of bounces.
* @return {Node<float>} The result value.
*/
var sinc$1 = (x, k) => sin$1(PI$1.mul(k.mul(x).sub(1))).div(PI$1.mul(k.mul(x).sub(1)));
var tri = /* @__PURE__ */ Fn$1(([x]) => {
	return x.fract().sub(.5).abs();
}).setLayout({
	name: "tri",
	type: "float",
	inputs: [{
		name: "x",
		type: "float"
	}]
});
var tri3 = /* @__PURE__ */ Fn$1(([p$1]) => {
	return vec3$1(tri(p$1.z.add(tri(p$1.y.mul(1)))), tri(p$1.z.add(tri(p$1.x.mul(1)))), tri(p$1.y.add(tri(p$1.x.mul(1)))));
}).setLayout({
	name: "tri3",
	type: "vec3",
	inputs: [{
		name: "p",
		type: "vec3"
	}]
});
/**
* Generates a noise value from the given position, speed and time parameters.
*
* @tsl
* @function
* @param {Node<vec3>} position - The position.
* @param {Node<float>} speed - The speed.
* @param {Node<float>} time - The time.
* @return {Node<float>} The generated noise.
*/
var triNoise3D$1 = /* @__PURE__ */ Fn$1(([position, speed, time$2]) => {
	const p$1 = vec3$1(position).toVar();
	const z = float$1(1.4).toVar();
	const rz = float$1(0).toVar();
	const bp = vec3$1(p$1).toVar();
	Loop$1({
		start: float$1(0),
		end: float$1(3),
		type: "float",
		condition: "<="
	}, () => {
		const dg = vec3$1(tri3(bp.mul(2))).toVar();
		p$1.addAssign(dg.add(time$2.mul(float$1(.1).mul(speed))));
		bp.mulAssign(1.8);
		z.mulAssign(1.5);
		p$1.mulAssign(1.2);
		const t = float$1(tri(p$1.z.add(tri(p$1.x.add(tri(p$1.y)))))).toVar();
		rz.addAssign(t.div(z));
		bp.addAssign(.14);
	});
	return rz;
}).setLayout({
	name: "triNoise3D",
	type: "float",
	inputs: [
		{
			name: "position",
			type: "vec3"
		},
		{
			name: "speed",
			type: "float"
		},
		{
			name: "time",
			type: "float"
		}
	]
});
/**
* This class allows to define multiple overloaded versions
* of the same function. Depending on the parameters of the function
* call, the node picks the best-fit overloaded version.
*
* @augments Node
*/
var FunctionOverloadingNode = class extends Node {
	static get type() {
		return "FunctionOverloadingNode";
	}
	/**
	* Constructs a new function overloading node.
	*
	* @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
	* @param {...Node} parametersNodes - A list of parameter nodes.
	*/
	constructor(functionNodes = [], ...parametersNodes) {
		super();
		/**
		* Array of `Fn` function definitions.
		*
		* @type {Array<Function>}
		*/
		this.functionNodes = functionNodes;
		/**
		* A list of parameter nodes.
		*
		* @type {Array<Node>}
		*/
		this.parametersNodes = parametersNodes;
		/**
		* The selected overloaded function call.
		*
		* @private
		* @type {ShaderCallNodeInternal}
		*/
		this._candidateFn = null;
		/**
		* This node is marked as global.
		*
		* @type {boolean}
		* @default true
		*/
		this.global = true;
	}
	/**
	* This method is overwritten since the node type is inferred from
	* the function's return type.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		return this.getCandidateFn(builder).shaderNode.layout.type;
	}
	/**
	* Returns the candidate function for the current parameters.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {FunctionNode} The candidate function.
	*/
	getCandidateFn(builder) {
		const params = this.parametersNodes;
		let candidateFn = this._candidateFn;
		if (candidateFn === null) {
			let bestCandidateFn = null;
			let bestScore = -1;
			for (const functionNode of this.functionNodes) {
				const layout = functionNode.shaderNode.layout;
				if (layout === null) throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");
				const inputs = layout.inputs;
				if (params.length === inputs.length) {
					let currentScore = 0;
					for (let i = 0; i < params.length; i++) {
						const param = params[i];
						const input = inputs[i];
						if (param.getNodeType(builder) === input.type) currentScore++;
					}
					if (currentScore > bestScore) {
						bestCandidateFn = functionNode;
						bestScore = currentScore;
					}
				}
			}
			this._candidateFn = candidateFn = bestCandidateFn;
		}
		return candidateFn;
	}
	/**
	* Sets up the node for the current parameters.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node} The setup node.
	*/
	setup(builder) {
		return this.getCandidateFn(builder)(...this.parametersNodes);
	}
};
var overloadingBaseFn = /* @__PURE__ */ nodeProxy$1(FunctionOverloadingNode);
/**
* TSL function for creating a function overloading node.
*
* @tsl
* @function
* @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
* @returns {FunctionOverloadingNode}
*/
var overloadingFn$1 = (functionNodes) => (...params) => overloadingBaseFn(functionNodes, ...params);
/**
* Represents the elapsed time in seconds.
*
* @tsl
* @type {UniformNode<float>}
*/
var time$1 = /* @__PURE__ */ uniform$1(0).setGroup(renderGroup$1).onRenderUpdate((frame) => frame.time);
/**
* Represents the delta time in seconds.
*
* @tsl
* @type {UniformNode<float>}
*/
var deltaTime$1 = /* @__PURE__ */ uniform$1(0).setGroup(renderGroup$1).onRenderUpdate((frame) => frame.deltaTime);
/**
* Represents the current frame ID.
*
* @tsl
* @type {UniformNode<uint>}
*/
var frameId$1 = /* @__PURE__ */ uniform$1(0, "uint").setGroup(renderGroup$1).onRenderUpdate((frame) => frame.frameId);
/**
* Generates a sine wave oscillation based on a timer.
*
* @tsl
* @function
* @param {Node<float>} t - The timer to generate the oscillation with.
* @return {Node<float>} The oscillation node.
*/
var oscSine$1 = (t = time$1) => t.add(.75).mul(Math.PI * 2).sin().mul(.5).add(.5);
/**
* Generates a square wave oscillation based on a timer.
*
* @tsl
* @function
* @param {Node<float>} t - The timer to generate the oscillation with.
* @return {Node<float>} The oscillation node.
*/
var oscSquare$1 = (t = time$1) => t.fract().round();
/**
* Generates a triangle wave oscillation based on a timer.
*
* @tsl
* @function
* @param {Node<float>} t - The timer to generate the oscillation with.
* @return {Node<float>} The oscillation node.
*/
var oscTriangle$1 = (t = time$1) => t.add(.5).fract().mul(2).sub(1).abs();
/**
* Generates a sawtooth wave oscillation based on a timer.
*
* @tsl
* @function
* @param {Node<float>} t - The timer to generate the oscillation with.
* @return {Node<float>} The oscillation node.
*/
var oscSawtooth$1 = (t = time$1) => t.fract();
/**
* Rotates the given uv coordinates around a center point
*
* @tsl
* @function
* @param {Node<vec2>} uv - The uv coordinates.
* @param {Node<float>} rotation - The rotation defined in radians.
* @param {Node<vec2>} center - The center of rotation
* @return {Node<vec2>} The rotated uv coordinates.
*/
var rotateUV$1 = /* @__PURE__ */ Fn$1(([uv$3, rotation, center = vec2$1(.5)]) => {
	return rotate$1(uv$3.sub(center), rotation).add(center);
});
/**
* Applies a spherical warping effect to the given uv coordinates.
*
* @tsl
* @function
* @param {Node<vec2>} uv - The uv coordinates.
* @param {Node<float>} strength - The strength of the effect.
* @param {Node<vec2>} center - The center point
* @return {Node<vec2>} The updated uv coordinates.
*/
var spherizeUV$1 = /* @__PURE__ */ Fn$1(([uv$3, strength, center = vec2$1(.5)]) => {
	const delta = uv$3.sub(center);
	const delta2 = delta.dot(delta);
	const deltaOffset = delta2.mul(delta2).mul(strength);
	return uv$3.add(delta.mul(deltaOffset));
});
/**
* This can be used to achieve a billboarding behavior for flat meshes. That means they are
* oriented always towards the camera.
*
* ```js
* material.vertexNode = billboarding();
* ```
*
* @tsl
* @function
* @param {Object} config - The configuration object.
* @param {?Node<vec3>} [config.position=null] - Can be used to define the vertex positions in world space.
* @param {boolean} [config.horizontal=true] - Whether to follow the camera rotation horizontally or not.
* @param {boolean} [config.vertical=false] - Whether to follow the camera rotation vertically or not.
* @return {Node<vec3>} The updated vertex position in clip space.
*/
var billboarding$1 = /* @__PURE__ */ Fn$1(({ position = null, horizontal = true, vertical = false }) => {
	let worldMatrix;
	if (position !== null) {
		worldMatrix = modelWorldMatrix$1.toVar();
		worldMatrix[3][0] = position.x;
		worldMatrix[3][1] = position.y;
		worldMatrix[3][2] = position.z;
	} else worldMatrix = modelWorldMatrix$1;
	const modelViewMatrix$2 = cameraViewMatrix$1.mul(worldMatrix);
	if (defined$1(horizontal)) {
		modelViewMatrix$2[0][0] = modelWorldMatrix$1[0].length();
		modelViewMatrix$2[0][1] = 0;
		modelViewMatrix$2[0][2] = 0;
	}
	if (defined$1(vertical)) {
		modelViewMatrix$2[1][0] = 0;
		modelViewMatrix$2[1][1] = modelWorldMatrix$1[1].length();
		modelViewMatrix$2[1][2] = 0;
	}
	modelViewMatrix$2[2][0] = 0;
	modelViewMatrix$2[2][1] = 0;
	modelViewMatrix$2[2][2] = 1;
	return cameraProjectionMatrix$1.mul(modelViewMatrix$2).mul(positionLocal$1);
});
/**
* A special version of a screen uv function that involves a depth comparison
* when computing the final uvs. The function mitigates visual errors when
* using viewport texture nodes for refraction purposes. Without this function
* objects in front of a refractive surface might appear on the refractive surface
* which is incorrect.
*
* @tsl
* @function
* @param {?Node<vec2>} uv - Optional uv coordinates. By default `screenUV` is used.
* @return {Node<vec2>} The update uv coordinates.
*/
var viewportSafeUV$1 = /* @__PURE__ */ Fn$1(([uv$3 = null]) => {
	const depth$2 = linearDepth$1();
	return linearDepth$1(viewportDepthTexture$1(uv$3)).sub(depth$2).lessThan(0).select(screenUV$1, uv$3);
});
/**
* Can be used to compute texture coordinates for animated sprite sheets.
*
* ```js
* const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );
*
* material.colorNode = texture( spriteSheet, uvNode );
* ```
*
* @augments Node
*/
var SpriteSheetUVNode = class extends Node {
	static get type() {
		return "SpriteSheetUVNode";
	}
	/**
	* Constructs a new sprite sheet uv node.
	*
	* @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
	* @param {Node<vec2>} [uvNode=uv()] - The uv node.
	* @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
	*/
	constructor(countNode, uvNode = uv$1$1(), frameNode = float$1(0)) {
		super("vec2");
		/**
		* The node that defines the number of sprites in the x and y direction (e.g 6x6).
		*
		* @type {Node<vec2>}
		*/
		this.countNode = countNode;
		/**
		* The uv node.
		*
		* @type {Node<vec2>}
		*/
		this.uvNode = uvNode;
		/**
		* The node that defines the current frame/sprite.
		*
		* @type {Node<float>}
		*/
		this.frameNode = frameNode;
	}
	setup() {
		const { frameNode, uvNode, countNode } = this;
		const { width, height } = countNode;
		const frameNum = frameNode.mod(width.mul(height)).floor();
		const column = frameNum.mod(width);
		const row = height.sub(frameNum.add(1).div(width).ceil());
		const scale$3 = countNode.reciprocal();
		const uvFrameOffset = vec2$1(column, row);
		return uvNode.add(uvFrameOffset).mul(scale$3);
	}
};
/**
* TSL function for creating a sprite sheet uv node.
*
* @tsl
* @function
* @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
* @param {?Node<vec2>} [uvNode=uv()] - The uv node.
* @param {?Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
* @returns {SpriteSheetUVNode}
*/
var spritesheetUV$1 = /* @__PURE__ */ nodeProxy$1(SpriteSheetUVNode).setParameterLength(3);
/**
* TSL function for creating a triplanar textures node.
*
* Can be used for triplanar texture mapping.
*
* ```js
* material.colorNode = triplanarTexture( texture( diffuseMap ) );
* ```
*
* @tsl
* @function
* @param {Node} textureXNode - First texture node.
* @param {?Node} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.
* @param {?Node} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.
* @param {?Node<float>} [scaleNode=float(1)] - The scale node.
* @param {?Node<vec3>} [positionNode=positionLocal] - Vertex positions in local space.
* @param {?Node<vec3>} [normalNode=normalLocal] - Normals in local space.
* @returns {Node<vec4>}
*/
var triplanarTextures$1 = /* @__PURE__ */ Fn$1(([textureXNode, textureYNode = null, textureZNode = null, scaleNode = float$1(1), positionNode = positionLocal$1, normalNode = normalLocal$1]) => {
	let bf = normalNode.abs().normalize();
	bf = bf.div(bf.dot(vec3$1(1)));
	const tx = positionNode.yz.mul(scaleNode);
	const ty = positionNode.zx.mul(scaleNode);
	const tz = positionNode.xy.mul(scaleNode);
	const textureX = textureXNode.value;
	const textureY = textureYNode !== null ? textureYNode.value : textureX;
	const textureZ = textureZNode !== null ? textureZNode.value : textureX;
	const cx = texture$1(textureX, tx).mul(bf.x);
	const cy = texture$1(textureY, ty).mul(bf.y);
	const cz = texture$1(textureZ, tz).mul(bf.z);
	return add$1(cx, cy, cz);
});
/**
* TSL function for creating a triplanar textures node.
*
* @tsl
* @function
* @param {Node} textureXNode - First texture node.
* @param {?Node} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.
* @param {?Node} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.
* @param {?Node<float>} [scaleNode=float(1)] - The scale node.
* @param {?Node<vec3>} [positionNode=positionLocal] - Vertex positions in local space.
* @param {?Node<vec3>} [normalNode=normalLocal] - Normals in local space.
* @returns {Node<vec4>}
*/
var triplanarTexture$1 = (...params) => triplanarTextures$1(...params);
var _reflectorPlane = new Plane();
var _normal = new Vector3();
var _reflectorWorldPosition = new Vector3();
var _cameraWorldPosition = new Vector3();
var _rotationMatrix = new Matrix4();
var _lookAtPosition = new Vector3(0, 0, -1);
var clipPlane = new Vector4();
var _view = new Vector3();
var _target = new Vector3();
var _q = new Vector4();
var _size$2 = new Vector2();
var _defaultRT = new RenderTarget();
var _defaultUV = screenUV$1.flipX();
_defaultRT.depthTexture = new DepthTexture(1, 1);
var _inReflector = false;
/**
* This node can be used to implement mirror-like flat reflective surfaces.
*
* ```js
* const groundReflector = reflector();
* material.colorNode = groundReflector;
*
* const plane = new Mesh( geometry, material );
* plane.add( groundReflector.target );
* ```
*
* @augments TextureNode
*/
var ReflectorNode = class ReflectorNode extends TextureNode {
	static get type() {
		return "ReflectorNode";
	}
	/**
	* Constructs a new reflector node.
	*
	* @param {Object} [parameters={}] - An object holding configuration parameters.
	* @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
	* @param {number} [parameters.resolutionScale=1] - The resolution scale.
	* @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
	* @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
	* @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
	* @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
	* @param {TextureNode} [parameters.defaultTexture] - The default texture node.
	* @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
	*/
	constructor(parameters = {}) {
		super(parameters.defaultTexture || _defaultRT.texture, _defaultUV);
		/**
		* A reference to the internal reflector base node which holds the actual implementation.
		*
		* @private
		* @type {ReflectorBaseNode}
		* @default ReflectorBaseNode
		*/
		this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode(this, parameters);
		/**
		* A reference to the internal depth node.
		*
		* @private
		* @type {?Node}
		* @default null
		*/
		this._depthNode = null;
		this.setUpdateMatrix(false);
	}
	/**
	* A reference to the internal reflector node.
	*
	* @type {ReflectorBaseNode}
	*/
	get reflector() {
		return this._reflectorBaseNode;
	}
	/**
	* A reference to 3D object the reflector is linked to.
	*
	* @type {Object3D}
	*/
	get target() {
		return this._reflectorBaseNode.target;
	}
	/**
	* Returns a node representing the mirror's depth. That can be used
	* to implement more advanced reflection effects like distance attenuation.
	*
	* @return {Node} The depth node.
	*/
	getDepthNode() {
		if (this._depthNode === null) {
			if (this._reflectorBaseNode.depth !== true) throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");
			this._depthNode = nodeObject$1(new ReflectorNode({
				defaultTexture: _defaultRT.depthTexture,
				reflector: this._reflectorBaseNode
			}));
		}
		return this._depthNode;
	}
	setup(builder) {
		if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);
		return super.setup(builder);
	}
	clone() {
		const newNode = new this.constructor(this.reflectorNode);
		newNode.uvNode = this.uvNode;
		newNode.levelNode = this.levelNode;
		newNode.biasNode = this.biasNode;
		newNode.sampler = this.sampler;
		newNode.depthNode = this.depthNode;
		newNode.compareNode = this.compareNode;
		newNode.gradNode = this.gradNode;
		newNode.offsetNode = this.offsetNode;
		newNode._reflectorBaseNode = this._reflectorBaseNode;
		return newNode;
	}
	/**
	* Frees internal resources. Should be called when the node is no longer in use.
	*/
	dispose() {
		super.dispose();
		this._reflectorBaseNode.dispose();
	}
};
/**
* Holds the actual implementation of the reflector.
*
* TODO: Explain why `ReflectorBaseNode`. Originally the entire logic was implemented
* in `ReflectorNode`, see #29619.
*
* @private
* @augments Node
*/
var ReflectorBaseNode = class extends Node {
	static get type() {
		return "ReflectorBaseNode";
	}
	/**
	* Constructs a new reflector base node.
	*
	* @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.
	* @param {Object} [parameters={}] - An object holding configuration parameters.
	* @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
	* @param {number} [parameters.resolutionScale=1] - The resolution scale.
	* @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
	* @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
	* @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
	* @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
	*/
	constructor(textureNode, parameters = {}) {
		super();
		const { target = new Object3D(), resolutionScale = 1, generateMipmaps = false, bounces = true, depth: depth$2 = false, samples = 0 } = parameters;
		/**
		* Represents the rendered reflections as a texture node.
		*
		* @type {TextureNode}
		*/
		this.textureNode = textureNode;
		/**
		* The 3D object the reflector is linked to.
		*
		* @type {Object3D}
		* @default {new Object3D()}
		*/
		this.target = target;
		/**
		* The resolution scale.
		*
		* @type {number}
		* @default {1}
		*/
		this.resolutionScale = resolutionScale;
		if (parameters.resolution !== void 0) {
			warnOnce("ReflectorNode: The \"resolution\" parameter has been renamed to \"resolutionScale\".");
			this.resolutionScale = parameters.resolution;
		}
		/**
		* Whether mipmaps should be generated or not.
		*
		* @type {boolean}
		* @default {false}
		*/
		this.generateMipmaps = generateMipmaps;
		/**
		* Whether reflectors can render other reflector nodes or not.
		*
		* @type {boolean}
		* @default {true}
		*/
		this.bounces = bounces;
		/**
		* Whether depth data should be generated or not.
		*
		* @type {boolean}
		* @default {false}
		*/
		this.depth = depth$2;
		/**
		* The number of anti-aliasing samples for the render-target
		*
		* @type {number}
		* @default {0}
		*/
		this.samples = samples;
		/**
		* The `updateBeforeType` is set to `NodeUpdateType.RENDER` when {@link ReflectorBaseNode#bounces}
		* is `true`. Otherwise it's `NodeUpdateType.FRAME`.
		*
		* @type {string}
		* @default 'render'
		*/
		this.updateBeforeType = bounces ? NodeUpdateType$1.RENDER : NodeUpdateType$1.FRAME;
		/**
		* Weak map for managing virtual cameras.
		*
		* @type {WeakMap<Camera, Camera>}
		*/
		this.virtualCameras = /* @__PURE__ */ new WeakMap();
		/**
		* Weak map for managing render targets.
		*
		* @type {Map<Camera, RenderTarget>}
		*/
		this.renderTargets = /* @__PURE__ */ new Map();
		/**
		* Force render even if reflector is facing away from camera.
		*
		* @type {boolean}
		* @default {false}
		*/
		this.forceUpdate = false;
		/**
		* Whether the reflector has been rendered or not.
		*
		* When the reflector is facing away from the camera,
		* this flag is set to `false` and the texture will be empty(black).
		*
		* @type {boolean}
		* @default {false}
		*/
		this.hasOutput = false;
	}
	/**
	* Updates the resolution of the internal render target.
	*
	* @private
	* @param {RenderTarget} renderTarget - The render target to resize.
	* @param {Renderer} renderer - The renderer that is used to determine the new size.
	*/
	_updateResolution(renderTarget, renderer) {
		const resolution = this.resolutionScale;
		renderer.getDrawingBufferSize(_size$2);
		renderTarget.setSize(Math.round(_size$2.width * resolution), Math.round(_size$2.height * resolution));
	}
	setup(builder) {
		this._updateResolution(_defaultRT, builder.renderer);
		return super.setup(builder);
	}
	/**
	* Frees internal resources. Should be called when the node is no longer in use.
	*/
	dispose() {
		super.dispose();
		for (const renderTarget of this.renderTargets.values()) renderTarget.dispose();
	}
	/**
	* Returns a virtual camera for the given camera. The virtual camera is used to
	* render the scene from the reflector's view so correct reflections can be produced.
	*
	* @param {Camera} camera - The scene's camera.
	* @return {Camera} The corresponding virtual camera.
	*/
	getVirtualCamera(camera) {
		let virtualCamera = this.virtualCameras.get(camera);
		if (virtualCamera === void 0) {
			virtualCamera = camera.clone();
			this.virtualCameras.set(camera, virtualCamera);
		}
		return virtualCamera;
	}
	/**
	* Returns a render target for the given camera. The reflections are rendered
	* into this render target.
	*
	* @param {Camera} camera - The scene's camera.
	* @return {RenderTarget} The render target.
	*/
	getRenderTarget(camera) {
		let renderTarget = this.renderTargets.get(camera);
		if (renderTarget === void 0) {
			renderTarget = new RenderTarget(0, 0, {
				type: HalfFloatType,
				samples: this.samples
			});
			if (this.generateMipmaps === true) {
				renderTarget.texture.minFilter = LinearMipMapLinearFilter;
				renderTarget.texture.generateMipmaps = true;
			}
			if (this.depth === true) renderTarget.depthTexture = new DepthTexture();
			this.renderTargets.set(camera, renderTarget);
		}
		return renderTarget;
	}
	updateBefore(frame) {
		if (this.bounces === false && _inReflector) return false;
		_inReflector = true;
		const { scene, camera, renderer, material } = frame;
		const { target } = this;
		const virtualCamera = this.getVirtualCamera(camera);
		const renderTarget = this.getRenderTarget(virtualCamera);
		renderer.getDrawingBufferSize(_size$2);
		this._updateResolution(renderTarget, renderer);
		_reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);
		_cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
		_rotationMatrix.extractRotation(target.matrixWorld);
		_normal.set(0, 0, 1);
		_normal.applyMatrix4(_rotationMatrix);
		_view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);
		const isFacingAway = _view.dot(_normal) > 0;
		let needsClear = false;
		if (isFacingAway === true && this.forceUpdate === false) {
			if (this.hasOutput === false) {
				_inReflector = false;
				return;
			}
			needsClear = true;
		}
		_view.reflect(_normal).negate();
		_view.add(_reflectorWorldPosition);
		_rotationMatrix.extractRotation(camera.matrixWorld);
		_lookAtPosition.set(0, 0, -1);
		_lookAtPosition.applyMatrix4(_rotationMatrix);
		_lookAtPosition.add(_cameraWorldPosition);
		_target.subVectors(_reflectorWorldPosition, _lookAtPosition);
		_target.reflect(_normal).negate();
		_target.add(_reflectorWorldPosition);
		virtualCamera.coordinateSystem = camera.coordinateSystem;
		virtualCamera.position.copy(_view);
		virtualCamera.up.set(0, 1, 0);
		virtualCamera.up.applyMatrix4(_rotationMatrix);
		virtualCamera.up.reflect(_normal);
		virtualCamera.lookAt(_target);
		virtualCamera.near = camera.near;
		virtualCamera.far = camera.far;
		virtualCamera.updateMatrixWorld();
		virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
		_reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);
		_reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
		clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);
		const projectionMatrix = virtualCamera.projectionMatrix;
		_q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
		_q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
		_q.z = -1;
		_q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
		clipPlane.multiplyScalar(1 / clipPlane.dot(_q));
		const clipBias = 0;
		projectionMatrix.elements[2] = clipPlane.x;
		projectionMatrix.elements[6] = clipPlane.y;
		projectionMatrix.elements[10] = renderer.coordinateSystem === WebGPUCoordinateSystem ? clipPlane.z - clipBias : clipPlane.z + 1 - clipBias;
		projectionMatrix.elements[14] = clipPlane.w;
		this.textureNode.value = renderTarget.texture;
		if (this.depth === true) this.textureNode.getDepthNode().value = renderTarget.depthTexture;
		material.visible = false;
		const currentRenderTarget = renderer.getRenderTarget();
		const currentMRT = renderer.getMRT();
		const currentAutoClear = renderer.autoClear;
		renderer.setMRT(null);
		renderer.setRenderTarget(renderTarget);
		renderer.autoClear = true;
		const previousName = scene.name;
		scene.name = (scene.name || "Scene") + " [ Reflector ]";
		if (needsClear) {
			renderer.clear();
			this.hasOutput = false;
		} else {
			renderer.render(scene, virtualCamera);
			this.hasOutput = true;
		}
		scene.name = previousName;
		renderer.setMRT(currentMRT);
		renderer.setRenderTarget(currentRenderTarget);
		renderer.autoClear = currentAutoClear;
		material.visible = true;
		_inReflector = false;
		this.forceUpdate = false;
	}
	/**
	* The resolution scale.
	*
	* @deprecated
	* @type {number}
	* @default {1}
	*/
	get resolution() {
		warnOnce("ReflectorNode: The \"resolution\" property has been renamed to \"resolutionScale\".");
		return this.resolutionScale;
	}
	set resolution(value) {
		warnOnce("ReflectorNode: The \"resolution\" property has been renamed to \"resolutionScale\".");
		this.resolutionScale = value;
	}
};
/**
* TSL function for creating a reflector node.
*
* @tsl
* @function
* @param {Object} [parameters={}] - An object holding configuration parameters.
* @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
* @param {number} [parameters.resolution=1] - The resolution scale.
* @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
* @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
* @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
* @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
* @param {TextureNode} [parameters.defaultTexture] - The default texture node.
* @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
* @returns {ReflectorNode}
*/
var reflector$1 = (parameters) => nodeObject$1(new ReflectorNode(parameters));
var _camera = /* @__PURE__ */ new OrthographicCamera(-1, 1, 1, -1, 0, 1);
/**
* The purpose of this special geometry is to fill the entire viewport with a single triangle.
*
* Reference: {@link https://github.com/mrdoob/three.js/pull/21358}
*
* @private
* @augments BufferGeometry
*/
var QuadGeometry = class extends BufferGeometry {
	/**
	* Constructs a new quad geometry.
	*
	* @param {boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.
	*/
	constructor(flipY = false) {
		super();
		const uv$3 = flipY === false ? [
			0,
			-1,
			0,
			1,
			2,
			1
		] : [
			0,
			2,
			0,
			0,
			2,
			0
		];
		this.setAttribute("position", new Float32BufferAttribute([
			-1,
			3,
			0,
			-1,
			-1,
			0,
			3,
			-1,
			0
		], 3));
		this.setAttribute("uv", new Float32BufferAttribute(uv$3, 2));
	}
};
var _geometry = /* @__PURE__ */ new QuadGeometry();
/**
* This module is a helper for passes which need to render a full
* screen effect which is quite common in context of post processing.
*
* The intended usage is to reuse a single quad mesh for rendering
* subsequent passes by just reassigning the `material` reference.
*
* Note: This module can only be used with `WebGPURenderer`.
*
* @augments Mesh
*/
var QuadMesh = class extends Mesh {
	/**
	* Constructs a new quad mesh.
	*
	* @param {?Material} [material=null] - The material to render the quad mesh with.
	*/
	constructor(material = null) {
		super(_geometry, material);
		/**
		* The camera to render the quad mesh with.
		*
		* @type {OrthographicCamera}
		* @readonly
		*/
		this.camera = _camera;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isQuadMesh = true;
	}
	/**
	* Async version of `render()`.
	*
	* @async
	* @deprecated
	* @param {Renderer} renderer - The renderer.
	* @return {Promise} A Promise that resolves when the render has been finished.
	*/
	async renderAsync(renderer) {
		warnOnce("QuadMesh: \"renderAsync()\" has been deprecated. Use \"render()\" and \"await renderer.init();\" when creating the renderer.");
		await renderer.init();
		renderer.render(this, _camera);
	}
	/**
	* Renders the quad mesh
	*
	* @param {Renderer} renderer - The renderer.
	*/
	render(renderer) {
		renderer.render(this, _camera);
	}
};
var _size$1 = /* @__PURE__ */ new Vector2();
/**
* `RTTNode` takes another node and uses it with a `QuadMesh` to render into a texture (RTT).
* This module is especially relevant in context of post processing where certain nodes require
* texture input for their effects. With the helper function `convertToTexture()` which is based
* on this module, the node system can automatically ensure texture input if required.
*
* @augments TextureNode
*/
var RTTNode = class extends TextureNode {
	static get type() {
		return "RTTNode";
	}
	/**
	* Constructs a new RTT node.
	*
	* @param {Node} node - The node to render a texture with.
	* @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
	* @param {?number} [height=null] - The height of the internal render target.
	* @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
	*/
	constructor(node, width = null, height = null, options = { type: HalfFloatType }) {
		const renderTarget = new RenderTarget(width, height, options);
		super(renderTarget.texture, uv$1$1());
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isRTTNode = true;
		/**
		* The node to render a texture with.
		*
		* @type {Node}
		*/
		this.node = node;
		/**
		* The width of the internal render target.
		* If not width is applied, the render target is automatically resized.
		*
		* @type {?number}
		* @default null
		*/
		this.width = width;
		/**
		* The height of the internal render target.
		*
		* @type {?number}
		* @default null
		*/
		this.height = height;
		/**
		* The pixel ratio
		*
		* @type {number}
		* @default 1
		*/
		this.pixelRatio = 1;
		/**
		* The render target
		*
		* @type {RenderTarget}
		*/
		this.renderTarget = renderTarget;
		/**
		* Whether the texture requires an update or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.textureNeedsUpdate = true;
		/**
		* Whether the texture should automatically be updated or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.autoUpdate = true;
		/**
		* The node which is used with the quad mesh for RTT.
		*
		* @private
		* @type {Node}
		* @default null
		*/
		this._rttNode = null;
		/**
		* The internal quad mesh for RTT.
		*
		* @private
		* @type {QuadMesh}
		*/
		this._quadMesh = new QuadMesh(new NodeMaterial());
		/**
		* The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
		* the texture once per render in its {@link RTTNode#updateBefore} method.
		*
		* @type {string}
		* @default 'render'
		*/
		this.updateBeforeType = NodeUpdateType$1.RENDER;
	}
	/**
	* Whether the internal render target should automatically be resized or not.
	*
	* @type {boolean}
	* @readonly
	* @default true
	*/
	get autoResize() {
		return this.width === null;
	}
	setup(builder) {
		this._rttNode = this.node.context(builder.getSharedContext());
		this._quadMesh.material.name = "RTT";
		this._quadMesh.material.needsUpdate = true;
		return super.setup(builder);
	}
	/**
	* Sets the size of the internal render target
	*
	* @param {number} width - The width to set.
	* @param {number} height - The width to set.
	*/
	setSize(width, height) {
		this.width = width;
		this.height = height;
		const effectiveWidth = width * this.pixelRatio;
		const effectiveHeight = height * this.pixelRatio;
		this.renderTarget.setSize(effectiveWidth, effectiveHeight);
		this.textureNeedsUpdate = true;
	}
	/**
	* Sets the pixel ratio. This will also resize the render target.
	*
	* @param {number} pixelRatio - The pixel ratio to set.
	*/
	setPixelRatio(pixelRatio) {
		this.pixelRatio = pixelRatio;
		this.setSize(this.width, this.height);
	}
	updateBefore({ renderer }) {
		if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;
		this.textureNeedsUpdate = false;
		if (this.autoResize === true) {
			const pixelRatio = renderer.getPixelRatio();
			const size = renderer.getSize(_size$1);
			const effectiveWidth = Math.floor(size.width * pixelRatio);
			const effectiveHeight = Math.floor(size.height * pixelRatio);
			if (effectiveWidth !== this.renderTarget.width || effectiveHeight !== this.renderTarget.height) {
				this.renderTarget.setSize(effectiveWidth, effectiveHeight);
				this.textureNeedsUpdate = true;
			}
		}
		let name = "RTT";
		if (this.node.name) name = this.node.name + " [ " + name + " ]";
		this._quadMesh.material.fragmentNode = this._rttNode;
		this._quadMesh.name = name;
		const currentRenderTarget = renderer.getRenderTarget();
		renderer.setRenderTarget(this.renderTarget);
		this._quadMesh.render(renderer);
		renderer.setRenderTarget(currentRenderTarget);
	}
	clone() {
		const newNode = new TextureNode(this.value, this.uvNode, this.levelNode);
		newNode.sampler = this.sampler;
		newNode.referenceNode = this;
		return newNode;
	}
};
/**
* TSL function for creating a RTT node.
*
* @tsl
* @function
* @param {Node} node - The node to render a texture with.
* @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
* @param {?number} [height=null] - The height of the internal render target.
* @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
* @returns {RTTNode}
*/
var rtt$1 = (node, ...params) => nodeObject$1(new RTTNode(nodeObject$1(node), ...params));
/**
* TSL function for converting nodes to textures nodes.
*
* @tsl
* @function
* @param {Node} node - The node to render a texture with.
* @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
* @param {?number} [height=null] - The height of the internal render target.
* @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
* @returns {RTTNode}
*/
var convertToTexture$1 = (node, ...params) => {
	if (node.isSampleNode || node.isTextureNode) return node;
	if (node.isPassNode) return node.getTextureNode();
	return rtt$1(node, ...params);
};
/**
* Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments
* depth value and the camera's inverse projection matrix.
*
* @tsl
* @function
* @param {Node<vec2>} screenPosition - The fragment's screen position expressed as uv coordinates.
* @param {Node<float>} depth - The fragment's depth value.
* @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.
* @return {Node<vec3>} The fragments position in view space.
*/
var getViewPosition$1 = /* @__PURE__ */ Fn$1(([screenPosition, depth$2, projectionMatrixInverse], builder) => {
	let clipSpacePosition;
	if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
		screenPosition = vec2$1(screenPosition.x, screenPosition.y.oneMinus()).mul(2).sub(1);
		clipSpacePosition = vec4$1(vec3$1(screenPosition, depth$2), 1);
	} else clipSpacePosition = vec4$1(vec3$1(screenPosition.x, screenPosition.y.oneMinus(), depth$2).mul(2).sub(1), 1);
	const viewSpacePosition = vec4$1(projectionMatrixInverse.mul(clipSpacePosition));
	return viewSpacePosition.xyz.div(viewSpacePosition.w);
});
/**
* Computes a screen position expressed as uv coordinates based on a fragment's position in view space
* and the camera's projection matrix
*
* @tsl
* @function
* @param {Node<vec3>} viewPosition - The fragments position in view space.
* @param {Node<mat4>} projectionMatrix - The camera's projection matrix.
* @return {Node<vec2>} The fragment's screen position expressed as uv coordinates.
*/
var getScreenPosition$1 = /* @__PURE__ */ Fn$1(([viewPosition, projectionMatrix]) => {
	const sampleClipPos = projectionMatrix.mul(vec4$1(viewPosition, 1));
	const sampleUv = sampleClipPos.xy.div(sampleClipPos.w).mul(.5).add(.5).toVar();
	return vec2$1(sampleUv.x, sampleUv.y.oneMinus());
});
/**
* Computes a normal vector based on depth data. Can be used as a fallback when no normal render
* target is available or if flat surface normals are required.
*
* @tsl
* @function
* @param {Node<vec2>} uv - The texture coordinate.
* @param {DepthTexture} depthTexture - The depth texture.
* @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.
* @return {Node<vec3>} The computed normal vector.
*/
var getNormalFromDepth$1 = /* @__PURE__ */ Fn$1(([uv$3, depthTexture, projectionMatrixInverse]) => {
	const size = textureSize$1(textureLoad$1(depthTexture));
	const p$1 = ivec2$1(uv$3.mul(size)).toVar();
	const c0 = textureLoad$1(depthTexture, p$1).toVar();
	const l2 = textureLoad$1(depthTexture, p$1.sub(ivec2$1(2, 0))).toVar();
	const l1 = textureLoad$1(depthTexture, p$1.sub(ivec2$1(1, 0))).toVar();
	const r1 = textureLoad$1(depthTexture, p$1.add(ivec2$1(1, 0))).toVar();
	const r2 = textureLoad$1(depthTexture, p$1.add(ivec2$1(2, 0))).toVar();
	const b2 = textureLoad$1(depthTexture, p$1.add(ivec2$1(0, 2))).toVar();
	const b1 = textureLoad$1(depthTexture, p$1.add(ivec2$1(0, 1))).toVar();
	const t1 = textureLoad$1(depthTexture, p$1.sub(ivec2$1(0, 1))).toVar();
	const t2 = textureLoad$1(depthTexture, p$1.sub(ivec2$1(0, 2))).toVar();
	const dl = abs$1(sub$1(float$1(2).mul(l1).sub(l2), c0)).toVar();
	const dr = abs$1(sub$1(float$1(2).mul(r1).sub(r2), c0)).toVar();
	const db = abs$1(sub$1(float$1(2).mul(b1).sub(b2), c0)).toVar();
	const dt = abs$1(sub$1(float$1(2).mul(t1).sub(t2), c0)).toVar();
	const ce = getViewPosition$1(uv$3, c0, projectionMatrixInverse).toVar();
	const dpdx = dl.lessThan(dr).select(ce.sub(getViewPosition$1(uv$3.sub(vec2$1(float$1(1).div(size.x), 0)), l1, projectionMatrixInverse)), ce.negate().add(getViewPosition$1(uv$3.add(vec2$1(float$1(1).div(size.x), 0)), r1, projectionMatrixInverse)));
	const dpdy = db.lessThan(dt).select(ce.sub(getViewPosition$1(uv$3.add(vec2$1(0, float$1(1).div(size.y))), b1, projectionMatrixInverse)), ce.negate().add(getViewPosition$1(uv$3.sub(vec2$1(0, float$1(1).div(size.y))), t1, projectionMatrixInverse)));
	return normalize$1(cross$1(dpdx, dpdy));
});
/**
* Interleaved Gradient Noise (IGN) from Jimenez 2014.
*
* IGN has "low discrepancy" resulting in evenly distributed samples. It's superior compared to
* default white noise, blue noise or Bayer.
*
* References:
* - {@link https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/}
* - {@link https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/}
*
* @tsl
* @function
* @param {Node<vec2>} position - The input position, usually screen coordinates.
* @return {Node<float>} The noise value.
*/
var interleavedGradientNoise$1 = Fn$1(([position]) => {
	return fract$1(float$1(52.9829189).mul(fract$1(dot$1(position, vec2$1(.06711056, .00583715)))));
}).setLayout({
	name: "interleavedGradientNoise",
	type: "float",
	inputs: [{
		name: "position",
		type: "vec2"
	}]
});
/**
* Class representing a node that samples a value using a provided callback function.
*
* @extends Node
*/
var SampleNode = class extends Node {
	/**
	* Returns the type of the node.
	*
	* @type {string}
	* @readonly
	* @static
	*/
	static get type() {
		return "SampleNode";
	}
	/**
	* Creates an instance of SampleNode.
	*
	* @param {Function} callback - The function to be called when sampling. Should accept a UV node and return a value.
	* @param {?Node<vec2>} [uvNode=null] - The UV node to be used in the texture sampling.
	*/
	constructor(callback, uvNode = null) {
		super();
		this.callback = callback;
		/**
		* Represents the texture coordinates.
		*
		* @type {?Node<vec2|vec3>}
		* @default null
		*/
		this.uvNode = uvNode;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSampleNode = true;
	}
	/**
	* Sets up the node by sampling with the default UV accessor.
	*
	* @returns {Node} The result of the callback function when called with the UV node.
	*/
	setup() {
		return this.sample(uv$1$1());
	}
	/**
	* Calls the callback function with the provided UV node.
	*
	* @param {Node<vec2>} uv - The UV node or value to be passed to the callback.
	* @returns {Node} The result of the callback function.
	*/
	sample(uv$3) {
		return this.callback(uv$3);
	}
};
/**
* Helper function to create a SampleNode wrapped as a node object.
*
* @function
* @param {Function} callback - The function to be called when sampling. Should accept a UV node and return a value.
* @param {?Node<vec2>} [uv=null] - The UV node to be used in the texture sampling.
* @returns {SampleNode} The created SampleNode instance wrapped as a node object.
*/
var sample$1 = (callback, uv$3 = null) => nodeObject$1(new SampleNode(callback, nodeObject$1(uv$3)));
/**
* EventNode is a node that executes a callback during specific update phases.
*
* @augments Node
*/
var EventNode = class EventNode extends Node {
	static get type() {
		return "EventNode";
	}
	/**
	* Creates an EventNode.
	*
	* @param {string} eventType - The type of event
	* @param {Function} callback - The callback to execute on update.
	*/
	constructor(eventType, callback) {
		super("void");
		this.eventType = eventType;
		this.callback = callback;
		if (eventType === EventNode.OBJECT) this.updateType = NodeUpdateType$1.OBJECT;
		else if (eventType === EventNode.MATERIAL) this.updateType = NodeUpdateType$1.RENDER;
		else if (eventType === EventNode.BEFORE_OBJECT) this.updateBeforeType = NodeUpdateType$1.OBJECT;
		else if (eventType === EventNode.BEFORE_MATERIAL) this.updateBeforeType = NodeUpdateType$1.RENDER;
	}
	update(frame) {
		this.callback(frame);
	}
	updateBefore(frame) {
		this.callback(frame);
	}
};
EventNode.OBJECT = "object";
EventNode.MATERIAL = "material";
EventNode.BEFORE_OBJECT = "beforeObject";
EventNode.BEFORE_MATERIAL = "beforeMaterial";
/**
* Helper to create an EventNode and add it to the stack.
*
* @param {string} type - The event type.
* @param {Function} callback - The callback function.
* @returns {EventNode}
*/
var createEvent = (type$1, callback) => nodeObject$1(new EventNode(type$1, callback)).toStack();
/**
* Creates an event that triggers a function every time an object (Mesh|Sprite) is rendered.
*
* The event will be bound to the declared TSL function `Fn()`; it must be declared within a `Fn()` or the JS function call must be inherited from one.
*
* @param {Function} callback - The callback function.
* @returns {EventNode}
*/
var OnObjectUpdate$1 = (callback) => createEvent(EventNode.OBJECT, callback);
/**
* Creates an event that triggers a function when the first object that uses the material is rendered.
*
* The event will be bound to the declared TSL function `Fn()`; it must be declared within a `Fn()` or the JS function call must be inherited from one.
*
* @param {Function} callback - The callback function.
* @returns {EventNode}
*/
var OnMaterialUpdate$1 = (callback) => createEvent(EventNode.MATERIAL, callback);
/**
* Creates an event that triggers a function before an object (Mesh|Sprite) is updated.
*
* The event will be bound to the declared TSL function `Fn()`; it must be declared within a `Fn()` or the JS function call must be inherited from one.
*
* @param {Function} callback - The callback function.
* @returns {EventNode}
*/
var OnBeforeObjectUpdate$1 = (callback) => createEvent(EventNode.BEFORE_OBJECT, callback);
/**
* Creates an event that triggers a function before the material is updated.
*
* The event will be bound to the declared TSL function `Fn()`; it must be declared within a `Fn()` or the JS function call must be inherited from one.
*
* @param {Function} callback - The callback function.
* @returns {EventNode}
*/
var OnBeforeMaterialUpdate$1 = (callback) => createEvent(EventNode.BEFORE_MATERIAL, callback);
/**
* This special type of instanced buffer attribute is intended for compute shaders.
* In earlier three.js versions it was only possible to update attribute data
* on the CPU via JavaScript and then upload the data to the GPU. With the
* new material system and renderer it is now possible to use compute shaders
* to compute the data for an attribute more efficiently on the GPU.
*
* The idea is to create an instance of this class and provide it as an input
* to {@link StorageBufferNode}.
*
* Note: This type of buffer attribute can only be used with `WebGPURenderer`.
*
* @augments InstancedBufferAttribute
*/
var StorageInstancedBufferAttribute = class extends InstancedBufferAttribute {
	/**
	* Constructs a new storage instanced buffer attribute.
	*
	* @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
	* The subsequent parameters are then obsolete.
	* @param {number} itemSize - The item size.
	* @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
	*/
	constructor(count, itemSize, typeClass = Float32Array) {
		const array$2 = ArrayBuffer.isView(count) ? count : new typeClass(count * itemSize);
		super(array$2, itemSize);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isStorageInstancedBufferAttribute = true;
	}
};
/**
* This special type of buffer attribute is intended for compute shaders.
* In earlier three.js versions it was only possible to update attribute data
* on the CPU via JavaScript and then upload the data to the GPU. With the
* new material system and renderer it is now possible to use compute shaders
* to compute the data for an attribute more efficiently on the GPU.
*
* The idea is to create an instance of this class and provide it as an input
* to {@link StorageBufferNode}.
*
* Note: This type of buffer attribute can only be used with `WebGPURenderer`.
*
* @augments BufferAttribute
*/
var StorageBufferAttribute = class extends BufferAttribute {
	/**
	* Constructs a new storage buffer attribute.
	*
	* @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
	* The subsequent parameters are then obsolete.
	* @param {number} itemSize - The item size.
	* @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
	*/
	constructor(count, itemSize, typeClass = Float32Array) {
		const array$2 = ArrayBuffer.isView(count) ? count : new typeClass(count * itemSize);
		super(array$2, itemSize);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isStorageBufferAttribute = true;
	}
};
/**
* TSL function for creating a storage buffer node with a configured `StorageBufferAttribute`.
*
* @tsl
* @function
* @param {number|TypedArray} count - The data count. It is also valid to pass a typed array as an argument.
* @param {string|Struct} [type='float'] - The data type.
* @returns {StorageBufferNode}
*/
var attributeArray$1 = (count, type$1 = "float") => {
	let itemSize, typedArray;
	if (type$1.isStruct === true) {
		itemSize = type$1.layout.getLength();
		typedArray = getTypedArrayFromType("float");
	} else {
		itemSize = getLengthFromType(type$1);
		typedArray = getTypedArrayFromType(type$1);
	}
	const buffer$2 = new StorageBufferAttribute(count, itemSize, typedArray);
	return storage$1(buffer$2, type$1, count);
};
/**
* TSL function for creating a storage buffer node with a configured `StorageInstancedBufferAttribute`.
*
* @tsl
* @function
* @param {number|TypedArray} count - The data count. It is also valid to pass a typed array as an argument.
* @param {string|Struct} [type='float'] - The data type.
* @returns {StorageBufferNode}
*/
var instancedArray$1 = (count, type$1 = "float") => {
	let itemSize, typedArray;
	if (type$1.isStruct === true) {
		itemSize = type$1.layout.getLength();
		typedArray = getTypedArrayFromType("float");
	} else {
		itemSize = getLengthFromType(type$1);
		typedArray = getTypedArrayFromType(type$1);
	}
	const buffer$2 = new StorageInstancedBufferAttribute(count, itemSize, typedArray);
	return storage$1(buffer$2, type$1, count);
};
/**
* A node for representing the uv coordinates of points.
*
* Can only be used with a WebGL backend. In WebGPU, point
* primitives always have the size of one pixel and can thus
* can't be used as sprite-like objects that display textures.
*
* @augments Node
*/
var PointUVNode = class extends Node {
	static get type() {
		return "PointUVNode";
	}
	/**
	* Constructs a new point uv node.
	*/
	constructor() {
		super("vec2");
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isPointUVNode = true;
	}
	generate() {
		return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
	}
};
/**
* TSL object that represents the uv coordinates of points.
*
* @tsl
* @type {PointUVNode}
*/
var pointUV$1 = /* @__PURE__ */ nodeImmutable$1(PointUVNode);
var _e1$2 = /* @__PURE__ */ new Euler();
var _m1$2 = /* @__PURE__ */ new Matrix4();
/**
* This module allows access to a collection of scene properties. The following predefined TSL objects
* are available for easier use:
*
* - `backgroundBlurriness`: A node that represents the scene's background blurriness.
* - `backgroundIntensity`: A node that represents the scene's background intensity.
* - `backgroundRotation`: A node that represents the scene's background rotation.
*
* @augments Node
*/
var SceneNode = class SceneNode extends Node {
	static get type() {
		return "SceneNode";
	}
	/**
	* Constructs a new scene node.
	*
	* @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.
	* @param {?Scene} [scene=null] - A reference to the scene.
	*/
	constructor(scope = SceneNode.BACKGROUND_BLURRINESS, scene = null) {
		super();
		/**
		* The scope defines the type of scene property that is accessed.
		*
		* @type {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')}
		*/
		this.scope = scope;
		/**
		* A reference to the scene that is going to be accessed.
		*
		* @type {?Scene}
		* @default null
		*/
		this.scene = scene;
	}
	/**
	* Depending on the scope, the method returns a different type of node that represents
	* the respective scene property.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Node} The output node.
	*/
	setup(builder) {
		const scope = this.scope;
		const scene = this.scene !== null ? this.scene : builder.scene;
		let output$2;
		if (scope === SceneNode.BACKGROUND_BLURRINESS) output$2 = reference$2("backgroundBlurriness", "float", scene);
		else if (scope === SceneNode.BACKGROUND_INTENSITY) output$2 = reference$2("backgroundIntensity", "float", scene);
		else if (scope === SceneNode.BACKGROUND_ROTATION) output$2 = uniform$1("mat4").setName("backgroundRotation").setGroup(renderGroup$1).onRenderUpdate(() => {
			const background = scene.background;
			if (background !== null && background.isTexture && background.mapping !== UVMapping) {
				_e1$2.copy(scene.backgroundRotation);
				_e1$2.x *= -1;
				_e1$2.y *= -1;
				_e1$2.z *= -1;
				_m1$2.makeRotationFromEuler(_e1$2);
			} else _m1$2.identity();
			return _m1$2;
		});
		else error("SceneNode: Unknown scope:", scope);
		return output$2;
	}
};
SceneNode.BACKGROUND_BLURRINESS = "backgroundBlurriness";
SceneNode.BACKGROUND_INTENSITY = "backgroundIntensity";
SceneNode.BACKGROUND_ROTATION = "backgroundRotation";
/**
* TSL object that represents the scene's background blurriness.
*
* @tsl
* @type {SceneNode}
*/
var backgroundBlurriness$1 = /* @__PURE__ */ nodeImmutable$1(SceneNode, SceneNode.BACKGROUND_BLURRINESS);
/**
* TSL object that represents the scene's background intensity.
*
* @tsl
* @type {SceneNode}
*/
var backgroundIntensity$1 = /* @__PURE__ */ nodeImmutable$1(SceneNode, SceneNode.BACKGROUND_INTENSITY);
/**
* TSL object that represents the scene's background rotation.
*
* @tsl
* @type {SceneNode}
*/
var backgroundRotation$1 = /* @__PURE__ */ nodeImmutable$1(SceneNode, SceneNode.BACKGROUND_ROTATION);
/**
* This special version of a texture node can be used to
* write data into a storage texture with a compute shader.
*
* ```js
* const storageTexture = new THREE.StorageTexture( width, height );
*
* const computeTexture = Fn( ( { storageTexture } ) => {
*
* 	const posX = instanceIndex.mod( width );
* 	const posY = instanceIndex.div( width );
* 	const indexUV = uvec2( posX, posY );
*
* 	// generate RGB values
*
* 	const r = 1;
* 	const g = 1;
* 	const b = 1;
*
* 	textureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();
*
* } );
*
* const computeNode = computeTexture( { storageTexture } ).compute( width * height );
* renderer.computeAsync( computeNode );
* ```
*
* This node can only be used with a WebGPU backend.
*
* @augments TextureNode
*/
var StorageTextureNode = class extends TextureNode {
	static get type() {
		return "StorageTextureNode";
	}
	/**
	* Constructs a new storage texture node.
	*
	* @param {StorageTexture} value - The storage texture.
	* @param {Node<vec2|vec3>} uvNode - The uv node.
	* @param {?Node} [storeNode=null] - The value node that should be stored in the texture.
	*/
	constructor(value, uvNode, storeNode = null) {
		super(value, uvNode);
		/**
		* The value node that should be stored in the texture.
		*
		* @type {?Node}
		* @default null
		*/
		this.storeNode = storeNode;
		/**
		* The mip level to write to for storage textures.
		*
		* @type {number}
		* @default 0
		*/
		this.mipLevel = 0;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isStorageTextureNode = true;
		/**
		* The access type of the texture node.
		*
		* @type {string}
		* @default 'writeOnly'
		*/
		this.access = NodeAccess$1.WRITE_ONLY;
	}
	/**
	* Overwrites the default implementation to return a fixed value `'storageTexture'`.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType() {
		return "storageTexture";
	}
	setup(builder) {
		super.setup(builder);
		const properties = builder.getNodeProperties(this);
		properties.storeNode = this.storeNode;
		return properties;
	}
	/**
	* Defines the node access.
	*
	* @param {string} value - The node access.
	* @return {StorageTextureNode} A reference to this node.
	*/
	setAccess(value) {
		this.access = value;
		return this;
	}
	/**
	* Sets the mip level to write to.
	*
	* @param {number} level - The mip level.
	* @return {StorageTextureNode} A reference to this node.
	*/
	setMipLevel(level) {
		this.mipLevel = level;
		return this;
	}
	/**
	* Generates the code snippet of the storage node. If no `storeNode`
	* is defined, the texture node is generated as normal texture.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} output - The current output.
	* @return {string} The generated code snippet.
	*/
	generate(builder, output$2) {
		let snippet;
		if (this.storeNode !== null) snippet = this.generateStore(builder);
		else snippet = super.generate(builder, output$2);
		return snippet;
	}
	/**
	* Convenience method for configuring a read/write node access.
	*
	* @return {StorageTextureNode} A reference to this node.
	*/
	toReadWrite() {
		return this.setAccess(NodeAccess$1.READ_WRITE);
	}
	/**
	* Convenience method for configuring a read-only node access.
	*
	* @return {StorageTextureNode} A reference to this node.
	*/
	toReadOnly() {
		return this.setAccess(NodeAccess$1.READ_ONLY);
	}
	/**
	* Convenience method for configuring a write-only node access.
	*
	* @return {StorageTextureNode} A reference to this node.
	*/
	toWriteOnly() {
		return this.setAccess(NodeAccess$1.WRITE_ONLY);
	}
	/**
	* Generates the code snippet of the storage texture node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	generateStore(builder) {
		const { uvNode, storeNode, depthNode } = builder.getNodeProperties(this);
		const textureProperty = super.generate(builder, "property");
		const uvSnippet = uvNode.build(builder, this.value.is3DTexture === true ? "uvec3" : "uvec2");
		const storeSnippet = storeNode.build(builder, "vec4");
		const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
		const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, depthSnippet, storeSnippet);
		builder.addLineFlowCode(snippet, this);
	}
	clone() {
		const newNode = super.clone();
		newNode.storeNode = this.storeNode;
		newNode.mipLevel = this.mipLevel;
		return newNode;
	}
};
/**
* TSL function for creating a storage texture node.
*
* @tsl
* @function
* @param {StorageTexture} value - The storage texture.
* @param {?Node<vec2|vec3>} uvNode - The uv node.
* @param {?Node} [storeNode=null] - The value node that should be stored in the texture.
* @returns {StorageTextureNode}
*/
var storageTexture$1 = /* @__PURE__ */ nodeProxy$1(StorageTextureNode).setParameterLength(1, 3);
/**
* TODO: Explain difference to `storageTexture()`.
*
* @tsl
* @function
* @param {StorageTexture} value - The storage texture.
* @param {Node<vec2|vec3>} uvNode - The uv node.
* @param {?Node} [storeNode=null] - The value node that should be stored in the texture.
* @returns {StorageTextureNode}
*/
var textureStore$1 = (value, uvNode, storeNode) => {
	const node = storageTexture$1(value, uvNode, storeNode);
	if (storeNode !== null) node.toStack();
	return node;
};
var normal = Fn$1(({ texture: texture$2, uv: uv$3 }) => {
	const epsilon = 1e-4;
	const ret = vec3$1().toVar();
	If$1(uv$3.x.lessThan(epsilon), () => {
		ret.assign(vec3$1(1, 0, 0));
	}).ElseIf(uv$3.y.lessThan(epsilon), () => {
		ret.assign(vec3$1(0, 1, 0));
	}).ElseIf(uv$3.z.lessThan(epsilon), () => {
		ret.assign(vec3$1(0, 0, 1));
	}).ElseIf(uv$3.x.greaterThan(1 - epsilon), () => {
		ret.assign(vec3$1(-1, 0, 0));
	}).ElseIf(uv$3.y.greaterThan(1 - epsilon), () => {
		ret.assign(vec3$1(0, -1, 0));
	}).ElseIf(uv$3.z.greaterThan(1 - epsilon), () => {
		ret.assign(vec3$1(0, 0, -1));
	}).Else(() => {
		const step$2 = .01;
		const x = texture$2.sample(uv$3.add(vec3$1(-step$2, 0, 0))).r.sub(texture$2.sample(uv$3.add(vec3$1(step$2, 0, 0))).r);
		const y = texture$2.sample(uv$3.add(vec3$1(0, -step$2, 0))).r.sub(texture$2.sample(uv$3.add(vec3$1(0, step$2, 0))).r);
		const z = texture$2.sample(uv$3.add(vec3$1(0, 0, -step$2))).r.sub(texture$2.sample(uv$3.add(vec3$1(0, 0, step$2))).r);
		ret.assign(vec3$1(x, y, z));
	});
	return ret.normalize();
});
/**
* This type of uniform node represents a 3D texture.
*
* @augments TextureNode
*/
var Texture3DNode = class extends TextureNode {
	static get type() {
		return "Texture3DNode";
	}
	/**
	* Constructs a new 3D texture node.
	*
	* @param {Data3DTexture} value - The 3D texture.
	* @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
	* @param {?Node<int>} [levelNode=null] - The level node.
	*/
	constructor(value, uvNode = null, levelNode = null) {
		super(value, uvNode, levelNode);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isTexture3DNode = true;
	}
	/**
	* Overwrites the default implementation to return a fixed value `'texture3D'`.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType() {
		return "texture3D";
	}
	/**
	* Returns a default uv node which is in context of 3D textures a three-dimensional
	* uv node.
	*
	* @return {Node<vec3>} The default uv node.
	*/
	getDefaultUV() {
		return vec3$1(.5, .5, .5);
	}
	/**
	* Overwritten with an empty implementation since the `updateMatrix` flag is ignored
	* for 3D textures. The uv transformation matrix is not applied to 3D textures.
	*
	* @param {boolean} value - The update toggle.
	*/
	setUpdateMatrix() {}
	/**
	* Overwrites the default implementation to return the unmodified uv node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node} uvNode - The uv node to setup.
	* @return {Node} The unmodified uv node.
	*/
	setupUV(builder, uvNode) {
		const texture$2 = this.value;
		if (builder.isFlipY() && (texture$2.isRenderTargetTexture === true || texture$2.isFramebufferTexture === true)) if (this.sampler) uvNode = uvNode.flipY();
		else uvNode = uvNode.setY(int$1(textureSize$1(this, this.levelNode).y).sub(uvNode.y).sub(1));
		return uvNode;
	}
	/**
	* Generates the uv code snippet.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node} uvNode - The uv node to generate code for.
	* @return {string} The generated code snippet.
	*/
	generateUV(builder, uvNode) {
		return uvNode.build(builder, this.sampler === true ? "vec3" : "ivec3");
	}
	/**
	* Generates the offset code snippet.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {Node} offsetNode - The offset node to generate code for.
	* @return {string} The generated code snippet.
	*/
	generateOffset(builder, offsetNode) {
		return offsetNode.build(builder, "ivec3");
	}
	/**
	* TODO.
	*
	* @param {Node<vec3>} uvNode - The uv node .
	* @return {Node<vec3>} TODO.
	*/
	normal(uvNode) {
		return normal({
			texture: this,
			uv: uvNode
		});
	}
};
/**
* TSL function for creating a 3D texture node.
*
* @tsl
* @function
* @param {Data3DTexture} value - The 3D texture.
* @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
* @param {?Node<int>} [levelNode=null] - The level node.
* @returns {Texture3DNode}
*/
var texture3D$1 = /* @__PURE__ */ nodeProxy$1(Texture3DNode).setParameterLength(1, 3);
/**
* A special type of reference node that allows to link values in
* `userData` fields to node objects.
* ```js
* sprite.userData.rotation = 1; // stores individual rotation per sprite
*
* const material = new THREE.SpriteNodeMaterial();
* material.rotationNode = userData( 'rotation', 'float' );
* ```
* Since `UserDataNode` is extended from {@link ReferenceNode}, the node value
* will automatically be updated when the `rotation` user data field changes.
*
* @augments ReferenceNode
*/
var UserDataNode = class extends ReferenceNode {
	static get type() {
		return "UserDataNode";
	}
	/**
	* Constructs a new user data node.
	*
	* @param {string} property - The property name that should be referenced by the node.
	* @param {string} inputType - The node data type of the reference.
	* @param {?Object} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
	*/
	constructor(property$2, inputType, userData$2 = null) {
		super(property$2, inputType, userData$2);
		/**
		* A reference to the `userData` object. If not provided, the `userData`
		* property of the 3D object that uses the node material is evaluated.
		*
		* @type {?Object}
		* @default null
		*/
		this.userData = userData$2;
	}
	/**
	* Overwritten to make sure {@link ReferenceNode#reference} points to the correct
	* `userData` field.
	*
	* @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.
	* @return {Object} A reference to the `userData` field.
	*/
	updateReference(state) {
		this.reference = this.userData !== null ? this.userData : state.object.userData;
		return this.reference;
	}
};
/**
* TSL function for creating a user data node.
*
* @tsl
* @function
* @param {string} name - The property name that should be referenced by the node.
* @param {string} inputType - The node data type of the reference.
* @param {?Object} userData - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
* @returns {UserDataNode}
*/
var userData$1 = (name, inputType, userData$2) => nodeObject$1(new UserDataNode(name, inputType, userData$2));
var _objectData = /* @__PURE__ */ new WeakMap();
/**
* A node for representing motion or velocity vectors. Foundation
* for advanced post processing effects like motion blur or TRAA.
*
* The node keeps track of the model, view and projection matrices
* of the previous frame and uses them to compute offsets in NDC space.
* These offsets represent the final velocity.
*
* @augments TempNode
*/
var VelocityNode = class extends TempNode {
	static get type() {
		return "VelocityNode";
	}
	/**
	* Constructs a new vertex color node.
	*/
	constructor() {
		super("vec2");
		/**
		* The current projection matrix.
		*
		* @type {?Matrix4}
		* @default null
		*/
		this.projectionMatrix = null;
		/**
		* Overwritten since velocity nodes are updated per object.
		*
		* @type {string}
		* @default 'object'
		*/
		this.updateType = NodeUpdateType$1.OBJECT;
		/**
		* Overwritten since velocity nodes save data after the update.
		*
		* @type {string}
		* @default 'object'
		*/
		this.updateAfterType = NodeUpdateType$1.OBJECT;
		/**
		* Uniform node representing the previous model matrix in world space.
		*
		* @type {UniformNode<mat4>}
		* @default null
		*/
		this.previousModelWorldMatrix = uniform$1(new Matrix4());
		/**
		* Uniform node representing the previous projection matrix.
		*
		* @type {UniformNode<mat4>}
		* @default null
		*/
		this.previousProjectionMatrix = uniform$1(new Matrix4()).setGroup(renderGroup$1);
		/**
		* Uniform node representing the previous view matrix.
		*
		* @type {UniformNode<mat4>}
		* @default null
		*/
		this.previousCameraViewMatrix = uniform$1(new Matrix4());
	}
	/**
	* Sets the given projection matrix.
	*
	* @param {Matrix4} projectionMatrix - The projection matrix to set.
	*/
	setProjectionMatrix(projectionMatrix) {
		this.projectionMatrix = projectionMatrix;
	}
	/**
	* Updates velocity specific uniforms.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update({ frameId: frameId$2, camera, object }) {
		const previousModelMatrix = getPreviousMatrix(object);
		this.previousModelWorldMatrix.value.copy(previousModelMatrix);
		const cameraData = getData(camera);
		if (cameraData.frameId !== frameId$2) {
			cameraData.frameId = frameId$2;
			if (cameraData.previousProjectionMatrix === void 0) {
				cameraData.previousProjectionMatrix = new Matrix4();
				cameraData.previousCameraViewMatrix = new Matrix4();
				cameraData.currentProjectionMatrix = new Matrix4();
				cameraData.currentCameraViewMatrix = new Matrix4();
				cameraData.previousProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
				cameraData.previousCameraViewMatrix.copy(camera.matrixWorldInverse);
			} else {
				cameraData.previousProjectionMatrix.copy(cameraData.currentProjectionMatrix);
				cameraData.previousCameraViewMatrix.copy(cameraData.currentCameraViewMatrix);
			}
			cameraData.currentProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
			cameraData.currentCameraViewMatrix.copy(camera.matrixWorldInverse);
			this.previousProjectionMatrix.value.copy(cameraData.previousProjectionMatrix);
			this.previousCameraViewMatrix.value.copy(cameraData.previousCameraViewMatrix);
		}
	}
	/**
	* Overwritten to updated velocity specific uniforms.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	updateAfter({ object }) {
		getPreviousMatrix(object).copy(object.matrixWorld);
	}
	/**
	* Implements the velocity computation based on the previous and current vertex data.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @return {Node<vec2>} The motion vector.
	*/
	setup() {
		const projectionMatrix = this.projectionMatrix === null ? cameraProjectionMatrix$1 : uniform$1(this.projectionMatrix);
		const previousModelViewMatrix = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix);
		const clipPositionCurrent = projectionMatrix.mul(modelViewMatrix$1).mul(positionLocal$1);
		const clipPositionPrevious = this.previousProjectionMatrix.mul(previousModelViewMatrix).mul(positionPrevious$1);
		const ndcPositionCurrent = clipPositionCurrent.xy.div(clipPositionCurrent.w);
		const ndcPositionPrevious = clipPositionPrevious.xy.div(clipPositionPrevious.w);
		return sub$1(ndcPositionCurrent, ndcPositionPrevious);
	}
};
function getData(object) {
	let objectData = _objectData.get(object);
	if (objectData === void 0) {
		objectData = {};
		_objectData.set(object, objectData);
	}
	return objectData;
}
function getPreviousMatrix(object, index = 0) {
	const objectData = getData(object);
	let matrix = objectData[index];
	if (matrix === void 0) {
		objectData[index] = matrix = new Matrix4();
		objectData[index].copy(object.matrixWorld);
	}
	return matrix;
}
/**
* TSL object that represents the velocity of a render pass.
*
* @tsl
* @type {VelocityNode}
*/
var velocity$1 = /* @__PURE__ */ nodeImmutable$1(VelocityNode);
/**
* Computes a grayscale value for the given RGB color value.
*
* @tsl
* @function
* @param {Node<vec3>} color - The color value to compute the grayscale for.
* @return {Node<vec3>} The grayscale color.
*/
var grayscale$1 = /* @__PURE__ */ Fn$1(([color$2]) => {
	return luminance$2(color$2.rgb);
});
/**
* Super-saturates or desaturates the given RGB color.
*
* @tsl
* @function
* @param {Node<vec3>} color - The input color.
* @param {Node<float>} [adjustment=1] - Specifies the amount of the conversion. A value under `1` desaturates the color, a value over `1` super-saturates it.
* @return {Node<vec3>} The saturated color.
*/
var saturation$1 = /* @__PURE__ */ Fn$1(([color$2, adjustment = float$1(1)]) => {
	return adjustment.mix(luminance$2(color$2.rgb), color$2.rgb);
});
/**
* Selectively enhance the intensity of less saturated RGB colors. Can result
* in a more natural and visually appealing image with enhanced color depth
* compared to {@link ColorAdjustment#saturation}.
*
* @tsl
* @function
* @param {Node<vec3>} color - The input color.
* @param {Node<float>} [adjustment=1] - Controls the intensity of the vibrance effect.
* @return {Node<vec3>} The updated color.
*/
var vibrance$1 = /* @__PURE__ */ Fn$1(([color$2, adjustment = float$1(1)]) => {
	const average = add$1(color$2.r, color$2.g, color$2.b).div(3);
	const mx = color$2.r.max(color$2.g.max(color$2.b));
	const amt = mx.sub(average).mul(adjustment).mul(-3);
	return mix$2(color$2.rgb, mx, amt);
});
/**
* Updates the hue component of the given RGB color while preserving its luminance and saturation.
*
* @tsl
* @function
* @param {Node<vec3>} color - The input color.
* @param {Node<float>} [adjustment=1] - Defines the degree of hue rotation in radians. A positive value rotates the hue clockwise, while a negative value rotates it counterclockwise.
* @return {Node<vec3>} The updated color.
*/
var hue$1 = /* @__PURE__ */ Fn$1(([color$2, adjustment = float$1(1)]) => {
	const k = vec3$1(.57735, .57735, .57735);
	const cosAngle = adjustment.cos();
	return vec3$1(color$2.rgb.mul(cosAngle).add(k.cross(color$2.rgb).mul(adjustment.sin()).add(k.mul(dot$1(k, color$2.rgb).mul(cosAngle.oneMinus())))));
});
/**
* Computes the luminance for the given RGB color value.
*
* @tsl
* @function
* @param {Node<vec3>} color - The color value to compute the luminance for.
* @param {?Node<vec3>} luminanceCoefficients - The luminance coefficients. By default predefined values of the current working color space are used.
* @return {Node<float>} The luminance.
*/
var luminance$2 = (color$2, luminanceCoefficients = vec3$1(ColorManagement.getLuminanceCoefficients(new Vector3()))) => dot$1(color$2, luminanceCoefficients);
/**
* Color Decision List (CDL) v1.2
*
* Compact representation of color grading information, defined by slope, offset, power, and
* saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,
* or AgX Log), and will return output in the same space. Output may require clamping >=0.
*
* @tsl
* @function
* @param {Node<vec4>} color Input (-Infinity < input < +Infinity)
* @param {Node<vec3>} slope Slope (0 ≤ slope < +Infinity)
* @param {Node<vec3>} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)
* @param {Node<vec3>} power Power (0 < power < +Infinity)
* @param {Node<float>} saturation Saturation (0 ≤ saturation < +Infinity; typically 0 ≤ saturation < 4)
* @param {Node<vec3>} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709
* @return {Node<vec4>} Output, -Infinity < output < +Infinity
*
* References:
* - ASC CDL v1.2
* - {@link https://blender.stackexchange.com/a/55239/43930}
* - {@link https://docs.acescentral.com/specifications/acescc/}
*/
var cdl$1 = /* @__PURE__ */ Fn$1(([color$2, slope = vec3$1(1), offset = vec3$1(0), power = vec3$1(1), saturation$2 = float$1(1), luminanceCoefficients = vec3$1(ColorManagement.getLuminanceCoefficients(new Vector3(), LinearSRGBColorSpace))]) => {
	const luma = color$2.rgb.dot(vec3$1(luminanceCoefficients));
	const v = max$1$1(color$2.rgb.mul(slope).add(offset), 0).toVar();
	const pv = v.pow(power).toVar();
	If$1(v.r.greaterThan(0), () => {
		v.r.assign(pv.r);
	});
	If$1(v.g.greaterThan(0), () => {
		v.g.assign(pv.g);
	});
	If$1(v.b.greaterThan(0), () => {
		v.b.assign(pv.b);
	});
	v.assign(luma.add(v.sub(luma).mul(saturation$2)));
	return vec4$1(v.rgb, color$2.a);
});
/**
* Represents a posterize effect which reduces the number of colors
* in an image, resulting in a more blocky and stylized appearance.
*
* @augments TempNode
*/
var PosterizeNode = class extends TempNode {
	static get type() {
		return "PosterizeNode";
	}
	/**
	* Constructs a new posterize node.
	*
	* @param {Node} sourceNode - The input color.
	* @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
	*/
	constructor(sourceNode, stepsNode) {
		super();
		/**
		* The input color.
		*
		* @type {Node}
		*/
		this.sourceNode = sourceNode;
		/**
		* Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
		*
		* @type {Node}
		*/
		this.stepsNode = stepsNode;
	}
	setup() {
		const { sourceNode, stepsNode } = this;
		return sourceNode.mul(stepsNode).floor().div(stepsNode);
	}
};
/**
* TSL function for creating a posterize node.
*
* @tsl
* @function
* @param {Node} sourceNode - The input color.
* @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
* @returns {PosterizeNode}
*/
var posterize$1 = /* @__PURE__ */ nodeProxy$1(PosterizeNode).setParameterLength(2);
var _size = /* @__PURE__ */ new Vector2();
/**
* Represents the texture of a pass node.
*
* @augments TextureNode
*/
var PassTextureNode = class extends TextureNode {
	static get type() {
		return "PassTextureNode";
	}
	/**
	* Constructs a new pass texture node.
	*
	* @param {PassNode} passNode - The pass node.
	* @param {Texture} texture - The output texture.
	*/
	constructor(passNode, texture$2) {
		super(texture$2);
		/**
		* A reference to the pass node.
		*
		* @type {PassNode}
		*/
		this.passNode = passNode;
		this.setUpdateMatrix(false);
	}
	setup(builder) {
		this.passNode.build(builder);
		return super.setup(builder);
	}
	clone() {
		return new this.constructor(this.passNode, this.value);
	}
};
/**
* An extension of `PassTextureNode` which allows to manage more than one
* internal texture. Relevant for the `getPreviousTexture()` related API.
*
* @augments PassTextureNode
*/
var PassMultipleTextureNode = class extends PassTextureNode {
	static get type() {
		return "PassMultipleTextureNode";
	}
	/**
	* Constructs a new pass texture node.
	*
	* @param {PassNode} passNode - The pass node.
	* @param {string} textureName - The output texture name.
	* @param {boolean} [previousTexture=false] - Whether previous frame data should be used or not.
	*/
	constructor(passNode, textureName, previousTexture = false) {
		super(passNode, null);
		/**
		* The output texture name.
		*
		* @type {string}
		*/
		this.textureName = textureName;
		/**
		* Whether previous frame data should be used or not.
		*
		* @type {boolean}
		*/
		this.previousTexture = previousTexture;
	}
	/**
	* Updates the texture reference of this node.
	*/
	updateTexture() {
		this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
	}
	setup(builder) {
		this.updateTexture();
		return super.setup(builder);
	}
	clone() {
		const newNode = new this.constructor(this.passNode, this.textureName, this.previousTexture);
		newNode.uvNode = this.uvNode;
		newNode.levelNode = this.levelNode;
		newNode.biasNode = this.biasNode;
		newNode.sampler = this.sampler;
		newNode.depthNode = this.depthNode;
		newNode.compareNode = this.compareNode;
		newNode.gradNode = this.gradNode;
		newNode.offsetNode = this.offsetNode;
		return newNode;
	}
};
/**
* Represents a render pass (sometimes called beauty pass) in context of post processing.
* This pass produces a render for the given scene and camera and can provide multiple outputs
* via MRT for further processing.
*
* ```js
* const postProcessing = new PostProcessing( renderer );
*
* const scenePass = pass( scene, camera );
*
* postProcessing.outputNode = scenePass;
* ```
*
* @augments TempNode
*/
var PassNode = class PassNode extends TempNode {
	static get type() {
		return "PassNode";
	}
	/**
	* Constructs a new pass node.
	*
	* @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.
	* @param {Scene} scene - A reference to the scene.
	* @param {Camera} camera - A reference to the camera.
	* @param {Object} options - Options for the internal render target.
	*/
	constructor(scope, scene, camera, options = {}) {
		super("vec4");
		/**
		* The scope of the pass. The scope determines whether the node outputs color or depth.
		*
		* @type {('color'|'depth')}
		*/
		this.scope = scope;
		/**
		* A reference to the scene.
		*
		* @type {Scene}
		*/
		this.scene = scene;
		/**
		* A reference to the camera.
		*
		* @type {Camera}
		*/
		this.camera = camera;
		/**
		* Options for the internal render target.
		*
		* @type {Object}
		*/
		this.options = options;
		/**
		* The pass's pixel ratio. Will be kept automatically kept in sync with the renderer's pixel ratio.
		*
		* @private
		* @type {number}
		* @default 1
		*/
		this._pixelRatio = 1;
		/**
		* The pass's pixel width. Will be kept automatically kept in sync with the renderer's width.
		* @private
		* @type {number}
		* @default 1
		*/
		this._width = 1;
		/**
		* The pass's pixel height. Will be kept automatically kept in sync with the renderer's height.
		* @private
		* @type {number}
		* @default 1
		*/
		this._height = 1;
		const depthTexture = new DepthTexture();
		depthTexture.isRenderTargetTexture = true;
		depthTexture.name = "depth";
		const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, {
			type: HalfFloatType,
			...options
		});
		renderTarget.texture.name = "output";
		renderTarget.depthTexture = depthTexture;
		/**
		* The pass's render target.
		*
		* @type {RenderTarget}
		*/
		this.renderTarget = renderTarget;
		/**
		* A dictionary holding the internal result textures.
		*
		* @private
		* @type {Object<string, Texture>}
		*/
		this._textures = {
			output: renderTarget.texture,
			depth: depthTexture
		};
		/**
		* A dictionary holding the internal texture nodes.
		*
		* @private
		* @type {Object<string, TextureNode>}
		*/
		this._textureNodes = {};
		/**
		* A dictionary holding the internal depth nodes.
		*
		* @private
		* @type {Object}
		*/
		this._linearDepthNodes = {};
		/**
		* A dictionary holding the internal viewZ nodes.
		*
		* @private
		* @type {Object}
		*/
		this._viewZNodes = {};
		/**
		* A dictionary holding the texture data of the previous frame.
		* Used for computing velocity/motion vectors.
		*
		* @private
		* @type {Object<string, Texture>}
		*/
		this._previousTextures = {};
		/**
		* A dictionary holding the texture nodes of the previous frame.
		* Used for computing velocity/motion vectors.
		*
		* @private
		* @type {Object<string, TextureNode>}
		*/
		this._previousTextureNodes = {};
		/**
		* The `near` property of the camera as a uniform.
		*
		* @private
		* @type {UniformNode}
		*/
		this._cameraNear = uniform$1(0);
		/**
		* The `far` property of the camera as a uniform.
		*
		* @private
		* @type {UniformNode}
		*/
		this._cameraFar = uniform$1(0);
		/**
		* A MRT node configuring the MRT settings.
		*
		* @private
		* @type {?MRTNode}
		* @default null
		*/
		this._mrt = null;
		/**
		* Layer object for configuring the camera that is used
		* to produce the pass.
		*
		* @private
		* @type {?Layers}
		* @default null
		*/
		this._layers = null;
		/**
		* Scales the resolution of the internal render target.
		*
		* @private
		* @type {number}
		* @default 1
		*/
		this._resolutionScale = 1;
		/**
		* Custom viewport definition.
		*
		* @private
		* @type {?Vector4}
		* @default null
		*/
		this._viewport = null;
		/**
		* Custom scissor definition.
		*
		* @private
		* @type {?Vector4}
		* @default null
		*/
		this._scissor = null;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isPassNode = true;
		/**
		* The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
		* scene once per frame in its {@link PassNode#updateBefore} method.
		*
		* @type {string}
		* @default 'frame'
		*/
		this.updateBeforeType = NodeUpdateType$1.FRAME;
		/**
		* This flag is used for global cache.
		*
		* @type {boolean}
		* @default true
		*/
		this.global = true;
	}
	/**
	* Sets the resolution scale for the pass.
	* The resolution scale is a factor that is multiplied with the renderer's width and height.
	*
	* @param {number} resolutionScale - The resolution scale to set. A value of `1` means full resolution.
	* @return {PassNode} A reference to this pass.
	*/
	setResolutionScale(resolutionScale) {
		this._resolutionScale = resolutionScale;
		return this;
	}
	/**
	* Gets the current resolution scale of the pass.
	*
	* @return {number} The current resolution scale. A value of `1` means full resolution.
	*/
	getResolutionScale() {
		return this._resolutionScale;
	}
	/**
	* Sets the resolution for the pass.
	* The resolution is a factor that is multiplied with the renderer's width and height.
	*
	* @param {number} resolution - The resolution to set. A value of `1` means full resolution.
	* @return {PassNode} A reference to this pass.
	* @deprecated since r181. Use {@link PassNode#setResolutionScale `setResolutionScale()`} instead.
	*/
	setResolution(resolution) {
		warn("PassNode: .setResolution() is deprecated. Use .setResolutionScale() instead.");
		return this.setResolutionScale(resolution);
	}
	/**
	* Gets the current resolution of the pass.
	*
	* @return {number} The current resolution. A value of `1` means full resolution.
	* @deprecated since r181. Use {@link PassNode#getResolutionScale `getResolutionScale()`} instead.
	*/
	getResolution() {
		warn("PassNode: .getResolution() is deprecated. Use .getResolutionScale() instead.");
		return this.getResolutionScale();
	}
	/**
	* Sets the layer configuration that should be used when rendering the pass.
	*
	* @param {Layers} layers - The layers object to set.
	* @return {PassNode} A reference to this pass.
	*/
	setLayers(layers) {
		this._layers = layers;
		return this;
	}
	/**
	* Gets the current layer configuration of the pass.
	*
	* @return {?Layers} .
	*/
	getLayers() {
		return this._layers;
	}
	/**
	* Sets the given MRT node to setup MRT for this pass.
	*
	* @param {MRTNode} mrt - The MRT object.
	* @return {PassNode} A reference to this pass.
	*/
	setMRT(mrt$2) {
		this._mrt = mrt$2;
		return this;
	}
	/**
	* Returns the current MRT node.
	*
	* @return {MRTNode} The current MRT node.
	*/
	getMRT() {
		return this._mrt;
	}
	/**
	* Returns the texture for the given output name.
	*
	* @param {string} name - The output name to get the texture for.
	* @return {Texture} The texture.
	*/
	getTexture(name) {
		let texture$2 = this._textures[name];
		if (texture$2 === void 0) {
			texture$2 = this.renderTarget.texture.clone();
			texture$2.name = name;
			this._textures[name] = texture$2;
			this.renderTarget.textures.push(texture$2);
		}
		return texture$2;
	}
	/**
	* Returns the texture holding the data of the previous frame for the given output name.
	*
	* @param {string} name - The output name to get the texture for.
	* @return {Texture} The texture holding the data of the previous frame.
	*/
	getPreviousTexture(name) {
		let texture$2 = this._previousTextures[name];
		if (texture$2 === void 0) {
			texture$2 = this.getTexture(name).clone();
			this._previousTextures[name] = texture$2;
		}
		return texture$2;
	}
	/**
	* Switches current and previous textures for the given output name.
	*
	* @param {string} name - The output name.
	*/
	toggleTexture(name) {
		const prevTexture = this._previousTextures[name];
		if (prevTexture !== void 0) {
			const texture$2 = this._textures[name];
			const index = this.renderTarget.textures.indexOf(texture$2);
			this.renderTarget.textures[index] = prevTexture;
			this._textures[name] = prevTexture;
			this._previousTextures[name] = texture$2;
			this._textureNodes[name].updateTexture();
			this._previousTextureNodes[name].updateTexture();
		}
	}
	/**
	* Returns the texture node for the given output name.
	*
	* @param {string} [name='output'] - The output name to get the texture node for.
	* @return {TextureNode} The texture node.
	*/
	getTextureNode(name = "output") {
		let textureNode = this._textureNodes[name];
		if (textureNode === void 0) {
			textureNode = nodeObject$1(new PassMultipleTextureNode(this, name));
			textureNode.updateTexture();
			this._textureNodes[name] = textureNode;
		}
		return textureNode;
	}
	/**
	* Returns the previous texture node for the given output name.
	*
	* @param {string} [name='output'] - The output name to get the previous texture node for.
	* @return {TextureNode} The previous texture node.
	*/
	getPreviousTextureNode(name = "output") {
		let textureNode = this._previousTextureNodes[name];
		if (textureNode === void 0) {
			if (this._textureNodes[name] === void 0) this.getTextureNode(name);
			textureNode = nodeObject$1(new PassMultipleTextureNode(this, name, true));
			textureNode.updateTexture();
			this._previousTextureNodes[name] = textureNode;
		}
		return textureNode;
	}
	/**
	* Returns a viewZ node of this pass.
	*
	* @param {string} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
	* @return {Node} The viewZ node.
	*/
	getViewZNode(name = "depth") {
		let viewZNode = this._viewZNodes[name];
		if (viewZNode === void 0) {
			const cameraNear$2 = this._cameraNear;
			const cameraFar$2 = this._cameraFar;
			this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ$1(this.getTextureNode(name), cameraNear$2, cameraFar$2);
		}
		return viewZNode;
	}
	/**
	* Returns a linear depth node of this pass.
	*
	* @param {string} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
	* @return {Node} The linear depth node.
	*/
	getLinearDepthNode(name = "depth") {
		let linearDepthNode = this._linearDepthNodes[name];
		if (linearDepthNode === void 0) {
			const cameraNear$2 = this._cameraNear;
			const cameraFar$2 = this._cameraFar;
			const viewZNode = this.getViewZNode(name);
			this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth$1(viewZNode, cameraNear$2, cameraFar$2);
		}
		return linearDepthNode;
	}
	/**
	* Precompiles the pass.
	*
	* Note that this method must be called after the pass configuration is complete.
	* So calls like `setMRT()` and `getTextureNode()` must proceed the precompilation.
	*
	* @async
	* @param {Renderer} renderer - The renderer.
	* @return {Promise} A Promise that resolves when the compile has been finished.
	* @see {@link Renderer#compileAsync}
	*/
	async compileAsync(renderer) {
		const currentRenderTarget = renderer.getRenderTarget();
		const currentMRT = renderer.getMRT();
		renderer.setRenderTarget(this.renderTarget);
		renderer.setMRT(this._mrt);
		await renderer.compileAsync(this.scene, this.camera);
		renderer.setRenderTarget(currentRenderTarget);
		renderer.setMRT(currentMRT);
	}
	setup({ renderer }) {
		this.renderTarget.samples = this.options.samples === void 0 ? renderer.samples : this.options.samples;
		this.renderTarget.texture.type = renderer.getColorBufferType();
		return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
	}
	updateBefore(frame) {
		const { renderer } = frame;
		const { scene } = this;
		let camera;
		let pixelRatio;
		const outputRenderTarget = renderer.getOutputRenderTarget();
		if (outputRenderTarget && outputRenderTarget.isXRRenderTarget === true) {
			pixelRatio = 1;
			camera = renderer.xr.getCamera();
			renderer.xr.updateCamera(camera);
			_size.set(outputRenderTarget.width, outputRenderTarget.height);
		} else {
			camera = this.camera;
			pixelRatio = renderer.getPixelRatio();
			renderer.getSize(_size);
		}
		this._pixelRatio = pixelRatio;
		this.setSize(_size.width, _size.height);
		const currentRenderTarget = renderer.getRenderTarget();
		const currentMRT = renderer.getMRT();
		const currentAutoClear = renderer.autoClear;
		const currentMask = camera.layers.mask;
		this._cameraNear.value = camera.near;
		this._cameraFar.value = camera.far;
		if (this._layers !== null) camera.layers.mask = this._layers.mask;
		for (const name in this._previousTextures) this.toggleTexture(name);
		renderer.setRenderTarget(this.renderTarget);
		renderer.setMRT(this._mrt);
		renderer.autoClear = true;
		const currentSceneName = scene.name;
		scene.name = this.name ? this.name : scene.name;
		renderer.render(scene, camera);
		scene.name = currentSceneName;
		renderer.setRenderTarget(currentRenderTarget);
		renderer.setMRT(currentMRT);
		renderer.autoClear = currentAutoClear;
		camera.layers.mask = currentMask;
	}
	/**
	* Sets the size of the pass's render target. Honors the pixel ratio.
	*
	* @param {number} width - The width to set.
	* @param {number} height - The height to set.
	*/
	setSize(width, height) {
		this._width = width;
		this._height = height;
		const effectiveWidth = Math.floor(this._width * this._pixelRatio * this._resolutionScale);
		const effectiveHeight = Math.floor(this._height * this._pixelRatio * this._resolutionScale);
		this.renderTarget.setSize(effectiveWidth, effectiveHeight);
		if (this._scissor !== null) this.renderTarget.scissor.copy(this._scissor);
		if (this._viewport !== null) this.renderTarget.viewport.copy(this._viewport);
	}
	/**
	* This method allows to define the pass's scissor rectangle. By default, the scissor rectangle is kept
	* in sync with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
	* with `null` as the single argument.
	*
	* @param {?(number | Vector4)} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
	* Instead of passing four arguments, the method also works with a single four-dimensional vector.
	* @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
	* @param {number} width - The width of the scissor box in logical pixel unit.
	* @param {number} height - The height of the scissor box in logical pixel unit.
	*/
	setScissor(x, y, width, height) {
		if (x === null) this._scissor = null;
		else {
			if (this._scissor === null) this._scissor = new Vector4();
			if (x.isVector4) this._scissor.copy(x);
			else this._scissor.set(x, y, width, height);
			this._scissor.multiplyScalar(this._pixelRatio * this._resolutionScale).floor();
		}
	}
	/**
	* This method allows to define the pass's viewport. By default, the viewport is kept in sync
	* with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
	* with `null` as the single argument.
	*
	* @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
	* @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
	* @param {number} width - The width of the viewport in logical pixel unit.
	* @param {number} height - The height of the viewport in logical pixel unit.
	*/
	setViewport(x, y, width, height) {
		if (x === null) this._viewport = null;
		else {
			if (this._viewport === null) this._viewport = new Vector4();
			if (x.isVector4) this._viewport.copy(x);
			else this._viewport.set(x, y, width, height);
			this._viewport.multiplyScalar(this._pixelRatio * this._resolutionScale).floor();
		}
	}
	/**
	* Sets the pixel ratio the pass's render target and updates the size.
	*
	* @param {number} pixelRatio - The pixel ratio to set.
	*/
	setPixelRatio(pixelRatio) {
		this._pixelRatio = pixelRatio;
		this.setSize(this._width, this._height);
	}
	/**
	* Frees internal resources. Should be called when the node is no longer in use.
	*/
	dispose() {
		this.renderTarget.dispose();
	}
};
/**
* @static
* @type {'color'}
* @default 'color'
*/
PassNode.COLOR = "color";
/**
* @static
* @type {'depth'}
* @default 'depth'
*/
PassNode.DEPTH = "depth";
/**
* TSL function for creating a pass node.
*
* @tsl
* @function
* @param {Scene} scene - A reference to the scene.
* @param {Camera} camera - A reference to the camera.
* @param {Object} options - Options for the internal render target.
* @returns {PassNode}
*/
var pass$1 = (scene, camera, options) => nodeObject$1(new PassNode(PassNode.COLOR, scene, camera, options));
/**
* TSL function for creating a pass texture node.
*
* @tsl
* @function
* @param {PassNode} pass - The pass node.
* @param {Texture} texture - The output texture.
* @returns {PassTextureNode}
*/
var passTexture$1 = (pass$2, texture$2) => nodeObject$1(new PassTextureNode(pass$2, texture$2));
/**
* TSL function for creating a depth pass node.
*
* @tsl
* @function
* @param {Scene} scene - A reference to the scene.
* @param {Camera} camera - A reference to the camera.
* @param {Object} options - Options for the internal render target.
* @returns {PassNode}
*/
var depthPass$1 = (scene, camera, options) => nodeObject$1(new PassNode(PassNode.DEPTH, scene, camera, options));
/**
* Represents a render pass for producing a toon outline effect on compatible objects.
* Only 3D objects with materials of type `MeshToonMaterial` and `MeshToonNodeMaterial`
* will receive the outline.
*
* ```js
* const postProcessing = new PostProcessing( renderer );
*
* const scenePass = toonOutlinePass( scene, camera );
*
* postProcessing.outputNode = scenePass;
* ```
* @augments PassNode
*/
var ToonOutlinePassNode = class extends PassNode {
	static get type() {
		return "ToonOutlinePassNode";
	}
	/**
	* Constructs a new outline pass node.
	*
	* @param {Scene} scene - A reference to the scene.
	* @param {Camera} camera - A reference to the camera.
	* @param {Node} colorNode - Defines the outline's color.
	* @param {Node} thicknessNode - Defines the outline's thickness.
	* @param {Node} alphaNode - Defines the outline's alpha.
	*/
	constructor(scene, camera, colorNode, thicknessNode, alphaNode) {
		super(PassNode.COLOR, scene, camera);
		/**
		* Defines the outline's color.
		*
		* @type {Node}
		*/
		this.colorNode = colorNode;
		/**
		* Defines the outline's thickness.
		*
		* @type {Node}
		*/
		this.thicknessNode = thicknessNode;
		/**
		* Defines the outline's alpha.
		*
		* @type {Node}
		*/
		this.alphaNode = alphaNode;
		/**
		* An internal material cache.
		*
		* @private
		* @type {WeakMap<Material, NodeMaterial>}
		*/
		this._materialCache = /* @__PURE__ */ new WeakMap();
		/**
		* The name of this pass.
		*
		* @type {string}
		* @default 'Outline Pass'
		*/
		this.name = "Outline Pass";
	}
	updateBefore(frame) {
		const { renderer } = frame;
		const currentRenderObjectFunction = renderer.getRenderObjectFunction();
		renderer.setRenderObjectFunction((object, scene, camera, geometry, material, group, lightsNode, clippingContext) => {
			if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {
				if (material.wireframe === false) {
					const outlineMaterial = this._getOutlineMaterial(material);
					renderer.renderObject(object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext);
				}
			}
			renderer.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext);
		});
		super.updateBefore(frame);
		renderer.setRenderObjectFunction(currentRenderObjectFunction);
	}
	/**
	* Creates the material used for outline rendering.
	*
	* @private
	* @return {NodeMaterial} The outline material.
	*/
	_createMaterial() {
		const material = new NodeMaterial();
		material.isMeshToonOutlineMaterial = true;
		material.name = "Toon_Outline";
		material.side = BackSide;
		const outlineNormal = normalLocal$1.negate();
		const mvp = cameraProjectionMatrix$1.mul(modelViewMatrix$1);
		const ratio = float$1(1);
		const pos = mvp.mul(vec4$1(positionLocal$1, 1));
		const pos2 = mvp.mul(vec4$1(positionLocal$1.add(outlineNormal), 1));
		const norm = normalize$1(pos.sub(pos2));
		material.vertexNode = pos.add(norm.mul(this.thicknessNode).mul(pos.w).mul(ratio));
		material.colorNode = vec4$1(this.colorNode, this.alphaNode);
		return material;
	}
	/**
	* For the given toon material, this method returns a corresponding
	* outline material.
	*
	* @private
	* @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.
	* @return {NodeMaterial} The outline material.
	*/
	_getOutlineMaterial(originalMaterial) {
		let outlineMaterial = this._materialCache.get(originalMaterial);
		if (outlineMaterial === void 0) {
			outlineMaterial = this._createMaterial();
			this._materialCache.set(originalMaterial, outlineMaterial);
		}
		return outlineMaterial;
	}
};
/**
* TSL function for creating a toon outline pass node.
*
* @tsl
* @function
* @param {Scene} scene - A reference to the scene.
* @param {Camera} camera - A reference to the camera.
* @param {Color} color - Defines the outline's color.
* @param {number} [thickness=0.003] - Defines the outline's thickness.
* @param {number} [alpha=1] - Defines the outline's alpha.
* @returns {ToonOutlinePassNode}
*/
var toonOutlinePass$1 = (scene, camera, color$2 = new Color$1(0, 0, 0), thickness$2 = .003, alpha = 1) => nodeObject$1(new ToonOutlinePassNode(scene, camera, nodeObject$1(color$2), nodeObject$1(thickness$2), nodeObject$1(alpha)));
/**
* Linear tone mapping, exposure only.
*
* @tsl
* @function
* @param {Node<vec3>} color - The color that should be tone mapped.
* @param {Node<float>} exposure - The exposure.
* @return {Node<vec3>} The tone mapped color.
*/
var linearToneMapping$1 = /* @__PURE__ */ Fn$1(([color$2, exposure]) => {
	return color$2.mul(exposure).clamp();
}).setLayout({
	name: "linearToneMapping",
	type: "vec3",
	inputs: [{
		name: "color",
		type: "vec3"
	}, {
		name: "exposure",
		type: "float"
	}]
});
/**
* Reinhard tone mapping.
*
* Reference: {@link https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf}
*
* @tsl
* @function
* @param {Node<vec3>} color - The color that should be tone mapped.
* @param {Node<float>} exposure - The exposure.
* @return {Node<vec3>} The tone mapped color.
*/
var reinhardToneMapping$1 = /* @__PURE__ */ Fn$1(([color$2, exposure]) => {
	color$2 = color$2.mul(exposure);
	return color$2.div(color$2.add(1)).clamp();
}).setLayout({
	name: "reinhardToneMapping",
	type: "vec3",
	inputs: [{
		name: "color",
		type: "vec3"
	}, {
		name: "exposure",
		type: "float"
	}]
});
/**
* Cineon tone mapping.
*
* Reference: {@link http://filmicworlds.com/blog/filmic-tonemapping-operators/}
*
* @tsl
* @function
* @param {Node<vec3>} color - The color that should be tone mapped.
* @param {Node<float>} exposure - The exposure.
* @return {Node<vec3>} The tone mapped color.
*/
var cineonToneMapping$1 = /* @__PURE__ */ Fn$1(([color$2, exposure]) => {
	color$2 = color$2.mul(exposure);
	color$2 = color$2.sub(.004).max(0);
	const a$1 = color$2.mul(color$2.mul(6.2).add(.5));
	const b$2 = color$2.mul(color$2.mul(6.2).add(1.7)).add(.06);
	return a$1.div(b$2).pow(2.2);
}).setLayout({
	name: "cineonToneMapping",
	type: "vec3",
	inputs: [{
		name: "color",
		type: "vec3"
	}, {
		name: "exposure",
		type: "float"
	}]
});
var RRTAndODTFit = /* @__PURE__ */ Fn$1(([color$2]) => {
	const a$1 = color$2.mul(color$2.add(.0245786)).sub(90537e-9);
	const b$2 = color$2.mul(color$2.add(.432951).mul(.983729)).add(.238081);
	return a$1.div(b$2);
});
/**
* ACESFilmic tone mapping.
*
* Reference: {@link https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs}
*
* @tsl
* @function
* @param {Node<vec3>} color - The color that should be tone mapped.
* @param {Node<float>} exposure - The exposure.
* @return {Node<vec3>} The tone mapped color.
*/
var acesFilmicToneMapping$1 = /* @__PURE__ */ Fn$1(([color$2, exposure]) => {
	const ACESInputMat = mat3$1(.59719, .35458, .04823, .076, .90834, .01566, .0284, .13383, .83777);
	const ACESOutputMat = mat3$1(1.60475, -.53108, -.07367, -.10208, 1.10813, -.00605, -.00327, -.07276, 1.07602);
	color$2 = color$2.mul(exposure).div(.6);
	color$2 = ACESInputMat.mul(color$2);
	color$2 = RRTAndODTFit(color$2);
	color$2 = ACESOutputMat.mul(color$2);
	return color$2.clamp();
}).setLayout({
	name: "acesFilmicToneMapping",
	type: "vec3",
	inputs: [{
		name: "color",
		type: "vec3"
	}, {
		name: "exposure",
		type: "float"
	}]
});
var LINEAR_REC2020_TO_LINEAR_SRGB = /* @__PURE__ */ mat3$1(vec3$1(1.6605, -.1246, -.0182), vec3$1(-.5876, 1.1329, -.1006), vec3$1(-.0728, -.0083, 1.1187));
var LINEAR_SRGB_TO_LINEAR_REC2020 = /* @__PURE__ */ mat3$1(vec3$1(.6274, .0691, .0164), vec3$1(.3293, .9195, .088), vec3$1(.0433, .0113, .8956));
var agxDefaultContrastApprox = /* @__PURE__ */ Fn$1(([x_immutable]) => {
	const x = vec3$1(x_immutable).toVar();
	const x2 = vec3$1(x.mul(x)).toVar();
	const x4 = vec3$1(x2.mul(x2)).toVar();
	return float$1(15.5).mul(x4.mul(x2)).sub(mul$1(40.14, x4.mul(x))).add(mul$1(31.96, x4).sub(mul$1(6.868, x2.mul(x))).add(mul$1(.4298, x2).add(mul$1(.1191, x).sub(.00232))));
});
/**
* AgX tone mapping.
*
* @tsl
* @function
* @param {Node<vec3>} color - The color that should be tone mapped.
* @param {Node<float>} exposure - The exposure.
* @return {Node<vec3>} The tone mapped color.
*/
var agxToneMapping$1 = /* @__PURE__ */ Fn$1(([color$2, exposure]) => {
	const colortone = vec3$1(color$2).toVar();
	const AgXInsetMatrix = mat3$1(vec3$1(.856627153315983, .137318972929847, .11189821299995), vec3$1(.0951212405381588, .761241990602591, .0767994186031903), vec3$1(.0482516061458583, .101439036467562, .811302368396859));
	const AgXOutsetMatrix = mat3$1(vec3$1(1.1271005818144368, -.1413297634984383, -.14132976349843826), vec3$1(-.11060664309660323, 1.157823702216272, -.11060664309660294), vec3$1(-.016493938717834573, -.016493938717834257, 1.2519364065950405));
	const AgxMinEv = float$1(-12.47393);
	const AgxMaxEv = float$1(4.026069);
	colortone.mulAssign(exposure);
	colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));
	colortone.assign(AgXInsetMatrix.mul(colortone));
	colortone.assign(max$1$1(colortone, 1e-10));
	colortone.assign(log2$1(colortone));
	colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));
	colortone.assign(clamp$2(colortone, 0, 1));
	colortone.assign(agxDefaultContrastApprox(colortone));
	colortone.assign(AgXOutsetMatrix.mul(colortone));
	colortone.assign(pow$1(max$1$1(vec3$1(0), colortone), vec3$1(2.2)));
	colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));
	colortone.assign(clamp$2(colortone, 0, 1));
	return colortone;
}).setLayout({
	name: "agxToneMapping",
	type: "vec3",
	inputs: [{
		name: "color",
		type: "vec3"
	}, {
		name: "exposure",
		type: "float"
	}]
});
/**
* Neutral tone mapping.
*
* Reference: {@link https://modelviewer.dev/examples/tone-mapping}
*
* @tsl
* @function
* @param {Node<vec3>} color - The color that should be tone mapped.
* @param {Node<float>} exposure - The exposure.
* @return {Node<vec3>} The tone mapped color.
*/
var neutralToneMapping$1 = /* @__PURE__ */ Fn$1(([color$2, exposure]) => {
	const StartCompression = float$1(.76);
	const Desaturation = float$1(.15);
	color$2 = color$2.mul(exposure);
	const x = min$1(color$2.r, min$1(color$2.g, color$2.b));
	const offset = select$1(x.lessThan(.08), x.sub(mul$1(6.25, x.mul(x))), .04);
	color$2.subAssign(offset);
	const peak = max$1$1(color$2.r, max$1$1(color$2.g, color$2.b));
	If$1(peak.lessThan(StartCompression), () => {
		return color$2;
	});
	const d$1 = sub$1(1, StartCompression);
	const newPeak = sub$1(1, d$1.mul(d$1).div(peak.add(d$1.sub(StartCompression))));
	color$2.mulAssign(newPeak.div(peak));
	const g$1 = sub$1(1, div$1(1, Desaturation.mul(peak.sub(newPeak)).add(1)));
	return mix$2(color$2, vec3$1(newPeak), g$1);
}).setLayout({
	name: "neutralToneMapping",
	type: "vec3",
	inputs: [{
		name: "color",
		type: "vec3"
	}, {
		name: "exposure",
		type: "float"
	}]
});
/**
* This class represents native code sections. It is the base
* class for modules like {@link FunctionNode} which allows to implement
* functions with native shader languages.
*
* @augments Node
*/
var CodeNode = class extends Node {
	static get type() {
		return "CodeNode";
	}
	/**
	* Constructs a new code node.
	*
	* @param {string} [code=''] - The native code.
	* @param {Array<Node>} [includes=[]] - An array of includes.
	* @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
	*/
	constructor(code$2 = "", includes = [], language = "") {
		super("code");
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isCodeNode = true;
		/**
		* This flag is used for global cache.
		*
		* @type {boolean}
		* @default true
		*/
		this.global = true;
		/**
		* The native code.
		*
		* @type {string}
		* @default ''
		*/
		this.code = code$2;
		/**
		* An array of includes
		*
		* @type {Array<Node>}
		* @default []
		*/
		this.includes = includes;
		/**
		* The used language.
		*
		* @type {('js'|'wgsl'|'glsl')}
		* @default ''
		*/
		this.language = language;
	}
	/**
	* Sets the includes of this code node.
	*
	* @param {Array<Node>} includes - The includes to set.
	* @return {CodeNode} A reference to this node.
	*/
	setIncludes(includes) {
		this.includes = includes;
		return this;
	}
	/**
	* Returns the includes of this code node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Array<Node>} The includes.
	*/
	getIncludes() {
		return this.includes;
	}
	generate(builder) {
		const includes = this.getIncludes(builder);
		for (const include of includes) include.build(builder);
		const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
		nodeCode.code = this.code;
		return nodeCode.code;
	}
	serialize(data) {
		super.serialize(data);
		data.code = this.code;
		data.language = this.language;
	}
	deserialize(data) {
		super.deserialize(data);
		this.code = data.code;
		this.language = data.language;
	}
};
/**
* TSL function for creating a code node.
*
* @tsl
* @function
* @param {string} [code] - The native code.
* @param {?Array<Node>} [includes=[]] - An array of includes.
* @param {?('js'|'wgsl'|'glsl')} [language=''] - The used language.
* @returns {CodeNode}
*/
var code$1 = /* @__PURE__ */ nodeProxy$1(CodeNode).setParameterLength(1, 3);
/**
* TSL function for creating a JS code node.
*
* @tsl
* @function
* @param {string} src - The native code.
* @param {Array<Node>} includes - An array of includes.
* @returns {CodeNode}
*/
var js$1 = (src, includes) => code$1(src, includes, "js");
/**
* TSL function for creating a WGSL code node.
*
* @tsl
* @function
* @param {string} src - The native code.
* @param {Array<Node>} includes - An array of includes.
* @returns {CodeNode}
*/
var wgsl$1 = (src, includes) => code$1(src, includes, "wgsl");
/**
* TSL function for creating a GLSL code node.
*
* @tsl
* @function
* @param {string} src - The native code.
* @param {Array<Node>} includes - An array of includes.
* @returns {CodeNode}
*/
var glsl$1 = (src, includes) => code$1(src, includes, "glsl");
/**
* This class represents a native shader function. It can be used to implement
* certain aspects of a node material with native shader code. There are two predefined
* TSL functions for easier usage.
*
* - `wgslFn`: Creates a WGSL function node.
* - `glslFn`: Creates a GLSL function node.
*
* A basic example with one include looks like so:
*
* ```js
* const desaturateWGSLFn = wgslFn( `
*	fn desaturate( color:vec3<f32> ) -> vec3<f32> {
*		let lum = vec3<f32>( 0.299, 0.587, 0.114 );
*		return vec3<f32>( dot( lum, color ) );
*	}`
*);
* const someWGSLFn = wgslFn( `
*	fn someFn( color:vec3<f32> ) -> vec3<f32> {
* 		return desaturate( color );
* 	}
* `, [ desaturateWGSLFn ] );
* material.colorNode = someWGSLFn( { color: texture( map ) } );
*```
* @augments CodeNode
*/
var FunctionNode = class extends CodeNode {
	static get type() {
		return "FunctionNode";
	}
	/**
	* Constructs a new function node.
	*
	* @param {string} [code=''] - The native code.
	* @param {Array<Node>} [includes=[]] - An array of includes.
	* @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
	*/
	constructor(code$2 = "", includes = [], language = "") {
		super(code$2, includes, language);
	}
	/**
	* Returns the type of this function node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The type.
	*/
	getNodeType(builder) {
		return this.getNodeFunction(builder).type;
	}
	/**
	* Returns the type of a member of this function node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @param {string} name - The name of the member.
	* @return {string} The type of the member.
	*/
	getMemberType(builder, name) {
		const type$1 = this.getNodeType(builder);
		return builder.getStructTypeNode(type$1).getMemberType(builder, name);
	}
	/**
	* Returns the inputs of this function node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {Array<NodeFunctionInput>} The inputs.
	*/
	getInputs(builder) {
		return this.getNodeFunction(builder).inputs;
	}
	/**
	* Returns the node function for this function node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {NodeFunction} The node function.
	*/
	getNodeFunction(builder) {
		const nodeData = builder.getDataFromNode(this);
		let nodeFunction = nodeData.nodeFunction;
		if (nodeFunction === void 0) {
			nodeFunction = builder.parser.parseFunction(this.code);
			nodeData.nodeFunction = nodeFunction;
		}
		return nodeFunction;
	}
	generate(builder, output$2) {
		super.generate(builder);
		const nodeFunction = this.getNodeFunction(builder);
		const name = nodeFunction.name;
		const type$1 = nodeFunction.type;
		const nodeCode = builder.getCodeFromNode(this, type$1);
		if (name !== "") nodeCode.name = name;
		const propertyName = builder.getPropertyName(nodeCode);
		nodeCode.code = this.getNodeFunction(builder).getCode(propertyName) + "\n";
		if (output$2 === "property") return propertyName;
		else return builder.format(`${propertyName}()`, type$1, output$2);
	}
};
var nativeFn = (code$2, includes = [], language = "") => {
	for (let i = 0; i < includes.length; i++) {
		const include = includes[i];
		if (typeof include === "function") includes[i] = include.functionNode;
	}
	const functionNode = nodeObject$1(new FunctionNode(code$2, includes, language));
	const fn = (...params) => functionNode.call(...params);
	fn.functionNode = functionNode;
	return fn;
};
var glslFn$1 = (code$2, includes) => nativeFn(code$2, includes, "glsl");
var wgslFn$1 = (code$2, includes) => nativeFn(code$2, includes, "wgsl");
/**
* `ScriptableNode` uses this class to manage script inputs and outputs.
*
* @augments Node
*/
var ScriptableValueNode = class extends Node {
	static get type() {
		return "ScriptableValueNode";
	}
	/**
	* Constructs a new scriptable node.
	*
	* @param {any} [value=null] - The value.
	*/
	constructor(value = null) {
		super();
		/**
		* A reference to the value.
		*
		* @private
		* @default null
		*/
		this._value = value;
		/**
		* Depending on the type of `_value`, this property might cache parsed data.
		*
		* @private
		* @default null
		*/
		this._cache = null;
		/**
		* If this node represents an input, this property represents the input type.
		*
		* @type {?string}
		* @default null
		*/
		this.inputType = null;
		/**
		* If this node represents an output, this property represents the output type.
		*
		* @type {?string}
		* @default null
		*/
		this.outputType = null;
		/**
		* An event dispatcher for managing events.
		*
		* @type {EventDispatcher}
		*/
		this.events = new EventDispatcher();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isScriptableValueNode = true;
	}
	/**
	* Whether this node represents an output or not.
	*
	* @type {boolean}
	* @readonly
	* @default true
	*/
	get isScriptableOutputNode() {
		return this.outputType !== null;
	}
	set value(val) {
		if (this._value === val) return;
		if (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer) {
			URL.revokeObjectURL(this._cache);
			this._cache = null;
		}
		this._value = val;
		this.events.dispatchEvent({ type: "change" });
		this.refresh();
	}
	/**
	* The node's value.
	*
	* @type {any}
	*/
	get value() {
		return this._value;
	}
	/**
	* Dispatches the `refresh` event.
	*/
	refresh() {
		this.events.dispatchEvent({ type: "refresh" });
	}
	/**
	* The `value` property usually represents a node or even binary data in form of array buffers.
	* In this case, this method tries to return the actual value behind the complex type.
	*
	* @return {any} The value.
	*/
	getValue() {
		const value = this.value;
		if (value && this._cache === null && this.inputType === "URL" && value.value instanceof ArrayBuffer) this._cache = URL.createObjectURL(new Blob([value.value]));
		else if (value && value.value !== null && value.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof value.value === "string" || this.inputType === "Number" && typeof value.value === "number" || this.inputType === "Vector2" && value.value.isVector2 || this.inputType === "Vector3" && value.value.isVector3 || this.inputType === "Vector4" && value.value.isVector4 || this.inputType === "Color" && value.value.isColor || this.inputType === "Matrix3" && value.value.isMatrix3 || this.inputType === "Matrix4" && value.value.isMatrix4)) return value.value;
		return this._cache || value;
	}
	/**
	* Overwritten since the node type is inferred from the value.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		return this.value && this.value.isNode ? this.value.getNodeType(builder) : "float";
	}
	setup() {
		return this.value && this.value.isNode ? this.value : float$1();
	}
	serialize(data) {
		super.serialize(data);
		if (this.value !== null) if (this.inputType === "ArrayBuffer") data.value = arrayBufferToBase64(this.value);
		else data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
		else data.value = null;
		data.inputType = this.inputType;
		data.outputType = this.outputType;
	}
	deserialize(data) {
		super.deserialize(data);
		let value = null;
		if (data.value !== null) if (data.inputType === "ArrayBuffer") value = base64ToArrayBuffer(data.value);
		else if (data.inputType === "Texture") value = data.meta.textures[data.value];
		else value = data.meta.nodes[data.value] || null;
		this.value = value;
		this.inputType = data.inputType;
		this.outputType = data.outputType;
	}
};
/**
* TSL function for creating a scriptable value node.
*
* @tsl
* @function
* @param {any} [value] - The value.
* @returns {ScriptableValueNode}
*/
var scriptableValue$1 = /* @__PURE__ */ nodeProxy$1(ScriptableValueNode).setParameterLength(1);
/**
* A Map-like data structure for managing resources of scriptable nodes.
*
* @augments Map
*/
var Resources = class extends Map {
	get(key, callback = null, ...params) {
		if (this.has(key)) return super.get(key);
		if (callback !== null) {
			const value = callback(...params);
			this.set(key, value);
			return value;
		}
	}
};
var Parameters = class {
	constructor(scriptableNode) {
		this.scriptableNode = scriptableNode;
	}
	get parameters() {
		return this.scriptableNode.parameters;
	}
	get layout() {
		return this.scriptableNode.getLayout();
	}
	getInputLayout(id) {
		return this.scriptableNode.getInputLayout(id);
	}
	get(name) {
		const param = this.parameters[name];
		return param ? param.getValue() : null;
	}
};
/**
* Defines the resources (e.g. namespaces) of scriptable nodes.
*
* @type {Resources}
*/
var ScriptableNodeResources$1 = new Resources();
/**
* This type of node allows to implement nodes with custom scripts. The script
* section is represented as an instance of `CodeNode` written with JavaScript.
* The script itself must adhere to a specific structure.
*
* - main(): Executed once by default and every time `node.needsUpdate` is set.
* - layout: The layout object defines the script's interface (inputs and outputs).
*
* ```js
* ScriptableNodeResources.set( 'TSL', TSL );
*
* const scriptableNode = scriptable( js( `
* 	layout = {
* 		outputType: 'node',
* 		elements: [
* 			{ name: 'source', inputType: 'node' },
* 		]
* 	};
*
* 	const { mul, oscSine } = TSL;
*
* 	function main() {
* 		const source = parameters.get( 'source' ) || float();
* 		return mul( source, oscSine() ) );
* 	}
*
* ` ) );
*
* scriptableNode.setParameter( 'source', color( 1, 0, 0 ) );
*
* const material = new THREE.MeshBasicNodeMaterial();
* material.colorNode = scriptableNode;
* ```
*
* @augments Node
*/
var ScriptableNode = class extends Node {
	static get type() {
		return "ScriptableNode";
	}
	/**
	* Constructs a new scriptable node.
	*
	* @param {?CodeNode} [codeNode=null] - The code node.
	* @param {Object} [parameters={}] - The parameters definition.
	*/
	constructor(codeNode = null, parameters = {}) {
		super();
		/**
		* The code node.
		*
		* @type {?CodeNode}
		* @default null
		*/
		this.codeNode = codeNode;
		/**
		* The parameters definition.
		*
		* @type {Object}
		* @default {}
		*/
		this.parameters = parameters;
		this._local = new Resources();
		this._output = scriptableValue$1(null);
		this._outputs = {};
		this._source = this.source;
		this._method = null;
		this._object = null;
		this._value = null;
		this._needsOutputUpdate = true;
		this.onRefresh = this.onRefresh.bind(this);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isScriptableNode = true;
	}
	/**
	* The source code of the scriptable node.
	*
	* @type {string}
	*/
	get source() {
		return this.codeNode ? this.codeNode.code : "";
	}
	/**
	* Sets the reference of a local script variable.
	*
	* @param {string} name - The variable name.
	* @param {Object} value - The reference to set.
	* @return {Resources} The resource map
	*/
	setLocal(name, value) {
		return this._local.set(name, value);
	}
	/**
	* Gets the value of a local script variable.
	*
	* @param {string} name - The variable name.
	* @return {Object} The value.
	*/
	getLocal(name) {
		return this._local.get(name);
	}
	/**
	* Event listener for the `refresh` event.
	*/
	onRefresh() {
		this._refresh();
	}
	/**
	* Returns an input from the layout with the given id/name.
	*
	* @param {string} id - The id/name of the input.
	* @return {Object} The element entry.
	*/
	getInputLayout(id) {
		for (const element$2 of this.getLayout()) if (element$2.inputType && (element$2.id === id || element$2.name === id)) return element$2;
	}
	/**
	* Returns an output from the layout with the given id/name.
	*
	* @param {string} id - The id/name of the output.
	* @return {Object} The element entry.
	*/
	getOutputLayout(id) {
		for (const element$2 of this.getLayout()) if (element$2.outputType && (element$2.id === id || element$2.name === id)) return element$2;
	}
	/**
	* Defines a script output for the given name and value.
	*
	* @param {string} name - The name of the output.
	* @param {Node} value - The node value.
	* @return {ScriptableNode} A reference to this node.
	*/
	setOutput(name, value) {
		const outputs = this._outputs;
		if (outputs[name] === void 0) outputs[name] = scriptableValue$1(value);
		else outputs[name].value = value;
		return this;
	}
	/**
	* Returns a script output for the given name.
	*
	* @param {string} name - The name of the output.
	* @return {ScriptableValueNode} The node value.
	*/
	getOutput(name) {
		return this._outputs[name];
	}
	/**
	* Returns a parameter for the given name
	*
	* @param {string} name - The name of the parameter.
	* @return {ScriptableValueNode} The node value.
	*/
	getParameter(name) {
		return this.parameters[name];
	}
	/**
	* Sets a value for the given parameter name.
	*
	* @param {string} name - The parameter name.
	* @param {any} value - The parameter value.
	* @return {ScriptableNode} A reference to this node.
	*/
	setParameter(name, value) {
		const parameters = this.parameters;
		if (value && value.isScriptableNode) {
			this.deleteParameter(name);
			parameters[name] = value;
			parameters[name].getDefaultOutput().events.addEventListener("refresh", this.onRefresh);
		} else if (value && value.isScriptableValueNode) {
			this.deleteParameter(name);
			parameters[name] = value;
			parameters[name].events.addEventListener("refresh", this.onRefresh);
		} else if (parameters[name] === void 0) {
			parameters[name] = scriptableValue$1(value);
			parameters[name].events.addEventListener("refresh", this.onRefresh);
		} else parameters[name].value = value;
		return this;
	}
	/**
	* Returns the value of this node which is the value of
	* the default output.
	*
	* @return {Node} The value.
	*/
	getValue() {
		return this.getDefaultOutput().getValue();
	}
	/**
	* Deletes a parameter from the script.
	*
	* @param {string} name - The parameter to remove.
	* @return {ScriptableNode} A reference to this node.
	*/
	deleteParameter(name) {
		let valueNode = this.parameters[name];
		if (valueNode) {
			if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
			valueNode.events.removeEventListener("refresh", this.onRefresh);
		}
		return this;
	}
	/**
	* Deletes all parameters from the script.
	*
	* @return {ScriptableNode} A reference to this node.
	*/
	clearParameters() {
		for (const name of Object.keys(this.parameters)) this.deleteParameter(name);
		this.needsUpdate = true;
		return this;
	}
	/**
	* Calls a function from the script.
	*
	* @param {string} name - The function name.
	* @param {...any} params - A list of parameters.
	* @return {any} The result of the function call.
	*/
	call(name, ...params) {
		const method = this.getObject()[name];
		if (typeof method === "function") return method(...params);
	}
	/**
	* Asynchronously calls a function from the script.
	*
	* @param {string} name - The function name.
	* @param {...any} params - A list of parameters.
	* @return {Promise<any>} The result of the function call.
	*/
	async callAsync(name, ...params) {
		const method = this.getObject()[name];
		if (typeof method === "function") return method.constructor.name === "AsyncFunction" ? await method(...params) : method(...params);
	}
	/**
	* Overwritten since the node types is inferred from the script's output.
	*
	* @param {NodeBuilder} builder - The current node builder
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		return this.getDefaultOutputNode().getNodeType(builder);
	}
	/**
	* Refreshes the script node.
	*
	* @param {?string} [output=null] - An optional output.
	*/
	refresh(output$2 = null) {
		if (output$2 !== null) this.getOutput(output$2).refresh();
		else this._refresh();
	}
	/**
	* Returns an object representation of the script.
	*
	* @return {Object} The result object.
	*/
	getObject() {
		if (this.needsUpdate) this.dispose();
		if (this._object !== null) return this._object;
		const refresh = () => this.refresh();
		const setOutput = (id, value) => this.setOutput(id, value);
		const parameters = new Parameters(this);
		const THREE = ScriptableNodeResources$1.get("THREE");
		const TSL$1 = ScriptableNodeResources$1.get("TSL");
		const method = this.getMethod();
		const params = [
			parameters,
			this._local,
			ScriptableNodeResources$1,
			refresh,
			setOutput,
			THREE,
			TSL$1
		];
		this._object = method(...params);
		const layout = this._object.layout;
		if (layout) {
			if (layout.cache === false) this._local.clear();
			this._output.outputType = layout.outputType || null;
			if (Array.isArray(layout.elements)) for (const element$2 of layout.elements) {
				const id = element$2.id || element$2.name;
				if (element$2.inputType) {
					if (this.getParameter(id) === void 0) this.setParameter(id, null);
					this.getParameter(id).inputType = element$2.inputType;
				}
				if (element$2.outputType) {
					if (this.getOutput(id) === void 0) this.setOutput(id, null);
					this.getOutput(id).outputType = element$2.outputType;
				}
			}
		}
		return this._object;
	}
	deserialize(data) {
		super.deserialize(data);
		for (const name in this.parameters) {
			let valueNode = this.parameters[name];
			if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
			valueNode.events.addEventListener("refresh", this.onRefresh);
		}
	}
	/**
	* Returns the layout of the script.
	*
	* @return {Object} The script's layout.
	*/
	getLayout() {
		return this.getObject().layout;
	}
	/**
	* Returns default node output of the script.
	*
	* @return {Node} The default node output.
	*/
	getDefaultOutputNode() {
		const output$2 = this.getDefaultOutput().value;
		if (output$2 && output$2.isNode) return output$2;
		return float$1();
	}
	/**
	* Returns default output of the script.
	*
	* @return {ScriptableValueNode} The default output.
	*/
	getDefaultOutput() {
		return this._exec()._output;
	}
	/**
	* Returns a function created from the node's script.
	*
	* @return {Function} The function representing the node's code.
	*/
	getMethod() {
		if (this.needsUpdate) this.dispose();
		if (this._method !== null) return this._method;
		const parametersProps = [
			"parameters",
			"local",
			"global",
			"refresh",
			"setOutput",
			"THREE",
			"TSL"
		];
		const properties = [
			"layout",
			"init",
			"main",
			"dispose"
		].join(", ");
		const declarations = "var " + properties + "; var output = {};\n";
		const returns = "\nreturn { ...output, " + properties + " };";
		const code$2 = declarations + this.codeNode.code + returns;
		this._method = new Function(...parametersProps, code$2);
		return this._method;
	}
	/**
	* Frees all internal resources.
	*/
	dispose() {
		if (this._method === null) return;
		if (this._object && typeof this._object.dispose === "function") this._object.dispose();
		this._method = null;
		this._object = null;
		this._source = null;
		this._value = null;
		this._needsOutputUpdate = true;
		this._output.value = null;
		this._outputs = {};
	}
	setup() {
		return this.getDefaultOutputNode();
	}
	getCacheKey(force) {
		const values = [hashString(this.source), this.getDefaultOutputNode().getCacheKey(force)];
		for (const param in this.parameters) values.push(this.parameters[param].getCacheKey(force));
		return hashArray(values);
	}
	set needsUpdate(value) {
		if (value === true) this.dispose();
	}
	get needsUpdate() {
		return this.source !== this._source;
	}
	/**
	* Executes the `main` function of the script.
	*
	* @private
	* @return {ScriptableNode} A reference to this node.
	*/
	_exec() {
		if (this.codeNode === null) return this;
		if (this._needsOutputUpdate === true) {
			this._value = this.call("main");
			this._needsOutputUpdate = false;
		}
		this._output.value = this._value;
		return this;
	}
	/**
	* Executes the refresh.
	*
	* @private
	*/
	_refresh() {
		this.needsUpdate = true;
		this._exec();
		this._output.refresh();
	}
};
/**
* TSL function for creating a scriptable node.
*
* @tsl
* @function
* @param {CodeNode} [codeNode] - The code node.
* @param {?Object} [parameters={}] - The parameters definition.
* @returns {ScriptableNode}
*/
var scriptable$1 = /* @__PURE__ */ nodeProxy$1(ScriptableNode).setParameterLength(1, 2);
/**
* Returns a node that represents the `z` coordinate in view space
* for the current fragment. It's a different representation of the
* default depth value.
*
* This value can be part of a computation that defines how the fog
* density increases when moving away from the camera.
*
* @param {NodeBuilder} builder - The current node builder.
* @return {Node} The viewZ node.
*/
function getViewZNode(builder) {
	let viewZ;
	const getViewZ = builder.context.getViewZ;
	if (getViewZ !== void 0) viewZ = getViewZ(this);
	return (viewZ || positionView$1.z).negate();
}
/**
* Constructs a new range factor node.
*
* @tsl
* @function
* @param {Node} near - Defines the near value.
* @param {Node} far - Defines the far value.
*/
var rangeFogFactor$1 = Fn$1(([near, far], builder) => {
	const viewZ = getViewZNode(builder);
	return smoothstep$1(near, far, viewZ);
});
/**
* Represents an exponential squared fog. This type of fog gives
* a clear view near the camera and a faster than exponentially
* densening fog farther from the camera.
*
* @tsl
* @function
* @param {Node} density - Defines the fog density.
*/
var densityFogFactor$1 = Fn$1(([density], builder) => {
	const viewZ = getViewZNode(builder);
	return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();
});
/**
* This class can be used to configure a fog for the scene.
* Nodes of this type are assigned to `Scene.fogNode`.
*
* @tsl
* @function
* @param {Node} color - Defines the color of the fog.
* @param {Node} factor - Defines how the fog is factored in the scene.
*/
var fog$1 = Fn$1(([color$2, factor]) => {
	return vec4$1(factor.toFloat().mix(output$1.rgb, color$2.toVec3()), output$1.a);
});
/**
* @tsl
* @function
* @deprecated since r171. Use `fog( color, rangeFogFactor( near, far ) )` instead.
*
* @param {Node} color
* @param {Node} near
* @param {Node} far
* @returns {Function}
*/
function rangeFog$1(color$2, near, far) {
	warn("TSL: \"rangeFog( color, near, far )\" is deprecated. Use \"fog( color, rangeFogFactor( near, far ) )\" instead.");
	return fog$1(color$2, rangeFogFactor$1(near, far));
}
/**
* @tsl
* @function
* @deprecated since r171. Use `fog( color, densityFogFactor( density ) )` instead.
*
* @param {Node} color
* @param {Node} density
* @returns {Function}
*/
function densityFog$1(color$2, density) {
	warn("TSL: \"densityFog( color, density )\" is deprecated. Use \"fog( color, densityFogFactor( density ) )\" instead.");
	return fog$1(color$2, densityFogFactor$1(density));
}
var min$2 = null;
var max$2 = null;
/**
* `RangeNode` generates random instanced attribute data in a defined range.
* An exemplary use case for this utility node is to generate random per-instance
* colors:
* ```js
* const material = new MeshBasicNodeMaterial();
* material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );
* const mesh = new InstancedMesh( geometry, material, count );
* ```
* @augments Node
*/
var RangeNode = class extends Node {
	static get type() {
		return "RangeNode";
	}
	/**
	* Constructs a new range node.
	*
	* @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
	* @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
	*/
	constructor(minNode = float$1(), maxNode = float$1()) {
		super();
		/**
		*  A node defining the lower bound of the range.
		*
		* @type {Node<any>}
		* @default float()
		*/
		this.minNode = minNode;
		/**
		*  A node defining the upper bound of the range.
		*
		* @type {Node<any>}
		* @default float()
		*/
		this.maxNode = maxNode;
	}
	/**
	* Returns the vector length which is computed based on the range definition.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {number} The vector length.
	*/
	getVectorLength(builder) {
		const minNode = this.getConstNode(this.minNode);
		const maxNode = this.getConstNode(this.maxNode);
		const minLength = builder.getTypeLength(getValueType(minNode.value));
		const maxLength = builder.getTypeLength(getValueType(maxNode.value));
		return minLength > maxLength ? minLength : maxLength;
	}
	/**
	* This method is overwritten since the node type is inferred from range definition.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		return builder.object.count > 1 ? builder.getTypeFromLength(this.getVectorLength(builder)) : "float";
	}
	/**
	* Returns a constant node from the given node by traversing it.
	*
	* @param {Node} node - The node to traverse.
	* @returns {Node} The constant node, if found.
	*/
	getConstNode(node) {
		let output$2 = null;
		node.traverse((n$2) => {
			if (n$2.isConstNode === true) output$2 = n$2;
		});
		if (output$2 === null) throw new Error("THREE.TSL: No \"ConstNode\" found in node graph.");
		return output$2;
	}
	setup(builder) {
		const object = builder.object;
		let output$2 = null;
		if (object.count > 1) {
			const minNode = this.getConstNode(this.minNode);
			const maxNode = this.getConstNode(this.maxNode);
			const minValue = minNode.value;
			const maxValue = maxNode.value;
			const minLength = builder.getTypeLength(getValueType(minValue));
			const maxLength = builder.getTypeLength(getValueType(maxValue));
			min$2 = min$2 || new Vector4();
			max$2 = max$2 || new Vector4();
			min$2.setScalar(0);
			max$2.setScalar(0);
			if (minLength === 1) min$2.setScalar(minValue);
			else if (minValue.isColor) min$2.set(minValue.r, minValue.g, minValue.b, 1);
			else min$2.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
			if (maxLength === 1) max$2.setScalar(maxValue);
			else if (maxValue.isColor) max$2.set(maxValue.r, maxValue.g, maxValue.b, 1);
			else max$2.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
			const stride = 4;
			const length$2 = stride * object.count;
			const array$2 = new Float32Array(length$2);
			for (let i = 0; i < length$2; i++) {
				const index = i % stride;
				const minElementValue = min$2.getComponent(index);
				const maxElementValue = max$2.getComponent(index);
				array$2[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
			}
			const nodeType = this.getNodeType(builder);
			if (object.count <= 4096) output$2 = buffer$1(array$2, "vec4", object.count).element(instanceIndex$1).convert(nodeType);
			else {
				const bufferAttribute$2 = new InstancedBufferAttribute(array$2, 4);
				builder.geometry.setAttribute("__range" + this.id, bufferAttribute$2);
				output$2 = instancedBufferAttribute$1(bufferAttribute$2).convert(nodeType);
			}
		} else output$2 = float$1(0);
		return output$2;
	}
};
/**
* TSL function for creating a range node.
*
* @tsl
* @function
* @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
* @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
* @returns {RangeNode}
*/
var range$2 = /* @__PURE__ */ nodeProxy$1(RangeNode).setParameterLength(2);
/**
* `ComputeBuiltinNode` represents a compute-scope builtin value that expose information
* about the currently running dispatch and/or the device it is running on.
*
* This node can only be used with a WebGPU backend.
*
* @augments Node
*/
var ComputeBuiltinNode = class extends Node {
	static get type() {
		return "ComputeBuiltinNode";
	}
	/**
	* Constructs a new compute builtin node.
	*
	* @param {string} builtinName - The built-in name.
	* @param {string} nodeType - The node type.
	*/
	constructor(builtinName, nodeType) {
		super(nodeType);
		/**
		* The built-in name.
		*
		* @private
		* @type {string}
		*/
		this._builtinName = builtinName;
	}
	/**
	* This method is overwritten since hash is derived from the built-in name.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The hash.
	*/
	getHash(builder) {
		return this.getBuiltinName(builder);
	}
	/**
	* This method is overwritten since the node type is simply derived from `nodeType`..
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType() {
		return this.nodeType;
	}
	/**
	* Sets the builtin name.
	*
	* @param {string} builtinName - The built-in name.
	* @return {ComputeBuiltinNode} A reference to this node.
	*/
	setBuiltinName(builtinName) {
		this._builtinName = builtinName;
		return this;
	}
	/**
	* Returns the builtin name.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The builtin name.
	*/
	getBuiltinName() {
		return this._builtinName;
	}
	/**
	* Whether the current node builder has the builtin or not.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {boolean} Whether the builder has the builtin or not.
	*/
	hasBuiltin(builder) {
		return builder.hasBuiltin(this._builtinName);
	}
	generate(builder, output$2) {
		const builtinName = this.getBuiltinName(builder);
		const nodeType = this.getNodeType(builder);
		if (builder.shaderStage === "compute") return builder.format(builtinName, nodeType, output$2);
		else {
			warn(`ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`);
			return builder.generateConst(nodeType);
		}
	}
	serialize(data) {
		super.serialize(data);
		data.global = this.global;
		data._builtinName = this._builtinName;
	}
	deserialize(data) {
		super.deserialize(data);
		this.global = data.global;
		this._builtinName = data._builtinName;
	}
};
/**
* TSL function for creating a compute builtin node.
*
* @tsl
* @function
* @param {string} name - The built-in name.
* @param {string} nodeType - The node type.
* @returns {ComputeBuiltinNode}
*/
var computeBuiltin = (name, nodeType) => nodeObject$1(new ComputeBuiltinNode(name, nodeType));
/**
* Represents the number of workgroups dispatched by the compute shader.
* ```js
* // Run 512 invocations/threads with a workgroup size of 128.
* const computeFn = Fn(() => {
*
*     // numWorkgroups.x = 4
*     storageBuffer.element(0).assign(numWorkgroups.x)
*
* })().compute(512, [128]);
*
* // Run 512 invocations/threads with the default workgroup size of 64.
* const computeFn = Fn(() => {
*
*     // numWorkgroups.x = 8
*     storageBuffer.element(0).assign(numWorkgroups.x)
*
* })().compute(512);
* ```
*
* @tsl
* @type {ComputeBuiltinNode<uvec3>}
*/
var numWorkgroups$1 = /* @__PURE__ */ computeBuiltin("numWorkgroups", "uvec3");
/**
* Represents the 3-dimensional index of the workgroup the current compute invocation belongs to.
* ```js
* // Execute 12 compute threads with a workgroup size of 3.
* const computeFn = Fn( () => {
*
* 	If( workgroupId.x.mod( 2 ).equal( 0 ), () => {
*
* 		storageBuffer.element( instanceIndex ).assign( instanceIndex );
*
* 	} ).Else( () => {
*
* 		storageBuffer.element( instanceIndex ).assign( 0 );
*
* 	} );
*
* } )().compute( 12, [ 3 ] );
*
* // workgroupId.x =  [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];
* // Buffer Output =  [0, 1, 2, 0, 0, 0, 6, 7, 8, 0, 0, 0];
* ```
*
* @tsl
* @type {ComputeBuiltinNode<uvec3>}
*/
var workgroupId$1 = /* @__PURE__ */ computeBuiltin("workgroupId", "uvec3");
/**
* A non-linearized 3-dimensional representation of the current invocation's position within a 3D global grid.
*
* @tsl
* @type {ComputeBuiltinNode<uvec3>}
*/
var globalId$1 = /* @__PURE__ */ computeBuiltin("globalId", "uvec3");
/**
* A non-linearized 3-dimensional representation of the current invocation's position within a 3D workgroup grid.
*
* @tsl
* @type {ComputeBuiltinNode<uvec3>}
*/
var localId$1 = /* @__PURE__ */ computeBuiltin("localId", "uvec3");
/**
* A device dependent variable that exposes the size of the current invocation's subgroup.
*
* @tsl
* @type {ComputeBuiltinNode<uint>}
*/
var subgroupSize$1 = /* @__PURE__ */ computeBuiltin("subgroupSize", "uint");
/**
* Represents a GPU control barrier that synchronizes compute operations within a given scope.
*
* This node can only be used with a WebGPU backend.
*
* @augments Node
*/
var BarrierNode = class extends Node {
	/**
	* Constructs a new barrier node.
	*
	* @param {string} scope - The scope defines the behavior of the node.
	*/
	constructor(scope) {
		super();
		this.scope = scope;
	}
	generate(builder) {
		const { scope } = this;
		const { renderer } = builder;
		if (renderer.backend.isWebGLBackend === true) builder.addFlowCode(`\t// ${scope}Barrier \n`);
		else builder.addLineFlowCode(`${scope}Barrier()`, this);
	}
};
/**
* TSL function for creating a barrier node.
*
* @tsl
* @function
* @param {string} scope - The scope defines the behavior of the node..
* @returns {BarrierNode}
*/
var barrier = nodeProxy$1(BarrierNode);
/**
* TSL function for creating a workgroup barrier. All compute shader
* invocations must wait for each invocation within a workgroup to
* complete before the barrier can be surpassed.
*
* @tsl
* @function
* @returns {BarrierNode}
*/
var workgroupBarrier$1 = () => barrier("workgroup").toStack();
/**
* TSL function for creating a storage barrier. All invocations must
* wait for each access to variables within the 'storage' address space
* to complete before the barrier can be passed.
*
* @tsl
* @function
* @returns {BarrierNode}
*/
var storageBarrier$1 = () => barrier("storage").toStack();
/**
* TSL function for creating a texture barrier. All invocations must
* wait for each access to variables within the 'texture' address space
* to complete before the barrier can be passed.
*
* @tsl
* @function
* @returns {BarrierNode}
*/
var textureBarrier$1 = () => barrier("texture").toStack();
/**
* Represents an element of a 'workgroup' scoped buffer.
*
* @augments ArrayElementNode
*/
var WorkgroupInfoElementNode = class extends ArrayElementNode {
	/**
	* Constructs a new workgroup info element node.
	*
	* @param {Node} workgroupInfoNode - The workgroup info node.
	* @param {Node} indexNode - The index node that defines the element access.
	*/
	constructor(workgroupInfoNode, indexNode) {
		super(workgroupInfoNode, indexNode);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isWorkgroupInfoElementNode = true;
	}
	generate(builder, output$2) {
		let snippet;
		const isAssignContext = builder.context.assign;
		snippet = super.generate(builder);
		if (isAssignContext !== true) {
			const type$1 = this.getNodeType(builder);
			snippet = builder.format(snippet, type$1, output$2);
		}
		return snippet;
	}
};
/**
* A node allowing the user to create a 'workgroup' scoped buffer within the
* context of a compute shader. Typically, workgroup scoped buffers are
* created to hold data that is transferred from a global storage scope into
* a local workgroup scope. For invocations within a workgroup, data
* access speeds on 'workgroup' scoped buffers can be significantly faster
* than similar access operations on globally accessible storage buffers.
*
* This node can only be used with a WebGPU backend.
*
* @augments Node
*/
var WorkgroupInfoNode = class extends Node {
	/**
	* Constructs a new buffer scoped to type scope.
	*
	* @param {string} scope - TODO.
	* @param {string} bufferType - The data type of a 'workgroup' scoped buffer element.
	* @param {number} [bufferCount=0] - The number of elements in the buffer.
	*/
	constructor(scope, bufferType, bufferCount = 0) {
		super(bufferType);
		/**
		* The buffer type.
		*
		* @type {string}
		*/
		this.bufferType = bufferType;
		/**
		* The buffer count.
		*
		* @type {number}
		* @default 0
		*/
		this.bufferCount = bufferCount;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isWorkgroupInfoNode = true;
		/**
		* The data type of the array buffer.
		*
		* @type {string}
		*/
		this.elementType = bufferType;
		/**
		* TODO.
		*
		* @type {string}
		*/
		this.scope = scope;
		/**
		* The name of the workgroup scoped buffer.
		*
		* @type {string}
		* @default ''
		*/
		this.name = "";
	}
	/**
	* Sets the name of this node.
	*
	* @param {string} name - The name to set.
	* @return {WorkgroupInfoNode} A reference to this node.
	*/
	setName(name) {
		this.name = name;
		return this;
	}
	/**
	* Sets the name/label of this node.
	*
	* @deprecated
	* @param {string} name - The name to set.
	* @return {WorkgroupInfoNode} A reference to this node.
	*/
	label(name) {
		warn("TSL: \"label()\" has been deprecated. Use \"setName()\" instead.");
		return this.setName(name);
	}
	/**
	* Sets the scope of this node.
	*
	* @param {string} scope - The scope to set.
	* @return {WorkgroupInfoNode} A reference to this node.
	*/
	setScope(scope) {
		this.scope = scope;
		return this;
	}
	/**
	* The data type of the array buffer.
	*
	* @return {string} The element type.
	*/
	getElementType() {
		return this.elementType;
	}
	/**
	* Overwrites the default implementation since the input type
	* is inferred from the scope.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType() {
		return `${this.scope}Array`;
	}
	/**
	* This method can be used to access elements via an index node.
	*
	* @param {IndexNode} indexNode - indexNode.
	* @return {WorkgroupInfoElementNode} A reference to an element.
	*/
	element(indexNode) {
		return nodeObject$1(new WorkgroupInfoElementNode(this, indexNode));
	}
	generate(builder) {
		const name = this.name !== "" ? this.name : `${this.scope}Array_${this.id}`;
		return builder.getScopedArray(name, this.scope.toLowerCase(), this.bufferType, this.bufferCount);
	}
};
/**
* TSL function for creating a workgroup info node.
* Creates a new 'workgroup' scoped array buffer.
*
* @tsl
* @function
* @param {string} type - The data type of a 'workgroup' scoped buffer element.
* @param {number} [count=0] - The number of elements in the buffer.
* @returns {WorkgroupInfoNode}
*/
var workgroupArray$1 = (type$1, count) => nodeObject$1(new WorkgroupInfoNode("Workgroup", type$1, count));
/**
* `AtomicFunctionNode` represents any function that can operate on atomic variable types
* within a shader. In an atomic function, any modification to an atomic variable will
* occur as an indivisible step with a defined order relative to other modifications.
* Accordingly, even if multiple atomic functions are modifying an atomic variable at once
* atomic operations will not interfere with each other.
*
* This node can only be used with a WebGPU backend.
*
* @augments Node
*/
var AtomicFunctionNode = class extends Node {
	static get type() {
		return "AtomicFunctionNode";
	}
	/**
	* Constructs a new atomic function node.
	*
	* @param {string} method - The signature of the atomic function to construct.
	* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
	* @param {Node} valueNode - The value that mutates the atomic variable.
	*/
	constructor(method, pointerNode, valueNode) {
		super("uint");
		/**
		* The signature of the atomic function to construct.
		*
		* @type {string}
		*/
		this.method = method;
		/**
		* An atomic variable or element of an atomic buffer.
		*
		* @type {Node}
		*/
		this.pointerNode = pointerNode;
		/**
		* A value that modifies the atomic variable.
		*
		* @type {Node}
		*/
		this.valueNode = valueNode;
		/**
		* Creates a list of the parents for this node for detecting if the node needs to return a value.
		*
		* @type {boolean}
		* @default true
		*/
		this.parents = true;
	}
	/**
	* Overwrites the default implementation to return the type of
	* the pointer node.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The input type.
	*/
	getInputType(builder) {
		return this.pointerNode.getNodeType(builder);
	}
	/**
	* Overwritten since the node type is inferred from the input type.
	*
	* @param {NodeBuilder} builder - The current node builder.
	* @return {string} The node type.
	*/
	getNodeType(builder) {
		return this.getInputType(builder);
	}
	generate(builder) {
		const properties = builder.getNodeProperties(this);
		const parents = properties.parents;
		const method = this.method;
		const type$1 = this.getNodeType(builder);
		const inputType = this.getInputType(builder);
		const a$1 = this.pointerNode;
		const b$2 = this.valueNode;
		const params = [];
		params.push(`&${a$1.build(builder, inputType)}`);
		if (b$2 !== null) params.push(b$2.build(builder, inputType));
		const methodSnippet = `${builder.getMethod(method, type$1)}( ${params.join(", ")} )`;
		if (parents ? parents.length === 1 && parents[0].isStackNode === true : false) builder.addLineFlowCode(methodSnippet, this);
		else {
			if (properties.constNode === void 0) properties.constNode = expression$1(methodSnippet, type$1).toConst();
			return properties.constNode.build(builder);
		}
	}
};
AtomicFunctionNode.ATOMIC_LOAD = "atomicLoad";
AtomicFunctionNode.ATOMIC_STORE = "atomicStore";
AtomicFunctionNode.ATOMIC_ADD = "atomicAdd";
AtomicFunctionNode.ATOMIC_SUB = "atomicSub";
AtomicFunctionNode.ATOMIC_MAX = "atomicMax";
AtomicFunctionNode.ATOMIC_MIN = "atomicMin";
AtomicFunctionNode.ATOMIC_AND = "atomicAnd";
AtomicFunctionNode.ATOMIC_OR = "atomicOr";
AtomicFunctionNode.ATOMIC_XOR = "atomicXor";
/**
* TSL function for creating an atomic function node.
*
* @tsl
* @function
* @param {string} method - The signature of the atomic function to construct.
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @param {Node} valueNode - The value that mutates the atomic variable.
* @returns {AtomicFunctionNode}
*/
var atomicNode = nodeProxy$1(AtomicFunctionNode);
/**
* TSL function for appending an atomic function call into the programmatic flow of a compute shader.
*
* @tsl
* @function
* @param {string} method - The signature of the atomic function to construct.
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @param {Node} valueNode - The value that mutates the atomic variable.
* @returns {AtomicFunctionNode}
*/
var atomicFunc$1 = (method, pointerNode, valueNode) => {
	return atomicNode(method, pointerNode, valueNode).toStack();
};
/**
* Loads the value stored in the atomic variable.
*
* @tsl
* @function
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @returns {AtomicFunctionNode}
*/
var atomicLoad$1 = (pointerNode) => atomicFunc$1(AtomicFunctionNode.ATOMIC_LOAD, pointerNode, null);
/**
* Stores a value in the atomic variable.
*
* @tsl
* @function
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @param {Node} valueNode - The value that mutates the atomic variable.
* @returns {AtomicFunctionNode}
*/
var atomicStore$1 = (pointerNode, valueNode) => atomicFunc$1(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode);
/**
* Increments the value stored in the atomic variable.
*
* @tsl
* @function
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @param {Node} valueNode - The value that mutates the atomic variable.
* @returns {AtomicFunctionNode}
*/
var atomicAdd$1 = (pointerNode, valueNode) => atomicFunc$1(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode);
/**
* Decrements the value stored in the atomic variable.
*
* @tsl
* @function
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @param {Node} valueNode - The value that mutates the atomic variable.
* @returns {AtomicFunctionNode}
*/
var atomicSub$1 = (pointerNode, valueNode) => atomicFunc$1(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode);
/**
* Stores in an atomic variable the maximum between its current value and a parameter.
*
* @tsl
* @function
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @param {Node} valueNode - The value that mutates the atomic variable.
* @returns {AtomicFunctionNode}
*/
var atomicMax$1 = (pointerNode, valueNode) => atomicFunc$1(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode);
/**
* Stores in an atomic variable the minimum between its current value and a parameter.
*
* @tsl
* @function
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @param {Node} valueNode - The value that mutates the atomic variable.
* @returns {AtomicFunctionNode}
*/
var atomicMin$1 = (pointerNode, valueNode) => atomicFunc$1(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode);
/**
* Stores in an atomic variable the bitwise AND of its value with a parameter.
*
* @tsl
* @function
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @param {Node} valueNode - The value that mutates the atomic variable.
* @returns {AtomicFunctionNode}
*/
var atomicAnd$1 = (pointerNode, valueNode) => atomicFunc$1(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode);
/**
* Stores in an atomic variable the bitwise OR of its value with a parameter.
*
* @tsl
* @function
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @param {Node} valueNode - The value that mutates the atomic variable.
* @returns {AtomicFunctionNode}
*/
var atomicOr$1 = (pointerNode, valueNode) => atomicFunc$1(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode);
/**
* Stores in an atomic variable the bitwise XOR of its value with a parameter.
*
* @tsl
* @function
* @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
* @param {Node} valueNode - The value that mutates the atomic variable.
* @returns {AtomicFunctionNode}
*/
var atomicXor$1 = (pointerNode, valueNode) => atomicFunc$1(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode);
/**
* This class represents a set of built in WGSL shader functions that sync
* synchronously execute an operation across a subgroup, or 'warp', of compute
* or fragment shader invocations within a workgroup. Typically, these functions
* will synchronously execute an operation using data from all active invocations
* within the subgroup, then broadcast that result to all active invocations. In
* other graphics APIs, subgroup functions are also referred to as wave intrinsics
* (DirectX/HLSL) or warp intrinsics (CUDA).
*
* @augments TempNode
*/
var SubgroupFunctionNode = class SubgroupFunctionNode extends TempNode {
	static get type() {
		return "SubgroupFunctionNode";
	}
	/**
	* Constructs a new function node.
	*
	* @param {string} method - The subgroup/wave intrinsic method to construct.
	* @param {Node} [aNode=null] - The method's first argument.
	* @param {Node} [bNode=null] - The method's second argument.
	*/
	constructor(method, aNode = null, bNode = null) {
		super();
		/**
		* The subgroup/wave intrinsic method to construct.
		*
		* @type {String}
		*/
		this.method = method;
		/**
		* The method's first argument.
		*
		* @type {Node}
		*/
		this.aNode = aNode;
		/**
		* The method's second argument.
		*
		* @type {Node}
		*/
		this.bNode = bNode;
	}
	getInputType(builder) {
		const aType = this.aNode ? this.aNode.getNodeType(builder) : null;
		const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
		const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
		const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
		if (aLen > bLen) return aType;
		else return bType;
	}
	getNodeType(builder) {
		const method = this.method;
		if (method === SubgroupFunctionNode.SUBGROUP_ELECT) return "bool";
		else if (method === SubgroupFunctionNode.SUBGROUP_BALLOT) return "uvec4";
		else return this.getInputType(builder);
	}
	generate(builder, output$2) {
		const method = this.method;
		const type$1 = this.getNodeType(builder);
		const inputType = this.getInputType(builder);
		const a$1 = this.aNode;
		const b$2 = this.bNode;
		const params = [];
		if (method === SubgroupFunctionNode.SUBGROUP_BROADCAST || method === SubgroupFunctionNode.SUBGROUP_SHUFFLE || method === SubgroupFunctionNode.QUAD_BROADCAST) {
			const bType = b$2.getNodeType(builder);
			params.push(a$1.build(builder, type$1), b$2.build(builder, bType === "float" ? "int" : type$1));
		} else if (method === SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR || method === SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN || method === SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP) params.push(a$1.build(builder, type$1), b$2.build(builder, "uint"));
		else {
			if (a$1 !== null) params.push(a$1.build(builder, inputType));
			if (b$2 !== null) params.push(b$2.build(builder, inputType));
		}
		const paramsString = params.length === 0 ? "()" : `( ${params.join(", ")} )`;
		return builder.format(`${builder.getMethod(method, type$1)}${paramsString}`, type$1, output$2);
	}
	serialize(data) {
		super.serialize(data);
		data.method = this.method;
	}
	deserialize(data) {
		super.deserialize(data);
		this.method = data.method;
	}
};
SubgroupFunctionNode.SUBGROUP_ELECT = "subgroupElect";
SubgroupFunctionNode.SUBGROUP_BALLOT = "subgroupBallot";
SubgroupFunctionNode.SUBGROUP_ADD = "subgroupAdd";
SubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD = "subgroupInclusiveAdd";
SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND = "subgroupExclusiveAdd";
SubgroupFunctionNode.SUBGROUP_MUL = "subgroupMul";
SubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL = "subgroupInclusiveMul";
SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL = "subgroupExclusiveMul";
SubgroupFunctionNode.SUBGROUP_AND = "subgroupAnd";
SubgroupFunctionNode.SUBGROUP_OR = "subgroupOr";
SubgroupFunctionNode.SUBGROUP_XOR = "subgroupXor";
SubgroupFunctionNode.SUBGROUP_MIN = "subgroupMin";
SubgroupFunctionNode.SUBGROUP_MAX = "subgroupMax";
SubgroupFunctionNode.SUBGROUP_ALL = "subgroupAll";
SubgroupFunctionNode.SUBGROUP_ANY = "subgroupAny";
SubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST = "subgroupBroadcastFirst";
SubgroupFunctionNode.QUAD_SWAP_X = "quadSwapX";
SubgroupFunctionNode.QUAD_SWAP_Y = "quadSwapY";
SubgroupFunctionNode.QUAD_SWAP_DIAGONAL = "quadSwapDiagonal";
SubgroupFunctionNode.SUBGROUP_BROADCAST = "subgroupBroadcast";
SubgroupFunctionNode.SUBGROUP_SHUFFLE = "subgroupShuffle";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR = "subgroupShuffleXor";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP = "subgroupShuffleUp";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN = "subgroupShuffleDown";
SubgroupFunctionNode.QUAD_BROADCAST = "quadBroadcast";
/**
* Returns true if this invocation has the lowest subgroup_invocation_id
* among active invocations in the subgroup.
*
* @tsl
* @method
* @return {bool} The result of the computation.
*/
var subgroupElect$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ELECT).setParameterLength(0);
/**
* Returns a set of bitfields where the bit corresponding to subgroup_invocation_id
* is 1 if pred is true for that active invocation and 0 otherwise.
*
* @tsl
* @method
* @param {bool} pred - A boolean that sets the bit corresponding to the invocations subgroup invocation id.
* @return {vec4<u32>}- A bitfield corresponding to the pred value of each subgroup invocation.
*/
var subgroupBallot$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BALLOT).setParameterLength(1);
/**
* A reduction that adds e among all active invocations and returns that result.
*
* @tsl
* @method
* @param {number} e - The value provided to the reduction by the current invocation.
* @return {number} The accumulated result of the reduction operation.
*/
var subgroupAdd$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ADD).setParameterLength(1);
/**
* An inclusive scan returning the sum of e for all active invocations with subgroup_invocation_id less than or equal to this invocation.
*
* @tsl
* @method
* @param {number} e - The value provided to the inclusive scan by the current invocation.
* @return {number} The accumulated result of the inclusive scan operation.
*/
var subgroupInclusiveAdd$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD).setParameterLength(1);
/**
* An exclusive scan that returns the sum of e for all active invocations with subgroup_invocation_id less than this invocation.
*
* @tsl
* @method
* @param {number} e - The value provided to the exclusive scan by the current invocation.
* @return {number} The accumulated result of the exclusive scan operation.
*/
var subgroupExclusiveAdd$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND).setParameterLength(1);
/**
* A reduction that multiplies e among all active invocations and returns that result.
*
* @tsl
* @method
* @param {number} e - The value provided to the reduction by the current invocation.
* @return {number} The accumulated result of the reduction operation.
*/
var subgroupMul$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MUL).setParameterLength(1);
/**
* An inclusive scan returning the product of e for all active invocations with subgroup_invocation_id less than or equal to this invocation.
*
* @tsl
* @method
* @param {number} e - The value provided to the inclusive scan by the current invocation.
* @return {number} The accumulated result of the inclusive scan operation.
*/
var subgroupInclusiveMul$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL).setParameterLength(1);
/**
* An exclusive scan that returns the product of e for all active invocations with subgroup_invocation_id less than this invocation.
*
* @tsl
* @method
* @param {number} e - The value provided to the exclusive scan by the current invocation.
* @return {number} The accumulated result of the exclusive scan operation.
*/
var subgroupExclusiveMul$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL).setParameterLength(1);
/**
* A reduction that performs a bitwise and of e among all active invocations and returns that result.
*
* @tsl
* @method
* @param {number} e - The value provided to the reduction by the current invocation.
* @return {number} The result of the reduction operation.
*/
var subgroupAnd$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_AND).setParameterLength(1);
/**
* A reduction that performs a bitwise or of e among all active invocations and returns that result.
*
* @tsl
* @method
* @param {number} e - The value provided to the reduction by the current invocation.
* @return {number} The result of the reduction operation.
*/
var subgroupOr$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_OR).setParameterLength(1);
/**
* A reduction that performs a bitwise xor of e among all active invocations and returns that result.
*
* @tsl
* @method
* @param {number} e - The value provided to the reduction by the current invocation.
* @return {number} The result of the reduction operation.
*/
var subgroupXor$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_XOR).setParameterLength(1);
/**
* A reduction that performs a min of e among all active invocations and returns that result.
*
* @tsl
* @method
* @param {number} e - The value provided to the reduction by the current invocation.
* @return {number} The result of the reduction operation.
*/
var subgroupMin$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MIN).setParameterLength(1);
/**
* A reduction that performs a max of e among all active invocations and returns that result.
*
* @tsl
* @method
* @param {number} e - The value provided to the reduction by the current invocation.
* @return {number} The result of the reduction operation.
*/
var subgroupMax$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MAX).setParameterLength(1);
/**
* Returns true if e is true for all active invocations in the subgroup.
*
* @tsl
* @method
* @return {bool} The result of the computation.
*/
var subgroupAll$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ALL).setParameterLength(0);
/**
* Returns true if e is true for any active invocation in the subgroup
*
* @tsl
* @method
* @return {bool} The result of the computation.
*/
var subgroupAny$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ANY).setParameterLength(0);
/**
* Broadcasts e from the active invocation with the lowest subgroup_invocation_id in the subgroup to all other active invocations.
*
* @tsl
* @method
* @param {number} e - The value to broadcast from the lowest subgroup invocation.
* @param {number} id - The subgroup invocation to broadcast from.
* @return {number} The broadcast value.
*/
var subgroupBroadcastFirst$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST).setParameterLength(2);
/**
* Swaps e between invocations in the quad in the X direction.
*
* @tsl
* @method
* @param {number} e - The value to swap from the current invocation.
* @return {number} The value received from the swap operation.
*/
var quadSwapX = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_X).setParameterLength(1);
/**
* Swaps e between invocations in the quad in the Y direction.
*
* @tsl
* @method
* @param {number} e - The value to swap from the current invocation.
* @return {number} The value received from the swap operation.
*/
var quadSwapY = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_Y).setParameterLength(1);
/**
* Swaps e between invocations in the quad diagonally.
*
* @tsl
* @method
* @param {number} e - The value to swap from the current invocation.
* @return {number} The value received from the swap operation.
*/
var quadSwapDiagonal = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_DIAGONAL).setParameterLength(1);
/**
* Broadcasts e from the invocation whose subgroup_invocation_id matches id, to all active invocations.
*
* @tsl
* @method
* @param {number} e - The value to broadcast from subgroup invocation 'id'.
* @param {number} id - The subgroup invocation to broadcast from.
* @return {number} The broadcast value.
*/
var subgroupBroadcast$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BROADCAST).setParameterLength(2);
/**
* Returns v from the active invocation whose subgroup_invocation_id matches id
*
* @tsl
* @method
* @param {number} v - The value to return from subgroup invocation id^mask.
* @param {number} id - The subgroup invocation which returns the value v.
* @return {number} The broadcast value.
*/
var subgroupShuffle$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE).setParameterLength(2);
/**
* Returns v from the active invocation whose subgroup_invocation_id matches subgroup_invocation_id ^ mask.
*
* @tsl
* @method
* @param {number} v - The value to return from subgroup invocation id^mask.
* @param {number} mask - A bitmask that determines the target invocation via a XOR operation.
* @return {number} The broadcast value.
*/
var subgroupShuffleXor$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR).setParameterLength(2);
/**
* Returns v from the active invocation whose subgroup_invocation_id matches subgroup_invocation_id - delta
*
* @tsl
* @method
* @param {number} v - The value to return from subgroup invocation id^mask.
* @param {number} delta - A value that offsets the current in.
* @return {number} The broadcast value.
*/
var subgroupShuffleUp$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP).setParameterLength(2);
/**
* Returns v from the active invocation whose subgroup_invocation_id matches subgroup_invocation_id + delta
*
* @tsl
* @method
* @param {number} v - The value to return from subgroup invocation id^mask.
* @param {number} delta - A value that offsets the current subgroup invocation.
* @return {number} The broadcast value.
*/
var subgroupShuffleDown$1 = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN).setParameterLength(2);
/**
* Broadcasts e from the quad invocation with id equal to id.
*
* @tsl
* @method
* @param {number} e - The value to broadcast.
* @return {number} The broadcast value.
*/
var quadBroadcast = /* @__PURE__ */ nodeProxyIntent$1(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_BROADCAST).setParameterLength(1);
var uniformsLib;
function getLightData(light) {
	uniformsLib = uniformsLib || /* @__PURE__ */ new WeakMap();
	let uniforms = uniformsLib.get(light);
	if (uniforms === void 0) uniformsLib.set(light, uniforms = {});
	return uniforms;
}
/**
* TSL function for getting a shadow matrix uniform node for the given light.
*
* @tsl
* @function
* @param {Light} light -The light source.
* @returns {UniformNode<mat4>} The shadow matrix uniform node.
*/
function lightShadowMatrix$1(light) {
	const data = getLightData(light);
	return data.shadowMatrix || (data.shadowMatrix = uniform$1("mat4").setGroup(renderGroup$1).onRenderUpdate((frame) => {
		if (light.castShadow !== true || frame.renderer.shadowMap.enabled === false) {
			if (light.shadow.camera.coordinateSystem !== frame.camera.coordinateSystem) {
				light.shadow.camera.coordinateSystem = frame.camera.coordinateSystem;
				light.shadow.camera.updateProjectionMatrix();
			}
			light.shadow.updateMatrices(light);
		}
		return light.shadow.matrix;
	}));
}
/**
* TSL function for getting projected uv coordinates for the given light.
* Relevant when using maps with spot lights.
*
* @tsl
* @function
* @param {Light} light -The light source.
* @param {Node<vec3>} [position=positionWorld] -The position to project.
* @returns {Node<vec3>} The projected uvs.
*/
function lightProjectionUV$1(light, position = positionWorld$1) {
	const spotLightCoord = lightShadowMatrix$1(light).mul(position);
	return spotLightCoord.xyz.div(spotLightCoord.w);
}
/**
* TSL function for getting the position in world space for the given light.
*
* @tsl
* @function
* @param {Light} light -The light source.
* @returns {UniformNode<vec3>} The light's position in world space.
*/
function lightPosition$1(light) {
	const data = getLightData(light);
	return data.position || (data.position = uniform$1(new Vector3()).setGroup(renderGroup$1).onRenderUpdate((_, self$1) => self$1.value.setFromMatrixPosition(light.matrixWorld)));
}
/**
* TSL function for getting the light target position in world space for the given light.
*
* @tsl
* @function
* @param {Light} light -The light source.
* @returns {UniformNode<vec3>} The light target position in world space.
*/
function lightTargetPosition$1(light) {
	const data = getLightData(light);
	return data.targetPosition || (data.targetPosition = uniform$1(new Vector3()).setGroup(renderGroup$1).onRenderUpdate((_, self$1) => self$1.value.setFromMatrixPosition(light.target.matrixWorld)));
}
/**
* TSL function for getting the position in view space for the given light.
*
* @tsl
* @function
* @param {Light} light - The light source.
* @returns {UniformNode<vec3>} The light's position in view space.
*/
function lightViewPosition$1(light) {
	const data = getLightData(light);
	return data.viewPosition || (data.viewPosition = uniform$1(new Vector3()).setGroup(renderGroup$1).onRenderUpdate(({ camera }, self$1) => {
		self$1.value = self$1.value || new Vector3();
		self$1.value.setFromMatrixPosition(light.matrixWorld);
		self$1.value.applyMatrix4(camera.matrixWorldInverse);
	}));
}
/**
* TSL function for getting the light target direction for the given light.
*
* @tsl
* @function
* @param {Light} light -The light source.
* @returns {Node<vec3>} The light's target direction.
*/
var lightTargetDirection$1 = (light) => cameraViewMatrix$1.transformDirection(lightPosition$1(light).sub(lightTargetPosition$1(light)));
var sortLights = (lights$2) => {
	return lights$2.sort((a$1, b$2) => a$1.id - b$2.id);
};
var getLightNodeById = (id, lightNodes) => {
	for (const lightNode of lightNodes) if (lightNode.isAnalyticLightNode && lightNode.light.id === id) return lightNode;
	return null;
};
var _lightsNodeRef = /* @__PURE__ */ new WeakMap();
var _hashData = [];
/**
* This node represents the scene's lighting and manages the lighting model's life cycle
* for the current build 3D object. It is responsible for computing the total outgoing
* light in a given lighting context.
*
* @augments Node
*/
var LightsNode = class extends Node {
	static get type() {
		return "LightsNode";
	}
	/**
	* Constructs a new lights node.
	*/
	constructor() {
		super("vec3");
		/**
		* A node representing the total diffuse light.
		*
		* @type {Node<vec3>}
		*/
		this.totalDiffuseNode = property$1("vec3", "totalDiffuse");
		/**
		* A node representing the total specular light.
		*
		* @type {Node<vec3>}
		*/
		this.totalSpecularNode = property$1("vec3", "totalSpecular");
		/**
		* A node representing the outgoing light.
		*
		* @type {Node<vec3>}
		*/
		this.outgoingLightNode = property$1("vec3", "outgoingLight");
		/**
		* An array representing the lights in the scene.
		*
		* @private
		* @type {Array<Light>}
		*/
		this._lights = [];
		/**
		* For each light in the scene, this node will create a
		* corresponding light node.
		*
		* @private
		* @type {?Array<LightingNode>}
		* @default null
		*/
		this._lightNodes = null;
		/**
		* A hash for identifying the current light nodes setup.
		*
		* @private
		* @type {?string}
		* @default null
		*/
		this._lightNodesHash = null;
		/**
		* `LightsNode` sets this property to `true` by default.
		*
		* @type {boolean}
		* @default true
		*/
		this.global = true;
	}
	/**
	* Overwrites the default {@link Node#customCacheKey} implementation by including
	* light data into the cache key.
	*
	* @return {number} The custom cache key.
	*/
	customCacheKey() {
		const lights$2 = this._lights;
		for (let i = 0; i < lights$2.length; i++) {
			const light = lights$2[i];
			_hashData.push(light.id);
			_hashData.push(light.castShadow ? 1 : 0);
			if (light.isSpotLight === true) {
				const hashMap = light.map !== null ? light.map.id : -1;
				const hashColorNode = light.colorNode ? light.colorNode.getCacheKey() : -1;
				_hashData.push(hashMap, hashColorNode);
			}
		}
		const cacheKey = hashArray(_hashData);
		_hashData.length = 0;
		return cacheKey;
	}
	/**
	* Computes a hash value for identifying the current light nodes setup.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @return {string} The computed hash.
	*/
	getHash(builder) {
		if (this._lightNodesHash === null) {
			if (this._lightNodes === null) this.setupLightsNode(builder);
			const hash$3 = [];
			for (const lightNode of this._lightNodes) hash$3.push(lightNode.getHash());
			this._lightNodesHash = "lights-" + hash$3.join(",");
		}
		return this._lightNodesHash;
	}
	analyze(builder) {
		const properties = builder.getNodeProperties(this);
		for (const node of properties.nodes) node.build(builder);
		properties.outputNode.build(builder);
	}
	/**
	* Creates lighting nodes for each scene light. This makes it possible to further
	* process lights in the node system.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	*/
	setupLightsNode(builder) {
		const lightNodes = [];
		const previousLightNodes = this._lightNodes;
		const lights$2 = sortLights(this._lights);
		const nodeLibrary = builder.renderer.library;
		for (const light of lights$2) if (light.isNode) lightNodes.push(nodeObject$1(light));
		else {
			let lightNode = null;
			if (previousLightNodes !== null) lightNode = getLightNodeById(light.id, previousLightNodes);
			if (lightNode === null) {
				const lightNodeClass = nodeLibrary.getLightNodeClass(light.constructor);
				if (lightNodeClass === null) {
					warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);
					continue;
				}
				let lightNode$1 = null;
				if (!_lightsNodeRef.has(light)) {
					lightNode$1 = nodeObject$1(new lightNodeClass(light));
					_lightsNodeRef.set(light, lightNode$1);
				} else lightNode$1 = _lightsNodeRef.get(light);
				lightNodes.push(lightNode$1);
			}
		}
		this._lightNodes = lightNodes;
	}
	/**
	* Sets up a direct light in the lighting model.
	*
	* @param {Object} builder - The builder object containing the context and stack.
	* @param {Object} lightNode - The light node.
	* @param {Object} lightData - The light object containing color and direction properties.
	*/
	setupDirectLight(builder, lightNode, lightData) {
		const { lightingModel, reflectedLight } = builder.context;
		lightingModel.direct({
			...lightData,
			lightNode,
			reflectedLight
		}, builder);
	}
	setupDirectRectAreaLight(builder, lightNode, lightData) {
		const { lightingModel, reflectedLight } = builder.context;
		lightingModel.directRectArea({
			...lightData,
			lightNode,
			reflectedLight
		}, builder);
	}
	/**
	* Setups the internal lights by building all respective
	* light nodes.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @param {Array<LightingNode>} lightNodes - An array of lighting nodes.
	*/
	setupLights(builder, lightNodes) {
		for (const lightNode of lightNodes) lightNode.build(builder);
	}
	getLightNodes(builder) {
		if (this._lightNodes === null) this.setupLightsNode(builder);
		return this._lightNodes;
	}
	/**
	* The implementation makes sure that for each light in the scene
	* there is a corresponding light node. By building the light nodes
	* and evaluating the lighting model the outgoing light is computed.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @return {Node<vec3>} A node representing the outgoing light.
	*/
	setup(builder) {
		const currentLightsNode = builder.lightsNode;
		builder.lightsNode = this;
		let outgoingLightNode = this.outgoingLightNode;
		const context$2 = builder.context;
		const lightingModel = context$2.lightingModel;
		const properties = builder.getNodeProperties(this);
		if (lightingModel) {
			const { totalDiffuseNode, totalSpecularNode } = this;
			context$2.outgoingLight = outgoingLightNode;
			properties.nodes = builder.addStack().nodes;
			lightingModel.start(builder);
			const { backdrop, backdropAlpha } = context$2;
			const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context$2.reflectedLight;
			let totalDiffuse = directDiffuse.add(indirectDiffuse);
			if (backdrop !== null) if (backdropAlpha !== null) totalDiffuse = vec3$1(backdropAlpha.mix(totalDiffuse, backdrop));
			else totalDiffuse = vec3$1(backdrop);
			totalDiffuseNode.assign(totalDiffuse);
			totalSpecularNode.assign(directSpecular.add(indirectSpecular));
			outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));
			lightingModel.finish(builder);
			outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
		} else properties.nodes = [];
		builder.lightsNode = currentLightsNode;
		return outgoingLightNode;
	}
	/**
	* Configures this node with an array of lights.
	*
	* @param {Array<Light>} lights - An array of lights.
	* @return {LightsNode} A reference to this node.
	*/
	setLights(lights$2) {
		this._lights = lights$2;
		this._lightNodes = null;
		this._lightNodesHash = null;
		return this;
	}
	/**
	* Returns an array of the scene's lights.
	*
	* @return {Array<Light>} The scene's lights.
	*/
	getLights() {
		return this._lights;
	}
	/**
	* Whether the scene has lights or not.
	*
	* @type {boolean}
	*/
	get hasLights() {
		return this._lights.length > 0;
	}
};
/**
* TSL function for creating an instance of `LightsNode` and configuring
* it with the given array of lights.
*
* @tsl
* @function
* @param {Array<Light>} lights - An array of lights.
* @return {LightsNode} The created lights node.
*/
var lights$1 = (lights$2 = []) => nodeObject$1(new LightsNode()).setLights(lights$2);
/**
* Base class for all shadow nodes.
*
* Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.
* Lighting nodes might share the same shadow node type or use specific ones depending on
* their requirements.
*
* @augments Node
*/
var ShadowBaseNode = class extends Node {
	static get type() {
		return "ShadowBaseNode";
	}
	/**
	* Constructs a new shadow base node.
	*
	* @param {Light} light - The shadow casting light.
	*/
	constructor(light) {
		super();
		/**
		* The shadow casting light.
		*
		* @type {Light}
		*/
		this.light = light;
		/**
		* Overwritten since shadows are updated by default per render.
		*
		* @type {string}
		* @default 'render'
		*/
		this.updateBeforeType = NodeUpdateType$1.RENDER;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isShadowBaseNode = true;
	}
	/**
	* Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.
	*
	* @param {NodeBuilder} object - A configuration object that must at least hold a material reference.
	*/
	setupShadowPosition({ context: context$2, material }) {
		shadowPositionWorld$1.assign(material.receivedShadowPositionNode || context$2.shadowPositionWorld || positionWorld$1);
	}
};
/**
* TSL object that represents the vertex position in world space during the shadow pass.
*
* @tsl
* @type {Node<vec3>}
*/
var shadowPositionWorld$1 = /* @__PURE__ */ property$1("vec3", "shadowPositionWorld");
/**
* Saves the state of the given renderer and stores it into the given state object.
*
* If not state object is provided, the function creates one.
*
* @private
* @function
* @param {Renderer} renderer - The renderer.
* @param {Object} [state={}] - The state.
* @return {Object} The state.
*/
function saveRendererState(renderer, state = {}) {
	state.toneMapping = renderer.toneMapping;
	state.toneMappingExposure = renderer.toneMappingExposure;
	state.outputColorSpace = renderer.outputColorSpace;
	state.renderTarget = renderer.getRenderTarget();
	state.activeCubeFace = renderer.getActiveCubeFace();
	state.activeMipmapLevel = renderer.getActiveMipmapLevel();
	state.renderObjectFunction = renderer.getRenderObjectFunction();
	state.pixelRatio = renderer.getPixelRatio();
	state.mrt = renderer.getMRT();
	state.clearColor = renderer.getClearColor(state.clearColor || new Color$1());
	state.clearAlpha = renderer.getClearAlpha();
	state.autoClear = renderer.autoClear;
	state.scissorTest = renderer.getScissorTest();
	return state;
}
/**
* Saves the state of the given renderer and stores it into the given state object.
* Besides, the function also resets the state of the renderer to its default values.
*
* If not state object is provided, the function creates one.
*
* @private
* @function
* @param {Renderer} renderer - The renderer.
* @param {Object} [state={}] - The state.
* @return {Object} The state.
*/
function resetRendererState(renderer, state) {
	state = saveRendererState(renderer, state);
	renderer.setMRT(null);
	renderer.setRenderObjectFunction(null);
	renderer.setClearColor(0, 1);
	renderer.autoClear = true;
	return state;
}
/**
* Restores the state of the given renderer from the given state object.
*
* @private
* @function
* @param {Renderer} renderer - The renderer.
* @param {Object} state - The state to restore.
*/
function restoreRendererState(renderer, state) {
	renderer.toneMapping = state.toneMapping;
	renderer.toneMappingExposure = state.toneMappingExposure;
	renderer.outputColorSpace = state.outputColorSpace;
	renderer.setRenderTarget(state.renderTarget, state.activeCubeFace, state.activeMipmapLevel);
	renderer.setRenderObjectFunction(state.renderObjectFunction);
	renderer.setPixelRatio(state.pixelRatio);
	renderer.setMRT(state.mrt);
	renderer.setClearColor(state.clearColor, state.clearAlpha);
	renderer.autoClear = state.autoClear;
	renderer.setScissorTest(state.scissorTest);
}
/**
* Saves the state of the given scene and stores it into the given state object.
*
* If not state object is provided, the function creates one.
*
* @private
* @function
* @param {Scene} scene - The scene.
* @param {Object} [state={}] - The state.
* @return {Object} The state.
*/
function saveSceneState(scene, state = {}) {
	state.background = scene.background;
	state.backgroundNode = scene.backgroundNode;
	state.overrideMaterial = scene.overrideMaterial;
	return state;
}
/**
* Saves the state of the given scene and stores it into the given state object.
* Besides, the function also resets the state of the scene to its default values.
*
* If not state object is provided, the function creates one.
*
* @private
* @function
* @param {Scene} scene - The scene.
* @param {Object} [state={}] - The state.
* @return {Object} The state.
*/
function resetSceneState(scene, state) {
	state = saveSceneState(scene, state);
	scene.background = null;
	scene.backgroundNode = null;
	scene.overrideMaterial = null;
	return state;
}
/**
* Restores the state of the given scene from the given state object.
*
* @private
* @function
* @param {Scene} scene - The scene.
* @param {Object} state - The state to restore.
*/
function restoreSceneState(scene, state) {
	scene.background = state.background;
	scene.backgroundNode = state.backgroundNode;
	scene.overrideMaterial = state.overrideMaterial;
}
/**
* Saves the state of the given renderer and scene and stores it into the given state object.
* Besides, the function also resets the state of the renderer and scene to its default values.
*
* If not state object is provided, the function creates one.
*
* @private
* @function
* @param {Renderer} renderer - The renderer.
* @param {Scene} scene - The scene.
* @param {Object} [state={}] - The state.
* @return {Object} The state.
*/
function resetRendererAndSceneState(renderer, scene, state) {
	state = resetRendererState(renderer, state);
	state = resetSceneState(scene, state);
	return state;
}
/**
* Restores the state of the given renderer and scene from the given state object.
*
* @private
* @function
* @param {Renderer} renderer - The renderer.
* @param {Scene} scene - The scene.
* @param {Object} state - The state to restore.
*/
function restoreRendererAndSceneState(renderer, scene, state) {
	restoreRendererState(renderer, state);
	restoreSceneState(scene, state);
}
var shadowMaterialLib = /* @__PURE__ */ new WeakMap();
/**
* A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map
* with a binary `[0,1]` result.
*
* @method
* @param {Object} inputs - The input parameter object.
* @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
* @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
* @return {Node<float>} The filtering result.
*/
var BasicShadowFilter$1 = /* @__PURE__ */ Fn$1(({ depthTexture, shadowCoord, depthLayer }) => {
	let basic = texture$1(depthTexture, shadowCoord.xy).setName("t_basic");
	if (depthTexture.isArrayTexture) basic = basic.depth(depthLayer);
	return basic.compare(shadowCoord.z);
});
/**
* A shadow filtering function performing PCF filtering.
*
* @method
* @param {Object} inputs - The input parameter object.
* @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
* @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
* @param {LightShadow} inputs.shadow - The light shadow.
* @return {Node<float>} The filtering result.
*/
var PCFShadowFilter$1 = /* @__PURE__ */ Fn$1(({ depthTexture, shadowCoord, shadow: shadow$2, depthLayer }) => {
	const depthCompare = (uv$3, compare) => {
		let depth$2 = texture$1(depthTexture, uv$3);
		if (depthTexture.isArrayTexture) depth$2 = depth$2.depth(depthLayer);
		return depth$2.compare(compare);
	};
	const mapSize = reference$2("mapSize", "vec2", shadow$2).setGroup(renderGroup$1);
	const radius = reference$2("radius", "float", shadow$2).setGroup(renderGroup$1);
	const texelSize = vec2$1(1).div(mapSize);
	const dx0 = texelSize.x.negate().mul(radius);
	const dy0 = texelSize.y.negate().mul(radius);
	const dx1 = texelSize.x.mul(radius);
	const dy1 = texelSize.y.mul(radius);
	const dx2 = dx0.div(2);
	const dy2 = dy0.div(2);
	const dx3 = dx1.div(2);
	const dy3 = dy1.div(2);
	return add$1(depthCompare(shadowCoord.xy.add(vec2$1(dx0, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(0, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx1, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx2, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(0, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx3, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx0, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx2, 0)), shadowCoord.z), depthCompare(shadowCoord.xy, shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx3, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx1, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx2, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(0, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx3, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx0, dy1)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(0, dy1)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2$1(dx1, dy1)), shadowCoord.z)).mul(1 / 17);
});
/**
* A shadow filtering function performing PCF soft filtering.
*
* @method
* @param {Object} inputs - The input parameter object.
* @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
* @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
* @param {LightShadow} inputs.shadow - The light shadow.
* @return {Node<float>} The filtering result.
*/
var PCFSoftShadowFilter$1 = /* @__PURE__ */ Fn$1(({ depthTexture, shadowCoord, shadow: shadow$2, depthLayer }) => {
	const depthCompare = (uv$4, compare) => {
		let depth$2 = texture$1(depthTexture, uv$4);
		if (depthTexture.isArrayTexture) depth$2 = depth$2.depth(depthLayer);
		return depth$2.compare(compare);
	};
	const mapSize = reference$2("mapSize", "vec2", shadow$2).setGroup(renderGroup$1);
	const texelSize = vec2$1(1).div(mapSize);
	const dx = texelSize.x;
	const dy = texelSize.y;
	const uv$3 = shadowCoord.xy;
	const f = fract$1(uv$3.mul(mapSize).add(.5));
	uv$3.subAssign(f.mul(texelSize));
	return add$1(depthCompare(uv$3, shadowCoord.z), depthCompare(uv$3.add(vec2$1(dx, 0)), shadowCoord.z), depthCompare(uv$3.add(vec2$1(0, dy)), shadowCoord.z), depthCompare(uv$3.add(texelSize), shadowCoord.z), mix$2(depthCompare(uv$3.add(vec2$1(dx.negate(), 0)), shadowCoord.z), depthCompare(uv$3.add(vec2$1(dx.mul(2), 0)), shadowCoord.z), f.x), mix$2(depthCompare(uv$3.add(vec2$1(dx.negate(), dy)), shadowCoord.z), depthCompare(uv$3.add(vec2$1(dx.mul(2), dy)), shadowCoord.z), f.x), mix$2(depthCompare(uv$3.add(vec2$1(0, dy.negate())), shadowCoord.z), depthCompare(uv$3.add(vec2$1(0, dy.mul(2))), shadowCoord.z), f.y), mix$2(depthCompare(uv$3.add(vec2$1(dx, dy.negate())), shadowCoord.z), depthCompare(uv$3.add(vec2$1(dx, dy.mul(2))), shadowCoord.z), f.y), mix$2(mix$2(depthCompare(uv$3.add(vec2$1(dx.negate(), dy.negate())), shadowCoord.z), depthCompare(uv$3.add(vec2$1(dx.mul(2), dy.negate())), shadowCoord.z), f.x), mix$2(depthCompare(uv$3.add(vec2$1(dx.negate(), dy.mul(2))), shadowCoord.z), depthCompare(uv$3.add(vec2$1(dx.mul(2), dy.mul(2))), shadowCoord.z), f.x), f.y)).mul(1 / 9);
});
/**
* A shadow filtering function performing VSM filtering.
*
* @method
* @param {Object} inputs - The input parameter object.
* @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
* @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
* @return {Node<float>} The filtering result.
*/
var VSMShadowFilter$1 = /* @__PURE__ */ Fn$1(({ depthTexture, shadowCoord, depthLayer }) => {
	const occlusion = float$1(1).toVar();
	let distribution = texture$1(depthTexture).sample(shadowCoord.xy);
	if (depthTexture.isArrayTexture) distribution = distribution.depth(depthLayer);
	distribution = distribution.rg;
	const hardShadow = step$1(shadowCoord.z, distribution.x);
	If$1(hardShadow.notEqual(float$1(1)), () => {
		const distance$3 = shadowCoord.z.sub(distribution.x);
		const variance = max$1$1(0, distribution.y.mul(distribution.y));
		let softnessProbability = variance.div(variance.add(distance$3.mul(distance$3)));
		softnessProbability = clamp$2(sub$1(softnessProbability, .3).div(.6499999999999999));
		occlusion.assign(clamp$2(max$1$1(hardShadow, softnessProbability)));
	});
	return occlusion;
});
var linearDistance = /* @__PURE__ */ Fn$1(([position, cameraNear$2, cameraFar$2]) => {
	let dist = positionWorld$1.sub(position).length();
	dist = dist.sub(cameraNear$2).div(cameraFar$2.sub(cameraNear$2));
	dist = dist.saturate();
	return dist;
});
var linearShadowDistance = (light) => {
	const camera = light.shadow.camera;
	const nearDistance = reference$2("near", "float", camera).setGroup(renderGroup$1);
	const farDistance = reference$2("far", "float", camera).setGroup(renderGroup$1);
	const referencePosition = objectPosition$1(light);
	return linearDistance(referencePosition, nearDistance, farDistance);
};
/**
* Retrieves or creates a shadow material for the given light source.
*
* This function checks if a shadow material already exists for the provided light.
* If not, it creates a new `NodeMaterial` configured for shadow rendering and stores it
* in the `shadowMaterialLib` for future use.
*
* @tsl
* @function
* @param {Light} light - The light source for which the shadow material is needed.
*                         If the light is a point light, a depth node is calculated
*                         using the linear shadow distance.
* @returns {NodeMaterial} The shadow material associated with the given light.
*/
var getShadowMaterial$1 = (light) => {
	let material = shadowMaterialLib.get(light);
	if (material === void 0) {
		const depthNode = light.isPointLight ? linearShadowDistance(light) : null;
		material = new NodeMaterial();
		material.colorNode = vec4$1(0, 0, 0, 1);
		material.depthNode = depthNode;
		material.isShadowPassMaterial = true;
		material.name = "ShadowMaterial";
		material.fog = false;
		shadowMaterialLib.set(light, material);
	}
	return material;
};
var _shadowRenderObjectLibrary = /* @__PURE__ */ new ChainMap();
var _shadowRenderObjectKeys = [];
/**
* Creates a function to render shadow objects in a scene.
*
* @tsl
* @function
* @param {Renderer} renderer - The renderer.
* @param {LightShadow} shadow - The light shadow object containing shadow properties.
* @param {number} shadowType - The type of shadow map (e.g., BasicShadowMap).
* @param {boolean} useVelocity - Whether to use velocity data for rendering.
* @return {Function} A function that renders shadow objects.
*
* The returned function has the following parameters:
* @param {Object3D} object - The 3D object to render.
* @param {Scene} scene - The scene containing the object.
* @param {Camera} _camera - The camera used for rendering.
* @param {BufferGeometry} geometry - The geometry of the object.
* @param {Material} material - The material of the object.
* @param {Group} group - The group the object belongs to.
* @param {...any} params - Additional parameters for rendering.
*/
var getShadowRenderObjectFunction$1 = (renderer, shadow$2, shadowType, useVelocity) => {
	_shadowRenderObjectKeys[0] = renderer;
	_shadowRenderObjectKeys[1] = shadow$2;
	let renderObjectFunction = _shadowRenderObjectLibrary.get(_shadowRenderObjectKeys);
	if (renderObjectFunction === void 0 || renderObjectFunction.shadowType !== shadowType || renderObjectFunction.useVelocity !== useVelocity) {
		renderObjectFunction = (object, scene, _camera$1, geometry, material, group, ...params) => {
			if (object.castShadow === true || object.receiveShadow && shadowType === VSMShadowMap) {
				if (useVelocity) getDataFromObject(object).useVelocity = true;
				object.onBeforeShadow(renderer, object, _camera$1, shadow$2.camera, geometry, scene.overrideMaterial, group);
				renderer.renderObject(object, scene, _camera$1, geometry, material, group, ...params);
				object.onAfterShadow(renderer, object, _camera$1, shadow$2.camera, geometry, scene.overrideMaterial, group);
			}
		};
		renderObjectFunction.shadowType = shadowType;
		renderObjectFunction.useVelocity = useVelocity;
		_shadowRenderObjectLibrary.set(_shadowRenderObjectKeys, renderObjectFunction);
	}
	_shadowRenderObjectKeys[0] = null;
	_shadowRenderObjectKeys[1] = null;
	return renderObjectFunction;
};
/**
* Represents the shader code for the first VSM render pass.
*
* @method
* @param {Object} inputs - The input parameter object.
* @param {Node<float>} inputs.samples - The number of samples
* @param {Node<float>} inputs.radius - The radius.
* @param {Node<float>} inputs.size - The size.
* @param {TextureNode} inputs.shadowPass - A reference to the render target's depth data.
* @return {Node<vec2>} The VSM output.
*/
var VSMPassVertical = /* @__PURE__ */ Fn$1(({ samples, radius, size, shadowPass, depthLayer }) => {
	const mean = float$1(0).toVar("meanVertical");
	const squaredMean = float$1(0).toVar("squareMeanVertical");
	const uvStride = samples.lessThanEqual(float$1(1)).select(float$1(0), float$1(2).div(samples.sub(1)));
	const uvStart = samples.lessThanEqual(float$1(1)).select(float$1(0), float$1(-1));
	Loop$1({
		start: int$1(0),
		end: int$1(samples),
		type: "int",
		condition: "<"
	}, ({ i }) => {
		const uvOffset = uvStart.add(float$1(i).mul(uvStride));
		let depth$2 = shadowPass.sample(add$1(screenCoordinate$1.xy, vec2$1(0, uvOffset).mul(radius)).div(size));
		if (shadowPass.value.isArrayTexture) depth$2 = depth$2.depth(depthLayer);
		depth$2 = depth$2.x;
		mean.addAssign(depth$2);
		squaredMean.addAssign(depth$2.mul(depth$2));
	});
	mean.divAssign(samples);
	squaredMean.divAssign(samples);
	const std_dev = sqrt$1(squaredMean.sub(mean.mul(mean)));
	return vec2$1(mean, std_dev);
});
/**
* Represents the shader code for the second VSM render pass.
*
* @method
* @param {Object} inputs - The input parameter object.
* @param {Node<float>} inputs.samples - The number of samples
* @param {Node<float>} inputs.radius - The radius.
* @param {Node<float>} inputs.size - The size.
* @param {TextureNode} inputs.shadowPass - The result of the first VSM render pass.
* @return {Node<vec2>} The VSM output.
*/
var VSMPassHorizontal = /* @__PURE__ */ Fn$1(({ samples, radius, size, shadowPass, depthLayer }) => {
	const mean = float$1(0).toVar("meanHorizontal");
	const squaredMean = float$1(0).toVar("squareMeanHorizontal");
	const uvStride = samples.lessThanEqual(float$1(1)).select(float$1(0), float$1(2).div(samples.sub(1)));
	const uvStart = samples.lessThanEqual(float$1(1)).select(float$1(0), float$1(-1));
	Loop$1({
		start: int$1(0),
		end: int$1(samples),
		type: "int",
		condition: "<"
	}, ({ i }) => {
		const uvOffset = uvStart.add(float$1(i).mul(uvStride));
		let distribution = shadowPass.sample(add$1(screenCoordinate$1.xy, vec2$1(uvOffset, 0).mul(radius)).div(size));
		if (shadowPass.value.isArrayTexture) distribution = distribution.depth(depthLayer);
		mean.addAssign(distribution.x);
		squaredMean.addAssign(add$1(distribution.y.mul(distribution.y), distribution.x.mul(distribution.x)));
	});
	mean.divAssign(samples);
	squaredMean.divAssign(samples);
	const std_dev = sqrt$1(squaredMean.sub(mean.mul(mean)));
	return vec2$1(mean, std_dev);
});
var _shadowFilterLib = [
	BasicShadowFilter$1,
	PCFShadowFilter$1,
	PCFSoftShadowFilter$1,
	VSMShadowFilter$1
];
var _rendererState;
var _quadMesh = /* @__PURE__ */ new QuadMesh();
/**
* Represents the default shadow implementation for lighting nodes.
*
* @augments ShadowBaseNode
*/
var ShadowNode = class extends ShadowBaseNode {
	static get type() {
		return "ShadowNode";
	}
	/**
	* Constructs a new shadow node.
	*
	* @param {Light} light - The shadow casting light.
	* @param {?LightShadow} [shadow=null] - An optional light shadow.
	*/
	constructor(light, shadow$2 = null) {
		super(light);
		/**
		* The light shadow which defines the properties light's
		* shadow.
		*
		* @type {?LightShadow}
		* @default null
		*/
		this.shadow = shadow$2 || light.shadow;
		/**
		* A reference to the shadow map which is a render target.
		*
		* @type {?RenderTarget}
		* @default null
		*/
		this.shadowMap = null;
		/**
		* Only relevant for VSM shadows. Render target for the
		* first VSM render pass.
		*
		* @type {?RenderTarget}
		* @default null
		*/
		this.vsmShadowMapVertical = null;
		/**
		* Only relevant for VSM shadows. Render target for the
		* second VSM render pass.
		*
		* @type {?RenderTarget}
		* @default null
		*/
		this.vsmShadowMapHorizontal = null;
		/**
		* Only relevant for VSM shadows. Node material which
		* is used to render the first VSM pass.
		*
		* @type {?NodeMaterial}
		* @default null
		*/
		this.vsmMaterialVertical = null;
		/**
		* Only relevant for VSM shadows. Node material which
		* is used to render the second VSM pass.
		*
		* @type {?NodeMaterial}
		* @default null
		*/
		this.vsmMaterialHorizontal = null;
		/**
		* A reference to the output node which defines the
		* final result of this shadow node.
		*
		* @type {?Node}
		* @private
		* @default null
		*/
		this._node = null;
		/**
		* The current shadow map type of this shadow node.
		*
		* @type {?number}
		* @private
		* @default null
		*/
		this._currentShadowType = null;
		/**
		* A Weak Map holding the current frame ID per camera. Used
		* to control the update of shadow maps.
		*
		* @type {WeakMap<Camera,number>}
		* @private
		*/
		this._cameraFrameId = /* @__PURE__ */ new WeakMap();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isShadowNode = true;
		/**
		* This index can be used when overriding setupRenderTarget with a RenderTarget Array to specify the depth layer.
		*
		* @type {number}
		* @readonly
		* @default true
		*/
		this.depthLayer = 0;
	}
	/**
	* Setups the shadow filtering.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @param {Object} inputs - A configuration object that defines the shadow filtering.
	* @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
	* @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
	* @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
	* @param {LightShadow} inputs.shadow - The light shadow.
	* @return {Node<float>} The result node of the shadow filtering.
	*/
	setupShadowFilter(builder, { filterFn, depthTexture, shadowCoord, shadow: shadow$2, depthLayer }) {
		const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));
		const shadowNode = filterFn({
			depthTexture,
			shadowCoord,
			shadow: shadow$2,
			depthLayer
		});
		return frustumTest.select(shadowNode, float$1(1));
	}
	/**
	* Setups the shadow coordinates.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @param {Node<vec3>} shadowPosition - A node representing the shadow position.
	* @return {Node<vec3>} The shadow coordinates.
	*/
	setupShadowCoord(builder, shadowPosition) {
		const { shadow: shadow$2 } = this;
		const { renderer } = builder;
		const bias = reference$2("bias", "float", shadow$2).setGroup(renderGroup$1);
		let shadowCoord = shadowPosition;
		let coordZ;
		if (shadow$2.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true) {
			shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
			coordZ = shadowCoord.z;
			if (renderer.coordinateSystem === WebGPUCoordinateSystem) coordZ = coordZ.mul(2).sub(1);
		} else {
			const w = shadowCoord.w;
			shadowCoord = shadowCoord.xy.div(w);
			const cameraNearLocal = reference$2("near", "float", shadow$2.camera).setGroup(renderGroup$1);
			const cameraFarLocal = reference$2("far", "float", shadow$2.camera).setGroup(renderGroup$1);
			coordZ = viewZToLogarithmicDepth$1(w.negate(), cameraNearLocal, cameraFarLocal);
		}
		shadowCoord = vec3$1(shadowCoord.x, shadowCoord.y.oneMinus(), coordZ.add(bias));
		return shadowCoord;
	}
	/**
	* Returns the shadow filtering function for the given shadow type.
	*
	* @param {number} type - The shadow type.
	* @return {Function} The filtering function.
	*/
	getShadowFilterFn(type$1) {
		return _shadowFilterLib[type$1];
	}
	setupRenderTarget(shadow$2, builder) {
		const depthTexture = new DepthTexture(shadow$2.mapSize.width, shadow$2.mapSize.height);
		depthTexture.name = "ShadowDepthTexture";
		depthTexture.compareFunction = LessCompare;
		const shadowMap = builder.createRenderTarget(shadow$2.mapSize.width, shadow$2.mapSize.height);
		shadowMap.texture.name = "ShadowMap";
		shadowMap.texture.type = shadow$2.mapType;
		shadowMap.depthTexture = depthTexture;
		return {
			shadowMap,
			depthTexture
		};
	}
	/**
	* Setups the shadow output node.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @return {Node<vec3>} The shadow output node.
	*/
	setupShadow(builder) {
		const { renderer, camera } = builder;
		const { light, shadow: shadow$2 } = this;
		const shadowMapType = renderer.shadowMap.type;
		const { depthTexture, shadowMap } = this.setupRenderTarget(shadow$2, builder);
		shadow$2.camera.coordinateSystem = camera.coordinateSystem;
		shadow$2.camera.updateProjectionMatrix();
		if (shadowMapType === VSMShadowMap && shadow$2.isPointLightShadow !== true) {
			depthTexture.compareFunction = null;
			if (shadowMap.depth > 1) {
				if (!shadowMap._vsmShadowMapVertical) {
					shadowMap._vsmShadowMapVertical = builder.createRenderTarget(shadow$2.mapSize.width, shadow$2.mapSize.height, {
						format: RGFormat,
						type: HalfFloatType,
						depth: shadowMap.depth,
						depthBuffer: false
					});
					shadowMap._vsmShadowMapVertical.texture.name = "VSMVertical";
				}
				this.vsmShadowMapVertical = shadowMap._vsmShadowMapVertical;
				if (!shadowMap._vsmShadowMapHorizontal) {
					shadowMap._vsmShadowMapHorizontal = builder.createRenderTarget(shadow$2.mapSize.width, shadow$2.mapSize.height, {
						format: RGFormat,
						type: HalfFloatType,
						depth: shadowMap.depth,
						depthBuffer: false
					});
					shadowMap._vsmShadowMapHorizontal.texture.name = "VSMHorizontal";
				}
				this.vsmShadowMapHorizontal = shadowMap._vsmShadowMapHorizontal;
			} else {
				this.vsmShadowMapVertical = builder.createRenderTarget(shadow$2.mapSize.width, shadow$2.mapSize.height, {
					format: RGFormat,
					type: HalfFloatType,
					depthBuffer: false
				});
				this.vsmShadowMapHorizontal = builder.createRenderTarget(shadow$2.mapSize.width, shadow$2.mapSize.height, {
					format: RGFormat,
					type: HalfFloatType,
					depthBuffer: false
				});
			}
			let shadowPassVertical = texture$1(depthTexture);
			if (depthTexture.isArrayTexture) shadowPassVertical = shadowPassVertical.depth(this.depthLayer);
			let shadowPassHorizontal = texture$1(this.vsmShadowMapVertical.texture);
			if (depthTexture.isArrayTexture) shadowPassHorizontal = shadowPassHorizontal.depth(this.depthLayer);
			const samples = reference$2("blurSamples", "float", shadow$2).setGroup(renderGroup$1);
			const radius = reference$2("radius", "float", shadow$2).setGroup(renderGroup$1);
			const size = reference$2("mapSize", "vec2", shadow$2).setGroup(renderGroup$1);
			let material = this.vsmMaterialVertical || (this.vsmMaterialVertical = new NodeMaterial());
			material.fragmentNode = VSMPassVertical({
				samples,
				radius,
				size,
				shadowPass: shadowPassVertical,
				depthLayer: this.depthLayer
			}).context(builder.getSharedContext());
			material.name = "VSMVertical";
			material = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new NodeMaterial());
			material.fragmentNode = VSMPassHorizontal({
				samples,
				radius,
				size,
				shadowPass: shadowPassHorizontal,
				depthLayer: this.depthLayer
			}).context(builder.getSharedContext());
			material.name = "VSMHorizontal";
		}
		const shadowIntensity = reference$2("intensity", "float", shadow$2).setGroup(renderGroup$1);
		const normalBias = reference$2("normalBias", "float", shadow$2).setGroup(renderGroup$1);
		const shadowPosition = lightShadowMatrix$1(light).mul(shadowPositionWorld$1.add(normalWorld$1.mul(normalBias)));
		const shadowCoord = this.setupShadowCoord(builder, shadowPosition);
		const filterFn = shadow$2.filterNode || this.getShadowFilterFn(renderer.shadowMap.type) || null;
		if (filterFn === null) throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
		const shadowDepthTexture = shadowMapType === VSMShadowMap && shadow$2.isPointLightShadow !== true ? this.vsmShadowMapHorizontal.texture : depthTexture;
		const shadowNode = this.setupShadowFilter(builder, {
			filterFn,
			shadowTexture: shadowMap.texture,
			depthTexture: shadowDepthTexture,
			shadowCoord,
			shadow: shadow$2,
			depthLayer: this.depthLayer
		});
		let shadowColor = texture$1(shadowMap.texture, shadowCoord);
		if (depthTexture.isArrayTexture) shadowColor = shadowColor.depth(this.depthLayer);
		const shadowOutput = mix$2(1, shadowNode.rgb.mix(shadowColor, 1), shadowIntensity.mul(shadowColor.a)).toVar();
		this.shadowMap = shadowMap;
		this.shadow.map = shadowMap;
		const inspectName = `${this.light.type} Shadow [ ${this.light.name || "ID: " + this.light.id} ]`;
		return shadowOutput.toInspector(`${inspectName} / Color`, () => {
			return texture$1(this.shadowMap.texture);
		}).toInspector(`${inspectName} / Depth`, () => {
			return textureLoad$1(this.shadowMap.depthTexture, uv$1$1().mul(textureSize$1(texture$1(this.shadowMap.depthTexture)))).x.oneMinus();
		});
	}
	/**
	* The implementation performs the setup of the output node. An output is only
	* produces if shadow mapping is globally enabled in the renderer.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @return {ShaderCallNodeInternal} The output node.
	*/
	setup(builder) {
		if (builder.renderer.shadowMap.enabled === false) return;
		return Fn$1(() => {
			const currentShadowType = builder.renderer.shadowMap.type;
			if (this._currentShadowType !== currentShadowType) {
				this._reset();
				this._node = null;
			}
			let node = this._node;
			this.setupShadowPosition(builder);
			if (node === null) {
				this._node = node = this.setupShadow(builder);
				this._currentShadowType = currentShadowType;
			}
			if (builder.material.shadowNode) warn("NodeMaterial: \".shadowNode\" is deprecated. Use \".castShadowNode\" instead.");
			if (builder.material.receivedShadowNode) node = builder.material.receivedShadowNode(node);
			return node;
		})();
	}
	/**
	* Renders the shadow. The logic of this function could be included
	* into {@link ShadowNode#updateShadow} however more specialized shadow
	* nodes might require a custom shadow map rendering. By having a
	* dedicated method, it's easier to overwrite the default behavior.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	renderShadow(frame) {
		const { shadow: shadow$2, shadowMap, light } = this;
		const { renderer, scene } = frame;
		shadow$2.updateMatrices(light);
		shadowMap.setSize(shadow$2.mapSize.width, shadow$2.mapSize.height, shadowMap.depth);
		const currentSceneName = scene.name;
		scene.name = `Shadow Map [ ${light.name || "ID: " + light.id} ]`;
		renderer.render(scene, shadow$2.camera);
		scene.name = currentSceneName;
	}
	/**
	* Updates the shadow.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	updateShadow(frame) {
		const { shadowMap, light, shadow: shadow$2 } = this;
		const { renderer, scene, camera } = frame;
		const shadowType = renderer.shadowMap.type;
		this._depthVersionCached = shadowMap.depthTexture.version;
		const _shadowCameraLayer = shadow$2.camera.layers.mask;
		if ((shadow$2.camera.layers.mask & 4294967294) === 0) shadow$2.camera.layers.mask = camera.layers.mask;
		const currentRenderObjectFunction = renderer.getRenderObjectFunction();
		const currentMRT = renderer.getMRT();
		const useVelocity = currentMRT ? currentMRT.has("velocity") : false;
		_rendererState = resetRendererAndSceneState(renderer, scene, _rendererState);
		scene.overrideMaterial = getShadowMaterial$1(light);
		renderer.setRenderObjectFunction(getShadowRenderObjectFunction$1(renderer, shadow$2, shadowType, useVelocity));
		renderer.setClearColor(0, 0);
		renderer.setRenderTarget(shadowMap);
		this.renderShadow(frame);
		renderer.setRenderObjectFunction(currentRenderObjectFunction);
		if (shadowType === VSMShadowMap && shadow$2.isPointLightShadow !== true) this.vsmPass(renderer);
		shadow$2.camera.layers.mask = _shadowCameraLayer;
		restoreRendererAndSceneState(renderer, scene, _rendererState);
	}
	/**
	* For VSM additional render passes are required.
	*
	* @param {Renderer} renderer - A reference to the current renderer.
	*/
	vsmPass(renderer) {
		const { shadow: shadow$2 } = this;
		const depth$2 = this.shadowMap.depth;
		this.vsmShadowMapVertical.setSize(shadow$2.mapSize.width, shadow$2.mapSize.height, depth$2);
		this.vsmShadowMapHorizontal.setSize(shadow$2.mapSize.width, shadow$2.mapSize.height, depth$2);
		renderer.setRenderTarget(this.vsmShadowMapVertical);
		_quadMesh.material = this.vsmMaterialVertical;
		_quadMesh.render(renderer);
		renderer.setRenderTarget(this.vsmShadowMapHorizontal);
		_quadMesh.material = this.vsmMaterialHorizontal;
		_quadMesh.render(renderer);
	}
	/**
	* Frees the internal resources of this shadow node.
	*/
	dispose() {
		this._reset();
		super.dispose();
	}
	/**
	* Resets the resouce state of this shadow node.
	*
	* @private
	*/
	_reset() {
		this._currentShadowType = null;
		if (this.shadowMap) {
			this.shadowMap.dispose();
			this.shadowMap = null;
		}
		if (this.vsmShadowMapVertical !== null) {
			this.vsmShadowMapVertical.dispose();
			this.vsmShadowMapVertical = null;
			this.vsmMaterialVertical.dispose();
			this.vsmMaterialVertical = null;
		}
		if (this.vsmShadowMapHorizontal !== null) {
			this.vsmShadowMapHorizontal.dispose();
			this.vsmShadowMapHorizontal = null;
			this.vsmMaterialHorizontal.dispose();
			this.vsmMaterialHorizontal = null;
		}
	}
	/**
	* The implementation performs the update of the shadow map if necessary.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	updateBefore(frame) {
		const { shadow: shadow$2 } = this;
		let needsUpdate = shadow$2.needsUpdate || shadow$2.autoUpdate;
		if (needsUpdate) {
			if (this._cameraFrameId[frame.camera] === frame.frameId) needsUpdate = false;
			this._cameraFrameId[frame.camera] = frame.frameId;
		}
		if (needsUpdate) {
			this.updateShadow(frame);
			if (this.shadowMap.depthTexture.version === this._depthVersionCached) shadow$2.needsUpdate = false;
		}
	}
};
/**
* TSL function for creating an instance of `ShadowNode`.
*
* @tsl
* @function
* @param {Light} light - The shadow casting light.
* @param {?LightShadow} [shadow] - The light shadow.
* @return {ShadowNode} The created shadow node.
*/
var shadow$1 = (light, shadow$2) => nodeObject$1(new ShadowNode(light, shadow$2));
var _clearColor$1 = /* @__PURE__ */ new Color$1();
var cubeToUV$1 = /* @__PURE__ */ Fn$1(([pos, texelSizeY]) => {
	const v = pos.toVar();
	const absV = abs$1(v);
	const scaleToCube = div$1(1, max$1$1(absV.x, max$1$1(absV.y, absV.z)));
	absV.mulAssign(scaleToCube);
	v.mulAssign(scaleToCube.mul(texelSizeY.mul(2).oneMinus()));
	const planar = vec2$1(v.xy).toVar();
	const almostOne = texelSizeY.mul(1.5).oneMinus();
	If$1(absV.z.greaterThanEqual(almostOne), () => {
		If$1(v.z.greaterThan(0), () => {
			planar.x.assign(sub$1(4, v.x));
		});
	}).ElseIf(absV.x.greaterThanEqual(almostOne), () => {
		const signX = sign$1(v.x);
		planar.x.assign(v.z.mul(signX).add(signX.mul(2)));
	}).ElseIf(absV.y.greaterThanEqual(almostOne), () => {
		const signY = sign$1(v.y);
		planar.x.assign(v.x.add(signY.mul(2)).add(2));
		planar.y.assign(v.z.mul(signY).sub(2));
	});
	return vec2$1(.125, .25).mul(planar).add(vec2$1(.375, .75)).flipY();
}).setLayout({
	name: "cubeToUV",
	type: "vec2",
	inputs: [{
		name: "pos",
		type: "vec3"
	}, {
		name: "texelSizeY",
		type: "float"
	}]
});
var BasicPointShadowFilter$1 = /* @__PURE__ */ Fn$1(({ depthTexture, bd3D, dp, texelSize }) => {
	return texture$1(depthTexture, cubeToUV$1(bd3D, texelSize.y)).compare(dp);
});
var PointShadowFilter$1 = /* @__PURE__ */ Fn$1(({ depthTexture, bd3D, dp, texelSize, shadow: shadow$2 }) => {
	const radius = reference$2("radius", "float", shadow$2).setGroup(renderGroup$1);
	const offset = vec2$1(-1, 1).mul(radius).mul(texelSize.y);
	return texture$1(depthTexture, cubeToUV$1(bd3D.add(offset.xyy), texelSize.y)).compare(dp).add(texture$1(depthTexture, cubeToUV$1(bd3D.add(offset.yyy), texelSize.y)).compare(dp)).add(texture$1(depthTexture, cubeToUV$1(bd3D.add(offset.xyx), texelSize.y)).compare(dp)).add(texture$1(depthTexture, cubeToUV$1(bd3D.add(offset.yyx), texelSize.y)).compare(dp)).add(texture$1(depthTexture, cubeToUV$1(bd3D, texelSize.y)).compare(dp)).add(texture$1(depthTexture, cubeToUV$1(bd3D.add(offset.xxy), texelSize.y)).compare(dp)).add(texture$1(depthTexture, cubeToUV$1(bd3D.add(offset.yxy), texelSize.y)).compare(dp)).add(texture$1(depthTexture, cubeToUV$1(bd3D.add(offset.xxx), texelSize.y)).compare(dp)).add(texture$1(depthTexture, cubeToUV$1(bd3D.add(offset.yxx), texelSize.y)).compare(dp)).mul(1 / 9);
});
var pointShadowFilter = /* @__PURE__ */ Fn$1(({ filterFn, depthTexture, shadowCoord, shadow: shadow$2 }) => {
	const lightToPosition = shadowCoord.xyz.toVar();
	const lightToPositionLength = lightToPosition.length();
	const cameraNearLocal = uniform$1("float").setGroup(renderGroup$1).onRenderUpdate(() => shadow$2.camera.near);
	const cameraFarLocal = uniform$1("float").setGroup(renderGroup$1).onRenderUpdate(() => shadow$2.camera.far);
	const bias = reference$2("bias", "float", shadow$2).setGroup(renderGroup$1);
	const mapSize = uniform$1(shadow$2.mapSize).setGroup(renderGroup$1);
	const result = float$1(1).toVar();
	If$1(lightToPositionLength.sub(cameraFarLocal).lessThanEqual(0).and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0)), () => {
		const dp = lightToPositionLength.sub(cameraNearLocal).div(cameraFarLocal.sub(cameraNearLocal)).toVar();
		dp.addAssign(bias);
		const bd3D = lightToPosition.normalize();
		const texelSize = vec2$1(1).div(mapSize.mul(vec2$1(4, 2)));
		result.assign(filterFn({
			depthTexture,
			bd3D,
			dp,
			texelSize,
			shadow: shadow$2
		}));
	});
	return result;
});
var _viewport = /* @__PURE__ */ new Vector4();
var _viewportSize = /* @__PURE__ */ new Vector2();
var _shadowMapSize = /* @__PURE__ */ new Vector2();
/**
* Represents the shadow implementation for point light nodes.
*
* @augments ShadowNode
*/
var PointShadowNode = class extends ShadowNode {
	static get type() {
		return "PointShadowNode";
	}
	/**
	* Constructs a new point shadow node.
	*
	* @param {PointLight} light - The shadow casting point light.
	* @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
	*/
	constructor(light, shadow$2 = null) {
		super(light, shadow$2);
	}
	/**
	* Overwrites the default implementation to return point light shadow specific
	* filtering functions.
	*
	* @param {number} type - The shadow type.
	* @return {Function} The filtering function.
	*/
	getShadowFilterFn(type$1) {
		return type$1 === BasicShadowMap ? BasicPointShadowFilter$1 : PointShadowFilter$1;
	}
	/**
	* Overwrites the default implementation so the unaltered shadow position is used.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @param {Node<vec3>} shadowPosition - A node representing the shadow position.
	* @return {Node<vec3>} The shadow coordinates.
	*/
	setupShadowCoord(builder, shadowPosition) {
		return shadowPosition;
	}
	/**
	* Overwrites the default implementation to only use point light specific
	* shadow filter functions.
	*
	* @param {NodeBuilder} builder - A reference to the current node builder.
	* @param {Object} inputs - A configuration object that defines the shadow filtering.
	* @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
	* @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.
	* @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
	* @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
	* @param {LightShadow} inputs.shadow - The light shadow.
	* @return {Node<float>} The result node of the shadow filtering.
	*/
	setupShadowFilter(builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow: shadow$2 }) {
		return pointShadowFilter({
			filterFn,
			shadowTexture,
			depthTexture,
			shadowCoord,
			shadow: shadow$2
		});
	}
	/**
	* Overwrites the default implementation with point light specific
	* rendering code.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	renderShadow(frame) {
		const { shadow: shadow$2, shadowMap, light } = this;
		const { renderer, scene } = frame;
		const shadowFrameExtents = shadow$2.getFrameExtents();
		_shadowMapSize.copy(shadow$2.mapSize);
		_shadowMapSize.multiply(shadowFrameExtents);
		shadowMap.setSize(_shadowMapSize.width, _shadowMapSize.height);
		_viewportSize.copy(shadow$2.mapSize);
		const previousAutoClear = renderer.autoClear;
		const previousClearColor = renderer.getClearColor(_clearColor$1);
		const previousClearAlpha = renderer.getClearAlpha();
		renderer.autoClear = false;
		renderer.setClearColor(shadow$2.clearColor, shadow$2.clearAlpha);
		renderer.clear();
		const viewportCount = shadow$2.getViewportCount();
		for (let vp = 0; vp < viewportCount; vp++) {
			const viewport$2 = shadow$2.getViewport(vp);
			const x = _viewportSize.x * viewport$2.x;
			const y = _shadowMapSize.y - _viewportSize.y - _viewportSize.y * viewport$2.y;
			_viewport.set(x, y, _viewportSize.x * viewport$2.z, _viewportSize.y * viewport$2.w);
			shadowMap.viewport.copy(_viewport);
			shadow$2.updateMatrices(light, vp);
			const currentSceneName = scene.name;
			scene.name = `Point Light Shadow [ ${light.name || "ID: " + light.id} ] - Face ${vp + 1}`;
			renderer.render(scene, shadow$2.camera);
			scene.name = currentSceneName;
		}
		renderer.autoClear = previousAutoClear;
		renderer.setClearColor(previousClearColor, previousClearAlpha);
	}
};
/**
* TSL function for creating an instance of `PointShadowNode`.
*
* @tsl
* @function
* @param {PointLight} light - The shadow casting point light.
* @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
* @return {PointShadowNode} The created point shadow node.
*/
var pointShadow$1 = (light, shadow$2) => nodeObject$1(new PointShadowNode(light, shadow$2));
/**
* Base class for analytic light nodes.
*
* @augments LightingNode
*/
var AnalyticLightNode = class extends LightingNode {
	static get type() {
		return "AnalyticLightNode";
	}
	/**
	* Constructs a new analytic light node.
	*
	* @param {?Light} [light=null] - The light source.
	*/
	constructor(light = null) {
		super();
		/**
		* The light source.
		*
		* @type {?Light}
		* @default null
		*/
		this.light = light;
		/**
		* The light's color value.
		*
		* @type {Color}
		*/
		this.color = new Color$1();
		/**
		* The light's color node. Points to `colorNode` of the light source, if set. Otherwise
		* it creates a uniform node based on {@link AnalyticLightNode#color}.
		*
		* @type {Node}
		*/
		this.colorNode = light && light.colorNode || uniform$1(this.color).setGroup(renderGroup$1);
		/**
		* This property is used to retain a reference to the original value of {@link AnalyticLightNode#colorNode}.
		* The final color node is represented by a different node when using shadows.
		*
		* @type {?Node}
		* @default null
		*/
		this.baseColorNode = null;
		/**
		* Represents the light's shadow.
		*
		* @type {?ShadowNode}
		* @default null
		*/
		this.shadowNode = null;
		/**
		* Represents the light's shadow color.
		*
		* @type {?Node}
		* @default null
		*/
		this.shadowColorNode = null;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isAnalyticLightNode = true;
		/**
		* Overwritten since analytic light nodes are updated
		* once per frame.
		*
		* @type {string}
		* @default 'frame'
		*/
		this.updateType = NodeUpdateType$1.FRAME;
	}
	getHash() {
		return this.light.uuid;
	}
	/**
	* Returns a node representing a direction vector which points from the current
	* position in view space to the light's position in view space.
	*
	* @param {NodeBuilder} builder - The builder object used for setting up the light.
	* @return {Node<vec3>} The light vector node.
	*/
	getLightVector(builder) {
		return lightViewPosition$1(this.light).sub(builder.context.positionView || positionView$1);
	}
	/**
	* Sets up the direct lighting for the analytic light node.
	*
	* @abstract
	* @param {NodeBuilder} builder - The builder object used for setting up the light.
	* @return {Object|undefined} The direct light data (color and direction).
	*/
	setupDirect() {}
	/**
	* Sets up the direct rect area lighting for the analytic light node.
	*
	* @abstract
	* @param {NodeBuilder} builder - The builder object used for setting up the light.
	* @return {Object|undefined} The direct rect area light data.
	*/
	setupDirectRectArea() {}
	/**
	* Setups the shadow node for this light. The method exists so concrete light classes
	* can setup different types of shadow nodes.
	*
	* @return {ShadowNode} The created shadow node.
	*/
	setupShadowNode() {
		return shadow$1(this.light);
	}
	/**
	* Setups the shadow for this light. This method is only executed if the light
	* cast shadows and the current build object receives shadows. It incorporates
	* shadows into the lighting computation.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setupShadow(builder) {
		const { renderer } = builder;
		if (renderer.shadowMap.enabled === false) return;
		let shadowColorNode = this.shadowColorNode;
		if (shadowColorNode === null) {
			const customShadowNode = this.light.shadow.shadowNode;
			let shadowNode;
			if (customShadowNode !== void 0) shadowNode = nodeObject$1(customShadowNode);
			else shadowNode = this.setupShadowNode();
			this.shadowNode = shadowNode;
			this.shadowColorNode = shadowColorNode = this.colorNode.mul(shadowNode);
			this.baseColorNode = this.colorNode;
		}
		this.colorNode = shadowColorNode;
	}
	/**
	* Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.
	* The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or
	* invocate the respective interface methods.
	*
	* @param {NodeBuilder} builder - The current node builder.
	*/
	setup(builder) {
		this.colorNode = this.baseColorNode || this.colorNode;
		if (this.light.castShadow) {
			if (builder.object.receiveShadow) this.setupShadow(builder);
		} else if (this.shadowNode !== null) {
			this.shadowNode.dispose();
			this.shadowNode = null;
			this.shadowColorNode = null;
		}
		const directLightData = this.setupDirect(builder);
		const directRectAreaLightData = this.setupDirectRectArea(builder);
		if (directLightData) builder.lightsNode.setupDirectLight(builder, this, directLightData);
		if (directRectAreaLightData) builder.lightsNode.setupDirectRectAreaLight(builder, this, directRectAreaLightData);
	}
	/**
	* The update method is used to update light uniforms per frame.
	* Potentially overwritten in concrete light nodes to update light
	* specific uniforms.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update() {
		const { light } = this;
		this.color.copy(light.color).multiplyScalar(light.intensity);
	}
};
/**
* Represents a `discard` shader operation in TSL.
*
* @method
* @param {Object} inputs - The input parameter object.
* @param {Node<float>} inputs.lightDistance - The distance of the light's position to the current fragment position.
* @param {Node<float>} inputs.cutoffDistance - The light's cutoff distance.
* @param {Node<float>} inputs.decayExponent - The light's decay exponent.
* @return {Node<float>} The distance falloff.
*/
var getDistanceAttenuation$1 = /* @__PURE__ */ Fn$1(({ lightDistance, cutoffDistance, decayExponent }) => {
	const distanceFalloff = lightDistance.pow(decayExponent).max(.01).reciprocal();
	return cutoffDistance.greaterThan(0).select(distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()), distanceFalloff);
});
var directPointLight$1 = ({ color: color$2, lightVector, cutoffDistance, decayExponent }) => {
	const lightDirection = lightVector.normalize();
	const lightDistance = lightVector.length();
	const attenuation = getDistanceAttenuation$1({
		lightDistance,
		cutoffDistance,
		decayExponent
	});
	const lightColor = color$2.mul(attenuation);
	return {
		lightDirection,
		lightColor
	};
};
/**
* Module for representing point lights as nodes.
*
* @augments AnalyticLightNode
*/
var PointLightNode = class extends AnalyticLightNode {
	static get type() {
		return "PointLightNode";
	}
	/**
	* Constructs a new point light node.
	*
	* @param {?PointLight} [light=null] - The point light source.
	*/
	constructor(light = null) {
		super(light);
		/**
		* Uniform node representing the cutoff distance.
		*
		* @type {UniformNode<float>}
		*/
		this.cutoffDistanceNode = uniform$1(0).setGroup(renderGroup$1);
		/**
		* Uniform node representing the decay exponent.
		*
		* @type {UniformNode<float>}
		*/
		this.decayExponentNode = uniform$1(2).setGroup(renderGroup$1);
	}
	/**
	* Overwritten to updated point light specific uniforms.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update(frame) {
		const { light } = this;
		super.update(frame);
		this.cutoffDistanceNode.value = light.distance;
		this.decayExponentNode.value = light.decay;
	}
	/**
	* Overwritten to setup point light specific shadow.
	*
	* @return {PointShadowNode}
	*/
	setupShadowNode() {
		return pointShadow$1(this.light);
	}
	setupDirect(builder) {
		return directPointLight$1({
			color: this.colorNode,
			lightVector: this.getLightVector(builder),
			cutoffDistance: this.cutoffDistanceNode,
			decayExponent: this.decayExponentNode
		});
	}
};
/**
* Creates a 2x2 checkerboard pattern that can be used as procedural texture data.
*
* @tsl
* @function
* @param {Node<vec2>} coord - The uv coordinates.
* @return {Node<float>} The result data.
*/
var checker$1 = /* @__PURE__ */ Fn$1(([coord = uv$1$1()]) => {
	const uv$3 = coord.mul(2);
	const cx = uv$3.x.floor();
	const cy = uv$3.y.floor();
	return cx.add(cy).mod(2).sign();
});
/**
* Generates a circle based on the uv coordinates.
*
* @tsl
* @function
* @param {Node<vec2>} coord - The uv to generate the circle.
* @return {Node<float>} The circle shape.
*/
var shapeCircle$1 = Fn$1(([coord = uv$1$1()], { renderer, material }) => {
	const len2 = lengthSq$1(coord.mul(2).sub(1));
	let alpha;
	if (material.alphaToCoverage && renderer.currentSamples > 0) {
		const dlen = float$1(len2.fwidth()).toVar();
		alpha = smoothstep$1(dlen.oneMinus(), dlen.add(1), len2).oneMinus();
	} else alpha = select$1(len2.greaterThan(1), 0, 1);
	return alpha;
});
var mx_select = /* @__PURE__ */ Fn$1(([b_immutable, t_immutable, f_immutable]) => {
	const f = float$1(f_immutable).toVar();
	const t = float$1(t_immutable).toVar();
	const b$2 = bool$1(b_immutable).toVar();
	return select$1(b$2, t, f);
}).setLayout({
	name: "mx_select",
	type: "float",
	inputs: [
		{
			name: "b",
			type: "bool"
		},
		{
			name: "t",
			type: "float"
		},
		{
			name: "f",
			type: "float"
		}
	]
});
var mx_negate_if = /* @__PURE__ */ Fn$1(([val_immutable, b_immutable]) => {
	const b$2 = bool$1(b_immutable).toVar();
	const val = float$1(val_immutable).toVar();
	return select$1(b$2, val.negate(), val);
}).setLayout({
	name: "mx_negate_if",
	type: "float",
	inputs: [{
		name: "val",
		type: "float"
	}, {
		name: "b",
		type: "bool"
	}]
});
var mx_floor = /* @__PURE__ */ Fn$1(([x_immutable]) => {
	const x = float$1(x_immutable).toVar();
	return int$1(floor$1(x));
}).setLayout({
	name: "mx_floor",
	type: "int",
	inputs: [{
		name: "x",
		type: "float"
	}]
});
var mx_floorfrac = /* @__PURE__ */ Fn$1(([x_immutable, i]) => {
	const x = float$1(x_immutable).toVar();
	i.assign(mx_floor(x));
	return x.sub(float$1(i));
});
var mx_bilerp = /* @__PURE__ */ overloadingFn$1([/* @__PURE__ */ Fn$1(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
	const t = float$1(t_immutable).toVar();
	const s = float$1(s_immutable).toVar();
	const v3 = float$1(v3_immutable).toVar();
	const v2 = float$1(v2_immutable).toVar();
	const v1 = float$1(v1_immutable).toVar();
	const v0 = float$1(v0_immutable).toVar();
	const s1 = float$1(sub$1(1, s)).toVar();
	return sub$1(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
}).setLayout({
	name: "mx_bilerp_0",
	type: "float",
	inputs: [
		{
			name: "v0",
			type: "float"
		},
		{
			name: "v1",
			type: "float"
		},
		{
			name: "v2",
			type: "float"
		},
		{
			name: "v3",
			type: "float"
		},
		{
			name: "s",
			type: "float"
		},
		{
			name: "t",
			type: "float"
		}
	]
}), /* @__PURE__ */ Fn$1(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
	const t = float$1(t_immutable).toVar();
	const s = float$1(s_immutable).toVar();
	const v3 = vec3$1(v3_immutable).toVar();
	const v2 = vec3$1(v2_immutable).toVar();
	const v1 = vec3$1(v1_immutable).toVar();
	const v0 = vec3$1(v0_immutable).toVar();
	const s1 = float$1(sub$1(1, s)).toVar();
	return sub$1(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
}).setLayout({
	name: "mx_bilerp_1",
	type: "vec3",
	inputs: [
		{
			name: "v0",
			type: "vec3"
		},
		{
			name: "v1",
			type: "vec3"
		},
		{
			name: "v2",
			type: "vec3"
		},
		{
			name: "v3",
			type: "vec3"
		},
		{
			name: "s",
			type: "float"
		},
		{
			name: "t",
			type: "float"
		}
	]
})]);
var mx_trilerp = /* @__PURE__ */ overloadingFn$1([/* @__PURE__ */ Fn$1(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
	const r = float$1(r_immutable).toVar();
	const t = float$1(t_immutable).toVar();
	const s = float$1(s_immutable).toVar();
	const v7 = float$1(v7_immutable).toVar();
	const v6 = float$1(v6_immutable).toVar();
	const v5 = float$1(v5_immutable).toVar();
	const v4 = float$1(v4_immutable).toVar();
	const v3 = float$1(v3_immutable).toVar();
	const v2 = float$1(v2_immutable).toVar();
	const v1 = float$1(v1_immutable).toVar();
	const v0 = float$1(v0_immutable).toVar();
	const s1 = float$1(sub$1(1, s)).toVar();
	const t1 = float$1(sub$1(1, t)).toVar();
	return float$1(sub$1(1, r)).toVar().mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
}).setLayout({
	name: "mx_trilerp_0",
	type: "float",
	inputs: [
		{
			name: "v0",
			type: "float"
		},
		{
			name: "v1",
			type: "float"
		},
		{
			name: "v2",
			type: "float"
		},
		{
			name: "v3",
			type: "float"
		},
		{
			name: "v4",
			type: "float"
		},
		{
			name: "v5",
			type: "float"
		},
		{
			name: "v6",
			type: "float"
		},
		{
			name: "v7",
			type: "float"
		},
		{
			name: "s",
			type: "float"
		},
		{
			name: "t",
			type: "float"
		},
		{
			name: "r",
			type: "float"
		}
	]
}), /* @__PURE__ */ Fn$1(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
	const r = float$1(r_immutable).toVar();
	const t = float$1(t_immutable).toVar();
	const s = float$1(s_immutable).toVar();
	const v7 = vec3$1(v7_immutable).toVar();
	const v6 = vec3$1(v6_immutable).toVar();
	const v5 = vec3$1(v5_immutable).toVar();
	const v4 = vec3$1(v4_immutable).toVar();
	const v3 = vec3$1(v3_immutable).toVar();
	const v2 = vec3$1(v2_immutable).toVar();
	const v1 = vec3$1(v1_immutable).toVar();
	const v0 = vec3$1(v0_immutable).toVar();
	const s1 = float$1(sub$1(1, s)).toVar();
	const t1 = float$1(sub$1(1, t)).toVar();
	return float$1(sub$1(1, r)).toVar().mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
}).setLayout({
	name: "mx_trilerp_1",
	type: "vec3",
	inputs: [
		{
			name: "v0",
			type: "vec3"
		},
		{
			name: "v1",
			type: "vec3"
		},
		{
			name: "v2",
			type: "vec3"
		},
		{
			name: "v3",
			type: "vec3"
		},
		{
			name: "v4",
			type: "vec3"
		},
		{
			name: "v5",
			type: "vec3"
		},
		{
			name: "v6",
			type: "vec3"
		},
		{
			name: "v7",
			type: "vec3"
		},
		{
			name: "s",
			type: "float"
		},
		{
			name: "t",
			type: "float"
		},
		{
			name: "r",
			type: "float"
		}
	]
})]);
var mx_gradient_float = /* @__PURE__ */ overloadingFn$1([/* @__PURE__ */ Fn$1(([hash_immutable, x_immutable, y_immutable]) => {
	const y = float$1(y_immutable).toVar();
	const x = float$1(x_immutable).toVar();
	const hash$3 = uint$1(hash_immutable).toVar();
	const h = uint$1(hash$3.bitAnd(uint$1(7))).toVar();
	const u = float$1(mx_select(h.lessThan(uint$1(4)), x, y)).toVar();
	const v = float$1(mul$1(2, mx_select(h.lessThan(uint$1(4)), y, x))).toVar();
	return mx_negate_if(u, bool$1(h.bitAnd(uint$1(1)))).add(mx_negate_if(v, bool$1(h.bitAnd(uint$1(2)))));
}).setLayout({
	name: "mx_gradient_float_0",
	type: "float",
	inputs: [
		{
			name: "hash",
			type: "uint"
		},
		{
			name: "x",
			type: "float"
		},
		{
			name: "y",
			type: "float"
		}
	]
}), /* @__PURE__ */ Fn$1(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
	const z = float$1(z_immutable).toVar();
	const y = float$1(y_immutable).toVar();
	const x = float$1(x_immutable).toVar();
	const hash$3 = uint$1(hash_immutable).toVar();
	const h = uint$1(hash$3.bitAnd(uint$1(15))).toVar();
	const u = float$1(mx_select(h.lessThan(uint$1(8)), x, y)).toVar();
	const v = float$1(mx_select(h.lessThan(uint$1(4)), y, mx_select(h.equal(uint$1(12)).or(h.equal(uint$1(14))), x, z))).toVar();
	return mx_negate_if(u, bool$1(h.bitAnd(uint$1(1)))).add(mx_negate_if(v, bool$1(h.bitAnd(uint$1(2)))));
}).setLayout({
	name: "mx_gradient_float_1",
	type: "float",
	inputs: [
		{
			name: "hash",
			type: "uint"
		},
		{
			name: "x",
			type: "float"
		},
		{
			name: "y",
			type: "float"
		},
		{
			name: "z",
			type: "float"
		}
	]
})]);
var mx_gradient_vec3 = /* @__PURE__ */ overloadingFn$1([/* @__PURE__ */ Fn$1(([hash_immutable, x_immutable, y_immutable]) => {
	const y = float$1(y_immutable).toVar();
	const x = float$1(x_immutable).toVar();
	const hash$3 = uvec3$1(hash_immutable).toVar();
	return vec3$1(mx_gradient_float(hash$3.x, x, y), mx_gradient_float(hash$3.y, x, y), mx_gradient_float(hash$3.z, x, y));
}).setLayout({
	name: "mx_gradient_vec3_0",
	type: "vec3",
	inputs: [
		{
			name: "hash",
			type: "uvec3"
		},
		{
			name: "x",
			type: "float"
		},
		{
			name: "y",
			type: "float"
		}
	]
}), /* @__PURE__ */ Fn$1(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
	const z = float$1(z_immutable).toVar();
	const y = float$1(y_immutable).toVar();
	const x = float$1(x_immutable).toVar();
	const hash$3 = uvec3$1(hash_immutable).toVar();
	return vec3$1(mx_gradient_float(hash$3.x, x, y, z), mx_gradient_float(hash$3.y, x, y, z), mx_gradient_float(hash$3.z, x, y, z));
}).setLayout({
	name: "mx_gradient_vec3_1",
	type: "vec3",
	inputs: [
		{
			name: "hash",
			type: "uvec3"
		},
		{
			name: "x",
			type: "float"
		},
		{
			name: "y",
			type: "float"
		},
		{
			name: "z",
			type: "float"
		}
	]
})]);
var mx_gradient_scale2d_0 = /* @__PURE__ */ Fn$1(([v_immutable]) => {
	const v = float$1(v_immutable).toVar();
	return mul$1(.6616, v);
}).setLayout({
	name: "mx_gradient_scale2d_0",
	type: "float",
	inputs: [{
		name: "v",
		type: "float"
	}]
});
var mx_gradient_scale3d_0 = /* @__PURE__ */ Fn$1(([v_immutable]) => {
	const v = float$1(v_immutable).toVar();
	return mul$1(.982, v);
}).setLayout({
	name: "mx_gradient_scale3d_0",
	type: "float",
	inputs: [{
		name: "v",
		type: "float"
	}]
});
var mx_gradient_scale2d = /* @__PURE__ */ overloadingFn$1([mx_gradient_scale2d_0, /* @__PURE__ */ Fn$1(([v_immutable]) => {
	const v = vec3$1(v_immutable).toVar();
	return mul$1(.6616, v);
}).setLayout({
	name: "mx_gradient_scale2d_1",
	type: "vec3",
	inputs: [{
		name: "v",
		type: "vec3"
	}]
})]);
var mx_gradient_scale3d = /* @__PURE__ */ overloadingFn$1([mx_gradient_scale3d_0, /* @__PURE__ */ Fn$1(([v_immutable]) => {
	const v = vec3$1(v_immutable).toVar();
	return mul$1(.982, v);
}).setLayout({
	name: "mx_gradient_scale3d_1",
	type: "vec3",
	inputs: [{
		name: "v",
		type: "vec3"
	}]
})]);
var mx_rotl32 = /* @__PURE__ */ Fn$1(([x_immutable, k_immutable]) => {
	const k = int$1(k_immutable).toVar();
	const x = uint$1(x_immutable).toVar();
	return x.shiftLeft(k).bitOr(x.shiftRight(int$1(32).sub(k)));
}).setLayout({
	name: "mx_rotl32",
	type: "uint",
	inputs: [{
		name: "x",
		type: "uint"
	}, {
		name: "k",
		type: "int"
	}]
});
var mx_bjmix = /* @__PURE__ */ Fn$1(([a$1, b$2, c$1]) => {
	a$1.subAssign(c$1);
	a$1.bitXorAssign(mx_rotl32(c$1, int$1(4)));
	c$1.addAssign(b$2);
	b$2.subAssign(a$1);
	b$2.bitXorAssign(mx_rotl32(a$1, int$1(6)));
	a$1.addAssign(c$1);
	c$1.subAssign(b$2);
	c$1.bitXorAssign(mx_rotl32(b$2, int$1(8)));
	b$2.addAssign(a$1);
	a$1.subAssign(c$1);
	a$1.bitXorAssign(mx_rotl32(c$1, int$1(16)));
	c$1.addAssign(b$2);
	b$2.subAssign(a$1);
	b$2.bitXorAssign(mx_rotl32(a$1, int$1(19)));
	a$1.addAssign(c$1);
	c$1.subAssign(b$2);
	c$1.bitXorAssign(mx_rotl32(b$2, int$1(4)));
	b$2.addAssign(a$1);
});
var mx_bjfinal = /* @__PURE__ */ Fn$1(([a_immutable, b_immutable, c_immutable]) => {
	const c$1 = uint$1(c_immutable).toVar();
	const b$2 = uint$1(b_immutable).toVar();
	const a$1 = uint$1(a_immutable).toVar();
	c$1.bitXorAssign(b$2);
	c$1.subAssign(mx_rotl32(b$2, int$1(14)));
	a$1.bitXorAssign(c$1);
	a$1.subAssign(mx_rotl32(c$1, int$1(11)));
	b$2.bitXorAssign(a$1);
	b$2.subAssign(mx_rotl32(a$1, int$1(25)));
	c$1.bitXorAssign(b$2);
	c$1.subAssign(mx_rotl32(b$2, int$1(16)));
	a$1.bitXorAssign(c$1);
	a$1.subAssign(mx_rotl32(c$1, int$1(4)));
	b$2.bitXorAssign(a$1);
	b$2.subAssign(mx_rotl32(a$1, int$1(14)));
	c$1.bitXorAssign(b$2);
	c$1.subAssign(mx_rotl32(b$2, int$1(24)));
	return c$1;
}).setLayout({
	name: "mx_bjfinal",
	type: "uint",
	inputs: [
		{
			name: "a",
			type: "uint"
		},
		{
			name: "b",
			type: "uint"
		},
		{
			name: "c",
			type: "uint"
		}
	]
});
var mx_bits_to_01 = /* @__PURE__ */ Fn$1(([bits_immutable]) => {
	const bits = uint$1(bits_immutable).toVar();
	return float$1(bits).div(float$1(uint$1(int$1(4294967295))));
}).setLayout({
	name: "mx_bits_to_01",
	type: "float",
	inputs: [{
		name: "bits",
		type: "uint"
	}]
});
var mx_fade = /* @__PURE__ */ Fn$1(([t_immutable]) => {
	const t = float$1(t_immutable).toVar();
	return t.mul(t).mul(t).mul(t.mul(t.mul(6).sub(15)).add(10));
}).setLayout({
	name: "mx_fade",
	type: "float",
	inputs: [{
		name: "t",
		type: "float"
	}]
});
var mx_hash_int = /* @__PURE__ */ overloadingFn$1([
	/* @__PURE__ */ Fn$1(([x_immutable]) => {
		const x = int$1(x_immutable).toVar();
		const len = uint$1(uint$1(1)).toVar();
		const seed = uint$1(uint$1(int$1(3735928559)).add(len.shiftLeft(uint$1(2))).add(uint$1(13))).toVar();
		return mx_bjfinal(seed.add(uint$1(x)), seed, seed);
	}).setLayout({
		name: "mx_hash_int_0",
		type: "uint",
		inputs: [{
			name: "x",
			type: "int"
		}]
	}),
	/* @__PURE__ */ Fn$1(([x_immutable, y_immutable]) => {
		const y = int$1(y_immutable).toVar();
		const x = int$1(x_immutable).toVar();
		const len = uint$1(uint$1(2)).toVar();
		const a$1 = uint$1().toVar(), b$2 = uint$1().toVar(), c$1 = uint$1().toVar();
		a$1.assign(b$2.assign(c$1.assign(uint$1(int$1(3735928559)).add(len.shiftLeft(uint$1(2))).add(uint$1(13)))));
		a$1.addAssign(uint$1(x));
		b$2.addAssign(uint$1(y));
		return mx_bjfinal(a$1, b$2, c$1);
	}).setLayout({
		name: "mx_hash_int_1",
		type: "uint",
		inputs: [{
			name: "x",
			type: "int"
		}, {
			name: "y",
			type: "int"
		}]
	}),
	/* @__PURE__ */ Fn$1(([x_immutable, y_immutable, z_immutable]) => {
		const z = int$1(z_immutable).toVar();
		const y = int$1(y_immutable).toVar();
		const x = int$1(x_immutable).toVar();
		const len = uint$1(uint$1(3)).toVar();
		const a$1 = uint$1().toVar(), b$2 = uint$1().toVar(), c$1 = uint$1().toVar();
		a$1.assign(b$2.assign(c$1.assign(uint$1(int$1(3735928559)).add(len.shiftLeft(uint$1(2))).add(uint$1(13)))));
		a$1.addAssign(uint$1(x));
		b$2.addAssign(uint$1(y));
		c$1.addAssign(uint$1(z));
		return mx_bjfinal(a$1, b$2, c$1);
	}).setLayout({
		name: "mx_hash_int_2",
		type: "uint",
		inputs: [
			{
				name: "x",
				type: "int"
			},
			{
				name: "y",
				type: "int"
			},
			{
				name: "z",
				type: "int"
			}
		]
	}),
	/* @__PURE__ */ Fn$1(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {
		const xx = int$1(xx_immutable).toVar();
		const z = int$1(z_immutable).toVar();
		const y = int$1(y_immutable).toVar();
		const x = int$1(x_immutable).toVar();
		const len = uint$1(uint$1(4)).toVar();
		const a$1 = uint$1().toVar(), b$2 = uint$1().toVar(), c$1 = uint$1().toVar();
		a$1.assign(b$2.assign(c$1.assign(uint$1(int$1(3735928559)).add(len.shiftLeft(uint$1(2))).add(uint$1(13)))));
		a$1.addAssign(uint$1(x));
		b$2.addAssign(uint$1(y));
		c$1.addAssign(uint$1(z));
		mx_bjmix(a$1, b$2, c$1);
		a$1.addAssign(uint$1(xx));
		return mx_bjfinal(a$1, b$2, c$1);
	}).setLayout({
		name: "mx_hash_int_3",
		type: "uint",
		inputs: [
			{
				name: "x",
				type: "int"
			},
			{
				name: "y",
				type: "int"
			},
			{
				name: "z",
				type: "int"
			},
			{
				name: "xx",
				type: "int"
			}
		]
	}),
	/* @__PURE__ */ Fn$1(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {
		const yy = int$1(yy_immutable).toVar();
		const xx = int$1(xx_immutable).toVar();
		const z = int$1(z_immutable).toVar();
		const y = int$1(y_immutable).toVar();
		const x = int$1(x_immutable).toVar();
		const len = uint$1(uint$1(5)).toVar();
		const a$1 = uint$1().toVar(), b$2 = uint$1().toVar(), c$1 = uint$1().toVar();
		a$1.assign(b$2.assign(c$1.assign(uint$1(int$1(3735928559)).add(len.shiftLeft(uint$1(2))).add(uint$1(13)))));
		a$1.addAssign(uint$1(x));
		b$2.addAssign(uint$1(y));
		c$1.addAssign(uint$1(z));
		mx_bjmix(a$1, b$2, c$1);
		a$1.addAssign(uint$1(xx));
		b$2.addAssign(uint$1(yy));
		return mx_bjfinal(a$1, b$2, c$1);
	}).setLayout({
		name: "mx_hash_int_4",
		type: "uint",
		inputs: [
			{
				name: "x",
				type: "int"
			},
			{
				name: "y",
				type: "int"
			},
			{
				name: "z",
				type: "int"
			},
			{
				name: "xx",
				type: "int"
			},
			{
				name: "yy",
				type: "int"
			}
		]
	})
]);
var mx_hash_vec3 = /* @__PURE__ */ overloadingFn$1([/* @__PURE__ */ Fn$1(([x_immutable, y_immutable]) => {
	const y = int$1(y_immutable).toVar();
	const x = int$1(x_immutable).toVar();
	const h = uint$1(mx_hash_int(x, y)).toVar();
	const result = uvec3$1().toVar();
	result.x.assign(h.bitAnd(int$1(255)));
	result.y.assign(h.shiftRight(int$1(8)).bitAnd(int$1(255)));
	result.z.assign(h.shiftRight(int$1(16)).bitAnd(int$1(255)));
	return result;
}).setLayout({
	name: "mx_hash_vec3_0",
	type: "uvec3",
	inputs: [{
		name: "x",
		type: "int"
	}, {
		name: "y",
		type: "int"
	}]
}), /* @__PURE__ */ Fn$1(([x_immutable, y_immutable, z_immutable]) => {
	const z = int$1(z_immutable).toVar();
	const y = int$1(y_immutable).toVar();
	const x = int$1(x_immutable).toVar();
	const h = uint$1(mx_hash_int(x, y, z)).toVar();
	const result = uvec3$1().toVar();
	result.x.assign(h.bitAnd(int$1(255)));
	result.y.assign(h.shiftRight(int$1(8)).bitAnd(int$1(255)));
	result.z.assign(h.shiftRight(int$1(16)).bitAnd(int$1(255)));
	return result;
}).setLayout({
	name: "mx_hash_vec3_1",
	type: "uvec3",
	inputs: [
		{
			name: "x",
			type: "int"
		},
		{
			name: "y",
			type: "int"
		},
		{
			name: "z",
			type: "int"
		}
	]
})]);
var mx_perlin_noise_float = /* @__PURE__ */ overloadingFn$1([/* @__PURE__ */ Fn$1(([p_immutable]) => {
	const p$1 = vec2$1(p_immutable).toVar();
	const X = int$1().toVar(), Y = int$1().toVar();
	const fx = float$1(mx_floorfrac(p$1.x, X)).toVar();
	const fy = float$1(mx_floorfrac(p$1.y, Y)).toVar();
	const u = float$1(mx_fade(fx)).toVar();
	const v = float$1(mx_fade(fy)).toVar();
	const result = float$1(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int$1(1)), Y), fx.sub(1), fy), mx_gradient_float(mx_hash_int(X, Y.add(int$1(1))), fx, fy.sub(1)), mx_gradient_float(mx_hash_int(X.add(int$1(1)), Y.add(int$1(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
	return mx_gradient_scale2d(result);
}).setLayout({
	name: "mx_perlin_noise_float_0",
	type: "float",
	inputs: [{
		name: "p",
		type: "vec2"
	}]
}), /* @__PURE__ */ Fn$1(([p_immutable]) => {
	const p$1 = vec3$1(p_immutable).toVar();
	const X = int$1().toVar(), Y = int$1().toVar(), Z = int$1().toVar();
	const fx = float$1(mx_floorfrac(p$1.x, X)).toVar();
	const fy = float$1(mx_floorfrac(p$1.y, Y)).toVar();
	const fz = float$1(mx_floorfrac(p$1.z, Z)).toVar();
	const u = float$1(mx_fade(fx)).toVar();
	const v = float$1(mx_fade(fy)).toVar();
	const w = float$1(mx_fade(fz)).toVar();
	const result = float$1(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int$1(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int$1(1)), Z), fx, fy.sub(1), fz), mx_gradient_float(mx_hash_int(X.add(int$1(1)), Y.add(int$1(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int$1(1))), fx, fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int$1(1)), Y, Z.add(int$1(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X, Y.add(int$1(1)), Z.add(int$1(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int$1(1)), Y.add(int$1(1)), Z.add(int$1(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
	return mx_gradient_scale3d(result);
}).setLayout({
	name: "mx_perlin_noise_float_1",
	type: "float",
	inputs: [{
		name: "p",
		type: "vec3"
	}]
})]);
var mx_perlin_noise_vec3 = /* @__PURE__ */ overloadingFn$1([/* @__PURE__ */ Fn$1(([p_immutable]) => {
	const p$1 = vec2$1(p_immutable).toVar();
	const X = int$1().toVar(), Y = int$1().toVar();
	const fx = float$1(mx_floorfrac(p$1.x, X)).toVar();
	const fy = float$1(mx_floorfrac(p$1.y, Y)).toVar();
	const u = float$1(mx_fade(fx)).toVar();
	const v = float$1(mx_fade(fy)).toVar();
	const result = vec3$1(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int$1(1)), Y), fx.sub(1), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int$1(1))), fx, fy.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int$1(1)), Y.add(int$1(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
	return mx_gradient_scale2d(result);
}).setLayout({
	name: "mx_perlin_noise_vec3_0",
	type: "vec3",
	inputs: [{
		name: "p",
		type: "vec2"
	}]
}), /* @__PURE__ */ Fn$1(([p_immutable]) => {
	const p$1 = vec3$1(p_immutable).toVar();
	const X = int$1().toVar(), Y = int$1().toVar(), Z = int$1().toVar();
	const fx = float$1(mx_floorfrac(p$1.x, X)).toVar();
	const fy = float$1(mx_floorfrac(p$1.y, Y)).toVar();
	const fz = float$1(mx_floorfrac(p$1.z, Z)).toVar();
	const u = float$1(mx_fade(fx)).toVar();
	const v = float$1(mx_fade(fy)).toVar();
	const w = float$1(mx_fade(fz)).toVar();
	const result = vec3$1(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int$1(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int$1(1)), Z), fx, fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int$1(1)), Y.add(int$1(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int$1(1))), fx, fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int$1(1)), Y, Z.add(int$1(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int$1(1)), Z.add(int$1(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int$1(1)), Y.add(int$1(1)), Z.add(int$1(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
	return mx_gradient_scale3d(result);
}).setLayout({
	name: "mx_perlin_noise_vec3_1",
	type: "vec3",
	inputs: [{
		name: "p",
		type: "vec3"
	}]
})]);
var mx_cell_noise_float$1 = /* @__PURE__ */ overloadingFn$1([
	/* @__PURE__ */ Fn$1(([p_immutable]) => {
		const p$1 = float$1(p_immutable).toVar();
		const ix = int$1(mx_floor(p$1)).toVar();
		return mx_bits_to_01(mx_hash_int(ix));
	}).setLayout({
		name: "mx_cell_noise_float_0",
		type: "float",
		inputs: [{
			name: "p",
			type: "float"
		}]
	}),
	/* @__PURE__ */ Fn$1(([p_immutable]) => {
		const p$1 = vec2$1(p_immutable).toVar();
		const ix = int$1(mx_floor(p$1.x)).toVar();
		const iy = int$1(mx_floor(p$1.y)).toVar();
		return mx_bits_to_01(mx_hash_int(ix, iy));
	}).setLayout({
		name: "mx_cell_noise_float_1",
		type: "float",
		inputs: [{
			name: "p",
			type: "vec2"
		}]
	}),
	/* @__PURE__ */ Fn$1(([p_immutable]) => {
		const p$1 = vec3$1(p_immutable).toVar();
		const ix = int$1(mx_floor(p$1.x)).toVar();
		const iy = int$1(mx_floor(p$1.y)).toVar();
		const iz = int$1(mx_floor(p$1.z)).toVar();
		return mx_bits_to_01(mx_hash_int(ix, iy, iz));
	}).setLayout({
		name: "mx_cell_noise_float_2",
		type: "float",
		inputs: [{
			name: "p",
			type: "vec3"
		}]
	}),
	/* @__PURE__ */ Fn$1(([p_immutable]) => {
		const p$1 = vec4$1(p_immutable).toVar();
		const ix = int$1(mx_floor(p$1.x)).toVar();
		const iy = int$1(mx_floor(p$1.y)).toVar();
		const iz = int$1(mx_floor(p$1.z)).toVar();
		const iw = int$1(mx_floor(p$1.w)).toVar();
		return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
	}).setLayout({
		name: "mx_cell_noise_float_3",
		type: "float",
		inputs: [{
			name: "p",
			type: "vec4"
		}]
	})
]);
var mx_cell_noise_vec3 = /* @__PURE__ */ overloadingFn$1([
	/* @__PURE__ */ Fn$1(([p_immutable]) => {
		const p$1 = float$1(p_immutable).toVar();
		const ix = int$1(mx_floor(p$1)).toVar();
		return vec3$1(mx_bits_to_01(mx_hash_int(ix, int$1(0))), mx_bits_to_01(mx_hash_int(ix, int$1(1))), mx_bits_to_01(mx_hash_int(ix, int$1(2))));
	}).setLayout({
		name: "mx_cell_noise_vec3_0",
		type: "vec3",
		inputs: [{
			name: "p",
			type: "float"
		}]
	}),
	/* @__PURE__ */ Fn$1(([p_immutable]) => {
		const p$1 = vec2$1(p_immutable).toVar();
		const ix = int$1(mx_floor(p$1.x)).toVar();
		const iy = int$1(mx_floor(p$1.y)).toVar();
		return vec3$1(mx_bits_to_01(mx_hash_int(ix, iy, int$1(0))), mx_bits_to_01(mx_hash_int(ix, iy, int$1(1))), mx_bits_to_01(mx_hash_int(ix, iy, int$1(2))));
	}).setLayout({
		name: "mx_cell_noise_vec3_1",
		type: "vec3",
		inputs: [{
			name: "p",
			type: "vec2"
		}]
	}),
	/* @__PURE__ */ Fn$1(([p_immutable]) => {
		const p$1 = vec3$1(p_immutable).toVar();
		const ix = int$1(mx_floor(p$1.x)).toVar();
		const iy = int$1(mx_floor(p$1.y)).toVar();
		const iz = int$1(mx_floor(p$1.z)).toVar();
		return vec3$1(mx_bits_to_01(mx_hash_int(ix, iy, iz, int$1(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int$1(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int$1(2))));
	}).setLayout({
		name: "mx_cell_noise_vec3_2",
		type: "vec3",
		inputs: [{
			name: "p",
			type: "vec3"
		}]
	}),
	/* @__PURE__ */ Fn$1(([p_immutable]) => {
		const p$1 = vec4$1(p_immutable).toVar();
		const ix = int$1(mx_floor(p$1.x)).toVar();
		const iy = int$1(mx_floor(p$1.y)).toVar();
		const iz = int$1(mx_floor(p$1.z)).toVar();
		const iw = int$1(mx_floor(p$1.w)).toVar();
		return vec3$1(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int$1(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int$1(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int$1(2))));
	}).setLayout({
		name: "mx_cell_noise_vec3_3",
		type: "vec3",
		inputs: [{
			name: "p",
			type: "vec4"
		}]
	})
]);
var mx_fractal_noise_float$1 = /* @__PURE__ */ Fn$1(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
	const diminish = float$1(diminish_immutable).toVar();
	const lacunarity = float$1(lacunarity_immutable).toVar();
	const octaves = int$1(octaves_immutable).toVar();
	const p$1 = vec3$1(p_immutable).toVar();
	const result = float$1(0).toVar();
	const amplitude = float$1(1).toVar();
	Loop$1(octaves, () => {
		result.addAssign(amplitude.mul(mx_perlin_noise_float(p$1)));
		amplitude.mulAssign(diminish);
		p$1.mulAssign(lacunarity);
	});
	return result;
}).setLayout({
	name: "mx_fractal_noise_float",
	type: "float",
	inputs: [
		{
			name: "p",
			type: "vec3"
		},
		{
			name: "octaves",
			type: "int"
		},
		{
			name: "lacunarity",
			type: "float"
		},
		{
			name: "diminish",
			type: "float"
		}
	]
});
var mx_fractal_noise_vec3$1 = /* @__PURE__ */ Fn$1(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
	const diminish = float$1(diminish_immutable).toVar();
	const lacunarity = float$1(lacunarity_immutable).toVar();
	const octaves = int$1(octaves_immutable).toVar();
	const p$1 = vec3$1(p_immutable).toVar();
	const result = vec3$1(0).toVar();
	const amplitude = float$1(1).toVar();
	Loop$1(octaves, () => {
		result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p$1)));
		amplitude.mulAssign(diminish);
		p$1.mulAssign(lacunarity);
	});
	return result;
}).setLayout({
	name: "mx_fractal_noise_vec3",
	type: "vec3",
	inputs: [
		{
			name: "p",
			type: "vec3"
		},
		{
			name: "octaves",
			type: "int"
		},
		{
			name: "lacunarity",
			type: "float"
		},
		{
			name: "diminish",
			type: "float"
		}
	]
});
var mx_fractal_noise_vec2$1 = /* @__PURE__ */ Fn$1(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
	const diminish = float$1(diminish_immutable).toVar();
	const lacunarity = float$1(lacunarity_immutable).toVar();
	const octaves = int$1(octaves_immutable).toVar();
	const p$1 = vec3$1(p_immutable).toVar();
	return vec2$1(mx_fractal_noise_float$1(p$1, octaves, lacunarity, diminish), mx_fractal_noise_float$1(p$1.add(vec3$1(int$1(19), int$1(193), int$1(17))), octaves, lacunarity, diminish));
}).setLayout({
	name: "mx_fractal_noise_vec2",
	type: "vec2",
	inputs: [
		{
			name: "p",
			type: "vec3"
		},
		{
			name: "octaves",
			type: "int"
		},
		{
			name: "lacunarity",
			type: "float"
		},
		{
			name: "diminish",
			type: "float"
		}
	]
});
var mx_fractal_noise_vec4$1 = /* @__PURE__ */ Fn$1(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
	const diminish = float$1(diminish_immutable).toVar();
	const lacunarity = float$1(lacunarity_immutable).toVar();
	const octaves = int$1(octaves_immutable).toVar();
	const p$1 = vec3$1(p_immutable).toVar();
	const c$1 = vec3$1(mx_fractal_noise_vec3$1(p$1, octaves, lacunarity, diminish)).toVar();
	const f = float$1(mx_fractal_noise_float$1(p$1.add(vec3$1(int$1(19), int$1(193), int$1(17))), octaves, lacunarity, diminish)).toVar();
	return vec4$1(c$1, f);
}).setLayout({
	name: "mx_fractal_noise_vec4",
	type: "vec4",
	inputs: [
		{
			name: "p",
			type: "vec3"
		},
		{
			name: "octaves",
			type: "int"
		},
		{
			name: "lacunarity",
			type: "float"
		},
		{
			name: "diminish",
			type: "float"
		}
	]
});
var mx_worley_distance = /* @__PURE__ */ overloadingFn$1([/* @__PURE__ */ Fn$1(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {
	const metric = int$1(metric_immutable).toVar();
	const jitter = float$1(jitter_immutable).toVar();
	const yoff = int$1(yoff_immutable).toVar();
	const xoff = int$1(xoff_immutable).toVar();
	const y = int$1(y_immutable).toVar();
	const x = int$1(x_immutable).toVar();
	const p$1 = vec2$1(p_immutable).toVar();
	const tmp = vec3$1(mx_cell_noise_vec3(vec2$1(x.add(xoff), y.add(yoff)))).toVar();
	const off = vec2$1(tmp.x, tmp.y).toVar();
	off.subAssign(.5);
	off.mulAssign(jitter);
	off.addAssign(.5);
	const cellpos = vec2$1(vec2$1(float$1(x), float$1(y)).add(off)).toVar();
	const diff = vec2$1(cellpos.sub(p$1)).toVar();
	If$1(metric.equal(int$1(2)), () => {
		return abs$1(diff.x).add(abs$1(diff.y));
	});
	If$1(metric.equal(int$1(3)), () => {
		return max$1$1(abs$1(diff.x), abs$1(diff.y));
	});
	return dot$1(diff, diff);
}).setLayout({
	name: "mx_worley_distance_0",
	type: "float",
	inputs: [
		{
			name: "p",
			type: "vec2"
		},
		{
			name: "x",
			type: "int"
		},
		{
			name: "y",
			type: "int"
		},
		{
			name: "xoff",
			type: "int"
		},
		{
			name: "yoff",
			type: "int"
		},
		{
			name: "jitter",
			type: "float"
		},
		{
			name: "metric",
			type: "int"
		}
	]
}), /* @__PURE__ */ Fn$1(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {
	const metric = int$1(metric_immutable).toVar();
	const jitter = float$1(jitter_immutable).toVar();
	const zoff = int$1(zoff_immutable).toVar();
	const yoff = int$1(yoff_immutable).toVar();
	const xoff = int$1(xoff_immutable).toVar();
	const z = int$1(z_immutable).toVar();
	const y = int$1(y_immutable).toVar();
	const x = int$1(x_immutable).toVar();
	const p$1 = vec3$1(p_immutable).toVar();
	const off = vec3$1(mx_cell_noise_vec3(vec3$1(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();
	off.subAssign(.5);
	off.mulAssign(jitter);
	off.addAssign(.5);
	const cellpos = vec3$1(vec3$1(float$1(x), float$1(y), float$1(z)).add(off)).toVar();
	const diff = vec3$1(cellpos.sub(p$1)).toVar();
	If$1(metric.equal(int$1(2)), () => {
		return abs$1(diff.x).add(abs$1(diff.y)).add(abs$1(diff.z));
	});
	If$1(metric.equal(int$1(3)), () => {
		return max$1$1(abs$1(diff.x), abs$1(diff.y), abs$1(diff.z));
	});
	return dot$1(diff, diff);
}).setLayout({
	name: "mx_worley_distance_1",
	type: "float",
	inputs: [
		{
			name: "p",
			type: "vec3"
		},
		{
			name: "x",
			type: "int"
		},
		{
			name: "y",
			type: "int"
		},
		{
			name: "z",
			type: "int"
		},
		{
			name: "xoff",
			type: "int"
		},
		{
			name: "yoff",
			type: "int"
		},
		{
			name: "zoff",
			type: "int"
		},
		{
			name: "jitter",
			type: "float"
		},
		{
			name: "metric",
			type: "int"
		}
	]
})]);
var mx_worley_noise_float_0 = /* @__PURE__ */ Fn$1(([p_immutable, jitter_immutable, metric_immutable]) => {
	const metric = int$1(metric_immutable).toVar();
	const jitter = float$1(jitter_immutable).toVar();
	const p$1 = vec2$1(p_immutable).toVar();
	const X = int$1().toVar(), Y = int$1().toVar();
	const localpos = vec2$1(mx_floorfrac(p$1.x, X), mx_floorfrac(p$1.y, Y)).toVar();
	const sqdist = float$1(1e6).toVar();
	Loop$1({
		start: -1,
		end: int$1(1),
		name: "x",
		condition: "<="
	}, ({ x }) => {
		Loop$1({
			start: -1,
			end: int$1(1),
			name: "y",
			condition: "<="
		}, ({ y }) => {
			const dist = float$1(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
			sqdist.assign(min$1(sqdist, dist));
		});
	});
	If$1(metric.equal(int$1(0)), () => {
		sqdist.assign(sqrt$1(sqdist));
	});
	return sqdist;
}).setLayout({
	name: "mx_worley_noise_float_0",
	type: "float",
	inputs: [
		{
			name: "p",
			type: "vec2"
		},
		{
			name: "jitter",
			type: "float"
		},
		{
			name: "metric",
			type: "int"
		}
	]
});
var mx_worley_noise_vec2_0 = /* @__PURE__ */ Fn$1(([p_immutable, jitter_immutable, metric_immutable]) => {
	const metric = int$1(metric_immutable).toVar();
	const jitter = float$1(jitter_immutable).toVar();
	const p$1 = vec2$1(p_immutable).toVar();
	const X = int$1().toVar(), Y = int$1().toVar();
	const localpos = vec2$1(mx_floorfrac(p$1.x, X), mx_floorfrac(p$1.y, Y)).toVar();
	const sqdist = vec2$1(1e6, 1e6).toVar();
	Loop$1({
		start: -1,
		end: int$1(1),
		name: "x",
		condition: "<="
	}, ({ x }) => {
		Loop$1({
			start: -1,
			end: int$1(1),
			name: "y",
			condition: "<="
		}, ({ y }) => {
			const dist = float$1(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
			If$1(dist.lessThan(sqdist.x), () => {
				sqdist.y.assign(sqdist.x);
				sqdist.x.assign(dist);
			}).ElseIf(dist.lessThan(sqdist.y), () => {
				sqdist.y.assign(dist);
			});
		});
	});
	If$1(metric.equal(int$1(0)), () => {
		sqdist.assign(sqrt$1(sqdist));
	});
	return sqdist;
}).setLayout({
	name: "mx_worley_noise_vec2_0",
	type: "vec2",
	inputs: [
		{
			name: "p",
			type: "vec2"
		},
		{
			name: "jitter",
			type: "float"
		},
		{
			name: "metric",
			type: "int"
		}
	]
});
var mx_worley_noise_vec3_0 = /* @__PURE__ */ Fn$1(([p_immutable, jitter_immutable, metric_immutable]) => {
	const metric = int$1(metric_immutable).toVar();
	const jitter = float$1(jitter_immutable).toVar();
	const p$1 = vec2$1(p_immutable).toVar();
	const X = int$1().toVar(), Y = int$1().toVar();
	const localpos = vec2$1(mx_floorfrac(p$1.x, X), mx_floorfrac(p$1.y, Y)).toVar();
	const sqdist = vec3$1(1e6, 1e6, 1e6).toVar();
	Loop$1({
		start: -1,
		end: int$1(1),
		name: "x",
		condition: "<="
	}, ({ x }) => {
		Loop$1({
			start: -1,
			end: int$1(1),
			name: "y",
			condition: "<="
		}, ({ y }) => {
			const dist = float$1(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
			If$1(dist.lessThan(sqdist.x), () => {
				sqdist.z.assign(sqdist.y);
				sqdist.y.assign(sqdist.x);
				sqdist.x.assign(dist);
			}).ElseIf(dist.lessThan(sqdist.y), () => {
				sqdist.z.assign(sqdist.y);
				sqdist.y.assign(dist);
			}).ElseIf(dist.lessThan(sqdist.z), () => {
				sqdist.z.assign(dist);
			});
		});
	});
	If$1(metric.equal(int$1(0)), () => {
		sqdist.assign(sqrt$1(sqdist));
	});
	return sqdist;
}).setLayout({
	name: "mx_worley_noise_vec3_0",
	type: "vec3",
	inputs: [
		{
			name: "p",
			type: "vec2"
		},
		{
			name: "jitter",
			type: "float"
		},
		{
			name: "metric",
			type: "int"
		}
	]
});
var mx_worley_noise_float$1 = /* @__PURE__ */ overloadingFn$1([mx_worley_noise_float_0, /* @__PURE__ */ Fn$1(([p_immutable, jitter_immutable, metric_immutable]) => {
	const metric = int$1(metric_immutable).toVar();
	const jitter = float$1(jitter_immutable).toVar();
	const p$1 = vec3$1(p_immutable).toVar();
	const X = int$1().toVar(), Y = int$1().toVar(), Z = int$1().toVar();
	const localpos = vec3$1(mx_floorfrac(p$1.x, X), mx_floorfrac(p$1.y, Y), mx_floorfrac(p$1.z, Z)).toVar();
	const sqdist = float$1(1e6).toVar();
	Loop$1({
		start: -1,
		end: int$1(1),
		name: "x",
		condition: "<="
	}, ({ x }) => {
		Loop$1({
			start: -1,
			end: int$1(1),
			name: "y",
			condition: "<="
		}, ({ y }) => {
			Loop$1({
				start: -1,
				end: int$1(1),
				name: "z",
				condition: "<="
			}, ({ z }) => {
				const dist = float$1(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
				sqdist.assign(min$1(sqdist, dist));
			});
		});
	});
	If$1(metric.equal(int$1(0)), () => {
		sqdist.assign(sqrt$1(sqdist));
	});
	return sqdist;
}).setLayout({
	name: "mx_worley_noise_float_1",
	type: "float",
	inputs: [
		{
			name: "p",
			type: "vec3"
		},
		{
			name: "jitter",
			type: "float"
		},
		{
			name: "metric",
			type: "int"
		}
	]
})]);
var mx_worley_noise_vec2$1 = /* @__PURE__ */ overloadingFn$1([mx_worley_noise_vec2_0, /* @__PURE__ */ Fn$1(([p_immutable, jitter_immutable, metric_immutable]) => {
	const metric = int$1(metric_immutable).toVar();
	const jitter = float$1(jitter_immutable).toVar();
	const p$1 = vec3$1(p_immutable).toVar();
	const X = int$1().toVar(), Y = int$1().toVar(), Z = int$1().toVar();
	const localpos = vec3$1(mx_floorfrac(p$1.x, X), mx_floorfrac(p$1.y, Y), mx_floorfrac(p$1.z, Z)).toVar();
	const sqdist = vec2$1(1e6, 1e6).toVar();
	Loop$1({
		start: -1,
		end: int$1(1),
		name: "x",
		condition: "<="
	}, ({ x }) => {
		Loop$1({
			start: -1,
			end: int$1(1),
			name: "y",
			condition: "<="
		}, ({ y }) => {
			Loop$1({
				start: -1,
				end: int$1(1),
				name: "z",
				condition: "<="
			}, ({ z }) => {
				const dist = float$1(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
				If$1(dist.lessThan(sqdist.x), () => {
					sqdist.y.assign(sqdist.x);
					sqdist.x.assign(dist);
				}).ElseIf(dist.lessThan(sqdist.y), () => {
					sqdist.y.assign(dist);
				});
			});
		});
	});
	If$1(metric.equal(int$1(0)), () => {
		sqdist.assign(sqrt$1(sqdist));
	});
	return sqdist;
}).setLayout({
	name: "mx_worley_noise_vec2_1",
	type: "vec2",
	inputs: [
		{
			name: "p",
			type: "vec3"
		},
		{
			name: "jitter",
			type: "float"
		},
		{
			name: "metric",
			type: "int"
		}
	]
})]);
var mx_worley_noise_vec3$1 = /* @__PURE__ */ overloadingFn$1([mx_worley_noise_vec3_0, /* @__PURE__ */ Fn$1(([p_immutable, jitter_immutable, metric_immutable]) => {
	const metric = int$1(metric_immutable).toVar();
	const jitter = float$1(jitter_immutable).toVar();
	const p$1 = vec3$1(p_immutable).toVar();
	const X = int$1().toVar(), Y = int$1().toVar(), Z = int$1().toVar();
	const localpos = vec3$1(mx_floorfrac(p$1.x, X), mx_floorfrac(p$1.y, Y), mx_floorfrac(p$1.z, Z)).toVar();
	const sqdist = vec3$1(1e6, 1e6, 1e6).toVar();
	Loop$1({
		start: -1,
		end: int$1(1),
		name: "x",
		condition: "<="
	}, ({ x }) => {
		Loop$1({
			start: -1,
			end: int$1(1),
			name: "y",
			condition: "<="
		}, ({ y }) => {
			Loop$1({
				start: -1,
				end: int$1(1),
				name: "z",
				condition: "<="
			}, ({ z }) => {
				const dist = float$1(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
				If$1(dist.lessThan(sqdist.x), () => {
					sqdist.z.assign(sqdist.y);
					sqdist.y.assign(sqdist.x);
					sqdist.x.assign(dist);
				}).ElseIf(dist.lessThan(sqdist.y), () => {
					sqdist.z.assign(sqdist.y);
					sqdist.y.assign(dist);
				}).ElseIf(dist.lessThan(sqdist.z), () => {
					sqdist.z.assign(dist);
				});
			});
		});
	});
	If$1(metric.equal(int$1(0)), () => {
		sqdist.assign(sqrt$1(sqdist));
	});
	return sqdist;
}).setLayout({
	name: "mx_worley_noise_vec3_1",
	type: "vec3",
	inputs: [
		{
			name: "p",
			type: "vec3"
		},
		{
			name: "jitter",
			type: "float"
		},
		{
			name: "metric",
			type: "int"
		}
	]
})]);
var mx_unifiednoise2d$1 = /* @__PURE__ */ Fn$1(([noiseType_immutable, texcoord_immutable, freq_immutable, offset_immutable, jitter_immutable, outmin_immutable, outmax_immutable, clampoutput_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
	const noiseType = int$1(noiseType_immutable).toVar();
	const texcoord = vec2$1(texcoord_immutable).toVar();
	const freq = vec2$1(freq_immutable).toVar();
	const offset = vec2$1(offset_immutable).toVar();
	const jitter = float$1(jitter_immutable).toVar();
	const outmin = float$1(outmin_immutable).toVar();
	const outmax = float$1(outmax_immutable).toVar();
	const clampoutput = bool$1(clampoutput_immutable).toVar();
	const octaves = int$1(octaves_immutable).toVar();
	const lacunarity = float$1(lacunarity_immutable).toVar();
	const diminish = float$1(diminish_immutable).toVar();
	const p$1 = texcoord.mul(freq).add(offset);
	const result = float$1(0).toVar();
	If$1(noiseType.equal(int$1(0)), () => {
		result.assign(mx_perlin_noise_vec3(p$1));
	});
	If$1(noiseType.equal(int$1(1)), () => {
		result.assign(mx_cell_noise_vec3(p$1));
	});
	If$1(noiseType.equal(int$1(2)), () => {
		result.assign(mx_worley_noise_vec3$1(p$1, jitter, int$1(0)));
	});
	If$1(noiseType.equal(int$1(3)), () => {
		result.assign(mx_fractal_noise_vec3$1(vec3$1(p$1, 0), octaves, lacunarity, diminish));
	});
	result.assign(result.mul(outmax.sub(outmin)).add(outmin));
	If$1(clampoutput, () => {
		result.assign(clamp$2(result, outmin, outmax));
	});
	return result;
}).setLayout({
	name: "mx_unifiednoise2d",
	type: "float",
	inputs: [
		{
			name: "noiseType",
			type: "int"
		},
		{
			name: "texcoord",
			type: "vec2"
		},
		{
			name: "freq",
			type: "vec2"
		},
		{
			name: "offset",
			type: "vec2"
		},
		{
			name: "jitter",
			type: "float"
		},
		{
			name: "outmin",
			type: "float"
		},
		{
			name: "outmax",
			type: "float"
		},
		{
			name: "clampoutput",
			type: "bool"
		},
		{
			name: "octaves",
			type: "int"
		},
		{
			name: "lacunarity",
			type: "float"
		},
		{
			name: "diminish",
			type: "float"
		}
	]
});
var mx_unifiednoise3d$1 = /* @__PURE__ */ Fn$1(([noiseType_immutable, position_immutable, freq_immutable, offset_immutable, jitter_immutable, outmin_immutable, outmax_immutable, clampoutput_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
	const noiseType = int$1(noiseType_immutable).toVar();
	const position = vec3$1(position_immutable).toVar();
	const freq = vec3$1(freq_immutable).toVar();
	const offset = vec3$1(offset_immutable).toVar();
	const jitter = float$1(jitter_immutable).toVar();
	const outmin = float$1(outmin_immutable).toVar();
	const outmax = float$1(outmax_immutable).toVar();
	const clampoutput = bool$1(clampoutput_immutable).toVar();
	const octaves = int$1(octaves_immutable).toVar();
	const lacunarity = float$1(lacunarity_immutable).toVar();
	const diminish = float$1(diminish_immutable).toVar();
	const p$1 = position.mul(freq).add(offset);
	const result = float$1(0).toVar();
	If$1(noiseType.equal(int$1(0)), () => {
		result.assign(mx_perlin_noise_vec3(p$1));
	});
	If$1(noiseType.equal(int$1(1)), () => {
		result.assign(mx_cell_noise_vec3(p$1));
	});
	If$1(noiseType.equal(int$1(2)), () => {
		result.assign(mx_worley_noise_vec3$1(p$1, jitter, int$1(0)));
	});
	If$1(noiseType.equal(int$1(3)), () => {
		result.assign(mx_fractal_noise_vec3$1(p$1, octaves, lacunarity, diminish));
	});
	result.assign(result.mul(outmax.sub(outmin)).add(outmin));
	If$1(clampoutput, () => {
		result.assign(clamp$2(result, outmin, outmax));
	});
	return result;
}).setLayout({
	name: "mx_unifiednoise3d",
	type: "float",
	inputs: [
		{
			name: "noiseType",
			type: "int"
		},
		{
			name: "position",
			type: "vec3"
		},
		{
			name: "freq",
			type: "vec3"
		},
		{
			name: "offset",
			type: "vec3"
		},
		{
			name: "jitter",
			type: "float"
		},
		{
			name: "outmin",
			type: "float"
		},
		{
			name: "outmax",
			type: "float"
		},
		{
			name: "clampoutput",
			type: "bool"
		},
		{
			name: "octaves",
			type: "int"
		},
		{
			name: "lacunarity",
			type: "float"
		},
		{
			name: "diminish",
			type: "float"
		}
	]
});
var mx_hsvtorgb$1 = /* @__PURE__ */ Fn$1(([hsv]) => {
	const s = hsv.y;
	const v = hsv.z;
	const result = vec3$1().toVar();
	If$1(s.lessThan(1e-4), () => {
		result.assign(vec3$1(v, v, v));
	}).Else(() => {
		let h = hsv.x;
		h = h.sub(floor$1(h)).mul(6).toVar();
		const hi = int$1(trunc$1(h));
		const f = h.sub(float$1(hi));
		const p$1 = v.mul(s.oneMinus());
		const q = v.mul(s.mul(f).oneMinus());
		const t = v.mul(s.mul(f.oneMinus()).oneMinus());
		If$1(hi.equal(int$1(0)), () => {
			result.assign(vec3$1(v, t, p$1));
		}).ElseIf(hi.equal(int$1(1)), () => {
			result.assign(vec3$1(q, v, p$1));
		}).ElseIf(hi.equal(int$1(2)), () => {
			result.assign(vec3$1(p$1, v, t));
		}).ElseIf(hi.equal(int$1(3)), () => {
			result.assign(vec3$1(p$1, q, v));
		}).ElseIf(hi.equal(int$1(4)), () => {
			result.assign(vec3$1(t, p$1, v));
		}).Else(() => {
			result.assign(vec3$1(v, p$1, q));
		});
	});
	return result;
}).setLayout({
	name: "mx_hsvtorgb",
	type: "vec3",
	inputs: [{
		name: "hsv",
		type: "vec3"
	}]
});
var mx_rgbtohsv$1 = /* @__PURE__ */ Fn$1(([c_immutable]) => {
	const c$1 = vec3$1(c_immutable).toVar();
	const r = float$1(c$1.x).toVar();
	const g$1 = float$1(c$1.y).toVar();
	const b$2 = float$1(c$1.z).toVar();
	const mincomp = float$1(min$1(r, min$1(g$1, b$2))).toVar();
	const maxcomp = float$1(max$1$1(r, max$1$1(g$1, b$2))).toVar();
	const delta = float$1(maxcomp.sub(mincomp)).toVar();
	const h = float$1().toVar(), s = float$1().toVar(), v = float$1().toVar();
	v.assign(maxcomp);
	If$1(maxcomp.greaterThan(0), () => {
		s.assign(delta.div(maxcomp));
	}).Else(() => {
		s.assign(0);
	});
	If$1(s.lessThanEqual(0), () => {
		h.assign(0);
	}).Else(() => {
		If$1(r.greaterThanEqual(maxcomp), () => {
			h.assign(g$1.sub(b$2).div(delta));
		}).ElseIf(g$1.greaterThanEqual(maxcomp), () => {
			h.assign(add$1(2, b$2.sub(r).div(delta)));
		}).Else(() => {
			h.assign(add$1(4, r.sub(g$1).div(delta)));
		});
		h.mulAssign(1 / 6);
		If$1(h.lessThan(0), () => {
			h.addAssign(1);
		});
	});
	return vec3$1(h, s, v);
}).setLayout({
	name: "mx_rgbtohsv",
	type: "vec3",
	inputs: [{
		name: "c",
		type: "vec3"
	}]
});
var mx_srgb_texture_to_lin_rec709$1 = /* @__PURE__ */ Fn$1(([color_immutable]) => {
	const color$2 = vec3$1(color_immutable).toVar();
	const isAbove = bvec3$1(greaterThan$1(color$2, vec3$1(.04045))).toVar();
	const linSeg = vec3$1(color$2.div(12.92)).toVar();
	const powSeg = vec3$1(pow$1(max$1$1(color$2.add(vec3$1(.055)), vec3$1(0)).div(1.055), vec3$1(2.4))).toVar();
	return mix$2(linSeg, powSeg, isAbove);
}).setLayout({
	name: "mx_srgb_texture_to_lin_rec709",
	type: "vec3",
	inputs: [{
		name: "color",
		type: "vec3"
	}]
});
var mx_aastep$1 = (threshold, value) => {
	threshold = float$1(threshold);
	value = float$1(value);
	const afwidth = vec2$1(value.dFdx(), value.dFdy()).length().mul(.7071067811865476);
	return smoothstep$1(threshold.sub(afwidth), threshold.add(afwidth), value);
};
var _ramp = (a$1, b$2, uv$3, p$1) => mix$2(a$1, b$2, uv$3[p$1].clamp());
var mx_ramplr$1 = (valuel, valuer, texcoord = uv$1$1()) => _ramp(valuel, valuer, texcoord, "x");
var mx_ramptb$1 = (valuet, valueb, texcoord = uv$1$1()) => _ramp(valuet, valueb, texcoord, "y");
var mx_ramp4$1 = (valuetl, valuetr, valuebl, valuebr, texcoord = uv$1$1()) => {
	const u = texcoord.x.clamp();
	const v = texcoord.y.clamp();
	const top = mix$2(valuetl, valuetr, u);
	const bottom = mix$2(valuebl, valuebr, u);
	return mix$2(top, bottom, v);
};
var _split = (a$1, b$2, center, uv$3, p$1) => mix$2(a$1, b$2, mx_aastep$1(center, uv$3[p$1]));
var mx_splitlr$1 = (valuel, valuer, center, texcoord = uv$1$1()) => _split(valuel, valuer, center, texcoord, "x");
var mx_splittb$1 = (valuet, valueb, center, texcoord = uv$1$1()) => _split(valuet, valueb, center, texcoord, "y");
var mx_transform_uv$1 = (uv_scale = 1, uv_offset = 0, uv_geo = uv$1$1()) => uv_geo.mul(uv_scale).add(uv_offset);
var mx_safepower$1 = (in1, in2 = 1) => {
	in1 = float$1(in1);
	return in1.abs().pow(in2).mul(in1.sign());
};
var mx_contrast$1 = (input, amount = 1, pivot = .5) => float$1(input).sub(pivot).mul(amount).add(pivot);
var mx_noise_float$1 = (texcoord = uv$1$1(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec3$1 = (texcoord = uv$1$1(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec4$1 = (texcoord = uv$1$1(), amplitude = 1, pivot = 0) => {
	texcoord = texcoord.convert("vec2|vec3");
	return vec4$1(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2$1(19, 73)))).mul(amplitude).add(pivot);
};
var mx_unifiednoise2d$2 = (noiseType, texcoord = uv$1$1(), freq = vec2$1(1, 1), offset = vec2$1(0, 0), jitter = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = .5) => mx_unifiednoise2d$1(noiseType, texcoord.convert("vec2|vec3"), freq, offset, jitter, outmin, outmax, clampoutput, octaves, lacunarity, diminish);
var mx_unifiednoise3d$2 = (noiseType, texcoord = uv$1$1(), freq = vec2$1(1, 1), offset = vec2$1(0, 0), jitter = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = .5) => mx_unifiednoise3d$1(noiseType, texcoord.convert("vec2|vec3"), freq, offset, jitter, outmin, outmax, clampoutput, octaves, lacunarity, diminish);
var mx_worley_noise_float$2 = (texcoord = uv$1$1(), jitter = 1) => mx_worley_noise_float$1(texcoord.convert("vec2|vec3"), jitter, int$1(1));
var mx_worley_noise_vec2$2 = (texcoord = uv$1$1(), jitter = 1) => mx_worley_noise_vec2$1(texcoord.convert("vec2|vec3"), jitter, int$1(1));
var mx_worley_noise_vec3$2 = (texcoord = uv$1$1(), jitter = 1) => mx_worley_noise_vec3$1(texcoord.convert("vec2|vec3"), jitter, int$1(1));
var mx_cell_noise_float$2 = (texcoord = uv$1$1()) => mx_cell_noise_float$1(texcoord.convert("vec2|vec3"));
var mx_fractal_noise_float$2 = (position = uv$1$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_float$1(position, int$1(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec2$2 = (position = uv$1$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec2$1(position, int$1(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec3$2 = (position = uv$1$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec3$1(position, int$1(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec4$2 = (position = uv$1$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec4$1(position, int$1(octaves), lacunarity, diminish).mul(amplitude);
var mx_add$1 = (in1, in2 = float$1(0)) => add$1(in1, in2);
var mx_subtract$1 = (in1, in2 = float$1(0)) => sub$1(in1, in2);
var mx_multiply$1 = (in1, in2 = float$1(1)) => mul$1(in1, in2);
var mx_divide$1 = (in1, in2 = float$1(1)) => div$1(in1, in2);
var mx_modulo$1 = (in1, in2 = float$1(1)) => mod$1(in1, in2);
var mx_power$1 = (in1, in2 = float$1(1)) => pow$1(in1, in2);
var mx_atan2$1 = (in1 = float$1(0), in2 = float$1(1)) => atan$1(in1, in2);
var mx_timer$1 = () => time$1;
var mx_frame$1 = () => frameId$1;
var mx_invert$1 = (in1, amount = float$1(1)) => sub$1(amount, in1);
var mx_ifgreater$1 = (value1, value2, in1, in2) => value1.greaterThan(value2).mix(in1, in2);
var mx_ifgreatereq$1 = (value1, value2, in1, in2) => value1.greaterThanEqual(value2).mix(in1, in2);
var mx_ifequal$1 = (value1, value2, in1, in2) => value1.equal(value2).mix(in1, in2);
var mx_separate$1 = (in1, channelOrOut = null) => {
	if (typeof channelOrOut === "string") {
		const map = {
			x: 0,
			r: 0,
			y: 1,
			g: 1,
			z: 2,
			b: 2,
			w: 3,
			a: 3
		};
		const c$1 = channelOrOut.replace(/^out/, "").toLowerCase();
		if (map[c$1] !== void 0) return in1.element(map[c$1]);
	}
	if (typeof channelOrOut === "number") return in1.element(channelOrOut);
	if (typeof channelOrOut === "string" && channelOrOut.length === 1) {
		const map = {
			x: 0,
			r: 0,
			y: 1,
			g: 1,
			z: 2,
			b: 2,
			w: 3,
			a: 3
		};
		if (map[channelOrOut] !== void 0) return in1.element(map[channelOrOut]);
	}
	return in1;
};
var mx_place2d$1 = (texcoord, pivot = vec2$1(.5, .5), scale$3 = vec2$1(1, 1), rotate$2 = float$1(0), offset = vec2$1(0, 0)) => {
	let uv$3 = texcoord;
	if (pivot) uv$3 = uv$3.sub(pivot);
	if (scale$3) uv$3 = uv$3.mul(scale$3);
	if (rotate$2) {
		const rad = rotate$2.mul(Math.PI / 180);
		const cosR = rad.cos();
		const sinR = rad.sin();
		uv$3 = vec2$1(uv$3.x.mul(cosR).sub(uv$3.y.mul(sinR)), uv$3.x.mul(sinR).add(uv$3.y.mul(cosR)));
	}
	if (pivot) uv$3 = uv$3.add(pivot);
	if (offset) uv$3 = uv$3.add(offset);
	return uv$3;
};
var mx_rotate2d$1 = (input, amount) => {
	input = vec2$1(input);
	amount = float$1(amount);
	const radians$2 = amount.mul(Math.PI / 180);
	return rotate$1(input, radians$2);
};
var mx_rotate3d$1 = (input, amount, axis) => {
	input = vec3$1(input);
	amount = float$1(amount);
	axis = vec3$1(axis);
	const radians$2 = amount.mul(Math.PI / 180);
	const nAxis = axis.normalize();
	const cosA = radians$2.cos();
	const sinA = radians$2.sin();
	const oneMinusCosA = float$1(1).sub(cosA);
	return input.mul(cosA).add(nAxis.cross(input).mul(sinA)).add(nAxis.mul(nAxis.dot(input)).mul(oneMinusCosA));
};
var mx_heighttonormal$1 = (input, scale$3) => {
	input = vec3$1(input);
	scale$3 = float$1(scale$3);
	return bumpMap$1(input, scale$3);
};
/**
* This computes a parallax corrected normal which is used for box-projected cube mapping (BPCEM).
*
* Reference: {@link https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html}
*
* ```js
* const uvNode = getParallaxCorrectNormal( reflectVector, vec3( 200, 100, 100 ), vec3( 0, - 50, 0 ) );
* material.envNode = pmremTexture( renderTarget.texture, uvNode );
* ```
*
* @tsl
* @function
* @param {Node<vec3>} normal - The normal to correct.
* @param {Node<vec3>} cubeSize - The cube size should reflect the size of the environment (BPCEM is usually applied in closed environments like rooms).
* @param {Node<vec3>} cubePos - The cube position.
* @return {Node<vec3>} The parallax corrected normal.
*/
var getParallaxCorrectNormal$1 = /* @__PURE__ */ Fn$1(([normal$1, cubeSize, cubePos]) => {
	const nDir = normalize$1(normal$1).toVar();
	const rbmax = sub$1(float$1(.5).mul(cubeSize.sub(cubePos)), positionWorld$1).div(nDir).toVar();
	const rbmin = sub$1(float$1(-.5).mul(cubeSize.sub(cubePos)), positionWorld$1).div(nDir).toVar();
	const rbminmax = vec3$1().toVar();
	rbminmax.x = nDir.x.greaterThan(float$1(0)).select(rbmax.x, rbmin.x);
	rbminmax.y = nDir.y.greaterThan(float$1(0)).select(rbmax.y, rbmin.y);
	rbminmax.z = nDir.z.greaterThan(float$1(0)).select(rbmax.z, rbmin.z);
	const correction = min$1(rbminmax.x, rbminmax.y, rbminmax.z).toVar();
	return positionWorld$1.add(nDir.mul(correction)).toVar().sub(cubePos);
});
var getShIrradianceAt$1 = /* @__PURE__ */ Fn$1(([normal$1, shCoefficients]) => {
	const x = normal$1.x, y = normal$1.y, z = normal$1.z;
	let result = shCoefficients.element(0).mul(.886227);
	result = result.add(shCoefficients.element(1).mul(2 * .511664).mul(y));
	result = result.add(shCoefficients.element(2).mul(2 * .511664).mul(z));
	result = result.add(shCoefficients.element(3).mul(2 * .511664).mul(x));
	result = result.add(shCoefficients.element(4).mul(2 * .429043).mul(x).mul(y));
	result = result.add(shCoefficients.element(5).mul(2 * .429043).mul(y).mul(z));
	result = result.add(shCoefficients.element(6).mul(z.mul(z).mul(.743125).sub(.247708)));
	result = result.add(shCoefficients.element(7).mul(2 * .429043).mul(x).mul(z));
	result = result.add(shCoefficients.element(8).mul(.429043).mul(mul$1(x, x).sub(mul$1(y, y))));
	return result;
});
var TSL = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	BRDF_GGX: BRDF_GGX$1,
	BRDF_Lambert: BRDF_Lambert$1,
	BasicPointShadowFilter: BasicPointShadowFilter$1,
	BasicShadowFilter: BasicShadowFilter$1,
	Break: Break$1,
	Const: Const$1,
	Continue: Continue$1,
	DFGApprox: DFGApprox$1,
	D_GGX: D_GGX$1,
	Discard: Discard$1,
	EPSILON: EPSILON$1,
	F_Schlick: F_Schlick$1,
	Fn: Fn$1,
	HALF_PI: HALF_PI$1,
	INFINITY: INFINITY$1,
	If: If$1,
	Loop: Loop$1,
	NodeAccess: NodeAccess$1,
	NodeShaderStage: NodeShaderStage$1,
	NodeType: NodeType$1,
	NodeUpdateType: NodeUpdateType$1,
	OnBeforeMaterialUpdate: OnBeforeMaterialUpdate$1,
	OnBeforeObjectUpdate: OnBeforeObjectUpdate$1,
	OnMaterialUpdate: OnMaterialUpdate$1,
	OnObjectUpdate: OnObjectUpdate$1,
	PCFShadowFilter: PCFShadowFilter$1,
	PCFSoftShadowFilter: PCFSoftShadowFilter$1,
	PI: PI$1,
	PI2: PI2$1,
	PointShadowFilter: PointShadowFilter$1,
	Return: Return$1,
	Schlick_to_F0: Schlick_to_F0$1,
	ScriptableNodeResources: ScriptableNodeResources$1,
	ShaderNode: ShaderNode$1,
	Stack: Stack$1,
	Switch: Switch$1,
	TBNViewMatrix: TBNViewMatrix$1,
	TWO_PI: TWO_PI$1,
	VSMShadowFilter: VSMShadowFilter$1,
	V_GGX_SmithCorrelated: V_GGX_SmithCorrelated$1,
	Var: Var$1,
	VarIntent: VarIntent$1,
	abs: abs$1,
	acesFilmicToneMapping: acesFilmicToneMapping$1,
	acos: acos$1,
	add: add$1,
	addMethodChaining: addMethodChaining$1,
	addNodeElement: addNodeElement$1,
	agxToneMapping: agxToneMapping$1,
	all: all$1,
	alphaT: alphaT$1,
	and: and$1,
	anisotropy: anisotropy$1,
	anisotropyB: anisotropyB$1,
	anisotropyT: anisotropyT$1,
	any: any$1,
	append: append$1,
	array: array$1,
	arrayBuffer: arrayBuffer$1,
	asin: asin$1,
	assign: assign$1,
	atan: atan$1,
	atan2: atan2$1,
	atomicAdd: atomicAdd$1,
	atomicAnd: atomicAnd$1,
	atomicFunc: atomicFunc$1,
	atomicLoad: atomicLoad$1,
	atomicMax: atomicMax$1,
	atomicMin: atomicMin$1,
	atomicOr: atomicOr$1,
	atomicStore: atomicStore$1,
	atomicSub: atomicSub$1,
	atomicXor: atomicXor$1,
	attenuationColor: attenuationColor$1,
	attenuationDistance: attenuationDistance$1,
	attribute: attribute$1,
	attributeArray: attributeArray$1,
	backgroundBlurriness: backgroundBlurriness$1,
	backgroundIntensity: backgroundIntensity$1,
	backgroundRotation: backgroundRotation$1,
	batch: batch$1,
	bentNormalView: bentNormalView$1,
	billboarding: billboarding$1,
	bitAnd: bitAnd$1,
	bitNot: bitNot$1,
	bitOr: bitOr$1,
	bitXor: bitXor$1,
	bitangentGeometry: bitangentGeometry$1,
	bitangentLocal: bitangentLocal$1,
	bitangentView: bitangentView$1,
	bitangentWorld: bitangentWorld$1,
	bitcast: bitcast$1,
	blendBurn: blendBurn$1,
	blendColor: blendColor$1,
	blendDodge: blendDodge$1,
	blendOverlay: blendOverlay$1,
	blendScreen: blendScreen$1,
	blur: blur$1,
	bool: bool$1,
	buffer: buffer$1,
	bufferAttribute: bufferAttribute$1,
	builtin: builtin$1,
	bumpMap: bumpMap$1,
	burn: burn$1,
	bvec2: bvec2$1,
	bvec3: bvec3$1,
	bvec4: bvec4$1,
	bypass: bypass$1,
	cache: cache$1,
	call: call$1,
	cameraFar: cameraFar$1,
	cameraIndex: cameraIndex$1,
	cameraNear: cameraNear$1,
	cameraNormalMatrix: cameraNormalMatrix$1,
	cameraPosition: cameraPosition$1,
	cameraProjectionMatrix: cameraProjectionMatrix$1,
	cameraProjectionMatrixInverse: cameraProjectionMatrixInverse$1,
	cameraViewMatrix: cameraViewMatrix$1,
	cameraViewport: cameraViewport$1,
	cameraWorldMatrix: cameraWorldMatrix$1,
	cbrt: cbrt$1,
	cdl: cdl$1,
	ceil: ceil$1,
	checker: checker$1,
	cineonToneMapping: cineonToneMapping$1,
	clamp: clamp$2,
	clearcoat: clearcoat$1,
	clearcoatNormalView: clearcoatNormalView$1,
	clearcoatRoughness: clearcoatRoughness$1,
	code: code$1,
	color: color$1,
	colorSpaceToWorking: colorSpaceToWorking$1,
	colorToDirection: colorToDirection$1,
	compute: compute$1,
	computeKernel: computeKernel$1,
	computeSkinning: computeSkinning$1,
	context: context$1,
	convert: convert$1,
	convertColorSpace: convertColorSpace$1,
	convertToTexture: convertToTexture$1,
	cos: cos$1,
	cross: cross$1,
	cubeTexture: cubeTexture$1,
	cubeTextureBase: cubeTextureBase$1,
	cubeToUV: cubeToUV$1,
	dFdx: dFdx$1,
	dFdy: dFdy$1,
	dashSize: dashSize$1,
	debug: debug$1,
	decrement: decrement$1,
	decrementBefore: decrementBefore$1,
	defaultBuildStages: defaultBuildStages$1,
	defaultShaderStages: defaultShaderStages$1,
	defined: defined$1,
	degrees: degrees$1,
	deltaTime: deltaTime$1,
	densityFog: densityFog$1,
	densityFogFactor: densityFogFactor$1,
	depth: depth$1,
	depthPass: depthPass$1,
	determinant: determinant$1,
	difference: difference$1,
	diffuseColor: diffuseColor$1,
	directPointLight: directPointLight$1,
	directionToColor: directionToColor$1,
	directionToFaceDirection: directionToFaceDirection$1,
	dispersion: dispersion$1,
	distance: distance$2,
	div: div$1,
	dodge: dodge$1,
	dot: dot$1,
	drawIndex: drawIndex$1,
	dynamicBufferAttribute: dynamicBufferAttribute$1,
	element: element$1,
	emissive: emissive$1,
	equal: equal$1,
	equals: equals$2,
	equirectUV: equirectUV$1,
	exp: exp$1,
	exp2: exp2$1,
	expression: expression$1,
	faceDirection: faceDirection$1,
	faceForward: faceForward$1,
	faceforward: faceforward$1,
	float: float$1,
	floatBitsToInt: floatBitsToInt$1,
	floatBitsToUint: floatBitsToUint$1,
	floor: floor$1,
	fog: fog$1,
	fract: fract$1,
	frameGroup: frameGroup$1,
	frameId: frameId$1,
	frontFacing: frontFacing$1,
	fwidth: fwidth$1,
	gain: gain$1,
	gapSize: gapSize$1,
	getConstNodeType: getConstNodeType$1,
	getCurrentStack: getCurrentStack$1,
	getDirection: getDirection$1,
	getDistanceAttenuation: getDistanceAttenuation$1,
	getGeometryRoughness: getGeometryRoughness$1,
	getNormalFromDepth: getNormalFromDepth$1,
	getParallaxCorrectNormal: getParallaxCorrectNormal$1,
	getRoughness: getRoughness$1,
	getScreenPosition: getScreenPosition$1,
	getShIrradianceAt: getShIrradianceAt$1,
	getShadowMaterial: getShadowMaterial$1,
	getShadowRenderObjectFunction: getShadowRenderObjectFunction$1,
	getTextureIndex: getTextureIndex$1,
	getViewPosition: getViewPosition$1,
	ggxConvolution,
	globalId: globalId$1,
	glsl: glsl$1,
	glslFn: glslFn$1,
	grayscale: grayscale$1,
	greaterThan: greaterThan$1,
	greaterThanEqual: greaterThanEqual$1,
	hash: hash$2,
	highpModelNormalViewMatrix: highpModelNormalViewMatrix$1,
	highpModelViewMatrix: highpModelViewMatrix$1,
	hue: hue$1,
	increment: increment$1,
	incrementBefore: incrementBefore$1,
	inspector,
	instance: instance$1,
	instanceIndex: instanceIndex$1,
	instancedArray: instancedArray$1,
	instancedBufferAttribute: instancedBufferAttribute$1,
	instancedDynamicBufferAttribute: instancedDynamicBufferAttribute$1,
	instancedMesh: instancedMesh$1,
	int: int$1,
	intBitsToFloat: intBitsToFloat$1,
	interleavedGradientNoise: interleavedGradientNoise$1,
	inverse: inverse$1,
	inverseSqrt: inverseSqrt$1,
	inversesqrt: inversesqrt$1,
	invocationLocalIndex: invocationLocalIndex$1,
	invocationSubgroupIndex: invocationSubgroupIndex$1,
	ior: ior$1,
	iridescence: iridescence$1,
	iridescenceIOR: iridescenceIOR$1,
	iridescenceThickness: iridescenceThickness$1,
	isolate,
	ivec2: ivec2$1,
	ivec3: ivec3$1,
	ivec4: ivec4$1,
	js: js$1,
	label: label$1,
	length: length$1,
	lengthSq: lengthSq$1,
	lessThan: lessThan$1,
	lessThanEqual: lessThanEqual$1,
	lightPosition: lightPosition$1,
	lightProjectionUV: lightProjectionUV$1,
	lightShadowMatrix: lightShadowMatrix$1,
	lightTargetDirection: lightTargetDirection$1,
	lightTargetPosition: lightTargetPosition$1,
	lightViewPosition: lightViewPosition$1,
	lightingContext: lightingContext$1,
	lights: lights$1,
	linearDepth: linearDepth$1,
	linearToneMapping: linearToneMapping$1,
	localId: localId$1,
	log: log$2,
	log2: log2$1,
	logarithmicDepthToViewZ: logarithmicDepthToViewZ$1,
	luminance: luminance$2,
	mat2: mat2$1,
	mat3: mat3$1,
	mat4: mat4$1,
	matcapUV: matcapUV$1,
	materialAO: materialAO$1,
	materialAlphaTest: materialAlphaTest$1,
	materialAnisotropy: materialAnisotropy$1,
	materialAnisotropyVector: materialAnisotropyVector$1,
	materialAttenuationColor: materialAttenuationColor$1,
	materialAttenuationDistance: materialAttenuationDistance$1,
	materialClearcoat: materialClearcoat$1,
	materialClearcoatNormal: materialClearcoatNormal$1,
	materialClearcoatRoughness: materialClearcoatRoughness$1,
	materialColor: materialColor$1,
	materialDispersion: materialDispersion$1,
	materialEmissive: materialEmissive$1,
	materialEnvIntensity: materialEnvIntensity$1,
	materialEnvRotation: materialEnvRotation$1,
	materialIOR: materialIOR$1,
	materialIridescence: materialIridescence$1,
	materialIridescenceIOR: materialIridescenceIOR$1,
	materialIridescenceThickness: materialIridescenceThickness$1,
	materialLightMap: materialLightMap$1,
	materialLineDashOffset: materialLineDashOffset$1,
	materialLineDashSize: materialLineDashSize$1,
	materialLineGapSize: materialLineGapSize$1,
	materialLineScale: materialLineScale$1,
	materialLineWidth: materialLineWidth$1,
	materialMetalness: materialMetalness$1,
	materialNormal: materialNormal$1,
	materialOpacity: materialOpacity$1,
	materialPointSize: materialPointSize$1,
	materialReference: materialReference$1,
	materialReflectivity: materialReflectivity$1,
	materialRefractionRatio: materialRefractionRatio$1,
	materialRotation: materialRotation$1,
	materialRoughness: materialRoughness$1,
	materialSheen: materialSheen$1,
	materialSheenRoughness: materialSheenRoughness$1,
	materialShininess: materialShininess$1,
	materialSpecular: materialSpecular$1,
	materialSpecularColor: materialSpecularColor$1,
	materialSpecularIntensity: materialSpecularIntensity$1,
	materialSpecularStrength: materialSpecularStrength$1,
	materialThickness: materialThickness$1,
	materialTransmission: materialTransmission$1,
	max: max$1$1,
	maxMipLevel: maxMipLevel$1,
	mediumpModelViewMatrix: mediumpModelViewMatrix$1,
	metalness: metalness$1,
	min: min$1,
	mix: mix$2,
	mixElement: mixElement$1,
	mod: mod$1,
	modInt: modInt$1,
	modelDirection: modelDirection$1,
	modelNormalMatrix: modelNormalMatrix$1,
	modelPosition: modelPosition$1,
	modelRadius: modelRadius$1,
	modelScale: modelScale$1,
	modelViewMatrix: modelViewMatrix$1,
	modelViewPosition: modelViewPosition$1,
	modelViewProjection: modelViewProjection$1,
	modelWorldMatrix: modelWorldMatrix$1,
	modelWorldMatrixInverse: modelWorldMatrixInverse$1,
	morphReference: morphReference$1,
	mrt: mrt$1,
	mul: mul$1,
	mx_aastep: mx_aastep$1,
	mx_add: mx_add$1,
	mx_atan2: mx_atan2$1,
	mx_cell_noise_float: mx_cell_noise_float$2,
	mx_contrast: mx_contrast$1,
	mx_divide: mx_divide$1,
	mx_fractal_noise_float: mx_fractal_noise_float$2,
	mx_fractal_noise_vec2: mx_fractal_noise_vec2$2,
	mx_fractal_noise_vec3: mx_fractal_noise_vec3$2,
	mx_fractal_noise_vec4: mx_fractal_noise_vec4$2,
	mx_frame: mx_frame$1,
	mx_heighttonormal: mx_heighttonormal$1,
	mx_hsvtorgb: mx_hsvtorgb$1,
	mx_ifequal: mx_ifequal$1,
	mx_ifgreater: mx_ifgreater$1,
	mx_ifgreatereq: mx_ifgreatereq$1,
	mx_invert: mx_invert$1,
	mx_modulo: mx_modulo$1,
	mx_multiply: mx_multiply$1,
	mx_noise_float: mx_noise_float$1,
	mx_noise_vec3: mx_noise_vec3$1,
	mx_noise_vec4: mx_noise_vec4$1,
	mx_place2d: mx_place2d$1,
	mx_power: mx_power$1,
	mx_ramp4: mx_ramp4$1,
	mx_ramplr: mx_ramplr$1,
	mx_ramptb: mx_ramptb$1,
	mx_rgbtohsv: mx_rgbtohsv$1,
	mx_rotate2d: mx_rotate2d$1,
	mx_rotate3d: mx_rotate3d$1,
	mx_safepower: mx_safepower$1,
	mx_separate: mx_separate$1,
	mx_splitlr: mx_splitlr$1,
	mx_splittb: mx_splittb$1,
	mx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709$1,
	mx_subtract: mx_subtract$1,
	mx_timer: mx_timer$1,
	mx_transform_uv: mx_transform_uv$1,
	mx_unifiednoise2d: mx_unifiednoise2d$2,
	mx_unifiednoise3d: mx_unifiednoise3d$2,
	mx_worley_noise_float: mx_worley_noise_float$2,
	mx_worley_noise_vec2: mx_worley_noise_vec2$2,
	mx_worley_noise_vec3: mx_worley_noise_vec3$2,
	negate: negate$1,
	neutralToneMapping: neutralToneMapping$1,
	nodeArray: nodeArray$1,
	nodeImmutable: nodeImmutable$1,
	nodeObject: nodeObject$1,
	nodeObjectIntent: nodeObjectIntent$1,
	nodeObjects: nodeObjects$1,
	nodeProxy: nodeProxy$1,
	nodeProxyIntent: nodeProxyIntent$1,
	normalFlat: normalFlat$1,
	normalGeometry: normalGeometry$1,
	normalLocal: normalLocal$1,
	normalMap: normalMap$1,
	normalView: normalView$1,
	normalViewGeometry: normalViewGeometry$1,
	normalWorld: normalWorld$1,
	normalWorldGeometry: normalWorldGeometry$1,
	normalize: normalize$1,
	not: not$1,
	notEqual: notEqual$1,
	numWorkgroups: numWorkgroups$1,
	objectDirection: objectDirection$1,
	objectGroup: objectGroup$1,
	objectPosition: objectPosition$1,
	objectRadius: objectRadius$1,
	objectScale: objectScale$1,
	objectViewPosition: objectViewPosition$1,
	objectWorldMatrix: objectWorldMatrix$1,
	oneMinus: oneMinus$1,
	or: or$1,
	orthographicDepthToViewZ: orthographicDepthToViewZ$1,
	oscSawtooth: oscSawtooth$1,
	oscSine: oscSine$1,
	oscSquare: oscSquare$1,
	oscTriangle: oscTriangle$1,
	output: output$1,
	outputStruct: outputStruct$1,
	overlay: overlay$1,
	overloadingFn: overloadingFn$1,
	parabola: parabola$1,
	parallaxDirection: parallaxDirection$1,
	parallaxUV: parallaxUV$1,
	parameter: parameter$1,
	pass: pass$1,
	passTexture: passTexture$1,
	pcurve: pcurve$1,
	perspectiveDepthToViewZ: perspectiveDepthToViewZ$1,
	pmremTexture: pmremTexture$1,
	pointShadow: pointShadow$1,
	pointUV: pointUV$1,
	pointWidth: pointWidth$1,
	positionGeometry: positionGeometry$1,
	positionLocal: positionLocal$1,
	positionPrevious: positionPrevious$1,
	positionView: positionView$1,
	positionViewDirection: positionViewDirection$1,
	positionWorld: positionWorld$1,
	positionWorldDirection: positionWorldDirection$1,
	posterize: posterize$1,
	pow: pow$1,
	pow2: pow2$1,
	pow3: pow3$1,
	pow4: pow4$1,
	premultiplyAlpha: premultiplyAlpha$1,
	property: property$1,
	quadBroadcast,
	quadSwapDiagonal,
	quadSwapX,
	quadSwapY,
	radians: radians$1,
	rand: rand$1,
	range: range$2,
	rangeFog: rangeFog$1,
	rangeFogFactor: rangeFogFactor$1,
	reciprocal: reciprocal$1,
	reference: reference$2,
	referenceBuffer: referenceBuffer$1,
	reflect: reflect$1,
	reflectVector: reflectVector$1,
	reflectView: reflectView$1,
	reflector: reflector$1,
	refract: refract$1,
	refractVector: refractVector$1,
	refractView: refractView$1,
	reinhardToneMapping: reinhardToneMapping$1,
	remap: remap$1,
	remapClamp: remapClamp$1,
	renderGroup: renderGroup$1,
	renderOutput: renderOutput$1,
	rendererReference: rendererReference$1,
	rotate: rotate$1,
	rotateUV: rotateUV$1,
	roughness: roughness$1,
	round: round$1,
	rtt: rtt$1,
	sRGBTransferEOTF: sRGBTransferEOTF$1,
	sRGBTransferOETF: sRGBTransferOETF$1,
	sample: sample$1,
	sampler: sampler$1,
	samplerComparison: samplerComparison$1,
	saturate: saturate$1,
	saturation: saturation$1,
	screen: screen$1,
	screenCoordinate: screenCoordinate$1,
	screenDPR: screenDPR$1,
	screenSize: screenSize$1,
	screenUV: screenUV$1,
	scriptable: scriptable$1,
	scriptableValue: scriptableValue$1,
	select: select$1,
	setCurrentStack: setCurrentStack$1,
	setName: setName$1,
	shaderStages: shaderStages$1,
	shadow: shadow$1,
	shadowPositionWorld: shadowPositionWorld$1,
	shapeCircle: shapeCircle$1,
	sharedUniformGroup: sharedUniformGroup$1,
	sheen: sheen$1,
	sheenRoughness: sheenRoughness$1,
	shiftLeft: shiftLeft$1,
	shiftRight: shiftRight$1,
	shininess: shininess$1,
	sign: sign$1,
	sin: sin$1,
	sinc: sinc$1,
	skinning: skinning$1,
	smoothstep: smoothstep$1,
	smoothstepElement: smoothstepElement$1,
	specularColor: specularColor$1,
	specularF90: specularF90$1,
	spherizeUV: spherizeUV$1,
	split: split$1,
	spritesheetUV: spritesheetUV$1,
	sqrt: sqrt$1,
	stack: stack$1,
	step: step$1,
	stepElement: stepElement$1,
	storage: storage$1,
	storageBarrier: storageBarrier$1,
	storageObject: storageObject$1,
	storageTexture: storageTexture$1,
	string: string$1,
	struct: struct$1,
	sub: sub$1,
	subBuild: subBuild$1,
	subgroupAdd: subgroupAdd$1,
	subgroupAll: subgroupAll$1,
	subgroupAnd: subgroupAnd$1,
	subgroupAny: subgroupAny$1,
	subgroupBallot: subgroupBallot$1,
	subgroupBroadcast: subgroupBroadcast$1,
	subgroupBroadcastFirst: subgroupBroadcastFirst$1,
	subgroupElect: subgroupElect$1,
	subgroupExclusiveAdd: subgroupExclusiveAdd$1,
	subgroupExclusiveMul: subgroupExclusiveMul$1,
	subgroupInclusiveAdd: subgroupInclusiveAdd$1,
	subgroupInclusiveMul: subgroupInclusiveMul$1,
	subgroupIndex: subgroupIndex$1,
	subgroupMax: subgroupMax$1,
	subgroupMin: subgroupMin$1,
	subgroupMul: subgroupMul$1,
	subgroupOr: subgroupOr$1,
	subgroupShuffle: subgroupShuffle$1,
	subgroupShuffleDown: subgroupShuffleDown$1,
	subgroupShuffleUp: subgroupShuffleUp$1,
	subgroupShuffleXor: subgroupShuffleXor$1,
	subgroupSize: subgroupSize$1,
	subgroupXor: subgroupXor$1,
	tan: tan$1,
	tangentGeometry: tangentGeometry$1,
	tangentLocal: tangentLocal$1,
	tangentView: tangentView$1,
	tangentWorld: tangentWorld$1,
	texture: texture$1,
	texture3D: texture3D$1,
	textureBarrier: textureBarrier$1,
	textureBicubic: textureBicubic$1,
	textureBicubicLevel: textureBicubicLevel$1,
	textureCubeUV: textureCubeUV$1,
	textureLevel: textureLevel$1,
	textureLoad: textureLoad$1,
	textureSize: textureSize$1,
	textureStore: textureStore$1,
	thickness: thickness$1,
	time: time$1,
	toneMapping: toneMapping$1,
	toneMappingExposure: toneMappingExposure$1,
	toonOutlinePass: toonOutlinePass$1,
	transformDirection: transformDirection$1,
	transformNormal: transformNormal$1,
	transformNormalToView: transformNormalToView$1,
	transformedClearcoatNormalView: transformedClearcoatNormalView$1,
	transformedNormalView: transformedNormalView$1,
	transformedNormalWorld: transformedNormalWorld$1,
	transmission: transmission$1,
	transpose: transpose$1,
	triNoise3D: triNoise3D$1,
	triplanarTexture: triplanarTexture$1,
	triplanarTextures: triplanarTextures$1,
	trunc: trunc$1,
	uint: uint$1,
	uintBitsToFloat: uintBitsToFloat$1,
	uniform: uniform$1,
	uniformArray: uniformArray$1,
	uniformCubeTexture: uniformCubeTexture$1,
	uniformFlow: uniformFlow$1,
	uniformGroup: uniformGroup$1,
	uniformTexture: uniformTexture$1,
	unpremultiplyAlpha: unpremultiplyAlpha$1,
	userData: userData$1,
	uv: uv$1$1,
	uvec2: uvec2$1,
	uvec3: uvec3$1,
	uvec4: uvec4$1,
	varying: varying$1,
	varyingProperty: varyingProperty$1,
	vec2: vec2$1,
	vec3: vec3$1,
	vec4: vec4$1,
	vectorComponents: vectorComponents$1,
	velocity: velocity$1,
	vertexColor: vertexColor$1,
	vertexIndex: vertexIndex$1,
	vertexStage: vertexStage$1,
	vibrance: vibrance$1,
	viewZToLogarithmicDepth: viewZToLogarithmicDepth$1,
	viewZToOrthographicDepth: viewZToOrthographicDepth$1,
	viewZToPerspectiveDepth: viewZToPerspectiveDepth$1,
	viewport: viewport$1,
	viewportCoordinate: viewportCoordinate$1,
	viewportDepthTexture: viewportDepthTexture$1,
	viewportLinearDepth: viewportLinearDepth$1,
	viewportMipTexture: viewportMipTexture$1,
	viewportResolution: viewportResolution$1,
	viewportSafeUV: viewportSafeUV$1,
	viewportSharedTexture: viewportSharedTexture$1,
	viewportSize: viewportSize$1,
	viewportTexture: viewportTexture$1,
	viewportUV: viewportUV$1,
	wgsl: wgsl$1,
	wgslFn: wgslFn$1,
	workgroupArray: workgroupArray$1,
	workgroupBarrier: workgroupBarrier$1,
	workgroupId: workgroupId$1,
	workingToColorSpace: workingToColorSpace$1,
	xor: xor$1
});
var _clearColor$3 = /* @__PURE__ */ new Color4();
/**
* This renderer module manages the background.
*
* @private
* @augments DataMap
*/
var Background = class extends DataMap {
	/**
	* Constructs a new background management component.
	*
	* @param {Renderer} renderer - The renderer.
	* @param {Nodes} nodes - Renderer component for managing nodes related logic.
	*/
	constructor(renderer, nodes) {
		super();
		/**
		* The renderer.
		*
		* @type {Renderer}
		*/
		this.renderer = renderer;
		/**
		* Renderer component for managing nodes related logic.
		*
		* @type {Nodes}
		*/
		this.nodes = nodes;
	}
	/**
	* Updates the background for the given scene. Depending on how `Scene.background`
	* or `Scene.backgroundNode` are configured, this method might configure a simple clear
	* or add a mesh to the render list for rendering the background as a textured plane
	* or skybox.
	*
	* @param {Scene} scene - The scene.
	* @param {RenderList} renderList - The current render list.
	* @param {RenderContext} renderContext - The current render context.
	*/
	update(scene, renderList, renderContext) {
		const renderer = this.renderer;
		const background = this.nodes.getBackgroundNode(scene) || scene.background;
		let forceClear = false;
		if (background === null) {
			renderer._clearColor.getRGB(_clearColor$3);
			_clearColor$3.a = renderer._clearColor.a;
		} else if (background.isColor === true) {
			background.getRGB(_clearColor$3);
			_clearColor$3.a = 1;
			forceClear = true;
		} else if (background.isNode === true) {
			const sceneData = this.get(scene);
			const backgroundNode = background;
			_clearColor$3.copy(renderer._clearColor);
			let backgroundMesh = sceneData.backgroundMesh;
			if (backgroundMesh === void 0) {
				const backgroundMeshNode = context$1(vec4$1(backgroundNode).mul(backgroundIntensity$1), {
					getUV: () => backgroundRotation$1.mul(normalWorldGeometry$1),
					getTextureLevel: () => backgroundBlurriness$1
				});
				let viewProj = modelViewProjection$1;
				viewProj = viewProj.setZ(viewProj.w);
				const nodeMaterial = new NodeMaterial();
				nodeMaterial.name = "Background.material";
				nodeMaterial.side = BackSide;
				nodeMaterial.depthTest = false;
				nodeMaterial.depthWrite = false;
				nodeMaterial.allowOverride = false;
				nodeMaterial.fog = false;
				nodeMaterial.lights = false;
				nodeMaterial.vertexNode = viewProj;
				nodeMaterial.colorNode = backgroundMeshNode;
				sceneData.backgroundMeshNode = backgroundMeshNode;
				sceneData.backgroundMesh = backgroundMesh = new Mesh(new SphereGeometry(1, 32, 32), nodeMaterial);
				backgroundMesh.frustumCulled = false;
				backgroundMesh.name = "Background.mesh";
				backgroundMesh.onBeforeRender = function(renderer$1, scene$1, camera) {
					this.matrixWorld.copyPosition(camera.matrixWorld);
				};
				function onBackgroundDispose() {
					background.removeEventListener("dispose", onBackgroundDispose);
					backgroundMesh.material.dispose();
					backgroundMesh.geometry.dispose();
				}
				background.addEventListener("dispose", onBackgroundDispose);
			}
			const backgroundCacheKey = backgroundNode.getCacheKey();
			if (sceneData.backgroundCacheKey !== backgroundCacheKey) {
				sceneData.backgroundMeshNode.node = vec4$1(backgroundNode).mul(backgroundIntensity$1);
				sceneData.backgroundMeshNode.needsUpdate = true;
				backgroundMesh.material.needsUpdate = true;
				sceneData.backgroundCacheKey = backgroundCacheKey;
			}
			renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null);
		} else error("Renderer: Unsupported background configuration.", background);
		const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
		if (environmentBlendMode === "additive") _clearColor$3.set(0, 0, 0, 1);
		else if (environmentBlendMode === "alpha-blend") _clearColor$3.set(0, 0, 0, 0);
		if (renderer.autoClear === true || forceClear === true) {
			const clearColorValue = renderContext.clearColorValue;
			clearColorValue.r = _clearColor$3.r;
			clearColorValue.g = _clearColor$3.g;
			clearColorValue.b = _clearColor$3.b;
			clearColorValue.a = _clearColor$3.a;
			if (renderer.backend.isWebGLBackend === true || renderer.alpha === true) {
				clearColorValue.r *= clearColorValue.a;
				clearColorValue.g *= clearColorValue.a;
				clearColorValue.b *= clearColorValue.a;
			}
			renderContext.depthClearValue = renderer._clearDepth;
			renderContext.stencilClearValue = renderer._clearStencil;
			renderContext.clearColor = renderer.autoClearColor === true;
			renderContext.clearDepth = renderer.autoClearDepth === true;
			renderContext.clearStencil = renderer.autoClearStencil === true;
		} else {
			renderContext.clearColor = false;
			renderContext.clearDepth = false;
			renderContext.clearStencil = false;
		}
	}
};
var _id$7 = 0;
/**
* A bind group represents a collection of bindings and thus a collection
* or resources. Bind groups are assigned to pipelines to provide them
* with the required resources (like uniform buffers or textures).
*
* @private
*/
var BindGroup = class {
	/**
	* Constructs a new bind group.
	*
	* @param {string} name - The bind group's name.
	* @param {Array<Binding>} bindings - An array of bindings.
	* @param {number} index - The group index.
	* @param {Array<Binding>} bindingsReference - An array of reference bindings.
	*/
	constructor(name = "", bindings = [], index = 0, bindingsReference = []) {
		/**
		* The bind group's name.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* An array of bindings.
		*
		* @type {Array<Binding>}
		*/
		this.bindings = bindings;
		/**
		* The group index.
		*
		* @type {number}
		*/
		this.index = index;
		/**
		* An array of reference bindings.
		*
		* @type {Array<Binding>}
		*/
		this.bindingsReference = bindingsReference;
		/**
		* The group's ID.
		*
		* @type {number}
		*/
		this.id = _id$7++;
	}
};
/**
* This module represents the state of a node builder after it was
* used to build the nodes for a render object. The state holds the
* results of the build for further processing in the renderer.
*
* Render objects with identical cache keys share the same node builder state.
*
* @private
*/
var NodeBuilderState = class {
	/**
	* Constructs a new node builder state.
	*
	* @param {string} vertexShader - The native vertex shader code.
	* @param {string} fragmentShader - The native fragment shader code.
	* @param {string} computeShader - The native compute shader code.
	* @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.
	* @param {Array<BindGroup>} bindings - An array of bind groups.
	* @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.
	* @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.
	* @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.
	* @param {NodeMaterialObserver} observer - A node material observer.
	* @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
	*/
	constructor(vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, observer, transforms = []) {
		/**
		* The native vertex shader code.
		*
		* @type {string}
		*/
		this.vertexShader = vertexShader;
		/**
		* The native fragment shader code.
		*
		* @type {string}
		*/
		this.fragmentShader = fragmentShader;
		/**
		* The native compute shader code.
		*
		* @type {string}
		*/
		this.computeShader = computeShader;
		/**
		* An array with transform attribute objects.
		* Only relevant when using compute shaders with WebGL 2.
		*
		* @type {Array<Object>}
		*/
		this.transforms = transforms;
		/**
		* An array of node attributes representing
		* the attributes of the shaders.
		*
		* @type {Array<NodeAttribute>}
		*/
		this.nodeAttributes = nodeAttributes;
		/**
		* An array of bind groups representing the uniform or storage
		* buffers, texture or samplers of the shader.
		*
		* @type {Array<BindGroup>}
		*/
		this.bindings = bindings;
		/**
		* An array of nodes that implement their `update()` method.
		*
		* @type {Array<Node>}
		*/
		this.updateNodes = updateNodes;
		/**
		* An array of nodes that implement their `updateBefore()` method.
		*
		* @type {Array<Node>}
		*/
		this.updateBeforeNodes = updateBeforeNodes;
		/**
		* An array of nodes that implement their `updateAfter()` method.
		*
		* @type {Array<Node>}
		*/
		this.updateAfterNodes = updateAfterNodes;
		/**
		* A node material observer.
		*
		* @type {NodeMaterialObserver}
		*/
		this.observer = observer;
		/**
		* How often this state is used by render objects.
		*
		* @type {number}
		*/
		this.usedTimes = 0;
	}
	/**
	* This method is used to create a array of bind groups based
	* on the existing bind groups of this state. Shared groups are
	* not cloned.
	*
	* @return {Array<BindGroup>} A array of bind groups.
	*/
	createBindings() {
		const bindings = [];
		for (const instanceGroup of this.bindings) if (instanceGroup.bindings[0].groupNode.shared !== true) {
			const bindingsGroup = new BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup.bindingsReference);
			bindings.push(bindingsGroup);
			for (const instanceBinding of instanceGroup.bindings) bindingsGroup.bindings.push(instanceBinding.clone());
		} else bindings.push(instanceGroup);
		return bindings;
	}
};
/**
* {@link NodeBuilder} is going to create instances of this class during the build process
* of nodes. They represent the final shader attributes that are going to be generated
* by the builder. Arrays of node attributes is maintained in {@link NodeBuilder#attributes}
* and {@link NodeBuilder#bufferAttributes} for this purpose.
*/
var NodeAttribute = class {
	/**
	* Constructs a new node attribute.
	*
	* @param {string} name - The name of the attribute.
	* @param {string} type - The type of the attribute.
	* @param {?Node} node - An optional reference to the node.
	*/
	constructor(name, type$1, node = null) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isNodeAttribute = true;
		/**
		* The name of the attribute.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* The type of the attribute.
		*
		* @type {string}
		*/
		this.type = type$1;
		/**
		* An optional reference to the node.
		*
		* @type {?Node}
		* @default null
		*/
		this.node = node;
	}
};
/**
* {@link NodeBuilder} is going to create instances of this class during the build process
* of nodes. They represent the final shader uniforms that are going to be generated
* by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}
* for this purpose.
*/
var NodeUniform = class {
	/**
	* Constructs a new node uniform.
	*
	* @param {string} name - The name of the uniform.
	* @param {string} type - The type of the uniform.
	* @param {UniformNode} node - An reference to the node.
	*/
	constructor(name, type$1, node) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isNodeUniform = true;
		/**
		* The name of the uniform.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* The type of the uniform.
		*
		* @type {string}
		*/
		this.type = type$1;
		/**
		* An reference to the node.
		*
		* @type {UniformNode}
		*/
		this.node = node;
	}
	/**
	* The value of the uniform node.
	*
	* @type {any}
	*/
	get value() {
		return this.node.value;
	}
	set value(val) {
		this.node.value = val;
	}
	/**
	* The id of the uniform node.
	*
	* @type {number}
	*/
	get id() {
		return this.node.id;
	}
	/**
	* The uniform node's group.
	*
	* @type {UniformGroupNode}
	*/
	get groupNode() {
		return this.node.groupNode;
	}
};
/**
* {@link NodeBuilder} is going to create instances of this class during the build process
* of nodes. They represent the final shader variables that are going to be generated
* by the builder. A dictionary of node variables is maintained in {@link NodeBuilder#vars} for
* this purpose.
*/
var NodeVar = class {
	/**
	* Constructs a new node variable.
	*
	* @param {string} name - The name of the variable.
	* @param {string} type - The type of the variable.
	* @param {boolean} [readOnly=false] - The read-only flag.
	* @param {?number} [count=null] - The size.
	*/
	constructor(name, type$1, readOnly = false, count = null) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isNodeVar = true;
		/**
		* The name of the variable.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* The type of the variable.
		*
		* @type {string}
		*/
		this.type = type$1;
		/**
		*  The read-only flag.
		*
		* @type {boolean}
		*/
		this.readOnly = readOnly;
		/**
		* The size.
		*
		* @type {?number}
		*/
		this.count = count;
	}
};
/**
* {@link NodeBuilder} is going to create instances of this class during the build process
* of nodes. They represent the final shader varyings that are going to be generated
* by the builder. An array of node varyings is maintained in {@link NodeBuilder#varyings} for
* this purpose.
*
* @augments NodeVar
*/
var NodeVarying = class extends NodeVar {
	/**
	* Constructs a new node varying.
	*
	* @param {string} name - The name of the varying.
	* @param {string} type - The type of the varying.
	* @param {?string} interpolationType - The interpolation type of the varying.
	* @param {?string} interpolationSampling - The interpolation sampling type of the varying.
	*/
	constructor(name, type$1, interpolationType = null, interpolationSampling = null) {
		super(name, type$1);
		/**
		* Whether this varying requires interpolation or not. This property can be used
		* to check if the varying can be optimized for a variable.
		*
		* @type {boolean}
		* @default false
		*/
		this.needsInterpolation = false;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isNodeVarying = true;
		/**
		* The interpolation type of the varying data.
		*
		* @type {?string}
		* @default null
		*/
		this.interpolationType = interpolationType;
		/**
		* The interpolation sampling type of varying data.
		*
		* @type {?string}
		* @default null
		*/
		this.interpolationSampling = interpolationSampling;
	}
};
/**
* {@link NodeBuilder} is going to create instances of this class during the build process
* of nodes. They represent user-defined, native shader code portions that are going to be
* injected by the builder. A dictionary of node codes is maintained in {@link NodeBuilder#codes}
* for this purpose.
*/
var NodeCode = class {
	/**
	* Constructs a new code node.
	*
	* @param {string} name - The name of the code.
	* @param {string} type - The node type.
	* @param {string} [code=''] - The native shader code.
	*/
	constructor(name, type$1, code$2 = "") {
		/**
		* The name of the code.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* The node type.
		*
		* @type {string}
		*/
		this.type = type$1;
		/**
		* The native shader code.
		*
		* @type {string}
		* @default ''
		*/
		this.code = code$2;
		Object.defineProperty(this, "isNodeCode", { value: true });
	}
};
var _id$6 = 0;
/**
* This utility class is used in {@link NodeBuilder} as an internal
* cache data structure for node data.
*/
var NodeCache = class {
	/**
	* Constructs a new node cache.
	*
	* @param {?NodeCache} parent - A reference to a parent cache.
	*/
	constructor(parent = null) {
		/**
		* The id of the cache.
		*
		* @type {number}
		* @readonly
		*/
		this.id = _id$6++;
		/**
		* A weak map for managing node data.
		*
		* @type {WeakMap<Node, Object>}
		*/
		this.nodesData = /* @__PURE__ */ new WeakMap();
		/**
		* Reference to a parent node cache.
		*
		* @type {?NodeCache}
		* @default null
		*/
		this.parent = parent;
	}
	/**
	* Returns the data for the given node.
	*
	* @param {Node} node - The node.
	* @return {?Object} The data for the node.
	*/
	getData(node) {
		let data = this.nodesData.get(node);
		if (data === void 0 && this.parent !== null) data = this.parent.getData(node);
		return data;
	}
	/**
	* Sets the data for a given node.
	*
	* @param {Node} node - The node.
	* @param {Object} data - The data that should be cached.
	*/
	setData(node, data) {
		this.nodesData.set(node, data);
	}
};
var StructType = class {
	constructor(name, members) {
		this.name = name;
		this.members = members;
		this.output = false;
	}
};
/**
* Abstract base class for uniforms.
*
* @abstract
* @private
*/
var Uniform$1 = class {
	/**
	* Constructs a new uniform.
	*
	* @param {string} name - The uniform's name.
	* @param {any} value - The uniform's value.
	*/
	constructor(name, value) {
		/**
		* The uniform's name.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* The uniform's value.
		*
		* @type {any}
		*/
		this.value = value;
		/**
		* Used to build the uniform buffer according to the STD140 layout.
		* Derived uniforms will set this property to a data type specific
		* value.
		*
		* @type {number}
		*/
		this.boundary = 0;
		/**
		* The item size. Derived uniforms will set this property to a data
		* type specific value.
		*
		* @type {number}
		*/
		this.itemSize = 0;
		/**
		* This property is set by {@link UniformsGroup} and marks
		* the start position in the uniform buffer.
		*
		* @type {number}
		*/
		this.offset = 0;
	}
	/**
	* Sets the uniform's value.
	*
	* @param {any} value - The value to set.
	*/
	setValue(value) {
		this.value = value;
	}
	/**
	* Returns the uniform's value.
	*
	* @return {any} The value.
	*/
	getValue() {
		return this.value;
	}
};
/**
* Represents a Number uniform.
*
* @private
* @augments Uniform
*/
var NumberUniform = class extends Uniform$1 {
	/**
	* Constructs a new Number uniform.
	*
	* @param {string} name - The uniform's name.
	* @param {number} value - The uniform's value.
	*/
	constructor(name, value = 0) {
		super(name, value);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isNumberUniform = true;
		this.boundary = 4;
		this.itemSize = 1;
	}
};
/**
* Represents a Vector2 uniform.
*
* @private
* @augments Uniform
*/
var Vector2Uniform = class extends Uniform$1 {
	/**
	* Constructs a new Number uniform.
	*
	* @param {string} name - The uniform's name.
	* @param {Vector2} value - The uniform's value.
	*/
	constructor(name, value = new Vector2()) {
		super(name, value);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isVector2Uniform = true;
		this.boundary = 8;
		this.itemSize = 2;
	}
};
/**
* Represents a Vector3 uniform.
*
* @private
* @augments Uniform
*/
var Vector3Uniform = class extends Uniform$1 {
	/**
	* Constructs a new Number uniform.
	*
	* @param {string} name - The uniform's name.
	* @param {Vector3} value - The uniform's value.
	*/
	constructor(name, value = new Vector3()) {
		super(name, value);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isVector3Uniform = true;
		this.boundary = 16;
		this.itemSize = 3;
	}
};
/**
* Represents a Vector4 uniform.
*
* @private
* @augments Uniform
*/
var Vector4Uniform = class extends Uniform$1 {
	/**
	* Constructs a new Number uniform.
	*
	* @param {string} name - The uniform's name.
	* @param {Vector4} value - The uniform's value.
	*/
	constructor(name, value = new Vector4()) {
		super(name, value);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isVector4Uniform = true;
		this.boundary = 16;
		this.itemSize = 4;
	}
};
/**
* Represents a Color uniform.
*
* @private
* @augments Uniform
*/
var ColorUniform = class extends Uniform$1 {
	/**
	* Constructs a new Number uniform.
	*
	* @param {string} name - The uniform's name.
	* @param {Color} value - The uniform's value.
	*/
	constructor(name, value = new Color$1()) {
		super(name, value);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isColorUniform = true;
		this.boundary = 16;
		this.itemSize = 3;
	}
};
/**
* Represents a Matrix2 uniform.
*
* @private
* @augments Uniform
*/
var Matrix2Uniform = class extends Uniform$1 {
	/**
	* Constructs a new Number uniform.
	*
	* @param {string} name - The uniform's name.
	* @param {Matrix2} value - The uniform's value.
	*/
	constructor(name, value = new Matrix2()) {
		super(name, value);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMatrix2Uniform = true;
		this.boundary = 8;
		this.itemSize = 4;
	}
};
/**
* Represents a Matrix3 uniform.
*
* @private
* @augments Uniform
*/
var Matrix3Uniform = class extends Uniform$1 {
	/**
	* Constructs a new Number uniform.
	*
	* @param {string} name - The uniform's name.
	* @param {Matrix3} value - The uniform's value.
	*/
	constructor(name, value = new Matrix3()) {
		super(name, value);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMatrix3Uniform = true;
		this.boundary = 48;
		this.itemSize = 12;
	}
};
/**
* Represents a Matrix4 uniform.
*
* @private
* @augments Uniform
*/
var Matrix4Uniform = class extends Uniform$1 {
	/**
	* Constructs a new Number uniform.
	*
	* @param {string} name - The uniform's name.
	* @param {Matrix4} value - The uniform's value.
	*/
	constructor(name, value = new Matrix4()) {
		super(name, value);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isMatrix4Uniform = true;
		this.boundary = 64;
		this.itemSize = 16;
	}
};
/**
* A special form of Number uniform binding type.
* It's value is managed by a node object.
*
* @private
* @augments NumberUniform
*/
var NumberNodeUniform = class extends NumberUniform {
	/**
	* Constructs a new node-based Number uniform.
	*
	* @param {NodeUniform} nodeUniform - The node uniform.
	*/
	constructor(nodeUniform) {
		super(nodeUniform.name, nodeUniform.value);
		/**
		* The node uniform.
		*
		* @type {NodeUniform}
		*/
		this.nodeUniform = nodeUniform;
	}
	/**
	* Overwritten to return the value of the node uniform.
	*
	* @return {number} The value.
	*/
	getValue() {
		return this.nodeUniform.value;
	}
	/**
	* Returns the node uniform data type.
	*
	* @return {string} The data type.
	*/
	getType() {
		return this.nodeUniform.type;
	}
};
/**
* A special form of Vector2 uniform binding type.
* It's value is managed by a node object.
*
* @private
* @augments Vector2Uniform
*/
var Vector2NodeUniform = class extends Vector2Uniform {
	/**
	* Constructs a new node-based Vector2 uniform.
	*
	* @param {NodeUniform} nodeUniform - The node uniform.
	*/
	constructor(nodeUniform) {
		super(nodeUniform.name, nodeUniform.value);
		/**
		* The node uniform.
		*
		* @type {NodeUniform}
		*/
		this.nodeUniform = nodeUniform;
	}
	/**
	* Overwritten to return the value of the node uniform.
	*
	* @return {Vector2} The value.
	*/
	getValue() {
		return this.nodeUniform.value;
	}
	/**
	* Returns the node uniform data type.
	*
	* @return {string} The data type.
	*/
	getType() {
		return this.nodeUniform.type;
	}
};
/**
* A special form of Vector3 uniform binding type.
* It's value is managed by a node object.
*
* @private
* @augments Vector3Uniform
*/
var Vector3NodeUniform = class extends Vector3Uniform {
	/**
	* Constructs a new node-based Vector3 uniform.
	*
	* @param {NodeUniform} nodeUniform - The node uniform.
	*/
	constructor(nodeUniform) {
		super(nodeUniform.name, nodeUniform.value);
		/**
		* The node uniform.
		*
		* @type {NodeUniform}
		*/
		this.nodeUniform = nodeUniform;
	}
	/**
	* Overwritten to return the value of the node uniform.
	*
	* @return {Vector3} The value.
	*/
	getValue() {
		return this.nodeUniform.value;
	}
	/**
	* Returns the node uniform data type.
	*
	* @return {string} The data type.
	*/
	getType() {
		return this.nodeUniform.type;
	}
};
/**
* A special form of Vector4 uniform binding type.
* It's value is managed by a node object.
*
* @private
* @augments Vector4Uniform
*/
var Vector4NodeUniform = class extends Vector4Uniform {
	/**
	* Constructs a new node-based Vector4 uniform.
	*
	* @param {NodeUniform} nodeUniform - The node uniform.
	*/
	constructor(nodeUniform) {
		super(nodeUniform.name, nodeUniform.value);
		/**
		* The node uniform.
		*
		* @type {NodeUniform}
		*/
		this.nodeUniform = nodeUniform;
	}
	/**
	* Overwritten to return the value of the node uniform.
	*
	* @return {Vector4} The value.
	*/
	getValue() {
		return this.nodeUniform.value;
	}
	/**
	* Returns the node uniform data type.
	*
	* @return {string} The data type.
	*/
	getType() {
		return this.nodeUniform.type;
	}
};
/**
* A special form of Color uniform binding type.
* It's value is managed by a node object.
*
* @private
* @augments ColorUniform
*/
var ColorNodeUniform = class extends ColorUniform {
	/**
	* Constructs a new node-based Color uniform.
	*
	* @param {NodeUniform} nodeUniform - The node uniform.
	*/
	constructor(nodeUniform) {
		super(nodeUniform.name, nodeUniform.value);
		/**
		* The node uniform.
		*
		* @type {NodeUniform}
		*/
		this.nodeUniform = nodeUniform;
	}
	/**
	* Overwritten to return the value of the node uniform.
	*
	* @return {Color} The value.
	*/
	getValue() {
		return this.nodeUniform.value;
	}
	/**
	* Returns the node uniform data type.
	*
	* @return {string} The data type.
	*/
	getType() {
		return this.nodeUniform.type;
	}
};
/**
* A special form of Matrix2 uniform binding type.
* It's value is managed by a node object.
*
* @private
* @augments Matrix2Uniform
*/
var Matrix2NodeUniform = class extends Matrix2Uniform {
	/**
	* Constructs a new node-based Matrix2 uniform.
	*
	* @param {NodeUniform} nodeUniform - The node uniform.
	*/
	constructor(nodeUniform) {
		super(nodeUniform.name, nodeUniform.value);
		/**
		* The node uniform.
		*
		* @type {NodeUniform}
		*/
		this.nodeUniform = nodeUniform;
	}
	/**
	* Overwritten to return the value of the node uniform.
	*
	* @return {Matrix2} The value.
	*/
	getValue() {
		return this.nodeUniform.value;
	}
	/**
	* Returns the node uniform data type.
	*
	* @return {string} The data type.
	*/
	getType() {
		return this.nodeUniform.type;
	}
};
/**
* A special form of Matrix3 uniform binding type.
* It's value is managed by a node object.
*
* @private
* @augments Matrix3Uniform
*/
var Matrix3NodeUniform = class extends Matrix3Uniform {
	/**
	* Constructs a new node-based Matrix3 uniform.
	*
	* @param {NodeUniform} nodeUniform - The node uniform.
	*/
	constructor(nodeUniform) {
		super(nodeUniform.name, nodeUniform.value);
		/**
		* The node uniform.
		*
		* @type {NodeUniform}
		*/
		this.nodeUniform = nodeUniform;
	}
	/**
	* Overwritten to return the value of the node uniform.
	*
	* @return {Matrix3} The value.
	*/
	getValue() {
		return this.nodeUniform.value;
	}
	/**
	* Returns the node uniform data type.
	*
	* @return {string} The data type.
	*/
	getType() {
		return this.nodeUniform.type;
	}
};
/**
* A special form of Matrix4 uniform binding type.
* It's value is managed by a node object.
*
* @private
* @augments Matrix4Uniform
*/
var Matrix4NodeUniform = class extends Matrix4Uniform {
	/**
	* Constructs a new node-based Matrix4 uniform.
	*
	* @param {NodeUniform} nodeUniform - The node uniform.
	*/
	constructor(nodeUniform) {
		super(nodeUniform.name, nodeUniform.value);
		/**
		* The node uniform.
		*
		* @type {NodeUniform}
		*/
		this.nodeUniform = nodeUniform;
	}
	/**
	* Overwritten to return the value of the node uniform.
	*
	* @return {Matrix4} The value.
	*/
	getValue() {
		return this.nodeUniform.value;
	}
	/**
	* Returns the node uniform data type.
	*
	* @return {string} The data type.
	*/
	getType() {
		return this.nodeUniform.type;
	}
};
var _id$5 = 0;
var rendererCache = /* @__PURE__ */ new WeakMap();
var typeFromArray = new Map([
	[Int8Array, "int"],
	[Int16Array, "int"],
	[Int32Array, "int"],
	[Uint8Array, "uint"],
	[Uint16Array, "uint"],
	[Uint32Array, "uint"],
	[Float32Array, "float"]
]);
var toFloat = (value) => {
	if (/e/g.test(value)) return String(value).replace(/\+/g, "");
	else {
		value = Number(value);
		return value + (value % 1 ? "" : ".0");
	}
};
/**
* Base class for builders which generate a shader program based
* on a 3D object and its node material definition.
*/
var NodeBuilder = class {
	/**
	* Constructs a new node builder.
	*
	* @param {Object3D} object - The 3D object.
	* @param {Renderer} renderer - The current renderer.
	* @param {NodeParser} parser - A reference to a node parser.
	*/
	constructor(object, renderer, parser) {
		/**
		* The 3D object.
		*
		* @type {Object3D}
		*/
		this.object = object;
		/**
		* The material of the 3D object.
		*
		* @type {?Material}
		*/
		this.material = object && object.material || null;
		/**
		* The geometry of the 3D object.
		*
		* @type {?BufferGeometry}
		*/
		this.geometry = object && object.geometry || null;
		/**
		* The current renderer.
		*
		* @type {Renderer}
		*/
		this.renderer = renderer;
		/**
		* A reference to a node parser.
		*
		* @type {NodeParser}
		*/
		this.parser = parser;
		/**
		* The scene the 3D object belongs to.
		*
		* @type {?Scene}
		* @default null
		*/
		this.scene = null;
		/**
		* The camera the 3D object is rendered with.
		*
		* @type {?Camera}
		* @default null
		*/
		this.camera = null;
		/**
		* A list of all nodes the builder is processing
		* for this 3D object.
		*
		* @type {Array<Node>}
		*/
		this.nodes = [];
		/**
		* A list of all sequential nodes.
		*
		* @type {Array<Node>}
		*/
		this.sequentialNodes = [];
		/**
		* A list of all nodes which {@link Node#update} method should be executed.
		*
		* @type {Array<Node>}
		*/
		this.updateNodes = [];
		/**
		* A list of all nodes which {@link Node#updateBefore} method should be executed.
		*
		* @type {Array<Node>}
		*/
		this.updateBeforeNodes = [];
		/**
		* A list of all nodes which {@link Node#updateAfter} method should be executed.
		*
		* @type {Array<Node>}
		*/
		this.updateAfterNodes = [];
		/**
		* A dictionary that assigns each node to a unique hash.
		*
		* @type {Object<number,Node>}
		*/
		this.hashNodes = {};
		/**
		* A reference to a node material observer.
		*
		* @type {?NodeMaterialObserver}
		* @default null
		*/
		this.observer = null;
		/**
		* A reference to the current lights node.
		*
		* @type {?LightsNode}
		* @default null
		*/
		this.lightsNode = null;
		/**
		* A reference to the current environment node.
		*
		* @type {?Node}
		* @default null
		*/
		this.environmentNode = null;
		/**
		* A reference to the current fog node.
		*
		* @type {?Node}
		* @default null
		*/
		this.fogNode = null;
		/**
		* The current clipping context.
		*
		* @type {?ClippingContext}
		*/
		this.clippingContext = null;
		/**
		* The generated vertex shader.
		*
		* @type {?string}
		*/
		this.vertexShader = null;
		/**
		* The generated fragment shader.
		*
		* @type {?string}
		*/
		this.fragmentShader = null;
		/**
		* The generated compute shader.
		*
		* @type {?string}
		*/
		this.computeShader = null;
		/**
		* Nodes used in the primary flow of code generation.
		*
		* @type {Object<string,Array<Node>>}
		*/
		this.flowNodes = {
			vertex: [],
			fragment: [],
			compute: []
		};
		/**
		* Nodes code from `.flowNodes`.
		*
		* @type {Object<string,string>}
		*/
		this.flowCode = {
			vertex: "",
			fragment: "",
			compute: ""
		};
		/**
		* This dictionary holds the node uniforms of the builder.
		* The uniforms are maintained in an array for each shader stage.
		*
		* @type {Object}
		*/
		this.uniforms = {
			vertex: [],
			fragment: [],
			compute: [],
			index: 0
		};
		/**
		* This dictionary holds the output structs of the builder.
		* The structs are maintained in an array for each shader stage.
		*
		* @type {Object}
		*/
		this.structs = {
			vertex: [],
			fragment: [],
			compute: [],
			index: 0
		};
		/**
		* This dictionary holds the types of the builder.
		*
		* @type {Object}
		*/
		this.types = {
			vertex: [],
			fragment: [],
			compute: [],
			index: 0
		};
		/**
		* This dictionary holds the bindings for each shader stage.
		*
		* @type {Object}
		*/
		this.bindings = {
			vertex: {},
			fragment: {},
			compute: {}
		};
		/**
		* This dictionary maintains the binding indices per bind group.
		*
		* @type {Object}
		*/
		this.bindingsIndexes = {};
		/**
		* Reference to the array of bind groups.
		*
		* @type {?Array<BindGroup>}
		*/
		this.bindGroups = null;
		/**
		* This array holds the node attributes of this builder
		* created via {@link AttributeNode}.
		*
		* @type {Array<NodeAttribute>}
		*/
		this.attributes = [];
		/**
		* This array holds the node attributes of this builder
		* created via {@link BufferAttributeNode}.
		*
		* @type {Array<NodeAttribute>}
		*/
		this.bufferAttributes = [];
		/**
		* This array holds the node varyings of this builder.
		*
		* @type {Array<NodeVarying>}
		*/
		this.varyings = [];
		/**
		* This dictionary holds the (native) node codes of this builder.
		* The codes are maintained in an array for each shader stage.
		*
		* @type {Object<string,Array<NodeCode>>}
		*/
		this.codes = {};
		/**
		* This dictionary holds the node variables of this builder.
		* The variables are maintained in an array for each shader stage.
		* This dictionary is also used to count the number of variables
		* according to their type (const, vars).
		*
		* @type {Object<string,Array<NodeVar>|number>}
		*/
		this.vars = {};
		/**
		* This dictionary holds the declarations for each shader stage.
		*
		* @type {Object}
		*/
		this.declarations = {};
		/**
		* Current code flow.
		* All code generated in this stack will be stored in `.flow`.
		*
		* @type {{code: string}}
		*/
		this.flow = { code: "" };
		/**
		* A chain of nodes.
		* Used to check recursive calls in node-graph.
		*
		* @type {Array<Node>}
		*/
		this.chaining = [];
		/**
		* The current stack.
		* This reflects the current process in the code block hierarchy,
		* it is useful to know if the current process is inside a conditional for example.
		*
		* @type {StackNode}
		*/
		this.stack = stack$1();
		/**
		* List of stack nodes.
		* The current stack hierarchy is stored in an array.
		*
		* @type {Array<StackNode>}
		*/
		this.stacks = [];
		/**
		* A tab value. Used for shader string generation.
		*
		* @type {string}
		* @default '\t'
		*/
		this.tab = "	";
		/**
		* Reference to the current function node.
		*
		* @type {?FunctionNode}
		* @default null
		*/
		this.currentFunctionNode = null;
		/**
		* The builder's context.
		*
		* @type {Object}
		*/
		this.context = { material: this.material };
		/**
		* The builder's cache.
		*
		* @type {NodeCache}
		*/
		this.cache = new NodeCache();
		/**
		* Since the {@link NodeBuilder#cache} might be temporarily
		* overwritten by other caches, this member retains the reference
		* to the builder's own cache.
		*
		* @type {NodeCache}
		* @default this.cache
		*/
		this.globalCache = this.cache;
		this.flowsData = /* @__PURE__ */ new WeakMap();
		/**
		* The current shader stage.
		*
		* @type {?('vertex'|'fragment'|'compute'|'any')}
		*/
		this.shaderStage = null;
		/**
		* The current build stage.
		*
		* @type {?('setup'|'analyze'|'generate')}
		*/
		this.buildStage = null;
		/**
		* The sub-build layers.
		*
		* @type {Array<SubBuildNode>}
		* @default []
		*/
		this.subBuildLayers = [];
		/**
		* The active stack nodes.
		*
		* @type {Array<StackNode>}
		*/
		this.activeStacks = [];
		/**
		* The current sub-build TSL function(Fn).
		*
		* @type {?string}
		* @default null
		*/
		this.subBuildFn = null;
		/**
		* The current TSL function(Fn) call node.
		*
		* @type {?Node}
		* @default null
		*/
		this.fnCall = null;
		Object.defineProperty(this, "id", { value: _id$5++ });
	}
	/**
	* Whether the material is opaque or not.
	*
	* @return {boolean} Whether the material is opaque or not.
	*/
	isOpaque() {
		const material = this.material;
		return material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false;
	}
	/**
	* Returns the bind groups of the current renderer.
	*
	* @return {ChainMap} The cache.
	*/
	getBindGroupsCache() {
		let bindGroupsCache = rendererCache.get(this.renderer);
		if (bindGroupsCache === void 0) {
			bindGroupsCache = new ChainMap();
			rendererCache.set(this.renderer, bindGroupsCache);
		}
		return bindGroupsCache;
	}
	/**
	* Factory method for creating an instance of {@link RenderTarget} with the given
	* dimensions and options.
	*
	* @param {number} width - The width of the render target.
	* @param {number} height - The height of the render target.
	* @param {Object} options - The options of the render target.
	* @return {RenderTarget} The render target.
	*/
	createRenderTarget(width, height, options) {
		return new RenderTarget(width, height, options);
	}
	/**
	* Factory method for creating an instance of {@link CubeRenderTarget} with the given
	* dimensions and options.
	*
	* @param {number} size - The size of the cube render target.
	* @param {Object} options - The options of the cube render target.
	* @return {CubeRenderTarget} The cube render target.
	*/
	createCubeRenderTarget(size, options) {
		return new CubeRenderTarget(size, options);
	}
	/**
	* Whether the given node is included in the internal array of nodes or not.
	*
	* @param {Node} node - The node to test.
	* @return {boolean} Whether the given node is included in the internal array of nodes or not.
	*/
	includes(node) {
		return this.nodes.includes(node);
	}
	/**
	* Returns the output struct name which is required by
	* {@link OutputStructNode}.
	*
	* @abstract
	* @return {string} The name of the output struct.
	*/
	getOutputStructName() {}
	/**
	* Returns a bind group for the given group name and binding.
	*
	* @private
	* @param {string} groupName - The group name.
	* @param {Array<NodeUniformsGroup>} bindings - List of bindings.
	* @return {BindGroup} The bind group
	*/
	_getBindGroup(groupName, bindings) {
		const bindGroupsCache = this.getBindGroupsCache();
		const bindingsArray = [];
		let sharedGroup = true;
		for (const binding of bindings) {
			bindingsArray.push(binding);
			sharedGroup = sharedGroup && binding.groupNode.shared !== true;
		}
		let bindGroup;
		if (sharedGroup) {
			bindGroup = bindGroupsCache.get(bindingsArray);
			if (bindGroup === void 0) {
				bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
				bindGroupsCache.set(bindingsArray, bindGroup);
			}
		} else bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
		return bindGroup;
	}
	/**
	* Returns an array of node uniform groups for the given group name and shader stage.
	*
	* @param {string} groupName - The group name.
	* @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	* @return {Array<NodeUniformsGroup>} The array of node uniform groups.
	*/
	getBindGroupArray(groupName, shaderStage) {
		const bindings = this.bindings[shaderStage];
		let bindGroup = bindings[groupName];
		if (bindGroup === void 0) {
			if (this.bindingsIndexes[groupName] === void 0) this.bindingsIndexes[groupName] = {
				binding: 0,
				group: Object.keys(this.bindingsIndexes).length
			};
			bindings[groupName] = bindGroup = [];
		}
		return bindGroup;
	}
	/**
	* Returns a list bindings of all shader stages separated by groups.
	*
	* @return {Array<BindGroup>} The list of bindings.
	*/
	getBindings() {
		let bindingsGroups = this.bindGroups;
		if (bindingsGroups === null) {
			const groups = {};
			const bindings = this.bindings;
			for (const shaderStage of shaderStages$1) for (const groupName in bindings[shaderStage]) {
				const uniforms = bindings[shaderStage][groupName];
				(groups[groupName] || (groups[groupName] = [])).push(...uniforms);
			}
			bindingsGroups = [];
			for (const groupName in groups) {
				const group = groups[groupName];
				const bindingsGroup = this._getBindGroup(groupName, group);
				bindingsGroups.push(bindingsGroup);
			}
			this.bindGroups = bindingsGroups;
		}
		return bindingsGroups;
	}
	/**
	* Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.
	*/
	sortBindingGroups() {
		const bindingsGroups = this.getBindings();
		bindingsGroups.sort((a$1, b$2) => a$1.bindings[0].groupNode.order - b$2.bindings[0].groupNode.order);
		for (let i = 0; i < bindingsGroups.length; i++) {
			const bindingGroup = bindingsGroups[i];
			this.bindingsIndexes[bindingGroup.name].group = i;
			bindingGroup.index = i;
		}
	}
	/**
	* The builder maintains each node in a hash-based dictionary.
	* This method sets the given node (value) with the given hash (key) into this dictionary.
	*
	* @param {Node} node - The node to add.
	* @param {number} hash - The hash of the node.
	*/
	setHashNode(node, hash$3) {
		this.hashNodes[hash$3] = node;
	}
	/**
	* Adds a node to this builder.
	*
	* @param {Node} node - The node to add.
	*/
	addNode(node) {
		if (this.nodes.includes(node) === false) {
			this.nodes.push(node);
			this.setHashNode(node, node.getHash(this));
		}
	}
	/**
	* It is used to add Nodes that will be used as FRAME and RENDER events,
	* and need to follow a certain sequence in the calls to work correctly.
	* This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.
	*
	* @param {Node} node - The node to add.
	*/
	addSequentialNode(node) {
		if (this.sequentialNodes.includes(node) === false) this.sequentialNodes.push(node);
	}
	/**
	* Checks the update types of nodes
	*/
	buildUpdateNodes() {
		for (const node of this.nodes) if (node.getUpdateType() !== NodeUpdateType$1.NONE) this.updateNodes.push(node);
		for (const node of this.sequentialNodes) {
			const updateBeforeType = node.getUpdateBeforeType();
			const updateAfterType = node.getUpdateAfterType();
			if (updateBeforeType !== NodeUpdateType$1.NONE) this.updateBeforeNodes.push(node);
			if (updateAfterType !== NodeUpdateType$1.NONE) this.updateAfterNodes.push(node);
		}
	}
	/**
	* A reference the current node which is the
	* last node in the chain of nodes.
	*
	* @type {Node}
	*/
	get currentNode() {
		return this.chaining[this.chaining.length - 1];
	}
	/**
	* Whether the given texture is filtered or not.
	*
	* @param {Texture} texture - The texture to check.
	* @return {boolean} Whether the given texture is filtered or not.
	*/
	isFilteredTexture(texture$2) {
		return texture$2.magFilter === LinearFilter || texture$2.magFilter === LinearMipmapNearestFilter || texture$2.magFilter === NearestMipmapLinearFilter || texture$2.magFilter === LinearMipmapLinearFilter || texture$2.minFilter === LinearFilter || texture$2.minFilter === LinearMipmapNearestFilter || texture$2.minFilter === NearestMipmapLinearFilter || texture$2.minFilter === LinearMipmapLinearFilter;
	}
	/**
	* Adds the given node to the internal node chain.
	* This is used to check recursive calls in node-graph.
	*
	* @param {Node} node - The node to add.
	*/
	addChain(node) {
		this.chaining.push(node);
	}
	/**
	* Removes the given node from the internal node chain.
	*
	* @param {Node} node - The node to remove.
	*/
	removeChain(node) {
		if (this.chaining.pop() !== node) throw new Error("NodeBuilder: Invalid node chaining!");
	}
	/**
	* Returns the native shader method name for a given generic name. E.g.
	* the method name `textureDimensions` matches the WGSL name but must be
	* resolved to `textureSize` in GLSL.
	*
	* @abstract
	* @param {string} method - The method name to resolve.
	* @return {string} The resolved method name.
	*/
	getMethod(method) {
		return method;
	}
	/**
	* Returns the native snippet for a ternary operation. E.g. GLSL would output
	* a ternary op as `cond ? x : y` whereas WGSL would output it as `select(y, x, cond)`
	*
	* @abstract
	* @param {string} condSnippet - The condition determining which expression gets resolved.
	* @param {string} ifSnippet - The expression to resolve to if the condition is true.
	* @param {string} elseSnippet - The expression to resolve to if the condition is false.
	* @return {string} The resolved method name.
	*/
	getTernary() {
		return null;
	}
	/**
	* Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.
	*
	* @param {number} hash - The hash of the node.
	* @return {Node} The found node.
	*/
	getNodeFromHash(hash$3) {
		return this.hashNodes[hash$3];
	}
	/**
	* Adds the Node to a target flow so that it can generate code in the 'generate' process.
	*
	* @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.
	* @param {Node} node - The node to add.
	* @return {Node} The node.
	*/
	addFlow(shaderStage, node) {
		this.flowNodes[shaderStage].push(node);
		return node;
	}
	/**
	* Sets builder's context.
	*
	* @param {Object} context - The context to set.
	*/
	setContext(context$2) {
		this.context = context$2;
	}
	/**
	* Returns the builder's current context.
	*
	* @return {Object} The builder's current context.
	*/
	getContext() {
		return this.context;
	}
	/**
	* Adds context data to the builder's current context.
	*
	* @param {Object} context - The context to add.
	* @return {Object} The previous context.
	*/
	addContext(context$2) {
		const previousContext = this.getContext();
		this.setContext({
			...this.context,
			...context$2
		});
		return previousContext;
	}
	/**
	* Gets a context used in shader construction that can be shared across different materials.
	* This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.
	*
	* @return {Object} The builder's current context without material.
	*/
	getSharedContext() {
		({ ...this.context });
		return this.context;
	}
	/**
	* Sets builder's cache.
	*
	* @param {NodeCache} cache - The cache to set.
	*/
	setCache(cache$2) {
		this.cache = cache$2;
	}
	/**
	* Returns the builder's current cache.
	*
	* @return {NodeCache} The builder's current cache.
	*/
	getCache() {
		return this.cache;
	}
	/**
	* Returns a cache for the given node.
	*
	* @param {Node} node - The node.
	* @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
	* @return {NodeCache} The cache.
	*/
	getCacheFromNode(node, parent = true) {
		const data = this.getDataFromNode(node);
		if (data.cache === void 0) data.cache = new NodeCache(parent ? this.getCache() : null);
		return data.cache;
	}
	/**
	* Whether the requested feature is available or not.
	*
	* @abstract
	* @param {string} name - The requested feature.
	* @return {boolean} Whether the requested feature is supported or not.
	*/
	isAvailable() {
		return false;
	}
	/**
	* Returns the vertexIndex input variable as a native shader string.
	*
	* @abstract
	* @return {string} The instanceIndex shader string.
	*/
	getVertexIndex() {
		warn("Abstract function.");
	}
	/**
	* Contextually returns either the vertex stage instance index builtin
	* or the linearized index of an compute invocation within a grid of workgroups.
	*
	* @abstract
	* @return {string} The instanceIndex shader string.
	*/
	getInstanceIndex() {
		warn("Abstract function.");
	}
	/**
	* Returns the drawIndex input variable as a native shader string.
	* Only relevant for WebGL and its `WEBGL_multi_draw` extension.
	*
	* @abstract
	* @return {?string} The drawIndex shader string.
	*/
	getDrawIndex() {
		warn("Abstract function.");
	}
	/**
	* Returns the frontFacing input variable as a native shader string.
	*
	* @abstract
	* @return {string} The frontFacing shader string.
	*/
	getFrontFacing() {
		warn("Abstract function.");
	}
	/**
	* Returns the fragCoord input variable as a native shader string.
	*
	* @abstract
	* @return {string} The fragCoord shader string.
	*/
	getFragCoord() {
		warn("Abstract function.");
	}
	/**
	* Whether to flip texture data along its vertical axis or not. WebGL needs
	* this method evaluate to `true`, WebGPU to `false`.
	*
	* @abstract
	* @return {boolean} Whether to flip texture data along its vertical axis or not.
	*/
	isFlipY() {
		return false;
	}
	/**
	* Calling this method increases the usage count for the given node by one.
	*
	* @param {Node} node - The node to increase the usage count for.
	* @return {number} The updated usage count.
	*/
	increaseUsage(node) {
		const nodeData = this.getDataFromNode(node);
		nodeData.usageCount = nodeData.usageCount === void 0 ? 1 : nodeData.usageCount + 1;
		return nodeData.usageCount;
	}
	/**
	* Generates a texture sample shader string for the given texture data.
	*
	* @abstract
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The texture property name.
	* @param {string} uvSnippet - Snippet defining the texture coordinates.
	* @return {string} The generated shader string.
	*/
	generateTexture() {
		warn("Abstract function.");
	}
	/**
	* Generates a texture LOD shader string for the given texture data.
	*
	* @abstract
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The texture property name.
	* @param {string} uvSnippet - Snippet defining the texture coordinates.
	* @param {?string} depthSnippet - Snippet defining the 0-based texture array index to sample.
	* @param {string} levelSnippet - Snippet defining the mip level.
	* @return {string} The generated shader string.
	*/
	generateTextureLod() {
		warn("Abstract function.");
	}
	/**
	* Generates the array declaration string.
	*
	* @param {string} type - The type.
	* @param {?number} [count] - The count.
	* @return {string} The generated value as a shader string.
	*/
	generateArrayDeclaration(type$1, count) {
		return this.getType(type$1) + "[ " + count + " ]";
	}
	/**
	* Generates the array shader string for the given type and value.
	*
	* @param {string} type - The type.
	* @param {?number} [count] - The count.
	* @param {?Array<Node>} [values=null] - The default values.
	* @return {string} The generated value as a shader string.
	*/
	generateArray(type$1, count, values = null) {
		let snippet = this.generateArrayDeclaration(type$1, count) + "( ";
		for (let i = 0; i < count; i++) {
			const value = values ? values[i] : null;
			if (value !== null) snippet += value.build(this, type$1);
			else snippet += this.generateConst(type$1);
			if (i < count - 1) snippet += ", ";
		}
		snippet += " )";
		return snippet;
	}
	/**
	* Generates the struct shader string.
	*
	* @param {string} type - The type.
	* @param {Array<Object>} [membersLayout] - The count.
	* @param {?Array<Node>} [values=null] - The default values.
	* @return {string} The generated value as a shader string.
	*/
	generateStruct(type$1, membersLayout, values = null) {
		const snippets = [];
		for (const member of membersLayout) {
			const { name, type: type$2 } = member;
			if (values && values[name] && values[name].isNode) snippets.push(values[name].build(this, type$2));
			else snippets.push(this.generateConst(type$2));
		}
		return type$1 + "( " + snippets.join(", ") + " )";
	}
	/**
	* Generates the shader string for the given type and value.
	*
	* @param {string} type - The type.
	* @param {?any} [value=null] - The value.
	* @return {string} The generated value as a shader string.
	*/
	generateConst(type$1, value = null) {
		if (value === null) {
			if (type$1 === "float" || type$1 === "int" || type$1 === "uint") value = 0;
			else if (type$1 === "bool") value = false;
			else if (type$1 === "color") value = new Color$1();
			else if (type$1 === "vec2") value = new Vector2();
			else if (type$1 === "vec3") value = new Vector3();
			else if (type$1 === "vec4") value = new Vector4();
		}
		if (type$1 === "float") return toFloat(value);
		if (type$1 === "int") return `${Math.round(value)}`;
		if (type$1 === "uint") return value >= 0 ? `${Math.round(value)}u` : "0u";
		if (type$1 === "bool") return value ? "true" : "false";
		if (type$1 === "color") return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
		const typeLength = this.getTypeLength(type$1);
		const componentType = this.getComponentType(type$1);
		const generateConst = (value$1) => this.generateConst(componentType, value$1);
		if (typeLength === 2) return `${this.getType(type$1)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
		else if (typeLength === 3) return `${this.getType(type$1)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
		else if (typeLength === 4 && type$1 !== "mat2") return `${this.getType(type$1)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
		else if (typeLength >= 4 && value && (value.isMatrix2 || value.isMatrix3 || value.isMatrix4)) return `${this.getType(type$1)}( ${value.elements.map(generateConst).join(", ")} )`;
		else if (typeLength > 4) return `${this.getType(type$1)}()`;
		throw new Error(`NodeBuilder: Type '${type$1}' not found in generate constant attempt.`);
	}
	/**
	* It might be necessary to convert certain data types to different ones
	* so this method can be used to hide the conversion.
	*
	* @param {string} type - The type.
	* @return {string} The updated type.
	*/
	getType(type$1) {
		if (type$1 === "color") return "vec3";
		return type$1;
	}
	/**
	* Whether the given attribute name is defined in the geometry or not.
	*
	* @param {string} name - The attribute name.
	* @return {boolean} Whether the given attribute name is defined in the geometry.
	*/
	hasGeometryAttribute(name) {
		return this.geometry && this.geometry.getAttribute(name) !== void 0;
	}
	/**
	* Returns a node attribute for the given name and type.
	*
	* @param {string} name - The attribute's name.
	* @param {string} type - The attribute's type.
	* @return {NodeAttribute} The node attribute.
	*/
	getAttribute(name, type$1) {
		const attributes = this.attributes;
		for (const attribute$3 of attributes) if (attribute$3.name === name) return attribute$3;
		const attribute$2 = new NodeAttribute(name, type$1);
		this.registerDeclaration(attribute$2);
		attributes.push(attribute$2);
		return attribute$2;
	}
	/**
	* Returns for the given node and shader stage the property name for the shader.
	*
	* @param {Node} node - The node.
	* @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	* @return {string} The property name.
	*/
	getPropertyName(node) {
		return node.name;
	}
	/**
	* Whether the given type is a vector type or not.
	*
	* @param {string} type - The type to check.
	* @return {boolean} Whether the given type is a vector type or not.
	*/
	isVector(type$1) {
		return /vec\d/.test(type$1);
	}
	/**
	* Whether the given type is a matrix type or not.
	*
	* @param {string} type - The type to check.
	* @return {boolean} Whether the given type is a matrix type or not.
	*/
	isMatrix(type$1) {
		return /mat\d/.test(type$1);
	}
	/**
	* Whether the given type is a reference type or not.
	*
	* @param {string} type - The type to check.
	* @return {boolean} Whether the given type is a reference type or not.
	*/
	isReference(type$1) {
		return type$1 === "void" || type$1 === "property" || type$1 === "sampler" || type$1 === "samplerComparison" || type$1 === "texture" || type$1 === "cubeTexture" || type$1 === "storageTexture" || type$1 === "depthTexture" || type$1 === "texture3D";
	}
	/**
	* Checks if the given texture requires a manual conversion to the working color space.
	*
	* @abstract
	* @param {Texture} texture - The texture to check.
	* @return {boolean} Whether the given texture requires a conversion to working color space or not.
	*/
	needsToWorkingColorSpace() {
		return false;
	}
	/**
	* Returns the component type of a given texture.
	*
	* @param {Texture} texture - The texture.
	* @return {string} The component type.
	*/
	getComponentTypeFromTexture(texture$2) {
		const type$1 = texture$2.type;
		if (texture$2.isDataTexture) {
			if (type$1 === IntType) return "int";
			if (type$1 === UnsignedIntType) return "uint";
		}
		return "float";
	}
	/**
	* Returns the element type for a given type.
	*
	* @param {string} type - The type.
	* @return {string} The element type.
	*/
	getElementType(type$1) {
		if (type$1 === "mat2") return "vec2";
		if (type$1 === "mat3") return "vec3";
		if (type$1 === "mat4") return "vec4";
		return this.getComponentType(type$1);
	}
	/**
	* Returns the component type for a given type.
	*
	* @param {string} type - The type.
	* @return {string} The component type.
	*/
	getComponentType(type$1) {
		type$1 = this.getVectorType(type$1);
		if (type$1 === "float" || type$1 === "bool" || type$1 === "int" || type$1 === "uint") return type$1;
		const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type$1);
		if (componentType === null) return null;
		if (componentType[1] === "b") return "bool";
		if (componentType[1] === "i") return "int";
		if (componentType[1] === "u") return "uint";
		return "float";
	}
	/**
	* Returns the vector type for a given type.
	*
	* @param {string} type - The type.
	* @return {string} The vector type.
	*/
	getVectorType(type$1) {
		if (type$1 === "color") return "vec3";
		if (type$1 === "texture" || type$1 === "cubeTexture" || type$1 === "storageTexture" || type$1 === "texture3D") return "vec4";
		return type$1;
	}
	/**
	* Returns the data type for the given the length and component type.
	*
	* @param {number} length - The length.
	* @param {string} [componentType='float'] - The component type.
	* @return {string} The type.
	*/
	getTypeFromLength(length$2, componentType = "float") {
		if (length$2 === 1) return componentType;
		let baseType = getTypeFromLength(length$2);
		const prefix = componentType === "float" ? "" : componentType[0];
		if (/mat2/.test(componentType) === true) baseType = baseType.replace("vec", "mat");
		return prefix + baseType;
	}
	/**
	* Returns the type for a given typed array.
	*
	* @param {TypedArray} array - The typed array.
	* @return {string} The type.
	*/
	getTypeFromArray(array$2) {
		return typeFromArray.get(array$2.constructor);
	}
	/**
	* Returns the type is an integer type.
	*
	* @param {string} type - The type.
	* @return {boolean} Whether the type is an integer type or not.
	*/
	isInteger(type$1) {
		return /int|uint|(i|u)vec/.test(type$1);
	}
	/**
	* Returns the type for a given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	* @return {string} The type.
	*/
	getTypeFromAttribute(attribute$2) {
		let dataAttribute = attribute$2;
		if (attribute$2.isInterleavedBufferAttribute) dataAttribute = attribute$2.data;
		const array$2 = dataAttribute.array;
		const itemSize = attribute$2.itemSize;
		const normalized = attribute$2.normalized;
		let arrayType;
		if (!(attribute$2 instanceof Float16BufferAttribute) && normalized !== true) arrayType = this.getTypeFromArray(array$2);
		return this.getTypeFromLength(itemSize, arrayType);
	}
	/**
	* Returns the length for the given data type.
	*
	* @param {string} type - The data type.
	* @return {number} The length.
	*/
	getTypeLength(type$1) {
		const vecType = this.getVectorType(type$1);
		const vecNum = /vec([2-4])/.exec(vecType);
		if (vecNum !== null) return Number(vecNum[1]);
		if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint") return 1;
		if (/mat2/.test(type$1) === true) return 4;
		if (/mat3/.test(type$1) === true) return 9;
		if (/mat4/.test(type$1) === true) return 16;
		return 0;
	}
	/**
	* Returns the vector type for a given matrix type.
	*
	* @param {string} type - The matrix type.
	* @return {string} The vector type.
	*/
	getVectorFromMatrix(type$1) {
		return type$1.replace("mat", "vec");
	}
	/**
	* For a given type this method changes the component type to the
	* given value. E.g. `vec4` should be changed to the new component type
	* `uint` which results in `uvec4`.
	*
	* @param {string} type - The type.
	* @param {string} newComponentType - The new component type.
	* @return {string} The new type.
	*/
	changeComponentType(type$1, newComponentType) {
		return this.getTypeFromLength(this.getTypeLength(type$1), newComponentType);
	}
	/**
	* Returns the integer type pendant for the given type.
	*
	* @param {string} type - The type.
	* @return {string} The integer type.
	*/
	getIntegerType(type$1) {
		const componentType = this.getComponentType(type$1);
		if (componentType === "int" || componentType === "uint") return type$1;
		return this.changeComponentType(type$1, "int");
	}
	/**
	* Adds an active stack to the internal stack.
	*
	* @param {StackNode} stack - The stack node to add.
	*/
	setActiveStack(stack$2) {
		this.activeStacks.push(stack$2);
	}
	/**
	* Removes the active stack from the internal stack.
	*
	* @param {StackNode} stack - The stack node to remove.
	*/
	removeActiveStack(stack$2) {
		if (this.activeStacks[this.activeStacks.length - 1] === stack$2) this.activeStacks.pop();
		else throw new Error("NodeBuilder: Invalid active stack removal.");
	}
	/**
	* Returns the active stack.
	*
	* @return {StackNode} The active stack.
	*/
	getActiveStack() {
		return this.activeStacks[this.activeStacks.length - 1];
	}
	/**
	* Returns the base stack.
	*
	* @return {StackNode} The base stack.
	*/
	getBaseStack() {
		return this.activeStacks[0];
	}
	/**
	* Adds a stack node to the internal stack.
	*
	* @return {StackNode} The added stack node.
	*/
	addStack() {
		this.stack = stack$1(this.stack);
		const previousStack = getCurrentStack$1();
		this.stacks.push(previousStack);
		setCurrentStack$1(this.stack);
		return this.stack;
	}
	/**
	* Removes the last stack node from the internal stack.
	*
	* @return {StackNode} The removed stack node.
	*/
	removeStack() {
		const lastStack = this.stack;
		for (const node of lastStack.nodes) {
			const nodeData = this.getDataFromNode(node);
			nodeData.stack = lastStack;
		}
		this.stack = lastStack.parent;
		setCurrentStack$1(this.stacks.pop());
		return lastStack;
	}
	/**
	* The builder maintains (cached) data for each node during the building process. This method
	* can be used to get these data for a specific shader stage and cache.
	*
	* @param {Node} node - The node to get the data for.
	* @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	* @param {?NodeCache} cache - An optional cache.
	* @return {Object} The node data.
	*/
	getDataFromNode(node, shaderStage = this.shaderStage, cache$2 = null) {
		cache$2 = cache$2 === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache$2;
		let nodeData = cache$2.getData(node);
		if (nodeData === void 0) {
			nodeData = {};
			cache$2.setData(node, nodeData);
		}
		if (nodeData[shaderStage] === void 0) nodeData[shaderStage] = {};
		let data = nodeData[shaderStage];
		const subBuilds = nodeData.any ? nodeData.any.subBuilds : null;
		const subBuild$2 = this.getClosestSubBuild(subBuilds);
		if (subBuild$2) {
			if (data.subBuildsCache === void 0) data.subBuildsCache = {};
			data = data.subBuildsCache[subBuild$2] || (data.subBuildsCache[subBuild$2] = {});
			data.subBuilds = subBuilds;
		}
		return data;
	}
	/**
	* Returns the properties for the given node and shader stage.
	*
	* Properties are typically used within a build stage to reference a node's
	* child node or nodes manually assigned to the properties in a separate build stage.
	* A typical usage pattern for defining nodes manually would be assigning dependency nodes
	* to the current node's properties in the setup stage and building those properties in the generate stage.
	*
	* @param {Node} node - The node to get the properties for.
	* @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
	* @return {Object} The node properties.
	*/
	getNodeProperties(node, shaderStage = "any") {
		const nodeData = this.getDataFromNode(node, shaderStage);
		return nodeData.properties || (nodeData.properties = { outputNode: null });
	}
	/**
	* Returns an instance of {@link NodeAttribute} for the given buffer attribute node.
	*
	* @param {BufferAttributeNode} node - The buffer attribute node.
	* @param {string} type - The node type.
	* @return {NodeAttribute} The node attribute.
	*/
	getBufferAttributeFromNode(node, type$1) {
		const nodeData = this.getDataFromNode(node);
		let bufferAttribute$2 = nodeData.bufferAttribute;
		if (bufferAttribute$2 === void 0) {
			const index = this.uniforms.index++;
			bufferAttribute$2 = new NodeAttribute("nodeAttribute" + index, type$1, node);
			this.bufferAttributes.push(bufferAttribute$2);
			nodeData.bufferAttribute = bufferAttribute$2;
		}
		return bufferAttribute$2;
	}
	/**
	* Returns an instance of {@link StructType} for the given struct name and shader stage
	* or null if not found.
	*
	* @param {string} name - The name of the struct.
	* @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	* @return {?StructType} The struct type or null if not found.
	*/
	getStructTypeNode(name, shaderStage = this.shaderStage) {
		return this.types[shaderStage][name] || null;
	}
	/**
	* Returns an instance of {@link StructType} for the given output struct node.
	*
	* @param {OutputStructNode} node - The output struct node.
	* @param {Array<Object>} membersLayout - The output struct types.
	* @param {?string} [name=null] - The name of the struct.
	* @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	* @return {StructType} The struct type attribute.
	*/
	getStructTypeFromNode(node, membersLayout, name = null, shaderStage = this.shaderStage) {
		const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
		let structType = nodeData.structType;
		if (structType === void 0) {
			const index = this.structs.index++;
			if (name === null) name = "StructType" + index;
			structType = new StructType(name, membersLayout);
			this.structs[shaderStage].push(structType);
			this.types[shaderStage][name] = node;
			nodeData.structType = structType;
		}
		return structType;
	}
	/**
	* Returns an instance of {@link StructType} for the given output struct node.
	*
	* @param {OutputStructNode} node - The output struct node.
	* @param {Array<Object>} membersLayout - The output struct types.
	* @return {StructType} The struct type attribute.
	*/
	getOutputStructTypeFromNode(node, membersLayout) {
		const structType = this.getStructTypeFromNode(node, membersLayout, "OutputType", "fragment");
		structType.output = true;
		return structType;
	}
	/**
	* Returns an instance of {@link NodeUniform} for the given uniform node.
	*
	* @param {UniformNode} node - The uniform node.
	* @param {string} type - The uniform type.
	* @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	* @param {?string} name - The name of the uniform.
	* @return {NodeUniform} The node uniform.
	*/
	getUniformFromNode(node, type$1, shaderStage = this.shaderStage, name = null) {
		const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
		let nodeUniform = nodeData.uniform;
		if (nodeUniform === void 0) {
			const index = this.uniforms.index++;
			nodeUniform = new NodeUniform(name || "nodeUniform" + index, type$1, node);
			this.uniforms[shaderStage].push(nodeUniform);
			this.registerDeclaration(nodeUniform);
			nodeData.uniform = nodeUniform;
		}
		return nodeUniform;
	}
	/**
	* Returns an instance of {@link NodeVar} for the given variable node.
	*
	* @param {VarNode} node - The variable node.
	* @param {?string} name - The variable's name.
	* @param {string} [type=node.getNodeType( this )] - The variable's type.
	* @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	* @param {boolean} [readOnly=false] - Whether the variable is read-only or not.
	*
	* @return {NodeVar} The node variable.
	*/
	getVarFromNode(node, name = null, type$1 = node.getNodeType(this), shaderStage = this.shaderStage, readOnly = false) {
		const nodeData = this.getDataFromNode(node, shaderStage);
		const subBuildVariable = this.getSubBuildProperty("variable", nodeData.subBuilds);
		let nodeVar = nodeData[subBuildVariable];
		if (nodeVar === void 0) {
			const idNS = readOnly ? "_const" : "_var";
			const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);
			const id = this.vars[idNS] || (this.vars[idNS] = 0);
			if (name === null) {
				name = (readOnly ? "nodeConst" : "nodeVar") + id;
				this.vars[idNS]++;
			}
			if (subBuildVariable !== "variable") name = this.getSubBuildProperty(name, nodeData.subBuilds);
			const count = node.getArrayCount(this);
			nodeVar = new NodeVar(name, type$1, readOnly, count);
			if (!readOnly) vars.push(nodeVar);
			this.registerDeclaration(nodeVar);
			nodeData[subBuildVariable] = nodeVar;
		}
		return nodeVar;
	}
	/**
	* Returns whether a Node or its flow is deterministic, useful for use in `const`.
	*
	* @param {Node} node - The varying node.
	* @return {boolean} Returns true if deterministic.
	*/
	isDeterministic(node) {
		if (node.isMathNode) return this.isDeterministic(node.aNode) && (node.bNode ? this.isDeterministic(node.bNode) : true) && (node.cNode ? this.isDeterministic(node.cNode) : true);
		else if (node.isOperatorNode) return this.isDeterministic(node.aNode) && (node.bNode ? this.isDeterministic(node.bNode) : true);
		else if (node.isArrayNode) {
			if (node.values !== null) {
				for (const n$2 of node.values) if (!this.isDeterministic(n$2)) return false;
			}
			return true;
		} else if (node.isConstNode) return true;
		return false;
	}
	/**
	* Returns an instance of {@link NodeVarying} for the given varying node.
	*
	* @param {(VaryingNode|PropertyNode)} node - The varying node.
	* @param {?string} name - The varying's name.
	* @param {string} [type=node.getNodeType( this )] - The varying's type.
	* @param {?string} interpolationType - The interpolation type of the varying.
	* @param {?string} interpolationSampling - The interpolation sampling type of the varying.
	* @return {NodeVar} The node varying.
	*/
	getVaryingFromNode(node, name = null, type$1 = node.getNodeType(this), interpolationType = null, interpolationSampling = null) {
		const nodeData = this.getDataFromNode(node, "any");
		const subBuildVarying = this.getSubBuildProperty("varying", nodeData.subBuilds);
		let nodeVarying = nodeData[subBuildVarying];
		if (nodeVarying === void 0) {
			const varyings = this.varyings;
			const index = varyings.length;
			if (name === null) name = "nodeVarying" + index;
			if (subBuildVarying !== "varying") name = this.getSubBuildProperty(name, nodeData.subBuilds);
			nodeVarying = new NodeVarying(name, type$1, interpolationType, interpolationSampling);
			varyings.push(nodeVarying);
			this.registerDeclaration(nodeVarying);
			nodeData[subBuildVarying] = nodeVarying;
		}
		return nodeVarying;
	}
	/**
	* Registers a node declaration in the current shader stage.
	*
	* @param {Object} node - The node to be registered.
	*/
	registerDeclaration(node) {
		const shaderStage = this.shaderStage;
		const declarations = this.declarations[shaderStage] || (this.declarations[shaderStage] = {});
		const property$2 = this.getPropertyName(node);
		let index = 1;
		let name = property$2;
		while (declarations[name] !== void 0) name = property$2 + "_" + index++;
		if (index > 1) {
			node.name = name;
			warn(`TSL: Declaration name '${property$2}' of '${node.type}' already in use. Renamed to '${name}'.`);
		}
		declarations[name] = node;
	}
	/**
	* Returns an instance of {@link NodeCode} for the given code node.
	*
	* @param {CodeNode} node - The code node.
	* @param {string} type - The node type.
	* @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	* @return {NodeCode} The node code.
	*/
	getCodeFromNode(node, type$1, shaderStage = this.shaderStage) {
		const nodeData = this.getDataFromNode(node);
		let nodeCode = nodeData.code;
		if (nodeCode === void 0) {
			const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);
			const index = codes.length;
			nodeCode = new NodeCode("nodeCode" + index, type$1);
			codes.push(nodeCode);
			nodeData.code = nodeCode;
		}
		return nodeCode;
	}
	/**
	* Adds a code flow based on the code-block hierarchy.
	
	* This is used so that code-blocks like If,Else create their variables locally if the Node
	* is only used inside one of these conditionals in the current shader stage.
	*
	* @param {Node} node - The node to add.
	* @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.
	*/
	addFlowCodeHierarchy(node, nodeBlock) {
		const { flowCodes, flowCodeBlock } = this.getDataFromNode(node);
		let needsFlowCode = true;
		let nodeBlockHierarchy = nodeBlock;
		while (nodeBlockHierarchy) {
			if (flowCodeBlock.get(nodeBlockHierarchy) === true) {
				needsFlowCode = false;
				break;
			}
			nodeBlockHierarchy = this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock;
		}
		if (needsFlowCode) for (const flowCode of flowCodes) this.addLineFlowCode(flowCode);
	}
	/**
	* Add a inline-code to the current flow code-block.
	*
	* @param {Node} node - The node to add.
	* @param {string} code - The code to add.
	* @param {Node} nodeBlock - Current ConditionalNode
	*/
	addLineFlowCodeBlock(node, code$2, nodeBlock) {
		const nodeData = this.getDataFromNode(node);
		const flowCodes = nodeData.flowCodes || (nodeData.flowCodes = []);
		const codeBlock = nodeData.flowCodeBlock || (nodeData.flowCodeBlock = /* @__PURE__ */ new WeakMap());
		flowCodes.push(code$2);
		codeBlock.set(nodeBlock, true);
	}
	/**
	* Add a inline-code to the current flow.
	*
	* @param {string} code - The code to add.
	* @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
	* @return {NodeBuilder} A reference to this node builder.
	*/
	addLineFlowCode(code$2, node = null) {
		if (code$2 === "") return this;
		if (node !== null && this.context.nodeBlock) this.addLineFlowCodeBlock(node, code$2, this.context.nodeBlock);
		code$2 = this.tab + code$2;
		if (!/;\s*$/.test(code$2)) code$2 = code$2 + ";\n";
		this.flow.code += code$2;
		return this;
	}
	/**
	* Adds a code to the current code flow.
	*
	* @param {string} code - Shader code.
	* @return {NodeBuilder} A reference to this node builder.
	*/
	addFlowCode(code$2) {
		this.flow.code += code$2;
		return this;
	}
	/**
	* Add tab in the code that will be generated so that other snippets respect the current tabulation.
	* Typically used in codes with If,Else.
	*
	* @return {NodeBuilder} A reference to this node builder.
	*/
	addFlowTab() {
		this.tab += "	";
		return this;
	}
	/**
	* Removes a tab.
	*
	* @return {NodeBuilder} A reference to this node builder.
	*/
	removeFlowTab() {
		this.tab = this.tab.slice(0, -1);
		return this;
	}
	/**
	* Gets the current flow data based on a Node.
	*
	* @param {Node} node - Node that the flow was started.
	* @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	* @return {Object} The flow data.
	*/
	getFlowData(node) {
		return this.flowsData.get(node);
	}
	/**
	* Executes the node flow based on a root node to generate the final shader code.
	*
	* @param {Node} node - The node to execute.
	* @return {Object} The code flow.
	*/
	flowNode(node) {
		const output$2 = node.getNodeType(this);
		const flowData = this.flowChildNode(node, output$2);
		this.flowsData.set(node, flowData);
		return flowData;
	}
	/**
	* Includes a node in the current function node.
	*
	* @param {Node} node - The node to include.
	* @returns {void}
	*/
	addInclude(node) {
		if (this.currentFunctionNode !== null) this.currentFunctionNode.includes.push(node);
	}
	/**
	* Returns the native shader operator name for a given generic name.
	* It is a similar type of method like {@link NodeBuilder#getMethod}.
	*
	* @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
	* @return {FunctionNode} The build function node.
	*/
	buildFunctionNode(shaderNode) {
		const fn = new FunctionNode();
		const previous = this.currentFunctionNode;
		this.currentFunctionNode = fn;
		fn.code = this.buildFunctionCode(shaderNode);
		this.currentFunctionNode = previous;
		return fn;
	}
	/**
	* Generates a code flow based on a TSL function: Fn().
	*
	* @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
	* @return {Object}
	*/
	flowShaderNode(shaderNode) {
		const layout = shaderNode.layout;
		const inputs = { [Symbol.iterator]() {
			let index = 0;
			const values = Object.values(this);
			return { next: () => ({
				value: values[index],
				done: index++ >= values.length
			}) };
		} };
		for (const input of layout.inputs) inputs[input.name] = new ParameterNode(input.type, input.name);
		shaderNode.layout = null;
		const callNode = shaderNode.call(inputs);
		const flowData = this.flowStagesNode(callNode, layout.type);
		shaderNode.layout = layout;
		return flowData;
	}
	/**
	* Executes the node in a specific build stage.
	*
	* This function can be used to arbitrarily execute the specified build stage
	* outside of the standard build process. For instance, if a node's type depends
	* on properties created by the 'setup' stage, then flowBuildStage(node, 'setup')
	* can be used to execute the setup build stage and access its generated nodes
	* before the standard build process begins.
	*
	* @param {Node} node - The node to execute.
	* @param {string} buildStage - The build stage to execute the node in.
	* @param {?(Node|string)} [output=null] - Expected output type. For example 'vec3'.
	* @return {?(Node|string)} The result of the node build.
	*/
	flowBuildStage(node, buildStage, output$2 = null) {
		const previousBuildStage = this.getBuildStage();
		this.setBuildStage(buildStage);
		const result = node.build(this, output$2);
		this.setBuildStage(previousBuildStage);
		return result;
	}
	/**
	* Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.
	*
	* @param {Node} node - The node to execute.
	* @param {?string} output - Expected output type. For example 'vec3'.
	* @return {Object}
	*/
	flowStagesNode(node, output$2 = null) {
		const previousFlow = this.flow;
		const previousVars = this.vars;
		const previousDeclarations = this.declarations;
		const previousCache = this.cache;
		const previousBuildStage = this.buildStage;
		const previousStack = this.stack;
		const flow = { code: "" };
		this.flow = flow;
		this.vars = {};
		this.declarations = {};
		this.cache = new NodeCache();
		this.stack = stack$1();
		for (const buildStage of defaultBuildStages$1) {
			this.setBuildStage(buildStage);
			flow.result = node.build(this, output$2);
		}
		flow.vars = this.getVars(this.shaderStage);
		this.flow = previousFlow;
		this.vars = previousVars;
		this.declarations = previousDeclarations;
		this.cache = previousCache;
		this.stack = previousStack;
		this.setBuildStage(previousBuildStage);
		return flow;
	}
	/**
	* Returns the native shader operator name for a given generic name.
	* It is a similar type of method like {@link NodeBuilder#getMethod}.
	*
	* @abstract
	* @param {string} op - The operator name to resolve.
	* @return {?string} The resolved operator name.
	*/
	getFunctionOperator() {
		return null;
	}
	/**
	* Builds the given shader node.
	*
	* @abstract
	* @param {ShaderNodeInternal} shaderNode - The shader node.
	* @return {string} The function code.
	*/
	buildFunctionCode() {
		warn("Abstract function.");
	}
	/**
	* Generates a code flow based on a child Node.
	*
	* @param {Node} node - The node to execute.
	* @param {?string} output - Expected output type. For example 'vec3'.
	* @return {Object} The code flow.
	*/
	flowChildNode(node, output$2 = null) {
		const previousFlow = this.flow;
		const flow = { code: "" };
		this.flow = flow;
		flow.result = node.build(this, output$2);
		this.flow = previousFlow;
		return flow;
	}
	/**
	* Executes a flow of code in a different stage.
	*
	* Some nodes like `varying()` have the ability to compute code in vertex-stage and
	* return the value in fragment-stage even if it is being executed in an input fragment.
	*
	* @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	* @param {Node} node - The node to execute.
	* @param {?string} output - Expected output type. For example 'vec3'.
	* @param {?string} propertyName - The property name to assign the result.
	* @return {?(Object|Node)} The code flow or node.build() result.
	*/
	flowNodeFromShaderStage(shaderStage, node, output$2 = null, propertyName = null) {
		const previousTab = this.tab;
		const previousCache = this.cache;
		const previousShaderStage = this.shaderStage;
		const previousContext = this.context;
		this.setShaderStage(shaderStage);
		const context$2 = { ...this.context };
		delete context$2.nodeBlock;
		this.cache = this.globalCache;
		this.tab = "	";
		this.context = context$2;
		let result = null;
		if (this.buildStage === "generate") {
			const flowData = this.flowChildNode(node, output$2);
			if (propertyName !== null) flowData.code += `${this.tab + propertyName} = ${flowData.result};\n`;
			this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
			result = flowData;
		} else result = node.build(this);
		this.setShaderStage(previousShaderStage);
		this.cache = previousCache;
		this.tab = previousTab;
		this.context = previousContext;
		return result;
	}
	/**
	* Returns an array holding all node attributes of this node builder.
	*
	* @return {Array<NodeAttribute>} The node attributes of this builder.
	*/
	getAttributesArray() {
		return this.attributes.concat(this.bufferAttributes);
	}
	/**
	* Returns the attribute definitions as a shader string for the given shader stage.
	*
	* @abstract
	* @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	* @return {string} The attribute code section.
	*/
	getAttributes() {
		warn("Abstract function.");
	}
	/**
	* Returns the varying definitions as a shader string for the given shader stage.
	*
	* @abstract
	* @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	* @return {string} The varying code section.
	*/
	getVaryings() {
		warn("Abstract function.");
	}
	/**
	* Returns a single variable definition as a shader string for the given variable type and name.
	*
	* @param {string} type - The variable's type.
	* @param {string} name - The variable's name.
	* @param {?number} [count=null] - The array length.
	* @return {string} The shader string.
	*/
	getVar(type$1, name, count = null) {
		return `${count !== null ? this.generateArrayDeclaration(type$1, count) : this.getType(type$1)} ${name}`;
	}
	/**
	* Returns the variable definitions as a shader string for the given shader stage.
	*
	* @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	* @return {string} The variable code section.
	*/
	getVars(shaderStage) {
		let snippet = "";
		const vars = this.vars[shaderStage];
		if (vars !== void 0) for (const variable of vars) snippet += `${this.getVar(variable.type, variable.name)}; `;
		return snippet;
	}
	/**
	* Returns the uniform definitions as a shader string for the given shader stage.
	*
	* @abstract
	* @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	* @return {string} The uniform code section.
	*/
	getUniforms() {
		warn("Abstract function.");
	}
	/**
	* Returns the native code definitions as a shader string for the given shader stage.
	*
	* @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	* @return {string} The native code section.
	*/
	getCodes(shaderStage) {
		const codes = this.codes[shaderStage];
		let code$2 = "";
		if (codes !== void 0) for (const nodeCode of codes) code$2 += nodeCode.code + "\n";
		return code$2;
	}
	/**
	* Returns the hash of this node builder.
	*
	* @return {string} The hash.
	*/
	getHash() {
		return this.vertexShader + this.fragmentShader + this.computeShader;
	}
	/**
	* Sets the current shader stage.
	*
	* @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.
	*/
	setShaderStage(shaderStage) {
		this.shaderStage = shaderStage;
	}
	/**
	* Returns the current shader stage.
	*
	* @return {?('vertex'|'fragment'|'compute'|'any')} The current shader stage.
	*/
	getShaderStage() {
		return this.shaderStage;
	}
	/**
	* Sets the current build stage.
	*
	* @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.
	*/
	setBuildStage(buildStage) {
		this.buildStage = buildStage;
	}
	/**
	* Returns the current build stage.
	*
	* @return {?('setup'|'analyze'|'generate')} The current build stage.
	*/
	getBuildStage() {
		return this.buildStage;
	}
	/**
	* Controls the code build of the shader stages.
	*
	* @abstract
	*/
	buildCode() {
		warn("Abstract function.");
	}
	/**
	* Returns the current sub-build layer.
	*
	* @return {SubBuildNode} The current sub-build layers.
	*/
	get subBuild() {
		return this.subBuildLayers[this.subBuildLayers.length - 1] || null;
	}
	/**
	* Adds a sub-build layer to the node builder.
	*
	* @param {SubBuildNode} subBuild - The sub-build layer to add.
	*/
	addSubBuild(subBuild$2) {
		this.subBuildLayers.push(subBuild$2);
	}
	/**
	* Removes the last sub-build layer from the node builder.
	*
	* @return {SubBuildNode} The removed sub-build layer.
	*/
	removeSubBuild() {
		return this.subBuildLayers.pop();
	}
	/**
	* Returns the closest sub-build layer for the given data.
	*
	* @param {Node|Set<string>|Array<string>} data - The data to get the closest sub-build layer from.
	* @return {?string} The closest sub-build name or null if none found.
	*/
	getClosestSubBuild(data) {
		let subBuilds;
		if (data && data.isNode) if (data.isShaderCallNodeInternal) subBuilds = data.shaderNode.subBuilds;
		else if (data.isStackNode) subBuilds = [data.subBuild];
		else subBuilds = this.getDataFromNode(data, "any").subBuilds;
		else if (data instanceof Set) subBuilds = [...data];
		else subBuilds = data;
		if (!subBuilds) return null;
		const subBuildLayers = this.subBuildLayers;
		for (let i = subBuilds.length - 1; i >= 0; i--) {
			const subBuild$2 = subBuilds[i];
			if (subBuildLayers.includes(subBuild$2)) return subBuild$2;
		}
		return null;
	}
	/**
	* Returns the output node of a sub-build layer.
	*
	* @param {Node} node - The node to get the output from.
	* @return {string} The output node name.
	*/
	getSubBuildOutput(node) {
		return this.getSubBuildProperty("outputNode", node);
	}
	/**
	* Returns the sub-build property name for the given property and node.
	*
	* @param {string} [property=''] - The property name.
	* @param {?Node} [node=null] - The node to get the sub-build from.
	* @return {string} The sub-build property name.
	*/
	getSubBuildProperty(property$2 = "", node = null) {
		let subBuild$2;
		if (node !== null) subBuild$2 = this.getClosestSubBuild(node);
		else subBuild$2 = this.subBuildFn;
		let result;
		if (subBuild$2) result = property$2 ? subBuild$2 + "_" + property$2 : subBuild$2;
		else result = property$2;
		return result;
	}
	/**
	* Central build method which controls the build for the given object.
	*
	* @return {NodeBuilder} A reference to this node builder.
	*/
	build() {
		const { object, material, renderer } = this;
		if (material !== null) {
			let nodeMaterial = renderer.library.fromMaterial(material);
			if (nodeMaterial === null) {
				error(`NodeMaterial: Material "${material.type}" is not compatible.`);
				nodeMaterial = new NodeMaterial();
			}
			nodeMaterial.build(this);
		} else this.addFlow("compute", object);
		for (const buildStage of defaultBuildStages$1) {
			this.setBuildStage(buildStage);
			if (this.context.vertex && this.context.vertex.isNode) this.flowNodeFromShaderStage("vertex", this.context.vertex);
			for (const shaderStage of shaderStages$1) {
				this.setShaderStage(shaderStage);
				const flowNodes = this.flowNodes[shaderStage];
				for (const node of flowNodes) if (buildStage === "generate") this.flowNode(node);
				else node.build(this);
			}
		}
		this.setBuildStage(null);
		this.setShaderStage(null);
		this.buildCode();
		this.buildUpdateNodes();
		return this;
	}
	/**
	* Returns a uniform representation which is later used for UBO generation and rendering.
	*
	* @param {NodeUniform} uniformNode - The uniform node.
	* @param {string} type - The requested type.
	* @return {Uniform} The uniform.
	*/
	getNodeUniform(uniformNode, type$1) {
		if (type$1 === "float" || type$1 === "int" || type$1 === "uint") return new NumberNodeUniform(uniformNode);
		if (type$1 === "vec2" || type$1 === "ivec2" || type$1 === "uvec2") return new Vector2NodeUniform(uniformNode);
		if (type$1 === "vec3" || type$1 === "ivec3" || type$1 === "uvec3") return new Vector3NodeUniform(uniformNode);
		if (type$1 === "vec4" || type$1 === "ivec4" || type$1 === "uvec4") return new Vector4NodeUniform(uniformNode);
		if (type$1 === "color") return new ColorNodeUniform(uniformNode);
		if (type$1 === "mat2") return new Matrix2NodeUniform(uniformNode);
		if (type$1 === "mat3") return new Matrix3NodeUniform(uniformNode);
		if (type$1 === "mat4") return new Matrix4NodeUniform(uniformNode);
		throw new Error(`Uniform "${type$1}" not declared.`);
	}
	/**
	* Formats the given shader snippet from a given type into another one. E.g.
	* this method might be used to convert a simple float string `"1.0"` into a
	* `vec3` representation: `"vec3<f32>( 1.0 )"`.
	*
	* @param {string} snippet - The shader snippet.
	* @param {string} fromType - The source type.
	* @param {string} toType - The target type.
	* @return {string} The updated shader string.
	*/
	format(snippet, fromType, toType) {
		fromType = this.getVectorType(fromType);
		toType = this.getVectorType(toType);
		if (fromType === toType || toType === null || this.isReference(toType)) return snippet;
		const fromTypeLength = this.getTypeLength(fromType);
		const toTypeLength = this.getTypeLength(toType);
		if (fromTypeLength === 16 && toTypeLength === 9) return `${this.getType(toType)}( ${snippet}[ 0 ].xyz, ${snippet}[ 1 ].xyz, ${snippet}[ 2 ].xyz )`;
		if (fromTypeLength === 9 && toTypeLength === 4) return `${this.getType(toType)}( ${snippet}[ 0 ].xy, ${snippet}[ 1 ].xy )`;
		if (fromTypeLength > 4) return snippet;
		if (toTypeLength > 4 || toTypeLength === 0) return snippet;
		if (fromTypeLength === toTypeLength) return `${this.getType(toType)}( ${snippet} )`;
		if (fromTypeLength > toTypeLength) {
			snippet = toType === "bool" ? `all( ${snippet} )` : `${snippet}.${"xyz".slice(0, toTypeLength)}`;
			return this.format(snippet, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);
		}
		if (toTypeLength === 4 && fromTypeLength > 1) return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec3")}, 1.0 )`;
		if (fromTypeLength === 2) return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec2")}, 0.0 )`;
		if (fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType(toType)) snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;
		return `${this.getType(toType)}( ${snippet} )`;
	}
	/**
	* Returns a signature with the engine's current revision.
	*
	* @return {string} The signature.
	*/
	getSignature() {
		return `// Three.js r${REVISION} - Node System\n`;
	}
};
/**
* Management class for updating nodes. The module tracks metrics like
* the elapsed time, delta time, the render and frame ID to correctly
* call the node update methods {@link Node#updateBefore}, {@link Node#update}
* and {@link Node#updateAfter} depending on the node's configuration.
*/
var NodeFrame = class {
	/**
	* Constructs a new node fame.
	*/
	constructor() {
		/**
		* The elapsed time in seconds.
		*
		* @type {number}
		* @default 0
		*/
		this.time = 0;
		/**
		* The delta time in seconds.
		*
		* @type {number}
		* @default 0
		*/
		this.deltaTime = 0;
		/**
		* The frame ID.
		*
		* @type {number}
		* @default 0
		*/
		this.frameId = 0;
		/**
		* The render ID.
		*
		* @type {number}
		* @default 0
		*/
		this.renderId = 0;
		/**
		* Used to control the {@link Node#update} call.
		*
		* @type {WeakMap<Node, Object>}
		*/
		this.updateMap = /* @__PURE__ */ new WeakMap();
		/**
		* Used to control the {@link Node#updateBefore} call.
		*
		* @type {WeakMap<Node, Object>}
		*/
		this.updateBeforeMap = /* @__PURE__ */ new WeakMap();
		/**
		* Used to control the {@link Node#updateAfter} call.
		*
		* @type {WeakMap<Node, Object>}
		*/
		this.updateAfterMap = /* @__PURE__ */ new WeakMap();
		/**
		* A reference to the current renderer.
		*
		* @type {?Renderer}
		* @default null
		*/
		this.renderer = null;
		/**
		* A reference to the current material.
		*
		* @type {?Material}
		* @default null
		*/
		this.material = null;
		/**
		* A reference to the current camera.
		*
		* @type {?Camera}
		* @default null
		*/
		this.camera = null;
		/**
		* A reference to the current 3D object.
		*
		* @type {?Object3D}
		* @default null
		*/
		this.object = null;
		/**
		* A reference to the current scene.
		*
		* @type {?Scene}
		* @default null
		*/
		this.scene = null;
	}
	/**
	* Returns a dictionary for a given node and update map which
	* is used to correctly call node update methods per frame or render.
	*
	* @private
	* @param {WeakMap<Node, Object>} referenceMap - The reference weak map.
	* @param {Node} nodeRef - The reference to the current node.
	* @return {Object<string,WeakMap<Object, number>>} The dictionary.
	*/
	_getMaps(referenceMap, nodeRef) {
		let maps = referenceMap.get(nodeRef);
		if (maps === void 0) {
			maps = {
				renderId: 0,
				frameId: 0
			};
			referenceMap.set(nodeRef, maps);
		}
		return maps;
	}
	/**
	* This method executes the {@link Node#updateBefore} for the given node.
	* It makes sure {@link Node#updateBeforeType} is honored meaning the update
	* is only executed once per frame, render or object depending on the update
	* type.
	*
	* @param {Node} node - The node that should be updated.
	*/
	updateBeforeNode(node) {
		const updateType = node.getUpdateBeforeType();
		const reference$3 = node.updateReference(this);
		if (updateType === NodeUpdateType$1.FRAME) {
			const nodeUpdateBeforeMap = this._getMaps(this.updateBeforeMap, reference$3);
			if (nodeUpdateBeforeMap.frameId !== this.frameId) {
				if (node.updateBefore(this) !== false) nodeUpdateBeforeMap.frameId = this.frameId;
			}
		} else if (updateType === NodeUpdateType$1.RENDER) {
			const nodeUpdateBeforeMap = this._getMaps(this.updateBeforeMap, reference$3);
			if (nodeUpdateBeforeMap.renderId !== this.renderId) {
				if (node.updateBefore(this) !== false) nodeUpdateBeforeMap.renderId = this.renderId;
			}
		} else if (updateType === NodeUpdateType$1.OBJECT) node.updateBefore(this);
	}
	/**
	* This method executes the {@link Node#updateAfter} for the given node.
	* It makes sure {@link Node#updateAfterType} is honored meaning the update
	* is only executed once per frame, render or object depending on the update
	* type.
	*
	* @param {Node} node - The node that should be updated.
	*/
	updateAfterNode(node) {
		const updateType = node.getUpdateAfterType();
		const reference$3 = node.updateReference(this);
		if (updateType === NodeUpdateType$1.FRAME) {
			const nodeUpdateAfterMap = this._getMaps(this.updateAfterMap, reference$3);
			if (nodeUpdateAfterMap.frameId !== this.frameId) {
				if (node.updateAfter(this) !== false) nodeUpdateAfterMap.frameId = this.frameId;
			}
		} else if (updateType === NodeUpdateType$1.RENDER) {
			const nodeUpdateAfterMap = this._getMaps(this.updateAfterMap, reference$3);
			if (nodeUpdateAfterMap.renderId !== this.renderId) {
				if (node.updateAfter(this) !== false) nodeUpdateAfterMap.renderId = this.renderId;
			}
		} else if (updateType === NodeUpdateType$1.OBJECT) node.updateAfter(this);
	}
	/**
	* This method executes the {@link Node#update} for the given node.
	* It makes sure {@link Node#updateType} is honored meaning the update
	* is only executed once per frame, render or object depending on the update
	* type.
	*
	* @param {Node} node - The node that should be updated.
	*/
	updateNode(node) {
		const updateType = node.getUpdateType();
		const reference$3 = node.updateReference(this);
		if (updateType === NodeUpdateType$1.FRAME) {
			const nodeUpdateMap = this._getMaps(this.updateMap, reference$3);
			if (nodeUpdateMap.frameId !== this.frameId) {
				if (node.update(this) !== false) nodeUpdateMap.frameId = this.frameId;
			}
		} else if (updateType === NodeUpdateType$1.RENDER) {
			const nodeUpdateMap = this._getMaps(this.updateMap, reference$3);
			if (nodeUpdateMap.renderId !== this.renderId) {
				if (node.update(this) !== false) nodeUpdateMap.renderId = this.renderId;
			}
		} else if (updateType === NodeUpdateType$1.OBJECT) node.update(this);
	}
	/**
	* Updates the internal state of the node frame. This method is
	* called by the renderer in its internal animation loop.
	*/
	update() {
		this.frameId++;
		if (this.lastTime === void 0) this.lastTime = performance.now();
		this.deltaTime = (performance.now() - this.lastTime) / 1e3;
		this.lastTime = performance.now();
		this.time += this.deltaTime;
	}
};
/**
* Describes the input of a {@link NodeFunction}.
*/
var NodeFunctionInput = class {
	/**
	* Constructs a new node function input.
	*
	* @param {string} type - The input type.
	* @param {string} name - The input name.
	* @param {?number} [count=null] - If the input is an Array, count will be the length.
	* @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).
	* @param {boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).
	*/
	constructor(type$1, name, count = null, qualifier = "", isConst = false) {
		/**
		*  The input type.
		*
		* @type {string}
		*/
		this.type = type$1;
		/**
		* The input name.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* If the input is an Array, count will be the length.
		*
		* @type {?number}
		* @default null
		*/
		this.count = count;
		/**
		*The parameter qualifier (only relevant for GLSL).
		*
		* @type {('in'|'out'|'inout')}
		* @default ''
		*/
		this.qualifier = qualifier;
		/**
		* Whether the input uses a const qualifier or not (only relevant for GLSL).
		*
		* @type {boolean}
		* @default false
		*/
		this.isConst = isConst;
	}
};
NodeFunctionInput.isNodeFunctionInput = true;
/**
* Module for representing directional lights as nodes.
*
* @augments AnalyticLightNode
*/
var DirectionalLightNode = class extends AnalyticLightNode {
	static get type() {
		return "DirectionalLightNode";
	}
	/**
	* Constructs a new directional light node.
	*
	* @param {?DirectionalLight} [light=null] - The directional light source.
	*/
	constructor(light = null) {
		super(light);
	}
	setupDirect() {
		const lightColor = this.colorNode;
		return {
			lightDirection: lightTargetDirection$1(this.light),
			lightColor
		};
	}
};
var _matrix41 = /* @__PURE__ */ new Matrix4();
var _matrix42 = /* @__PURE__ */ new Matrix4();
var _ltcLib = null;
/**
* Module for representing rect area lights as nodes.
*
* @augments AnalyticLightNode
*/
var RectAreaLightNode = class extends AnalyticLightNode {
	static get type() {
		return "RectAreaLightNode";
	}
	/**
	* Constructs a new rect area light node.
	*
	* @param {?RectAreaLight} [light=null] - The rect area light source.
	*/
	constructor(light = null) {
		super(light);
		/**
		* Uniform node representing the half height of the are light.
		*
		* @type {UniformNode<vec3>}
		*/
		this.halfHeight = uniform$1(new Vector3()).setGroup(renderGroup$1);
		/**
		* Uniform node representing the half width of the are light.
		*
		* @type {UniformNode<vec3>}
		*/
		this.halfWidth = uniform$1(new Vector3()).setGroup(renderGroup$1);
		/**
		* The `updateType` is set to `NodeUpdateType.RENDER` since the light
		* relies on `viewMatrix` which might vary per render call.
		*
		* @type {string}
		* @default 'render'
		*/
		this.updateType = NodeUpdateType$1.RENDER;
	}
	/**
	* Overwritten to updated rect area light specific uniforms.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update(frame) {
		super.update(frame);
		const { light } = this;
		const viewMatrix = frame.camera.matrixWorldInverse;
		_matrix42.identity();
		_matrix41.copy(light.matrixWorld);
		_matrix41.premultiply(viewMatrix);
		_matrix42.extractRotation(_matrix41);
		this.halfWidth.value.set(light.width * .5, 0, 0);
		this.halfHeight.value.set(0, light.height * .5, 0);
		this.halfWidth.value.applyMatrix4(_matrix42);
		this.halfHeight.value.applyMatrix4(_matrix42);
	}
	setupDirectRectArea(builder) {
		let ltc_1, ltc_2;
		if (builder.isAvailable("float32Filterable")) {
			ltc_1 = texture$1(_ltcLib.LTC_FLOAT_1);
			ltc_2 = texture$1(_ltcLib.LTC_FLOAT_2);
		} else {
			ltc_1 = texture$1(_ltcLib.LTC_HALF_1);
			ltc_2 = texture$1(_ltcLib.LTC_HALF_2);
		}
		const { colorNode, light } = this;
		const lightPosition$2 = lightViewPosition$1(light);
		return {
			lightColor: colorNode,
			lightPosition: lightPosition$2,
			halfWidth: this.halfWidth,
			halfHeight: this.halfHeight,
			ltc_1,
			ltc_2
		};
	}
	/**
	* Used to configure the internal BRDF approximation texture data.
	*
	* @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.
	*/
	static setLTC(ltc) {
		_ltcLib = ltc;
	}
};
/**
* Module for representing spot lights as nodes.
*
* @augments AnalyticLightNode
*/
var SpotLightNode = class extends AnalyticLightNode {
	static get type() {
		return "SpotLightNode";
	}
	/**
	* Constructs a new spot light node.
	*
	* @param {?SpotLight} [light=null] - The spot light source.
	*/
	constructor(light = null) {
		super(light);
		/**
		* Uniform node representing the cone cosine.
		*
		* @type {UniformNode<float>}
		*/
		this.coneCosNode = uniform$1(0).setGroup(renderGroup$1);
		/**
		* Uniform node representing the penumbra cosine.
		*
		* @type {UniformNode<float>}
		*/
		this.penumbraCosNode = uniform$1(0).setGroup(renderGroup$1);
		/**
		* Uniform node representing the cutoff distance.
		*
		* @type {UniformNode<float>}
		*/
		this.cutoffDistanceNode = uniform$1(0).setGroup(renderGroup$1);
		/**
		* Uniform node representing the decay exponent.
		*
		* @type {UniformNode<float>}
		*/
		this.decayExponentNode = uniform$1(0).setGroup(renderGroup$1);
		/**
		* Uniform node representing the light color.
		*
		* @type {UniformNode<Color>}
		*/
		this.colorNode = uniform$1(this.color).setGroup(renderGroup$1);
	}
	/**
	* Overwritten to updated spot light specific uniforms.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update(frame) {
		super.update(frame);
		const { light } = this;
		this.coneCosNode.value = Math.cos(light.angle);
		this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
		this.cutoffDistanceNode.value = light.distance;
		this.decayExponentNode.value = light.decay;
	}
	/**
	* Computes the spot attenuation for the given angle.
	*
	* @param {NodeBuilder} builder - The node builder.
	* @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
	* @return {Node<float>} The spot attenuation.
	*/
	getSpotAttenuation(builder, angleCosine) {
		const { coneCosNode, penumbraCosNode } = this;
		return smoothstep$1(coneCosNode, penumbraCosNode, angleCosine);
	}
	getLightCoord(builder) {
		const properties = builder.getNodeProperties(this);
		let projectionUV = properties.projectionUV;
		if (projectionUV === void 0) {
			projectionUV = lightProjectionUV$1(this.light, builder.context.positionWorld);
			properties.projectionUV = projectionUV;
		}
		return projectionUV;
	}
	setupDirect(builder) {
		const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
		const lightVector = this.getLightVector(builder);
		const lightDirection = lightVector.normalize();
		const angleCos = lightDirection.dot(lightTargetDirection$1(light));
		const spotAttenuation = this.getSpotAttenuation(builder, angleCos);
		const lightDistance = lightVector.length();
		const lightAttenuation = getDistanceAttenuation$1({
			lightDistance,
			cutoffDistance: cutoffDistanceNode,
			decayExponent: decayExponentNode
		});
		let lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
		let projected, lightCoord;
		if (light.colorNode) {
			lightCoord = this.getLightCoord(builder);
			projected = light.colorNode(lightCoord);
		} else if (light.map) {
			lightCoord = this.getLightCoord(builder);
			projected = texture$1(light.map, lightCoord.xy).onRenderUpdate(() => light.map);
		}
		if (projected) lightColor = lightCoord.mul(2).sub(1).abs().lessThan(1).all().select(lightColor.mul(projected), lightColor);
		return {
			lightColor,
			lightDirection
		};
	}
};
/**
* An IES version of the default spot light node.
*
* @augments SpotLightNode
*/
var IESSpotLightNode = class extends SpotLightNode {
	static get type() {
		return "IESSpotLightNode";
	}
	/**
	* Overwrites the default implementation to compute an IES conform spot attenuation.
	*
	* @param {NodeBuilder} builder - The node builder.
	* @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
	* @return {Node<float>} The spot attenuation.
	*/
	getSpotAttenuation(builder, angleCosine) {
		const iesMap = this.light.iesMap;
		let spotAttenuation = null;
		if (iesMap && iesMap.isTexture === true) {
			const angle = angleCosine.acos().mul(1 / Math.PI);
			spotAttenuation = texture$1(iesMap, vec2$1(angle, 0), 0).r;
		} else spotAttenuation = super.getSpotAttenuation(angleCosine);
		return spotAttenuation;
	}
};
var sdBox = /* @__PURE__ */ Fn$1(([p$1, b$2]) => {
	const d$1 = p$1.abs().sub(b$2);
	return length$1(max$1$1(d$1, 0)).add(min$1(max$1$1(d$1.x, d$1.y), 0));
});
/**
* An implementation of a projector light node.
*
* @augments SpotLightNode
*/
var ProjectorLightNode = class extends SpotLightNode {
	static get type() {
		return "ProjectorLightNode";
	}
	update(frame) {
		super.update(frame);
		const light = this.light;
		this.penumbraCosNode.value = Math.min(Math.cos(light.angle * (1 - light.penumbra)), .99999);
		if (light.aspect === null) {
			let aspect$1 = 1;
			if (light.map !== null) aspect$1 = light.map.width / light.map.height;
			light.shadow.aspect = aspect$1;
		} else light.shadow.aspect = light.aspect;
	}
	/**
	* Overwrites the default implementation to compute projection attenuation.
	*
	* @param {NodeBuilder} builder - The node builder.
	* @return {Node<float>} The spot attenuation.
	*/
	getSpotAttenuation(builder) {
		const attenuation = float$1(0);
		const penumbraCos = this.penumbraCosNode;
		const spotLightCoord = lightShadowMatrix$1(this.light).mul(builder.context.positionWorld || positionWorld$1);
		If$1(spotLightCoord.w.greaterThan(0), () => {
			const projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
			const boxDist = sdBox(projectionUV.xy.sub(vec2$1(.5)), vec2$1(.5));
			const angleFactor$1 = div$1(-1, sub$1(1, acos$1(penumbraCos)).sub(1));
			attenuation.assign(saturate$1(boxDist.mul(-2).mul(angleFactor$1)));
		});
		return attenuation;
	}
};
/**
* Module for representing ambient lights as nodes.
*
* @augments AnalyticLightNode
*/
var AmbientLightNode = class extends AnalyticLightNode {
	static get type() {
		return "AmbientLightNode";
	}
	/**
	* Constructs a new ambient light node.
	*
	* @param {?AmbientLight} [light=null] - The ambient light source.
	*/
	constructor(light = null) {
		super(light);
	}
	setup({ context: context$2 }) {
		context$2.irradiance.addAssign(this.colorNode);
	}
};
/**
* Module for representing hemisphere lights as nodes.
*
* @augments AnalyticLightNode
*/
var HemisphereLightNode = class extends AnalyticLightNode {
	static get type() {
		return "HemisphereLightNode";
	}
	/**
	* Constructs a new hemisphere light node.
	*
	* @param {?HemisphereLight} [light=null] - The hemisphere light source.
	*/
	constructor(light = null) {
		super(light);
		/**
		* Uniform node representing the light's position.
		*
		* @type {UniformNode<vec3>}
		*/
		this.lightPositionNode = lightPosition$1(light);
		/**
		* A node representing the light's direction.
		*
		* @type {Node<vec3>}
		*/
		this.lightDirectionNode = this.lightPositionNode.normalize();
		/**
		* Uniform node representing the light's ground color.
		*
		* @type {UniformNode<vec3>}
		*/
		this.groundColorNode = uniform$1(new Color$1()).setGroup(renderGroup$1);
	}
	/**
	* Overwritten to updated hemisphere light specific uniforms.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update(frame) {
		const { light } = this;
		super.update(frame);
		this.lightPositionNode.object3d = light;
		this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
	}
	setup(builder) {
		const { colorNode, groundColorNode, lightDirectionNode } = this;
		const hemiDiffuseWeight = normalWorld$1.dot(lightDirectionNode).mul(.5).add(.5);
		const irradiance = mix$2(groundColorNode, colorNode, hemiDiffuseWeight);
		builder.context.irradiance.addAssign(irradiance);
	}
};
/**
* Module for representing light probes as nodes.
*
* @augments AnalyticLightNode
*/
var LightProbeNode = class extends AnalyticLightNode {
	static get type() {
		return "LightProbeNode";
	}
	/**
	* Constructs a new light probe node.
	*
	* @param {?LightProbe} [light=null] - The light probe.
	*/
	constructor(light = null) {
		super(light);
		const array$2 = [];
		for (let i = 0; i < 9; i++) array$2.push(new Vector3());
		/**
		* Light probe represented as a uniform of spherical harmonics.
		*
		* @type {UniformArrayNode}
		*/
		this.lightProbe = uniformArray$1(array$2);
	}
	/**
	* Overwritten to updated light probe specific uniforms.
	*
	* @param {NodeFrame} frame - A reference to the current node frame.
	*/
	update(frame) {
		const { light } = this;
		super.update(frame);
		for (let i = 0; i < 9; i++) this.lightProbe.array[i].copy(light.sh.coefficients[i]).multiplyScalar(light.intensity);
	}
	setup(builder) {
		const irradiance = getShIrradianceAt$1(normalWorld$1, this.lightProbe);
		builder.context.irradiance.addAssign(irradiance);
	}
};
/**
* Base class for node parsers. A derived parser must be implemented
* for each supported native shader language.
*/
var NodeParser = class {
	/**
	* The method parses the given native code an returns a node function.
	*
	* @abstract
	* @param {string} source - The native shader code.
	* @return {NodeFunction} A node function.
	*/
	parseFunction() {
		warn("Abstract function.");
	}
};
/**
* Base class for node functions. A derived module must be implemented
* for each supported native shader language. Similar to other `Node*` modules,
* this class is only relevant during the building process and not used
* in user-level code.
*/
var NodeFunction = class {
	/**
	* Constructs a new node function.
	*
	* @param {string} type - The node type. This type is the return type of the node function.
	* @param {Array<NodeFunctionInput>} inputs - The function's inputs.
	* @param {string} [name=''] - The function's name.
	* @param {string} [precision=''] - The precision qualifier.
	*/
	constructor(type$1, inputs, name = "", precision = "") {
		/**
		* The node type. This type is the return type of the node function.
		*
		* @type {string}
		*/
		this.type = type$1;
		/**
		* The function's inputs.
		*
		* @type {Array<NodeFunctionInput>}
		*/
		this.inputs = inputs;
		/**
		* The name of the uniform.
		*
		* @type {string}
		* @default ''
		*/
		this.name = name;
		/**
		* The precision qualifier.
		*
		* @type {string}
		* @default ''
		*/
		this.precision = precision;
	}
	/**
	* This method returns the native code of the node function.
	*
	* @abstract
	* @param {string} name - The function's name.
	* @return {string} A shader code.
	*/
	getCode() {
		warn("Abstract function.");
	}
};
NodeFunction.isNodeFunction = true;
var declarationRegexp$1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
var propertiesRegexp$1 = /[a-z_0-9]+/gi;
var pragmaMain = "#pragma main";
var parse$1 = (source) => {
	source = source.trim();
	const pragmaMainIndex = source.indexOf(pragmaMain);
	const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + 12) : source;
	const declaration = mainCode.match(declarationRegexp$1);
	if (declaration !== null && declaration.length === 5) {
		const inputsCode = declaration[4];
		const propsMatches = [];
		let nameMatch = null;
		while ((nameMatch = propertiesRegexp$1.exec(inputsCode)) !== null) propsMatches.push(nameMatch);
		const inputs = [];
		let i = 0;
		while (i < propsMatches.length) {
			const isConst = propsMatches[i][0] === "const";
			if (isConst === true) i++;
			let qualifier = propsMatches[i][0];
			if (qualifier === "in" || qualifier === "out" || qualifier === "inout") i++;
			else qualifier = "";
			const type$2 = propsMatches[i++][0];
			let count = Number.parseInt(propsMatches[i][0]);
			if (Number.isNaN(count) === false) i++;
			else count = null;
			const name$1 = propsMatches[i++][0];
			inputs.push(new NodeFunctionInput(type$2, name$1, count, qualifier, isConst));
		}
		const blockCode = mainCode.substring(declaration[0].length);
		const name = declaration[3] !== void 0 ? declaration[3] : "";
		const type$1 = declaration[2];
		const precision = declaration[1] !== void 0 ? declaration[1] : "";
		const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : "";
		return {
			type: type$1,
			inputs,
			name,
			precision,
			inputsCode,
			blockCode,
			headerCode
		};
	} else throw new Error("FunctionNode: Function is not a GLSL code.");
};
/**
* This class represents a GLSL node function.
*
* @augments NodeFunction
*/
var GLSLNodeFunction = class extends NodeFunction {
	/**
	* Constructs a new GLSL node function.
	*
	* @param {string} source - The GLSL source.
	*/
	constructor(source) {
		const { type: type$1, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1(source);
		super(type$1, inputs, name, precision);
		this.inputsCode = inputsCode;
		this.blockCode = blockCode;
		this.headerCode = headerCode;
	}
	/**
	* This method returns the GLSL code of the node function.
	*
	* @param {string} [name=this.name] - The function's name.
	* @return {string} The shader code.
	*/
	getCode(name = this.name) {
		let code$2;
		const blockCode = this.blockCode;
		if (blockCode !== "") {
			const { type: type$1, inputsCode, headerCode, precision } = this;
			let declarationCode = `${type$1} ${name} ( ${inputsCode.trim()} )`;
			if (precision !== "") declarationCode = `${precision} ${declarationCode}`;
			code$2 = headerCode + declarationCode + blockCode;
		} else code$2 = "";
		return code$2;
	}
};
/**
* A GLSL node parser.
*
* @augments NodeParser
*/
var GLSLNodeParser = class extends NodeParser {
	/**
	* The method parses the given GLSL code an returns a node function.
	*
	* @param {string} source - The GLSL code.
	* @return {GLSLNodeFunction} A node function.
	*/
	parseFunction(source) {
		return new GLSLNodeFunction(source);
	}
};
var _outputNodeMap = /* @__PURE__ */ new WeakMap();
var _chainKeys$2 = [];
var _cacheKeyValues = [];
/**
* This renderer module manages node-related objects and is the
* primary interface between the renderer and the node system.
*
* @private
* @augments DataMap
*/
var Nodes = class extends DataMap {
	/**
	* Constructs a new nodes management component.
	*
	* @param {Renderer} renderer - The renderer.
	* @param {Backend} backend - The renderer's backend.
	*/
	constructor(renderer, backend) {
		super();
		/**
		* The renderer.
		*
		* @type {Renderer}
		*/
		this.renderer = renderer;
		/**
		* The renderer's backend.
		*
		* @type {Backend}
		*/
		this.backend = backend;
		/**
		* The node frame.
		*
		* @type {Renderer}
		*/
		this.nodeFrame = new NodeFrame();
		/**
		* A cache for managing node builder states.
		*
		* @type {Map<number,NodeBuilderState>}
		*/
		this.nodeBuilderCache = /* @__PURE__ */ new Map();
		/**
		* A cache for managing data cache key data.
		*
		* @type {ChainMap}
		*/
		this.callHashCache = new ChainMap();
		/**
		* A cache for managing node uniforms group data.
		*
		* @type {ChainMap}
		*/
		this.groupsData = new ChainMap();
		/**
		* A cache for managing node objects of
		* scene properties like fog or environments.
		*
		* @type {Object<string,WeakMap>}
		*/
		this.cacheLib = {};
	}
	/**
	* Returns `true` if the given node uniforms group must be updated or not.
	*
	* @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
	* @return {boolean} Whether the node uniforms group requires an update or not.
	*/
	updateGroup(nodeUniformsGroup) {
		const groupNode = nodeUniformsGroup.groupNode;
		const name = groupNode.name;
		if (name === objectGroup$1.name) return true;
		if (name === renderGroup$1.name) {
			const uniformsGroupData = this.get(nodeUniformsGroup);
			const renderId = this.nodeFrame.renderId;
			if (uniformsGroupData.renderId !== renderId) {
				uniformsGroupData.renderId = renderId;
				return true;
			}
			return false;
		}
		if (name === frameGroup$1.name) {
			const uniformsGroupData = this.get(nodeUniformsGroup);
			const frameId$2 = this.nodeFrame.frameId;
			if (uniformsGroupData.frameId !== frameId$2) {
				uniformsGroupData.frameId = frameId$2;
				return true;
			}
			return false;
		}
		_chainKeys$2[0] = groupNode;
		_chainKeys$2[1] = nodeUniformsGroup;
		let groupData = this.groupsData.get(_chainKeys$2);
		if (groupData === void 0) this.groupsData.set(_chainKeys$2, groupData = {});
		_chainKeys$2.length = 0;
		if (groupData.version !== groupNode.version) {
			groupData.version = groupNode.version;
			return true;
		}
		return false;
	}
	/**
	* Returns the cache key for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {number} The cache key.
	*/
	getForRenderCacheKey(renderObject) {
		return renderObject.initialCacheKey;
	}
	/**
	* Returns a node builder state for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {NodeBuilderState} The node builder state.
	*/
	getForRender(renderObject) {
		const renderObjectData = this.get(renderObject);
		let nodeBuilderState = renderObjectData.nodeBuilderState;
		if (nodeBuilderState === void 0) {
			const { nodeBuilderCache } = this;
			const cacheKey = this.getForRenderCacheKey(renderObject);
			nodeBuilderState = nodeBuilderCache.get(cacheKey);
			if (nodeBuilderState === void 0) {
				const createNodeBuilder = (material) => {
					const nodeBuilder$1 = this.backend.createNodeBuilder(renderObject.object, this.renderer);
					nodeBuilder$1.scene = renderObject.scene;
					nodeBuilder$1.material = material;
					nodeBuilder$1.camera = renderObject.camera;
					nodeBuilder$1.context.material = material;
					nodeBuilder$1.lightsNode = renderObject.lightsNode;
					nodeBuilder$1.environmentNode = this.getEnvironmentNode(renderObject.scene);
					nodeBuilder$1.fogNode = this.getFogNode(renderObject.scene);
					nodeBuilder$1.clippingContext = renderObject.clippingContext;
					if (this.renderer.getOutputRenderTarget() ? this.renderer.getOutputRenderTarget().multiview : false) nodeBuilder$1.enableMultiview();
					return nodeBuilder$1;
				};
				let nodeBuilder = createNodeBuilder(renderObject.material);
				try {
					nodeBuilder.build();
				} catch (e) {
					nodeBuilder = createNodeBuilder(new NodeMaterial());
					nodeBuilder.build();
					error("TSL: " + e);
				}
				nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
				nodeBuilderCache.set(cacheKey, nodeBuilderState);
			}
			nodeBuilderState.usedTimes++;
			renderObjectData.nodeBuilderState = nodeBuilderState;
		}
		return nodeBuilderState;
	}
	/**
	* Deletes the given object from the internal data map
	*
	* @param {any} object - The object to delete.
	* @return {?Object} The deleted dictionary.
	*/
	delete(object) {
		if (object.isRenderObject) {
			const nodeBuilderState = this.get(object).nodeBuilderState;
			nodeBuilderState.usedTimes--;
			if (nodeBuilderState.usedTimes === 0) this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
		}
		return super.delete(object);
	}
	/**
	* Returns a node builder state for the given compute node.
	*
	* @param {Node} computeNode - The compute node.
	* @return {NodeBuilderState} The node builder state.
	*/
	getForCompute(computeNode) {
		const computeData = this.get(computeNode);
		let nodeBuilderState = computeData.nodeBuilderState;
		if (nodeBuilderState === void 0) {
			const nodeBuilder = this.backend.createNodeBuilder(computeNode, this.renderer);
			nodeBuilder.build();
			nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
			computeData.nodeBuilderState = nodeBuilderState;
		}
		return nodeBuilderState;
	}
	/**
	* Creates a node builder state for the given node builder.
	*
	* @private
	* @param {NodeBuilder} nodeBuilder - The node builder.
	* @return {NodeBuilderState} The node builder state.
	*/
	_createNodeBuilderState(nodeBuilder) {
		return new NodeBuilderState(nodeBuilder.vertexShader, nodeBuilder.fragmentShader, nodeBuilder.computeShader, nodeBuilder.getAttributesArray(), nodeBuilder.getBindings(), nodeBuilder.updateNodes, nodeBuilder.updateBeforeNodes, nodeBuilder.updateAfterNodes, nodeBuilder.observer, nodeBuilder.transforms);
	}
	/**
	* Returns an environment node for the current configured
	* scene environment.
	*
	* @param {Scene} scene - The scene.
	* @return {Node} A node representing the current scene environment.
	*/
	getEnvironmentNode(scene) {
		this.updateEnvironment(scene);
		let environmentNode = null;
		if (scene.environmentNode && scene.environmentNode.isNode) environmentNode = scene.environmentNode;
		else {
			const sceneData = this.get(scene);
			if (sceneData.environmentNode) environmentNode = sceneData.environmentNode;
		}
		return environmentNode;
	}
	/**
	* Returns a background node for the current configured
	* scene background.
	*
	* @param {Scene} scene - The scene.
	* @return {Node} A node representing the current scene background.
	*/
	getBackgroundNode(scene) {
		this.updateBackground(scene);
		let backgroundNode = null;
		if (scene.backgroundNode && scene.backgroundNode.isNode) backgroundNode = scene.backgroundNode;
		else {
			const sceneData = this.get(scene);
			if (sceneData.backgroundNode) backgroundNode = sceneData.backgroundNode;
		}
		return backgroundNode;
	}
	/**
	* Returns a fog node for the current configured scene fog.
	*
	* @param {Scene} scene - The scene.
	* @return {Node} A node representing the current scene fog.
	*/
	getFogNode(scene) {
		this.updateFog(scene);
		return scene.fogNode || this.get(scene).fogNode || null;
	}
	/**
	* Returns a cache key for the given scene and lights node.
	* This key is used by `RenderObject` as a part of the dynamic
	* cache key (a key that must be checked every time the render
	* objects is drawn).
	*
	* @param {Scene} scene - The scene.
	* @param {LightsNode} lightsNode - The lights node.
	* @return {number} The cache key.
	*/
	getCacheKey(scene, lightsNode) {
		_chainKeys$2[0] = scene;
		_chainKeys$2[1] = lightsNode;
		const callId = this.renderer.info.calls;
		const cacheKeyData = this.callHashCache.get(_chainKeys$2) || {};
		if (cacheKeyData.callId !== callId) {
			const environmentNode = this.getEnvironmentNode(scene);
			const fogNode = this.getFogNode(scene);
			if (lightsNode) _cacheKeyValues.push(lightsNode.getCacheKey(true));
			if (environmentNode) _cacheKeyValues.push(environmentNode.getCacheKey());
			if (fogNode) _cacheKeyValues.push(fogNode.getCacheKey());
			_cacheKeyValues.push(this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview ? 1 : 0);
			_cacheKeyValues.push(this.renderer.shadowMap.enabled ? 1 : 0);
			_cacheKeyValues.push(this.renderer.shadowMap.type);
			cacheKeyData.callId = callId;
			cacheKeyData.cacheKey = hashArray(_cacheKeyValues);
			this.callHashCache.set(_chainKeys$2, cacheKeyData);
			_cacheKeyValues.length = 0;
		}
		_chainKeys$2.length = 0;
		return cacheKeyData.cacheKey;
	}
	/**
	* A boolean that indicates whether tone mapping should be enabled
	* or not.
	*
	* @type {boolean}
	*/
	get isToneMappingState() {
		return this.renderer.getRenderTarget() ? false : true;
	}
	/**
	* If a scene background is configured, this method makes sure to
	* represent the background with a corresponding node-based implementation.
	*
	* @param {Scene} scene - The scene.
	*/
	updateBackground(scene) {
		const sceneData = this.get(scene);
		const background = scene.background;
		if (background) {
			const forceUpdate = scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 || scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0;
			if (sceneData.background !== background || forceUpdate) {
				sceneData.backgroundNode = this.getCacheNode("background", background, () => {
					if (background.isCubeTexture === true || background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping) if (scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping) return pmremTexture$1(background);
					else {
						let envMap;
						if (background.isCubeTexture === true) envMap = cubeTexture$1(background);
						else envMap = texture$1(background);
						return cubeMapNode(envMap);
					}
					else if (background.isTexture === true) return texture$1(background, screenUV$1.flipY()).setUpdateMatrix(true);
					else if (background.isColor !== true) error("WebGPUNodes: Unsupported background configuration.", background);
				}, forceUpdate);
				sceneData.background = background;
				sceneData.backgroundBlurriness = scene.backgroundBlurriness;
			}
		} else if (sceneData.backgroundNode) {
			delete sceneData.backgroundNode;
			delete sceneData.background;
		}
	}
	/**
	* This method is part of the caching of nodes which are used to represents the
	* scene's background, fog or environment.
	*
	* @param {string} type - The type of object to cache.
	* @param {Object} object - The object.
	* @param {Function} callback - A callback that produces a node representation for the given object.
	* @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.
	* @return {Node} The node representation.
	*/
	getCacheNode(type$1, object, callback, forceUpdate = false) {
		const nodeCache = this.cacheLib[type$1] || (this.cacheLib[type$1] = /* @__PURE__ */ new WeakMap());
		let node = nodeCache.get(object);
		if (node === void 0 || forceUpdate) {
			node = callback();
			nodeCache.set(object, node);
		}
		return node;
	}
	/**
	* If a scene fog is configured, this method makes sure to
	* represent the fog with a corresponding node-based implementation.
	*
	* @param {Scene} scene - The scene.
	*/
	updateFog(scene) {
		const sceneData = this.get(scene);
		const sceneFog = scene.fog;
		if (sceneFog) {
			if (sceneData.fog !== sceneFog) {
				sceneData.fogNode = this.getCacheNode("fog", sceneFog, () => {
					if (sceneFog.isFogExp2) {
						const color$2 = reference$2("color", "color", sceneFog).setGroup(renderGroup$1);
						const density = reference$2("density", "float", sceneFog).setGroup(renderGroup$1);
						return fog$1(color$2, densityFogFactor$1(density));
					} else if (sceneFog.isFog) {
						const color$2 = reference$2("color", "color", sceneFog).setGroup(renderGroup$1);
						const near = reference$2("near", "float", sceneFog).setGroup(renderGroup$1);
						const far = reference$2("far", "float", sceneFog).setGroup(renderGroup$1);
						return fog$1(color$2, rangeFogFactor$1(near, far));
					} else error("Renderer: Unsupported fog configuration.", sceneFog);
				});
				sceneData.fog = sceneFog;
			}
		} else {
			delete sceneData.fogNode;
			delete sceneData.fog;
		}
	}
	/**
	* If a scene environment is configured, this method makes sure to
	* represent the environment with a corresponding node-based implementation.
	*
	* @param {Scene} scene - The scene.
	*/
	updateEnvironment(scene) {
		const sceneData = this.get(scene);
		const environment$1 = scene.environment;
		if (environment$1) {
			if (sceneData.environment !== environment$1) {
				sceneData.environmentNode = this.getCacheNode("environment", environment$1, () => {
					if (environment$1.isCubeTexture === true) return cubeTexture$1(environment$1);
					else if (environment$1.isTexture === true) return texture$1(environment$1);
					else error("Nodes: Unsupported environment configuration.", environment$1);
				});
				sceneData.environment = environment$1;
			}
		} else if (sceneData.environmentNode) {
			delete sceneData.environmentNode;
			delete sceneData.environment;
		}
	}
	getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {
		const nodeFrame = this.nodeFrame;
		nodeFrame.renderer = renderer;
		nodeFrame.scene = scene;
		nodeFrame.object = object;
		nodeFrame.camera = camera;
		nodeFrame.material = material;
		return nodeFrame;
	}
	getNodeFrameForRender(renderObject) {
		return this.getNodeFrame(renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material);
	}
	/**
	* Returns the current output cache key.
	*
	* @return {string} The output cache key.
	*/
	getOutputCacheKey() {
		const renderer = this.renderer;
		return renderer.toneMapping + "," + renderer.currentColorSpace + "," + renderer.xr.isPresenting;
	}
	/**
	* Checks if the output configuration (tone mapping and color space) for
	* the given target has changed.
	*
	* @param {Texture} outputTarget - The output target.
	* @return {boolean} Whether the output configuration has changed or not.
	*/
	hasOutputChange(outputTarget) {
		return _outputNodeMap.get(outputTarget) !== this.getOutputCacheKey();
	}
	/**
	* Returns a node that represents the output configuration (tone mapping and
	* color space) for the current target.
	*
	* @param {Texture} outputTarget - The output target.
	* @return {Node} The output node.
	*/
	getOutputNode(outputTarget) {
		const renderer = this.renderer;
		const cacheKey = this.getOutputCacheKey();
		const output$2 = outputTarget.isArrayTexture ? texture3D$1(outputTarget, vec3$1(screenUV$1, builtin$1("gl_ViewID_OVR"))).renderOutput(renderer.toneMapping, renderer.currentColorSpace) : texture$1(outputTarget, screenUV$1).renderOutput(renderer.toneMapping, renderer.currentColorSpace);
		_outputNodeMap.set(outputTarget, cacheKey);
		return output$2;
	}
	/**
	* Triggers the call of `updateBefore()` methods
	* for all nodes of the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	*/
	updateBefore(renderObject) {
		const nodeBuilder = renderObject.getNodeBuilderState();
		for (const node of nodeBuilder.updateBeforeNodes) this.getNodeFrameForRender(renderObject).updateBeforeNode(node);
	}
	/**
	* Triggers the call of `updateAfter()` methods
	* for all nodes of the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	*/
	updateAfter(renderObject) {
		const nodeBuilder = renderObject.getNodeBuilderState();
		for (const node of nodeBuilder.updateAfterNodes) this.getNodeFrameForRender(renderObject).updateAfterNode(node);
	}
	/**
	* Triggers the call of `update()` methods
	* for all nodes of the given compute node.
	*
	* @param {Node} computeNode - The compute node.
	*/
	updateForCompute(computeNode) {
		const nodeFrame = this.getNodeFrame();
		const nodeBuilder = this.getForCompute(computeNode);
		for (const node of nodeBuilder.updateNodes) nodeFrame.updateNode(node);
	}
	/**
	* Triggers the call of `update()` methods
	* for all nodes of the given compute node.
	*
	* @param {RenderObject} renderObject - The render object.
	*/
	updateForRender(renderObject) {
		const nodeFrame = this.getNodeFrameForRender(renderObject);
		const nodeBuilder = renderObject.getNodeBuilderState();
		for (const node of nodeBuilder.updateNodes) nodeFrame.updateNode(node);
	}
	/**
	* Returns `true` if the given render object requires a refresh.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {boolean} Whether the given render object requires a refresh or not.
	*/
	needsRefresh(renderObject) {
		const nodeFrame = this.getNodeFrameForRender(renderObject);
		return renderObject.getMonitor().needsRefresh(renderObject, nodeFrame);
	}
	/**
	* Frees the internal resources.
	*/
	dispose() {
		super.dispose();
		this.nodeFrame = new NodeFrame();
		this.nodeBuilderCache = /* @__PURE__ */ new Map();
		this.cacheLib = {};
	}
};
var _plane = /* @__PURE__ */ new Plane();
/**
* Represents the state that is used to perform clipping via clipping planes.
* There is a default clipping context for each render context. When the
* scene holds instances of `ClippingGroup`, there will be a context for each
* group.
*
* @private
*/
var ClippingContext = class ClippingContext {
	/**
	* Constructs a new clipping context.
	*
	* @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.
	*/
	constructor(parentContext = null) {
		/**
		* The clipping context's version.
		*
		* @type {number}
		* @readonly
		*/
		this.version = 0;
		/**
		* Whether the intersection of the clipping planes is used to clip objects, rather than their union.
		*
		* @type {?boolean}
		* @default null
		*/
		this.clipIntersection = null;
		/**
		* The clipping context's cache key.
		*
		* @type {string}
		*/
		this.cacheKey = "";
		/**
		* Whether the shadow pass is active or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.shadowPass = false;
		/**
		* The view normal matrix.
		*
		* @type {Matrix3}
		*/
		this.viewNormalMatrix = new Matrix3();
		/**
		* Internal cache for maintaining clipping contexts.
		*
		* @type {WeakMap<ClippingGroup,ClippingContext>}
		*/
		this.clippingGroupContexts = /* @__PURE__ */ new WeakMap();
		/**
		* The intersection planes.
		*
		* @type {Array<Vector4>}
		*/
		this.intersectionPlanes = [];
		/**
		* The intersection planes.
		*
		* @type {Array<Vector4>}
		*/
		this.unionPlanes = [];
		/**
		* The version of the clipping context's parent context.
		*
		* @type {?number}
		* @readonly
		*/
		this.parentVersion = null;
		if (parentContext !== null) {
			this.viewNormalMatrix = parentContext.viewNormalMatrix;
			this.clippingGroupContexts = parentContext.clippingGroupContexts;
			this.shadowPass = parentContext.shadowPass;
			this.viewMatrix = parentContext.viewMatrix;
		}
	}
	/**
	* Projects the given source clipping planes and writes the result into the
	* destination array.
	*
	* @param {Array<Plane>} source - The source clipping planes.
	* @param {Array<Vector4>} destination - The destination.
	* @param {number} offset - The offset.
	*/
	projectPlanes(source, destination, offset) {
		const l = source.length;
		for (let i = 0; i < l; i++) {
			_plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
			const v = destination[offset + i];
			const normal$1 = _plane.normal;
			v.x = -normal$1.x;
			v.y = -normal$1.y;
			v.z = -normal$1.z;
			v.w = _plane.constant;
		}
	}
	/**
	* Updates the root clipping context of a scene.
	*
	* @param {Scene} scene - The scene.
	* @param {Camera} camera - The camera that is used to render the scene.
	*/
	updateGlobal(scene, camera) {
		this.shadowPass = scene.overrideMaterial !== null && scene.overrideMaterial.isShadowPassMaterial;
		this.viewMatrix = camera.matrixWorldInverse;
		this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
	}
	/**
	* Updates the clipping context.
	*
	* @param {ClippingContext} parentContext - The parent context.
	* @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
	*/
	update(parentContext, clippingGroup) {
		let update = false;
		if (parentContext.version !== this.parentVersion) {
			this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);
			this.unionPlanes = Array.from(parentContext.unionPlanes);
			this.parentVersion = parentContext.version;
		}
		if (this.clipIntersection !== clippingGroup.clipIntersection) {
			this.clipIntersection = clippingGroup.clipIntersection;
			if (this.clipIntersection) this.unionPlanes.length = parentContext.unionPlanes.length;
			else this.intersectionPlanes.length = parentContext.intersectionPlanes.length;
		}
		const srcClippingPlanes = clippingGroup.clippingPlanes;
		const l = srcClippingPlanes.length;
		let dstClippingPlanes;
		let offset;
		if (this.clipIntersection) {
			dstClippingPlanes = this.intersectionPlanes;
			offset = parentContext.intersectionPlanes.length;
		} else {
			dstClippingPlanes = this.unionPlanes;
			offset = parentContext.unionPlanes.length;
		}
		if (dstClippingPlanes.length !== offset + l) {
			dstClippingPlanes.length = offset + l;
			for (let i = 0; i < l; i++) dstClippingPlanes[offset + i] = new Vector4();
			update = true;
		}
		this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);
		if (update) {
			this.version++;
			this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;
		}
	}
	/**
	* Returns a clipping context for the given clipping group.
	*
	* @param {ClippingGroup} clippingGroup - The clipping group.
	* @return {ClippingContext} The clipping context.
	*/
	getGroupContext(clippingGroup) {
		if (this.shadowPass && !clippingGroup.clipShadows) return this;
		let context$2 = this.clippingGroupContexts.get(clippingGroup);
		if (context$2 === void 0) {
			context$2 = new ClippingContext(this);
			this.clippingGroupContexts.set(clippingGroup, context$2);
		}
		context$2.update(this, clippingGroup);
		return context$2;
	}
	/**
	* The count of union clipping planes.
	*
	* @type {number}
	* @readonly
	*/
	get unionClippingCount() {
		return this.unionPlanes.length;
	}
};
/**
* This module is used to represent render bundles inside the renderer
* for further processing.
*
* @private
*/
var RenderBundle = class {
	/**
	* Constructs a new bundle group.
	*
	* @param {BundleGroup} bundleGroup - The bundle group.
	* @param {Camera} camera - The camera the bundle group is rendered with.
	*/
	constructor(bundleGroup, camera) {
		this.bundleGroup = bundleGroup;
		this.camera = camera;
	}
};
var _chainKeys$1 = [];
/**
* This renderer module manages render bundles.
*
* @private
*/
var RenderBundles = class {
	/**
	* Constructs a new render bundle management component.
	*/
	constructor() {
		/**
		* A chain map for maintaining the render bundles.
		*
		* @type {ChainMap}
		*/
		this.bundles = new ChainMap();
	}
	/**
	* Returns a render bundle for the given bundle group and camera.
	*
	* @param {BundleGroup} bundleGroup - The bundle group.
	* @param {Camera} camera - The camera the bundle group is rendered with.
	* @return {RenderBundle} The render bundle.
	*/
	get(bundleGroup, camera) {
		const bundles = this.bundles;
		_chainKeys$1[0] = bundleGroup;
		_chainKeys$1[1] = camera;
		let bundle = bundles.get(_chainKeys$1);
		if (bundle === void 0) {
			bundle = new RenderBundle(bundleGroup, camera);
			bundles.set(_chainKeys$1, bundle);
		}
		_chainKeys$1.length = 0;
		return bundle;
	}
	/**
	* Frees all internal resources.
	*/
	dispose() {
		this.bundles = new ChainMap();
	}
};
/**
* The purpose of a node library is to assign node implementations
* to existing library features. In `WebGPURenderer` lights, materials
* which are not based on `NodeMaterial` as well as tone mapping techniques
* are implemented with node-based modules.
*
* @private
*/
var NodeLibrary = class {
	/**
	* Constructs a new node library.
	*/
	constructor() {
		/**
		* A weak map that maps lights to light nodes.
		*
		* @type {WeakMap<Light.constructor,AnalyticLightNode.constructor>}
		*/
		this.lightNodes = /* @__PURE__ */ new WeakMap();
		/**
		* A map that maps materials to node materials.
		*
		* @type {Map<string,NodeMaterial.constructor>}
		*/
		this.materialNodes = /* @__PURE__ */ new Map();
		/**
		* A map that maps tone mapping techniques (constants)
		* to tone mapping node functions.
		*
		* @type {Map<number,Function>}
		*/
		this.toneMappingNodes = /* @__PURE__ */ new Map();
	}
	/**
	* Returns a matching node material instance for the given material object.
	*
	* This method also assigns/copies the properties of the given material object
	* to the node material. This is done to make sure the current material
	* configuration carries over to the node version.
	*
	* @param {Material} material - A material.
	* @return {NodeMaterial} The corresponding node material.
	*/
	fromMaterial(material) {
		if (material.isNodeMaterial) return material;
		let nodeMaterial = null;
		const nodeMaterialClass = this.getMaterialNodeClass(material.type);
		if (nodeMaterialClass !== null) {
			nodeMaterial = new nodeMaterialClass();
			for (const key in material) nodeMaterial[key] = material[key];
		}
		return nodeMaterial;
	}
	/**
	* Adds a tone mapping node function for a tone mapping technique (constant).
	*
	* @param {Function} toneMappingNode - The tone mapping node function.
	* @param {number} toneMapping - The tone mapping.
	*/
	addToneMapping(toneMappingNode, toneMapping$2) {
		this.addType(toneMappingNode, toneMapping$2, this.toneMappingNodes);
	}
	/**
	* Returns a tone mapping node function for a tone mapping technique (constant).
	*
	* @param {number} toneMapping - The tone mapping.
	* @return {?Function} The tone mapping node function. Returns `null` if no node function is found.
	*/
	getToneMappingFunction(toneMapping$2) {
		return this.toneMappingNodes.get(toneMapping$2) || null;
	}
	/**
	* Returns a node material class definition for a material type.
	*
	* @param {string} materialType - The material type.
	* @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.
	*/
	getMaterialNodeClass(materialType) {
		return this.materialNodes.get(materialType) || null;
	}
	/**
	* Adds a node material class definition for a given material type.
	*
	* @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
	* @param {string} materialClassType - The material type.
	*/
	addMaterial(materialNodeClass, materialClassType) {
		this.addType(materialNodeClass, materialClassType, this.materialNodes);
	}
	/**
	* Returns a light node class definition for a light class definition.
	*
	* @param {Light.constructor} light - The light class definition.
	* @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.
	*/
	getLightNodeClass(light) {
		return this.lightNodes.get(light) || null;
	}
	/**
	* Adds a light node class definition for a given light class definition.
	*
	* @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
	* @param {Light.constructor} lightClass - The light class definition.
	*/
	addLight(lightNodeClass, lightClass) {
		this.addClass(lightNodeClass, lightClass, this.lightNodes);
	}
	/**
	* Adds a node class definition for the given type to the provided type library.
	*
	* @param {Node.constructor} nodeClass - The node class definition.
	* @param {number|string} type - The object type.
	* @param {Map<number|string,Node.constructor>} library - The type library.
	*/
	addType(nodeClass, type$1, library) {
		if (library.has(type$1)) {
			warn(`Redefinition of node ${type$1}`);
			return;
		}
		if (typeof nodeClass !== "function") throw new Error(`Node class ${nodeClass.name} is not a class.`);
		if (typeof type$1 === "function" || typeof type$1 === "object") throw new Error(`Base class ${type$1} is not a class.`);
		library.set(type$1, nodeClass);
	}
	/**
	* Adds a node class definition for the given class definition to the provided type library.
	*
	* @param {Node.constructor} nodeClass - The node class definition.
	* @param {Node.constructor} baseClass - The class definition.
	* @param {WeakMap<Node.constructor, Node.constructor>} library - The type library.
	*/
	addClass(nodeClass, baseClass, library) {
		if (library.has(baseClass)) {
			warn(`Redefinition of node ${baseClass.name}`);
			return;
		}
		if (typeof nodeClass !== "function") throw new Error(`Node class ${nodeClass.name} is not a class.`);
		if (typeof baseClass !== "function") throw new Error(`Base class ${baseClass.name} is not a class.`);
		library.set(baseClass, nodeClass);
	}
};
var _defaultLights = /* @__PURE__ */ new LightsNode();
var _chainKeys = [];
/**
* This renderer module manages the lights nodes which are unique
* per scene and camera combination.
*
* The lights node itself is later configured in the render list
* with the actual lights from the scene.
*
* @private
* @augments ChainMap
*/
var Lighting = class extends ChainMap {
	/**
	* Constructs a lighting management component.
	*/
	constructor() {
		super();
	}
	/**
	* Creates a new lights node for the given array of lights.
	*
	* @param {Array<Light>} lights - The render object.
	* @return {LightsNode} The lights node.
	*/
	createNode(lights$2 = []) {
		return new LightsNode().setLights(lights$2);
	}
	/**
	* Returns a lights node for the given scene and camera.
	*
	* @param {Scene} scene - The scene.
	* @param {Camera} camera - The camera.
	* @return {LightsNode} The lights node.
	*/
	getNode(scene, camera) {
		if (scene.isQuadMesh) return _defaultLights;
		_chainKeys[0] = scene;
		_chainKeys[1] = camera;
		let node = this.get(_chainKeys);
		if (node === void 0) {
			node = this.createNode();
			this.set(_chainKeys, node);
		}
		_chainKeys.length = 0;
		return node;
	}
};
/**
* A special type of render target that is used when rendering
* with the WebXR Device API.
*
* @private
* @augments RenderTarget
*/
var XRRenderTarget = class extends RenderTarget {
	/**
	* Constructs a new XR render target.
	*
	* @param {number} [width=1] - The width of the render target.
	* @param {number} [height=1] - The height of the render target.
	* @param {Object} [options={}] - The configuration options.
	*/
	constructor(width = 1, height = 1, options = {}) {
		super(width, height, options);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isXRRenderTarget = true;
		/**
		* Whether the attachments of the render target
		* are defined by external textures. This flag is
		* set to `true` when using the WebXR Layers API.
		*
		* @private
		* @type {boolean}
		* @default false
		*/
		this._hasExternalTextures = false;
		/**
		* Whether a depth buffer should automatically be allocated
		* for this XR render target or not.
		*
		* Allocating a depth buffer is the default behavior of XR render
		* targets. However, when using the WebXR Layers API, this flag
		* must be set to `false` when the `ignoreDepthValues` property of
		* the projection layers evaluates to `false`.
		*
		* Reference: {@link https://www.w3.org/TR/webxrlayers-1/#dom-xrprojectionlayer-ignoredepthvalues}.
		*
		* @private
		* @type {boolean}
		* @default true
		*/
		this._autoAllocateDepthBuffer = true;
		/**
		* Whether this render target is associated with a XRWebGLLayer.
		*
		* A XRWebGLLayer points to an opaque framebuffer. Basically,
		* this means that you don't have access to its bound color,
		* stencil and depth buffers. We need to handle this framebuffer
		* differently since its textures are always bound.
		*
		* @private
		* @type {boolean}
		* @default false
		* */
		this._isOpaqueFramebuffer = false;
	}
	copy(source) {
		super.copy(source);
		this._hasExternalTextures = source._hasExternalTextures;
		this._autoAllocateDepthBuffer = source._autoAllocateDepthBuffer;
		this._isOpaqueFramebuffer = source._isOpaqueFramebuffer;
		return this;
	}
};
var _cameraLPos = /* @__PURE__ */ new Vector3();
var _cameraRPos = /* @__PURE__ */ new Vector3();
/**
* The XR manager is built on top of the WebXR Device API to
* manage XR sessions with `WebGPURenderer`.
*
* XR is currently only supported with a WebGL 2 backend.
*
* @augments EventDispatcher
*/
var XRManager = class extends EventDispatcher {
	/**
	* Constructs a new XR manager.
	*
	* @param {Renderer} renderer - The renderer.
	* @param {boolean} [multiview=false] - Enables multiview if the device supports it.
	*/
	constructor(renderer, multiview = false) {
		super();
		/**
		* This flag globally enables XR rendering.
		*
		* @type {boolean}
		* @default false
		*/
		this.enabled = false;
		/**
		* Whether the XR device is currently presenting or not.
		*
		* @type {boolean}
		* @default false
		* @readonly
		*/
		this.isPresenting = false;
		/**
		* Whether the XR camera should automatically be updated or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.cameraAutoUpdate = true;
		/**
		* The renderer.
		*
		* @private
		* @type {Renderer}
		*/
		this._renderer = renderer;
		/**
		* Represents the camera for the left eye.
		*
		* @private
		* @type {PerspectiveCamera}
		*/
		this._cameraL = new PerspectiveCamera();
		this._cameraL.viewport = new Vector4();
		/**
		* Represents the camera for the right eye.
		*
		* @private
		* @type {PerspectiveCamera}
		*/
		this._cameraR = new PerspectiveCamera();
		this._cameraR.viewport = new Vector4();
		/**
		* A list of cameras used for rendering the XR views.
		*
		* @private
		* @type {Array<Camera>}
		*/
		this._cameras = [this._cameraL, this._cameraR];
		/**
		* The main XR camera.
		*
		* @private
		* @type {ArrayCamera}
		*/
		this._cameraXR = new ArrayCamera();
		/**
		* The current near value of the XR camera.
		*
		* @private
		* @type {?number}
		* @default null
		*/
		this._currentDepthNear = null;
		/**
		* The current far value of the XR camera.
		*
		* @private
		* @type {?number}
		* @default null
		*/
		this._currentDepthFar = null;
		/**
		* A list of WebXR controllers requested by the application.
		*
		* @private
		* @type {Array<WebXRController>}
		*/
		this._controllers = [];
		/**
		* A list of XR input source. Each input source belongs to
		* an instance of WebXRController.
		*
		* @private
		* @type {Array<XRInputSource?>}
		*/
		this._controllerInputSources = [];
		/**
		* The XR render target that represents the rendering destination
		* during an active XR session.
		*
		* @private
		* @type {?RenderTarget}
		* @default null
		*/
		this._xrRenderTarget = null;
		/**
		* An array holding all the non-projection layers
		*
		* @private
		* @type {Array<Object>}
		* @default []
		*/
		this._layers = [];
		/**
		* Whether the XR session uses layers.
		*
		* @type {boolean}
		* @default false
		*/
		this._sessionUsesLayers = false;
		/**
		* Whether the device supports binding gl objects.
		*
		* @private
		* @type {boolean}
		* @readonly
		*/
		this._supportsGlBinding = typeof XRWebGLBinding !== "undefined";
		this._frameBufferTargets = null;
		/**
		* Helper function to create native WebXR Layer.
		*
		* @private
		* @type {Function}
		*/
		this._createXRLayer = createXRLayer.bind(this);
		/**
		* The current WebGL context.
		*
		* @private
		* @type {?WebGL2RenderingContext}
		* @default null
		*/
		this._gl = null;
		/**
		* The current animation context.
		*
		* @private
		* @type {?Window}
		* @default null
		*/
		this._currentAnimationContext = null;
		/**
		* The current animation loop.
		*
		* @private
		* @type {?Function}
		* @default null
		*/
		this._currentAnimationLoop = null;
		/**
		* The current pixel ratio.
		*
		* @private
		* @type {?number}
		* @default null
		*/
		this._currentPixelRatio = null;
		/**
		* The current size of the renderer's canvas
		* in logical pixel unit.
		*
		* @private
		* @type {Vector2}
		*/
		this._currentSize = new Vector2();
		/**
		* The default event listener for handling events inside a XR session.
		*
		* @private
		* @type {Function}
		*/
		this._onSessionEvent = onSessionEvent.bind(this);
		/**
		* The event listener for handling the end of a XR session.
		*
		* @private
		* @type {Function}
		*/
		this._onSessionEnd = onSessionEnd.bind(this);
		/**
		* The event listener for handling the `inputsourceschange` event.
		*
		* @private
		* @type {Function}
		*/
		this._onInputSourcesChange = onInputSourcesChange.bind(this);
		/**
		* The animation loop which is used as a replacement for the default
		* animation loop of the application. It is only used when a XR session
		* is active.
		*
		* @private
		* @type {Function}
		*/
		this._onAnimationFrame = onAnimationFrame.bind(this);
		/**
		* The current XR reference space.
		*
		* @private
		* @type {?XRReferenceSpace}
		* @default null
		*/
		this._referenceSpace = null;
		/**
		* The current XR reference space type.
		*
		* @private
		* @type {XRReferenceSpaceType}
		* @default 'local-floor'
		*/
		this._referenceSpaceType = "local-floor";
		/**
		* A custom reference space defined by the application.
		*
		* @private
		* @type {?XRReferenceSpace}
		* @default null
		*/
		this._customReferenceSpace = null;
		/**
		* The framebuffer scale factor.
		*
		* @private
		* @type {number}
		* @default 1
		*/
		this._framebufferScaleFactor = 1;
		/**
		* The foveation factor.
		*
		* @private
		* @type {number}
		* @default 1
		*/
		this._foveation = 1;
		/**
		* A reference to the current XR session.
		*
		* @private
		* @type {?XRSession}
		* @default null
		*/
		this._session = null;
		/**
		* A reference to the current XR base layer.
		*
		* @private
		* @type {?XRWebGLLayer}
		* @default null
		*/
		this._glBaseLayer = null;
		/**
		* A reference to the current XR binding.
		*
		* @private
		* @type {?XRWebGLBinding}
		* @default null
		*/
		this._glBinding = null;
		/**
		* A reference to the current XR projection layer.
		*
		* @private
		* @type {?XRProjectionLayer}
		* @default null
		*/
		this._glProjLayer = null;
		/**
		* A reference to the current XR frame.
		*
		* @private
		* @type {?XRFrame}
		* @default null
		*/
		this._xrFrame = null;
		/**
		* Whether the browser supports the APIs necessary to use XRProjectionLayers.
		*
		* Note: this does not represent XRSession explicitly requesting
		* `'layers'` as a feature - see `_sessionUsesLayers` and #30112
		*
		* @private
		* @type {boolean}
		* @readonly
		*/
		this._supportsLayers = this._supportsGlBinding && "createProjectionLayer" in XRWebGLBinding.prototype;
		/**
		* Whether the usage of multiview has been requested by the application or not.
		*
		* @private
		* @type {boolean}
		* @default false
		* @readonly
		*/
		this._useMultiviewIfPossible = multiview;
		/**
		* Whether the usage of multiview is actually enabled. This flag only evaluates to `true`
		* if multiview has been requested by the application and the `OVR_multiview2` is available.
		*
		* @private
		* @type {boolean}
		* @readonly
		*/
		this._useMultiview = false;
	}
	/**
	* Returns an instance of `THREE.Group` that represents the transformation
	* of a XR controller in target ray space. The requested controller is defined
	* by the given index.
	*
	* @param {number} index - The index of the XR controller.
	* @return {Group} A group that represents the controller's transformation.
	*/
	getController(index) {
		return this._getController(index).getTargetRaySpace();
	}
	/**
	* Returns an instance of `THREE.Group` that represents the transformation
	* of a XR controller in grip space. The requested controller is defined
	* by the given index.
	*
	* @param {number} index - The index of the XR controller.
	* @return {Group} A group that represents the controller's transformation.
	*/
	getControllerGrip(index) {
		return this._getController(index).getGripSpace();
	}
	/**
	* Returns an instance of `THREE.Group` that represents the transformation
	* of a XR controller in hand space. The requested controller is defined
	* by the given index.
	*
	* @param {number} index - The index of the XR controller.
	* @return {Group} A group that represents the controller's transformation.
	*/
	getHand(index) {
		return this._getController(index).getHandSpace();
	}
	/**
	* Returns the foveation value.
	*
	* @return {number|undefined} The foveation value. Returns `undefined` if no base or projection layer is defined.
	*/
	getFoveation() {
		if (this._glProjLayer === null && this._glBaseLayer === null) return;
		return this._foveation;
	}
	/**
	* Sets the foveation value.
	*
	* @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
	* and `1` means maximum foveation (the edges render at lower resolution).
	*/
	setFoveation(foveation) {
		this._foveation = foveation;
		if (this._glProjLayer !== null) this._glProjLayer.fixedFoveation = foveation;
		if (this._glBaseLayer !== null && this._glBaseLayer.fixedFoveation !== void 0) this._glBaseLayer.fixedFoveation = foveation;
	}
	/**
	* Returns the framebuffer scale factor.
	*
	* @return {number} The framebuffer scale factor.
	*/
	getFramebufferScaleFactor() {
		return this._framebufferScaleFactor;
	}
	/**
	* Sets the framebuffer scale factor.
	*
	* This method can not be used during a XR session.
	*
	* @param {number} factor - The framebuffer scale factor.
	*/
	setFramebufferScaleFactor(factor) {
		this._framebufferScaleFactor = factor;
		if (this.isPresenting === true) warn("XRManager: Cannot change framebuffer scale while presenting.");
	}
	/**
	* Returns the reference space type.
	*
	* @return {XRReferenceSpaceType} The reference space type.
	*/
	getReferenceSpaceType() {
		return this._referenceSpaceType;
	}
	/**
	* Sets the reference space type.
	*
	* This method can not be used during a XR session.
	*
	* @param {XRReferenceSpaceType} type - The reference space type.
	*/
	setReferenceSpaceType(type$1) {
		this._referenceSpaceType = type$1;
		if (this.isPresenting === true) warn("XRManager: Cannot change reference space type while presenting.");
	}
	/**
	* Returns the XR reference space.
	*
	* @return {XRReferenceSpace} The XR reference space.
	*/
	getReferenceSpace() {
		return this._customReferenceSpace || this._referenceSpace;
	}
	/**
	* Sets a custom XR reference space.
	*
	* @param {XRReferenceSpace} space - The XR reference space.
	*/
	setReferenceSpace(space) {
		this._customReferenceSpace = space;
	}
	/**
	* Returns the XR camera.
	*
	* @return {ArrayCamera} The XR camera.
	*/
	getCamera() {
		return this._cameraXR;
	}
	/**
	* Returns the environment blend mode from the current XR session.
	*
	* @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
	*/
	getEnvironmentBlendMode() {
		if (this._session !== null) return this._session.environmentBlendMode;
	}
	/**
	* Returns the current XR binding.
	*
	* Creates a new binding if needed and the browser is
	* capable of doing so.
	*
	* @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.
	*/
	getBinding() {
		if (this._glBinding === null && this._supportsGlBinding) this._glBinding = new XRWebGLBinding(this._session, this._gl);
		return this._glBinding;
	}
	/**
	* Returns the current XR frame.
	*
	* @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
	*/
	getFrame() {
		return this._xrFrame;
	}
	/**
	* Returns `true` if the engine renders to a multiview target.
	*
	* @return {boolean} Whether the engine renders to a multiview render target or not.
	*/
	useMultiview() {
		return this._useMultiview;
	}
	/**
	* This method can be used in XR applications to create a quadratic layer that presents a separate
	* rendered scene.
	*
	* @param {number} width - The width of the layer plane in world units.
	* @param {number} height - The height of the layer plane in world units.
	* @param {Vector3} translation - The position/translation of the layer plane in world units.
	* @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
	* @param {number} pixelwidth - The width of the layer's render target in pixels.
	* @param {number} pixelheight - The height of the layer's render target in pixels.
	* @param {Function} rendercall - A callback function that renders the layer. Similar to code in
	* the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
	* @param {Object} [attributes={}] - Allows to configure the layer's render target.
	* @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.
	*/
	createQuadLayer(width, height, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {}) {
		const geometry = new PlaneGeometry(width, height);
		const renderTarget = new XRRenderTarget(pixelwidth, pixelheight, {
			format: RGBAFormat,
			type: UnsignedByteType,
			depthTexture: new DepthTexture(pixelwidth, pixelheight, attributes.stencil ? UnsignedInt248Type : UnsignedIntType, void 0, void 0, void 0, void 0, void 0, void 0, attributes.stencil ? DepthStencilFormat : DepthFormat),
			stencilBuffer: attributes.stencil,
			resolveDepthBuffer: false,
			resolveStencilBuffer: false
		});
		renderTarget._autoAllocateDepthBuffer = true;
		const material = new MeshBasicMaterial({
			color: 16777215,
			side: FrontSide
		});
		material.map = renderTarget.texture;
		material.map.offset.y = 1;
		material.map.repeat.y = -1;
		const plane = new Mesh(geometry, material);
		plane.position.copy(translation);
		plane.quaternion.copy(quaternion);
		const layer = {
			type: "quad",
			width,
			height,
			translation,
			quaternion,
			pixelwidth,
			pixelheight,
			plane,
			material,
			rendercall,
			renderTarget
		};
		this._layers.push(layer);
		if (this._session !== null) {
			layer.plane.material = new MeshBasicMaterial({
				color: 16777215,
				side: FrontSide
			});
			layer.plane.material.blending = CustomBlending;
			layer.plane.material.blendEquation = AddEquation;
			layer.plane.material.blendSrc = ZeroFactor;
			layer.plane.material.blendDst = ZeroFactor;
			layer.xrlayer = this._createXRLayer(layer);
			const xrlayers = this._session.renderState.layers;
			xrlayers.unshift(layer.xrlayer);
			this._session.updateRenderState({ layers: xrlayers });
		} else renderTarget.isXRRenderTarget = false;
		return plane;
	}
	/**
	* This method can be used in XR applications to create a cylindrical layer that presents a separate
	* rendered scene.
	*
	* @param {number} radius - The radius of the cylinder in world units.
	* @param {number} centralAngle - The central angle of the cylinder in radians.
	* @param {number} aspectratio - The aspect ratio.
	* @param {Vector3} translation - The position/translation of the layer plane in world units.
	* @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
	* @param {number} pixelwidth - The width of the layer's render target in pixels.
	* @param {number} pixelheight - The height of the layer's render target in pixels.
	* @param {Function} rendercall - A callback function that renders the layer. Similar to code in
	* the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
	* @param {Object} [attributes={}] - Allows to configure the layer's render target.
	* @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.
	*/
	createCylinderLayer(radius, centralAngle, aspectratio, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {}) {
		const geometry = new CylinderGeometry(radius, radius, radius * centralAngle / aspectratio, 64, 64, true, Math.PI - centralAngle / 2, centralAngle);
		const renderTarget = new XRRenderTarget(pixelwidth, pixelheight, {
			format: RGBAFormat,
			type: UnsignedByteType,
			depthTexture: new DepthTexture(pixelwidth, pixelheight, attributes.stencil ? UnsignedInt248Type : UnsignedIntType, void 0, void 0, void 0, void 0, void 0, void 0, attributes.stencil ? DepthStencilFormat : DepthFormat),
			stencilBuffer: attributes.stencil,
			resolveDepthBuffer: false,
			resolveStencilBuffer: false
		});
		renderTarget._autoAllocateDepthBuffer = true;
		const material = new MeshBasicMaterial({
			color: 16777215,
			side: BackSide
		});
		material.map = renderTarget.texture;
		material.map.offset.y = 1;
		material.map.repeat.y = -1;
		const plane = new Mesh(geometry, material);
		plane.position.copy(translation);
		plane.quaternion.copy(quaternion);
		const layer = {
			type: "cylinder",
			radius,
			centralAngle,
			aspectratio,
			translation,
			quaternion,
			pixelwidth,
			pixelheight,
			plane,
			material,
			rendercall,
			renderTarget
		};
		this._layers.push(layer);
		if (this._session !== null) {
			layer.plane.material = new MeshBasicMaterial({
				color: 16777215,
				side: BackSide
			});
			layer.plane.material.blending = CustomBlending;
			layer.plane.material.blendEquation = AddEquation;
			layer.plane.material.blendSrc = ZeroFactor;
			layer.plane.material.blendDst = ZeroFactor;
			layer.xrlayer = this._createXRLayer(layer);
			const xrlayers = this._session.renderState.layers;
			xrlayers.unshift(layer.xrlayer);
			this._session.updateRenderState({ layers: xrlayers });
		} else renderTarget.isXRRenderTarget = false;
		return plane;
	}
	/**
	* Renders the XR layers that have been previously added to the scene.
	*
	* This method is usually called in your animation loop before rendering
	* the actual scene via `renderer.render( scene, camera );`.
	*/
	renderLayers() {
		const translationObject = new Vector3();
		const quaternionObject = new Quaternion();
		const renderer = this._renderer;
		const wasPresenting = this.isPresenting;
		const rendererOutputTarget = renderer.getOutputRenderTarget();
		const rendererFramebufferTarget = renderer._frameBufferTarget;
		this.isPresenting = false;
		const rendererSize = new Vector2();
		renderer.getSize(rendererSize);
		const rendererQuad = renderer._quad;
		for (const layer of this._layers) {
			layer.renderTarget.isXRRenderTarget = this._session !== null;
			layer.renderTarget._hasExternalTextures = layer.renderTarget.isXRRenderTarget;
			if (layer.renderTarget.isXRRenderTarget && this._sessionUsesLayers) {
				layer.xrlayer.transform = new XRRigidTransform(layer.plane.getWorldPosition(translationObject), layer.plane.getWorldQuaternion(quaternionObject));
				const glSubImage = this._glBinding.getSubImage(layer.xrlayer, this._xrFrame);
				renderer.backend.setXRRenderTargetTextures(layer.renderTarget, glSubImage.colorTexture, void 0);
				renderer._setXRLayerSize(layer.renderTarget.width, layer.renderTarget.height);
				renderer.setOutputRenderTarget(layer.renderTarget);
				renderer.setRenderTarget(null);
				renderer._frameBufferTarget = null;
				this._frameBufferTargets || (this._frameBufferTargets = /* @__PURE__ */ new WeakMap());
				const { frameBufferTarget, quad } = this._frameBufferTargets.get(layer.renderTarget) || {
					frameBufferTarget: null,
					quad: null
				};
				if (!frameBufferTarget) {
					renderer._quad = new QuadMesh(new NodeMaterial());
					this._frameBufferTargets.set(layer.renderTarget, {
						frameBufferTarget: renderer._getFrameBufferTarget(),
						quad: renderer._quad
					});
				} else {
					renderer._frameBufferTarget = frameBufferTarget;
					renderer._quad = quad;
				}
				layer.rendercall();
				renderer._frameBufferTarget = null;
			} else {
				renderer.setRenderTarget(layer.renderTarget);
				layer.rendercall();
			}
		}
		renderer.setRenderTarget(null);
		renderer.setOutputRenderTarget(rendererOutputTarget);
		renderer._frameBufferTarget = rendererFramebufferTarget;
		renderer._setXRLayerSize(rendererSize.x, rendererSize.y);
		renderer._quad = rendererQuad;
		this.isPresenting = wasPresenting;
	}
	/**
	* Returns the current XR session.
	*
	* @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
	*/
	getSession() {
		return this._session;
	}
	/**
	* After a XR session has been requested usually with one of the `*Button` modules, it
	* is injected into the renderer with this method. This method triggers the start of
	* the actual XR rendering.
	*
	* @async
	* @param {XRSession} session - The XR session to set.
	* @return {Promise} A Promise that resolves when the session has been set.
	*/
	async setSession(session) {
		const renderer = this._renderer;
		const backend = renderer.backend;
		this._gl = renderer.getContext();
		const gl = this._gl;
		const attributes = gl.getContextAttributes();
		this._session = session;
		if (session !== null) {
			if (backend.isWebGPUBackend === true) throw new Error("THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing \"{ forceWebGL: true }\" to the constructor of the renderer.");
			session.addEventListener("select", this._onSessionEvent);
			session.addEventListener("selectstart", this._onSessionEvent);
			session.addEventListener("selectend", this._onSessionEvent);
			session.addEventListener("squeeze", this._onSessionEvent);
			session.addEventListener("squeezestart", this._onSessionEvent);
			session.addEventListener("squeezeend", this._onSessionEvent);
			session.addEventListener("end", this._onSessionEnd);
			session.addEventListener("inputsourceschange", this._onInputSourcesChange);
			await backend.makeXRCompatible();
			this._currentPixelRatio = renderer.getPixelRatio();
			renderer.getSize(this._currentSize);
			this._currentAnimationContext = renderer._animation.getContext();
			this._currentAnimationLoop = renderer._animation.getAnimationLoop();
			renderer._animation.stop();
			if (this._supportsLayers === true) {
				let depthFormat = null;
				let depthType = null;
				let glDepthFormat = null;
				if (renderer.depth) {
					glDepthFormat = renderer.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
					depthFormat = renderer.stencil ? DepthStencilFormat : DepthFormat;
					depthType = renderer.stencil ? UnsignedInt248Type : UnsignedIntType;
				}
				const projectionlayerInit = {
					colorFormat: gl.RGBA8,
					depthFormat: glDepthFormat,
					scaleFactor: this._framebufferScaleFactor,
					clearOnAccess: false
				};
				if (this._useMultiviewIfPossible && renderer.hasFeature("OVR_multiview2")) {
					projectionlayerInit.textureType = "texture-array";
					this._useMultiview = true;
				}
				this._glBinding = this.getBinding();
				const glProjLayer = this._glBinding.createProjectionLayer(projectionlayerInit);
				const layersArray = [glProjLayer];
				this._glProjLayer = glProjLayer;
				renderer.setPixelRatio(1);
				renderer._setXRLayerSize(glProjLayer.textureWidth, glProjLayer.textureHeight);
				const depth$2 = this._useMultiview ? 2 : 1;
				const depthTexture = new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat, depth$2);
				this._xrRenderTarget = new XRRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
					format: RGBAFormat,
					type: UnsignedByteType,
					colorSpace: renderer.outputColorSpace,
					depthTexture,
					stencilBuffer: renderer.stencil,
					samples: attributes.antialias ? 4 : 0,
					resolveDepthBuffer: glProjLayer.ignoreDepthValues === false,
					resolveStencilBuffer: glProjLayer.ignoreDepthValues === false,
					depth: this._useMultiview ? 2 : 1,
					multiview: this._useMultiview
				});
				this._xrRenderTarget._hasExternalTextures = true;
				this._xrRenderTarget.depth = this._useMultiview ? 2 : 1;
				this._sessionUsesLayers = session.enabledFeatures.includes("layers");
				this._referenceSpace = await session.requestReferenceSpace(this.getReferenceSpaceType());
				if (this._sessionUsesLayers) for (const layer of this._layers) {
					layer.plane.material = new MeshBasicMaterial({
						color: 16777215,
						side: layer.type === "cylinder" ? BackSide : FrontSide
					});
					layer.plane.material.blending = CustomBlending;
					layer.plane.material.blendEquation = AddEquation;
					layer.plane.material.blendSrc = ZeroFactor;
					layer.plane.material.blendDst = ZeroFactor;
					layer.xrlayer = this._createXRLayer(layer);
					layersArray.unshift(layer.xrlayer);
				}
				session.updateRenderState({ layers: layersArray });
			} else {
				const layerInit = {
					antialias: renderer.currentSamples > 0,
					alpha: true,
					depth: renderer.depth,
					stencil: renderer.stencil,
					framebufferScaleFactor: this.getFramebufferScaleFactor()
				};
				const glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
				this._glBaseLayer = glBaseLayer;
				session.updateRenderState({ baseLayer: glBaseLayer });
				renderer.setPixelRatio(1);
				renderer._setXRLayerSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight);
				this._xrRenderTarget = new XRRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
					format: RGBAFormat,
					type: UnsignedByteType,
					colorSpace: renderer.outputColorSpace,
					stencilBuffer: renderer.stencil,
					resolveDepthBuffer: glBaseLayer.ignoreDepthValues === false,
					resolveStencilBuffer: glBaseLayer.ignoreDepthValues === false
				});
				this._xrRenderTarget._isOpaqueFramebuffer = true;
				this._referenceSpace = await session.requestReferenceSpace(this.getReferenceSpaceType());
			}
			this.setFoveation(this.getFoveation());
			renderer._animation.setAnimationLoop(this._onAnimationFrame);
			renderer._animation.setContext(session);
			renderer._animation.start();
			this.isPresenting = true;
			this.dispatchEvent({ type: "sessionstart" });
		}
	}
	/**
	* This method is called by the renderer per frame and updates the XR camera
	* and it sub cameras based on the given camera. The given camera is the "user"
	* camera created on application level and used for non-XR rendering.
	*
	* @param {PerspectiveCamera} camera - The camera.
	*/
	updateCamera(camera) {
		const session = this._session;
		if (session === null) return;
		const depthNear = camera.near;
		const depthFar = camera.far;
		const cameraXR = this._cameraXR;
		const cameraL = this._cameraL;
		const cameraR = this._cameraR;
		cameraXR.near = cameraR.near = cameraL.near = depthNear;
		cameraXR.far = cameraR.far = cameraL.far = depthFar;
		cameraXR.isMultiViewCamera = this._useMultiview;
		if (this._currentDepthNear !== cameraXR.near || this._currentDepthFar !== cameraXR.far) {
			session.updateRenderState({
				depthNear: cameraXR.near,
				depthFar: cameraXR.far
			});
			this._currentDepthNear = cameraXR.near;
			this._currentDepthFar = cameraXR.far;
		}
		cameraXR.layers.mask = camera.layers.mask | 6;
		cameraL.layers.mask = cameraXR.layers.mask & 3;
		cameraR.layers.mask = cameraXR.layers.mask & 5;
		const parent = camera.parent;
		const cameras = cameraXR.cameras;
		updateCamera(cameraXR, parent);
		for (let i = 0; i < cameras.length; i++) updateCamera(cameras[i], parent);
		if (cameras.length === 2) setProjectionFromUnion(cameraXR, cameraL, cameraR);
		else cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
		updateUserCamera(camera, cameraXR, parent);
	}
	/**
	* Returns a WebXR controller for the given controller index.
	*
	* @private
	* @param {number} index - The controller index.
	* @return {WebXRController} The XR controller.
	*/
	_getController(index) {
		let controller = this._controllers[index];
		if (controller === void 0) {
			controller = new WebXRController();
			this._controllers[index] = controller;
		}
		return controller;
	}
};
/**
* Assumes 2 cameras that are parallel and share an X-axis, and that
* the cameras' projection and world matrices have already been set.
* And that near and far planes are identical for both cameras.
* Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
*
* @param {ArrayCamera} camera - The camera to update.
* @param {PerspectiveCamera} cameraL - The left camera.
* @param {PerspectiveCamera} cameraR - The right camera.
*/
function setProjectionFromUnion(camera, cameraL, cameraR) {
	_cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
	_cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
	const ipd = _cameraLPos.distanceTo(_cameraRPos);
	const projL = cameraL.projectionMatrix.elements;
	const projR = cameraR.projectionMatrix.elements;
	const near = projL[14] / (projL[10] - 1);
	const far = projL[14] / (projL[10] + 1);
	const topFov = (projL[9] + 1) / projL[5];
	const bottomFov = (projL[9] - 1) / projL[5];
	const leftFov = (projL[8] - 1) / projL[0];
	const rightFov = (projR[8] + 1) / projR[0];
	const left = near * leftFov;
	const right = near * rightFov;
	const zOffset = ipd / (-leftFov + rightFov);
	const xOffset = zOffset * -leftFov;
	cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
	camera.translateX(xOffset);
	camera.translateZ(zOffset);
	camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
	camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
	if (projL[10] === -1) {
		camera.projectionMatrix.copy(cameraL.projectionMatrix);
		camera.projectionMatrixInverse.copy(cameraL.projectionMatrixInverse);
	} else {
		const near2 = near + zOffset;
		const far2 = far + zOffset;
		const left2 = left - xOffset;
		const right2 = right + (ipd - xOffset);
		const top2 = topFov * far / far2 * near2;
		const bottom2 = bottomFov * far / far2 * near2;
		camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
		camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
	}
}
/**
* Updates the world matrices for the given camera based on the parent 3D object.
*
* @inner
* @param {Camera} camera - The camera to update.
* @param {Object3D} parent - The parent 3D object.
*/
function updateCamera(camera, parent) {
	if (parent === null) camera.matrixWorld.copy(camera.matrix);
	else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
	camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
}
/**
* Updates the given camera with the transformation of the XR camera and parent object.
*
* @inner
* @param {Camera} camera - The camera to update.
* @param {ArrayCamera} cameraXR - The XR camera.
* @param {Object3D} parent - The parent 3D object.
*/
function updateUserCamera(camera, cameraXR, parent) {
	if (parent === null) camera.matrix.copy(cameraXR.matrixWorld);
	else {
		camera.matrix.copy(parent.matrixWorld);
		camera.matrix.invert();
		camera.matrix.multiply(cameraXR.matrixWorld);
	}
	camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
	camera.updateMatrixWorld(true);
	camera.projectionMatrix.copy(cameraXR.projectionMatrix);
	camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
	if (camera.isPerspectiveCamera) {
		camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
		camera.zoom = 1;
	}
}
function onSessionEvent(event) {
	const controllerIndex = this._controllerInputSources.indexOf(event.inputSource);
	if (controllerIndex === -1) return;
	const controller = this._controllers[controllerIndex];
	if (controller !== void 0) {
		const referenceSpace = this.getReferenceSpace();
		controller.update(event.inputSource, event.frame, referenceSpace);
		controller.dispatchEvent({
			type: event.type,
			data: event.inputSource
		});
	}
}
function onSessionEnd() {
	const session = this._session;
	const renderer = this._renderer;
	session.removeEventListener("select", this._onSessionEvent);
	session.removeEventListener("selectstart", this._onSessionEvent);
	session.removeEventListener("selectend", this._onSessionEvent);
	session.removeEventListener("squeeze", this._onSessionEvent);
	session.removeEventListener("squeezestart", this._onSessionEvent);
	session.removeEventListener("squeezeend", this._onSessionEvent);
	session.removeEventListener("end", this._onSessionEnd);
	session.removeEventListener("inputsourceschange", this._onInputSourcesChange);
	for (let i = 0; i < this._controllers.length; i++) {
		const inputSource = this._controllerInputSources[i];
		if (inputSource === null) continue;
		this._controllerInputSources[i] = null;
		this._controllers[i].disconnect(inputSource);
	}
	this._currentDepthNear = null;
	this._currentDepthFar = null;
	renderer._resetXRState();
	this._session = null;
	this._xrRenderTarget = null;
	this._glBinding = null;
	this._glBaseLayer = null;
	this._glProjLayer = null;
	if (this._sessionUsesLayers === true) for (const layer of this._layers) {
		layer.renderTarget = new XRRenderTarget(layer.pixelwidth, layer.pixelheight, {
			format: RGBAFormat,
			type: UnsignedByteType,
			depthTexture: new DepthTexture(layer.pixelwidth, layer.pixelheight, layer.stencilBuffer ? UnsignedInt248Type : UnsignedIntType, void 0, void 0, void 0, void 0, void 0, void 0, layer.stencilBuffer ? DepthStencilFormat : DepthFormat),
			stencilBuffer: layer.stencilBuffer,
			resolveDepthBuffer: false,
			resolveStencilBuffer: false
		});
		layer.renderTarget.isXRRenderTarget = false;
		layer.plane.material = layer.material;
		layer.material.map = layer.renderTarget.texture;
		layer.material.map.offset.y = 1;
		layer.material.map.repeat.y = -1;
		delete layer.xrlayer;
	}
	this.isPresenting = false;
	this._useMultiview = false;
	renderer._animation.stop();
	renderer._animation.setAnimationLoop(this._currentAnimationLoop);
	renderer._animation.setContext(this._currentAnimationContext);
	renderer._animation.start();
	renderer.setPixelRatio(this._currentPixelRatio);
	renderer.setSize(this._currentSize.width, this._currentSize.height, false);
	this.dispatchEvent({ type: "sessionend" });
}
function onInputSourcesChange(event) {
	const controllers = this._controllers;
	const controllerInputSources = this._controllerInputSources;
	for (let i = 0; i < event.removed.length; i++) {
		const inputSource = event.removed[i];
		const index = controllerInputSources.indexOf(inputSource);
		if (index >= 0) {
			controllerInputSources[index] = null;
			controllers[index].disconnect(inputSource);
		}
	}
	for (let i = 0; i < event.added.length; i++) {
		const inputSource = event.added[i];
		let controllerIndex = controllerInputSources.indexOf(inputSource);
		if (controllerIndex === -1) {
			for (let i$1 = 0; i$1 < controllers.length; i$1++) if (i$1 >= controllerInputSources.length) {
				controllerInputSources.push(inputSource);
				controllerIndex = i$1;
				break;
			} else if (controllerInputSources[i$1] === null) {
				controllerInputSources[i$1] = inputSource;
				controllerIndex = i$1;
				break;
			}
			if (controllerIndex === -1) break;
		}
		const controller = controllers[controllerIndex];
		if (controller) controller.connect(inputSource);
	}
}
function createXRLayer(layer) {
	if (layer.type === "quad") return this._glBinding.createQuadLayer({
		transform: new XRRigidTransform(layer.translation, layer.quaternion),
		width: layer.width / 2,
		height: layer.height / 2,
		space: this._referenceSpace,
		viewPixelWidth: layer.pixelwidth,
		viewPixelHeight: layer.pixelheight,
		clearOnAccess: false
	});
	else return this._glBinding.createCylinderLayer({
		transform: new XRRigidTransform(layer.translation, layer.quaternion),
		radius: layer.radius,
		centralAngle: layer.centralAngle,
		aspectRatio: layer.aspectRatio,
		space: this._referenceSpace,
		viewPixelWidth: layer.pixelwidth,
		viewPixelHeight: layer.pixelheight,
		clearOnAccess: false
	});
}
function onAnimationFrame(time$2, frame) {
	if (frame === void 0) return;
	const cameraXR = this._cameraXR;
	const renderer = this._renderer;
	const backend = renderer.backend;
	const glBaseLayer = this._glBaseLayer;
	const referenceSpace = this.getReferenceSpace();
	const pose = frame.getViewerPose(referenceSpace);
	this._xrFrame = frame;
	if (pose !== null) {
		const views = pose.views;
		if (this._glBaseLayer !== null) backend.setXRTarget(glBaseLayer.framebuffer);
		let cameraXRNeedsUpdate = false;
		if (views.length !== cameraXR.cameras.length) {
			cameraXR.cameras.length = 0;
			cameraXRNeedsUpdate = true;
		}
		for (let i = 0; i < views.length; i++) {
			const view = views[i];
			let viewport$2;
			if (this._supportsLayers === true) {
				const glSubImage = this._glBinding.getViewSubImage(this._glProjLayer, view);
				viewport$2 = glSubImage.viewport;
				if (i === 0) backend.setXRRenderTargetTextures(this._xrRenderTarget, glSubImage.colorTexture, this._glProjLayer.ignoreDepthValues && !this._useMultiview ? void 0 : glSubImage.depthStencilTexture);
			} else viewport$2 = glBaseLayer.getViewport(view);
			let camera = this._cameras[i];
			if (camera === void 0) {
				camera = new PerspectiveCamera();
				camera.layers.enable(i);
				camera.viewport = new Vector4();
				this._cameras[i] = camera;
			}
			camera.matrix.fromArray(view.transform.matrix);
			camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
			camera.projectionMatrix.fromArray(view.projectionMatrix);
			camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
			camera.viewport.set(viewport$2.x, viewport$2.y, viewport$2.width, viewport$2.height);
			if (i === 0) {
				cameraXR.matrix.copy(camera.matrix);
				cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
			}
			if (cameraXRNeedsUpdate === true) cameraXR.cameras.push(camera);
		}
		renderer.setOutputRenderTarget(this._xrRenderTarget);
	}
	for (let i = 0; i < this._controllers.length; i++) {
		const inputSource = this._controllerInputSources[i];
		const controller = this._controllers[i];
		if (inputSource !== null && controller !== void 0) controller.update(inputSource, frame, referenceSpace);
	}
	if (this._currentAnimationLoop) this._currentAnimationLoop(time$2, frame);
	if (frame.detectedPlanes) this.dispatchEvent({
		type: "planesdetected",
		data: frame
	});
	this._xrFrame = null;
}
/**
* CanvasTarget is a class that represents the final output destination of the renderer.
*
* @augments EventDispatcher
*/
var CanvasTarget = class extends EventDispatcher {
	/**
	* Constructs a new CanvasTarget.
	*
	* @param {HTMLCanvasElement|OffscreenCanvas} domElement - The canvas element to render to.
	*/
	constructor(domElement) {
		super();
		/**
		* A reference to the canvas element the renderer is drawing to.
		* This value of this property will automatically be created by
		* the renderer.
		*
		* @type {HTMLCanvasElement|OffscreenCanvas}
		*/
		this.domElement = domElement;
		/**
		* The renderer's pixel ratio.
		*
		* @private
		* @type {number}
		* @default 1
		*/
		this._pixelRatio = 1;
		/**
		* The width of the renderer's default framebuffer in logical pixel unit.
		*
		* @private
		* @type {number}
		*/
		this._width = this.domElement.width;
		/**
		* The height of the renderer's default framebuffer in logical pixel unit.
		*
		* @private
		* @type {number}
		*/
		this._height = this.domElement.height;
		/**
		* The viewport of the renderer in logical pixel unit.
		*
		* @private
		* @type {Vector4}
		*/
		this._viewport = new Vector4(0, 0, this._width, this._height);
		/**
		* The scissor rectangle of the renderer in logical pixel unit.
		*
		* @private
		* @type {Vector4}
		*/
		this._scissor = new Vector4(0, 0, this._width, this._height);
		/**
		* Whether the scissor test should be enabled or not.
		*
		* @private
		* @type {boolean}
		*/
		this._scissorTest = false;
		/**
		* The color texture of the default framebuffer.
		*
		* @type {FramebufferTexture}
		*/
		this.colorTexture = new FramebufferTexture();
		/**
		* The depth texture of the default framebuffer.
		*
		* @type {DepthTexture}
		*/
		this.depthTexture = new DepthTexture();
	}
	/**
	* Returns the pixel ratio.
	*
	* @return {number} The pixel ratio.
	*/
	getPixelRatio() {
		return this._pixelRatio;
	}
	/**
	* Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
	*
	* @param {Vector2} target - The method writes the result in this target object.
	* @return {Vector2} The drawing buffer size.
	*/
	getDrawingBufferSize(target) {
		return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
	}
	/**
	* Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
	*
	* @param {Vector2} target - The method writes the result in this target object.
	* @return {Vector2} The renderer's size in logical pixels.
	*/
	getSize(target) {
		return target.set(this._width, this._height);
	}
	/**
	* Sets the given pixel ratio and resizes the canvas if necessary.
	*
	* @param {number} [value=1] - The pixel ratio.
	*/
	setPixelRatio(value = 1) {
		if (this._pixelRatio === value) return;
		this._pixelRatio = value;
		this.setSize(this._width, this._height, false);
	}
	/**
	* This method allows to define the drawing buffer size by specifying
	* width, height and pixel ratio all at once. The size of the drawing
	* buffer is computed with this formula:
	* ```js
	* size.x = width * pixelRatio;
	* size.y = height * pixelRatio;
	* ```
	*
	* @param {number} width - The width in logical pixels.
	* @param {number} height - The height in logical pixels.
	* @param {number} pixelRatio - The pixel ratio.
	*/
	setDrawingBufferSize(width, height, pixelRatio) {
		if (this.xr && this.xr.isPresenting) return;
		this._width = width;
		this._height = height;
		this._pixelRatio = pixelRatio;
		this.domElement.width = Math.floor(width * pixelRatio);
		this.domElement.height = Math.floor(height * pixelRatio);
		this.setViewport(0, 0, width, height);
		this._dispatchResize();
	}
	/**
	* Sets the size of the renderer.
	*
	* @param {number} width - The width in logical pixels.
	* @param {number} height - The height in logical pixels.
	* @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
	*/
	setSize(width, height, updateStyle = true) {
		if (this.xr && this.xr.isPresenting) return;
		this._width = width;
		this._height = height;
		this.domElement.width = Math.floor(width * this._pixelRatio);
		this.domElement.height = Math.floor(height * this._pixelRatio);
		if (updateStyle === true) {
			this.domElement.style.width = width + "px";
			this.domElement.style.height = height + "px";
		}
		this.setViewport(0, 0, width, height);
		this._dispatchResize();
	}
	/**
	* Returns the scissor rectangle.
	*
	* @param {Vector4} target - The method writes the result in this target object.
	* @return {Vector4} The scissor rectangle.
	*/
	getScissor(target) {
		const scissor = this._scissor;
		target.x = scissor.x;
		target.y = scissor.y;
		target.width = scissor.width;
		target.height = scissor.height;
		return target;
	}
	/**
	* Defines the scissor rectangle.
	*
	* @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
	* Instead of passing four arguments, the method also works with a single four-dimensional vector.
	* @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
	* @param {number} width - The width of the scissor box in logical pixel unit.
	* @param {number} height - The height of the scissor box in logical pixel unit.
	*/
	setScissor(x, y, width, height) {
		const scissor = this._scissor;
		if (x.isVector4) scissor.copy(x);
		else scissor.set(x, y, width, height);
	}
	/**
	* Returns the scissor test value.
	*
	* @return {boolean} Whether the scissor test should be enabled or not.
	*/
	getScissorTest() {
		return this._scissorTest;
	}
	/**
	* Defines the scissor test.
	*
	* @param {boolean} boolean - Whether the scissor test should be enabled or not.
	*/
	setScissorTest(boolean) {
		this._scissorTest = boolean;
	}
	/**
	* Returns the viewport definition.
	*
	* @param {Vector4} target - The method writes the result in this target object.
	* @return {Vector4} The viewport definition.
	*/
	getViewport(target) {
		return target.copy(this._viewport);
	}
	/**
	* Defines the viewport.
	*
	* @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
	* @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
	* @param {number} width - The width of the viewport in logical pixel unit.
	* @param {number} height - The height of the viewport in logical pixel unit.
	* @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
	* @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
	*/
	setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
		const viewport$2 = this._viewport;
		if (x.isVector4) viewport$2.copy(x);
		else viewport$2.set(x, y, width, height);
		viewport$2.minDepth = minDepth;
		viewport$2.maxDepth = maxDepth;
	}
	/**
	* Dispatches the resize event.
	*
	* @private
	*/
	_dispatchResize() {
		this.dispatchEvent({ type: "resize" });
	}
	/**
	* Frees the GPU-related resources allocated by this instance. Call this
	* method whenever this instance is no longer used in your app.
	*
	* @fires RenderTarget#dispose
	*/
	dispose() {
		this.dispatchEvent({ type: "dispose" });
	}
};
var _scene = /* @__PURE__ */ new Scene();
var _drawingBufferSize = /* @__PURE__ */ new Vector2();
var _screen = /* @__PURE__ */ new Vector4();
var _frustum = /* @__PURE__ */ new Frustum();
var _frustumArray = /* @__PURE__ */ new FrustumArray();
var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
var _vector4 = /* @__PURE__ */ new Vector4();
/**
* Base class for renderers.
*/
var Renderer = class {
	/**
	* Renderer options.
	*
	* @typedef {Object} Renderer~Options
	* @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
	* @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
	* @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
	* @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
	* @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
	* @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0
	* to overwrite the default.
	* @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
	* @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best
	* quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
	* @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
	*/
	/**
	* Constructs a new renderer.
	*
	* @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).
	* @param {Renderer~Options} [parameters] - The configuration parameter.
	
	*/
	constructor(backend, parameters = {}) {
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isRenderer = true;
		const { logarithmicDepthBuffer = false, alpha = true, depth: depth$2 = true, stencil = false, antialias = false, samples = 0, getFallback = null, colorBufferType = HalfFloatType, multiview = false } = parameters;
		/**
		* A reference to the current backend.
		*
		* @type {Backend}
		*/
		this.backend = backend;
		/**
		* Whether the renderer should automatically clear the current rendering target
		* before execute a `render()` call. The target can be the canvas (default framebuffer)
		* or the current bound render target (custom framebuffer).
		*
		* @type {boolean}
		* @default true
		*/
		this.autoClear = true;
		/**
		* When `autoClear` is set to `true`, this property defines whether the renderer
		* should clear the color buffer.
		*
		* @type {boolean}
		* @default true
		*/
		this.autoClearColor = true;
		/**
		* When `autoClear` is set to `true`, this property defines whether the renderer
		* should clear the depth buffer.
		*
		* @type {boolean}
		* @default true
		*/
		this.autoClearDepth = true;
		/**
		* When `autoClear` is set to `true`, this property defines whether the renderer
		* should clear the stencil buffer.
		*
		* @type {boolean}
		* @default true
		*/
		this.autoClearStencil = true;
		/**
		* Whether the default framebuffer should be transparent or opaque.
		*
		* @type {boolean}
		* @default true
		*/
		this.alpha = alpha;
		/**
		* Whether logarithmic depth buffer is enabled or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.logarithmicDepthBuffer = logarithmicDepthBuffer;
		/**
		* Defines the output color space of the renderer.
		*
		* @type {string}
		* @default SRGBColorSpace
		*/
		this.outputColorSpace = SRGBColorSpace;
		/**
		* Defines the tone mapping of the renderer.
		*
		* @type {number}
		* @default NoToneMapping
		*/
		this.toneMapping = NoToneMapping;
		/**
		* Defines the tone mapping exposure.
		*
		* @type {number}
		* @default 1
		*/
		this.toneMappingExposure = 1;
		/**
		* Whether the renderer should sort its render lists or not.
		*
		* Note: Sorting is used to attempt to properly render objects that have some degree of transparency.
		* By definition, sorting objects may not work in all cases. Depending on the needs of application,
		* it may be necessary to turn off sorting and use other methods to deal with transparency rendering
		* e.g. manually determining each object's rendering order.
		*
		* @type {boolean}
		* @default true
		*/
		this.sortObjects = true;
		/**
		* Whether the default framebuffer should have a depth buffer or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.depth = depth$2;
		/**
		* Whether the default framebuffer should have a stencil buffer or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.stencil = stencil;
		/**
		* Holds a series of statistical information about the GPU memory
		* and the rendering process. Useful for debugging and monitoring.
		*
		* @type {Info}
		*/
		this.info = new Info();
		/**
		* Stores override nodes for specific transformations or calculations.
		* These nodes can be used to replace default behavior in the rendering pipeline.
		*
		* @type {Object}
		* @property {?Node} modelViewMatrix - An override node for the model-view matrix.
		* @property {?Node} modelNormalViewMatrix - An override node for the model normal view matrix.
		*/
		this.overrideNodes = {
			modelViewMatrix: null,
			modelNormalViewMatrix: null
		};
		/**
		* The node library defines how certain library objects like materials, lights
		* or tone mapping functions are mapped to node types. This is required since
		* although instances of classes like `MeshBasicMaterial` or `PointLight` can
		* be part of the scene graph, they are internally represented as nodes for
		* further processing.
		*
		* @type {NodeLibrary}
		*/
		this.library = new NodeLibrary();
		/**
		* A map-like data structure for managing lights.
		*
		* @type {Lighting}
		*/
		this.lighting = new Lighting();
		/**
		* The number of MSAA samples.
		*
		* @private
		* @type {number}
		* @default 0
		*/
		this._samples = samples || antialias === true ? 4 : 0;
		/**
		* OnCanvasTargetResize callback function.
		*
		* @private
		* @type {Function}
		*/
		this._onCanvasTargetResize = this._onCanvasTargetResize.bind(this);
		/**
		* The canvas target for rendering.
		*
		* @private
		* @type {CanvasTarget}
		*/
		this._canvasTarget = new CanvasTarget(backend.getDomElement());
		this._canvasTarget.addEventListener("resize", this._onCanvasTargetResize);
		this._canvasTarget.isDefaultCanvasTarget = true;
		/**
		* The inspector provides information about the internal renderer state.
		*
		* @private
		* @type {InspectorBase}
		*/
		this._inspector = new InspectorBase();
		this._inspector.setRenderer(this);
		/**
		* This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
		*
		* @private
		* @type {?Function}
		*/
		this._getFallback = getFallback;
		/**
		* A reference to a renderer module for managing shader attributes.
		*
		* @private
		* @type {?Attributes}
		* @default null
		*/
		this._attributes = null;
		/**
		* A reference to a renderer module for managing geometries.
		*
		* @private
		* @type {?Geometries}
		* @default null
		*/
		this._geometries = null;
		/**
		* A reference to a renderer module for managing node related logic.
		*
		* @private
		* @type {?Nodes}
		* @default null
		*/
		this._nodes = null;
		/**
		* A reference to a renderer module for managing the internal animation loop.
		*
		* @private
		* @type {?Animation}
		* @default null
		*/
		this._animation = null;
		/**
		* A reference to a renderer module for managing shader program bindings.
		*
		* @private
		* @type {?Bindings}
		* @default null
		*/
		this._bindings = null;
		/**
		* A reference to a renderer module for managing render objects.
		*
		* @private
		* @type {?RenderObjects}
		* @default null
		*/
		this._objects = null;
		/**
		* A reference to a renderer module for managing render and compute pipelines.
		*
		* @private
		* @type {?Pipelines}
		* @default null
		*/
		this._pipelines = null;
		/**
		* A reference to a renderer module for managing render bundles.
		*
		* @private
		* @type {?RenderBundles}
		* @default null
		*/
		this._bundles = null;
		/**
		* A reference to a renderer module for managing render lists.
		*
		* @private
		* @type {?RenderLists}
		* @default null
		*/
		this._renderLists = null;
		/**
		* A reference to a renderer module for managing render contexts.
		*
		* @private
		* @type {?RenderContexts}
		* @default null
		*/
		this._renderContexts = null;
		/**
		* A reference to a renderer module for managing textures.
		*
		* @private
		* @type {?Textures}
		* @default null
		*/
		this._textures = null;
		/**
		* A reference to a renderer module for backgrounds.
		*
		* @private
		* @type {?Background}
		* @default null
		*/
		this._background = null;
		/**
		* This fullscreen quad is used for internal render passes
		* like the tone mapping and color space output pass.
		*
		* @private
		* @type {QuadMesh}
		*/
		this._quad = new QuadMesh(new NodeMaterial());
		this._quad.name = "Output Color Transform";
		this._quad.material.name = "outputColorTransform";
		/**
		* A reference to the current render context.
		*
		* @private
		* @type {?RenderContext}
		* @default null
		*/
		this._currentRenderContext = null;
		/**
		* A custom sort function for the opaque render list.
		*
		* @private
		* @type {?Function}
		* @default null
		*/
		this._opaqueSort = null;
		/**
		* A custom sort function for the transparent render list.
		*
		* @private
		* @type {?Function}
		* @default null
		*/
		this._transparentSort = null;
		/**
		* The framebuffer target.
		*
		* @private
		* @type {?RenderTarget}
		* @default null
		*/
		this._frameBufferTarget = null;
		const alphaClear = this.alpha === true ? 0 : 1;
		/**
		* The clear color value.
		*
		* @private
		* @type {Color4}
		*/
		this._clearColor = new Color4(0, 0, 0, alphaClear);
		/**
		* The clear depth value.
		*
		* @private
		* @type {number}
		* @default 1
		*/
		this._clearDepth = 1;
		/**
		* The clear stencil value.
		*
		* @private
		* @type {number}
		* @default 0
		*/
		this._clearStencil = 0;
		/**
		* The current render target.
		*
		* @private
		* @type {?RenderTarget}
		* @default null
		*/
		this._renderTarget = null;
		/**
		* The active cube face.
		*
		* @private
		* @type {number}
		* @default 0
		*/
		this._activeCubeFace = 0;
		/**
		* The active mipmap level.
		*
		* @private
		* @type {number}
		* @default 0
		*/
		this._activeMipmapLevel = 0;
		/**
		* The current output render target.
		*
		* @private
		* @type {?RenderTarget}
		* @default null
		*/
		this._outputRenderTarget = null;
		/**
		* The MRT setting.
		*
		* @private
		* @type {?MRTNode}
		* @default null
		*/
		this._mrt = null;
		/**
		* This function defines how a render object is going
		* to be rendered.
		*
		* @private
		* @type {?Function}
		* @default null
		*/
		this._renderObjectFunction = null;
		/**
		* Used to keep track of the current render object function.
		*
		* @private
		* @type {?Function}
		* @default null
		*/
		this._currentRenderObjectFunction = null;
		/**
		* Used to keep track of the current render bundle.
		*
		* @private
		* @type {?RenderBundle}
		* @default null
		*/
		this._currentRenderBundle = null;
		/**
		* Next to `_renderObjectFunction()`, this function provides another hook
		* for influencing the render process of a render object. It is meant for internal
		* use and only relevant for `compileAsync()` right now. Instead of using
		* the default logic of `_renderObjectDirect()` which actually draws the render object,
		* a different function might be used which performs no draw but just the node
		* and pipeline updates.
		*
		* @private
		* @type {?Function}
		* @default null
		*/
		this._handleObjectFunction = this._renderObjectDirect;
		/**
		* Indicates whether the device has been lost or not. In WebGL terms, the device
		* lost is considered as a context lost. When this is set to `true`, rendering
		* isn't possible anymore.
		*
		* @private
		* @type {boolean}
		* @default false
		*/
		this._isDeviceLost = false;
		/**
		* A callback function that defines what should happen when a device/context lost occurs.
		*
		* @type {Function}
		*/
		this.onDeviceLost = this._onDeviceLost;
		/**
		* Defines the type of color buffers. The default `HalfFloatType` is recommend for
		* best quality. To save memory and bandwidth, `UnsignedByteType` might be used.
		* This will reduce rendering quality though.
		*
		* @private
		* @type {number}
		* @default HalfFloatType
		*/
		this._colorBufferType = colorBufferType;
		/**
		* A cache for shadow nodes per material
		*
		* @private
		* @type {WeakMap<Material, Object>}
		*/
		this._cacheShadowNodes = /* @__PURE__ */ new WeakMap();
		/**
		* Whether the renderer has been initialized or not.
		*
		* @private
		* @type {boolean}
		* @default false
		*/
		this._initialized = false;
		/**
		* A reference to the promise which initializes the renderer.
		*
		* @private
		* @type {?Promise<this>}
		* @default null
		*/
		this._initPromise = null;
		/**
		* An array of compilation promises which are used in `compileAsync()`.
		*
		* @private
		* @type {?Array<Promise>}
		* @default null
		*/
		this._compilationPromises = null;
		/**
		* Whether the renderer should render transparent render objects or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.transparent = true;
		/**
		* Whether the renderer should render opaque render objects or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.opaque = true;
		/**
		* Shadow map configuration
		* @typedef {Object} ShadowMapConfig
		* @property {boolean} enabled - Whether to globally enable shadows or not.
		* @property {number} type - The shadow map type.
		*/
		/**
		* The renderer's shadow configuration.
		*
		* @type {ShadowMapConfig}
		*/
		this.shadowMap = {
			enabled: false,
			type: PCFShadowMap
		};
		/**
		* XR configuration.
		* @typedef {Object} XRConfig
		* @property {boolean} enabled - Whether to globally enable XR or not.
		*/
		/**
		* The renderer's XR manager.
		*
		* @type {XRManager}
		*/
		this.xr = new XRManager(this, multiview);
		/**
		* Debug configuration.
		* @typedef {Object} DebugConfig
		* @property {boolean} checkShaderErrors - Whether shader errors should be checked or not.
		* @property {?Function} onShaderError - A callback function that is executed when a shader error happens. Only supported with WebGL 2 right now.
		* @property {Function} getShaderAsync - Allows the get the raw shader code for the given scene, camera and 3D object.
		*/
		/**
		* The renderer's debug configuration.
		*
		* @type {DebugConfig}
		*/
		this.debug = {
			checkShaderErrors: true,
			onShaderError: null,
			getShaderAsync: async (scene, camera, object) => {
				await this.compileAsync(scene, camera);
				const renderList = this._renderLists.get(scene, camera);
				const renderContext = this._renderContexts.get(scene, camera, this._renderTarget);
				const material = scene.overrideMaterial || object.material;
				const { fragmentShader, vertexShader } = this._objects.get(object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext).getNodeBuilderState();
				return {
					fragmentShader,
					vertexShader
				};
			}
		};
	}
	/**
	* Initializes the renderer so it is ready for usage.
	*
	* @async
	* @return {Promise<this>} A Promise that resolves when the renderer has been initialized.
	*/
	async init() {
		if (this._initPromise !== null) return this._initPromise;
		this._initPromise = new Promise(async (resolve, reject) => {
			let backend = this.backend;
			try {
				await backend.init(this);
			} catch (error$1) {
				if (this._getFallback !== null) try {
					this.backend = backend = this._getFallback(error$1);
					await backend.init(this);
				} catch (error$2) {
					reject(error$2);
					return;
				}
				else {
					reject(error$1);
					return;
				}
			}
			this._nodes = new Nodes(this, backend);
			this._animation = new Animation(this, this._nodes, this.info);
			this._attributes = new Attributes(backend);
			this._background = new Background(this, this._nodes);
			this._geometries = new Geometries(this._attributes, this.info);
			this._textures = new Textures(this, backend, this.info);
			this._pipelines = new Pipelines(backend, this._nodes);
			this._bindings = new Bindings(backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info);
			this._objects = new RenderObjects(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info);
			this._renderLists = new RenderLists(this.lighting);
			this._bundles = new RenderBundles();
			this._renderContexts = new RenderContexts();
			this._animation.start();
			this._initialized = true;
			this._inspector.init();
			resolve(this);
		});
		return this._initPromise;
	}
	/**
	* A reference to the canvas element the renderer is drawing to.
	* This value of this property will automatically be created by
	* the renderer.
	*
	* @type {HTMLCanvasElement|OffscreenCanvas}
	*/
	get domElement() {
		return this._canvasTarget.domElement;
	}
	/**
	* The coordinate system of the renderer. The value of this property
	* depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
	* `THREE.WebGPUCoordinateSystem`.
	*
	* @readonly
	* @type {number}
	*/
	get coordinateSystem() {
		return this.backend.coordinateSystem;
	}
	/**
	* Compiles all materials in the given scene. This can be useful to avoid a
	* phenomenon which is called "shader compilation stutter", which occurs when
	* rendering an object with a new shader for the first time.
	*
	* If you want to add a 3D object to an existing scene, use the third optional
	* parameter for applying the target scene. Note that the (target) scene's lighting
	* and environment must be configured before calling this method.
	*
	* @async
	* @param {Object3D} scene - The scene or 3D object to precompile.
	* @param {Camera} camera - The camera that is used to render the scene.
	* @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
	* @return {Promise<Array|undefined>} A Promise that resolves when the compile has been finished.
	*/
	async compileAsync(scene, camera, targetScene = null) {
		if (this._isDeviceLost === true) return;
		if (this._initialized === false) await this.init();
		const nodeFrame = this._nodes.nodeFrame;
		const previousRenderId = nodeFrame.renderId;
		const previousRenderContext = this._currentRenderContext;
		const previousRenderObjectFunction = this._currentRenderObjectFunction;
		const previousCompilationPromises = this._compilationPromises;
		const sceneRef = scene.isScene === true ? scene : _scene;
		if (targetScene === null) targetScene = scene;
		const renderTarget = this._renderTarget;
		const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);
		const activeMipmapLevel = this._activeMipmapLevel;
		const compilationPromises = [];
		this._currentRenderContext = renderContext;
		this._currentRenderObjectFunction = this.renderObject;
		this._handleObjectFunction = this._createObjectPipeline;
		this._compilationPromises = compilationPromises;
		nodeFrame.renderId++;
		nodeFrame.update();
		renderContext.depth = this.depth;
		renderContext.stencil = this.stencil;
		if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();
		renderContext.clippingContext.updateGlobal(sceneRef, camera);
		sceneRef.onBeforeRender(this, scene, camera, renderTarget);
		const renderList = this._renderLists.get(scene, camera);
		renderList.begin();
		this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
		if (targetScene !== scene) targetScene.traverseVisible(function(object) {
			if (object.isLight && object.layers.test(camera.layers)) renderList.pushLight(object);
		});
		renderList.finish();
		if (renderTarget !== null) {
			this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
			const renderTargetData = this._textures.get(renderTarget);
			renderContext.textures = renderTargetData.textures;
			renderContext.depthTexture = renderTargetData.depthTexture;
		} else {
			renderContext.textures = null;
			renderContext.depthTexture = null;
		}
		this._background.update(sceneRef, renderList, renderContext);
		const opaqueObjects = renderList.opaque;
		const transparentObjects = renderList.transparent;
		const transparentDoublePassObjects = renderList.transparentDoublePass;
		const lightsNode = renderList.lightsNode;
		if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
		if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);
		nodeFrame.renderId = previousRenderId;
		this._currentRenderContext = previousRenderContext;
		this._currentRenderObjectFunction = previousRenderObjectFunction;
		this._compilationPromises = previousCompilationPromises;
		this._handleObjectFunction = this._renderObjectDirect;
		await Promise.all(compilationPromises);
	}
	/**
	* Renders the scene in an async fashion.
	*
	* @async
	* @deprecated
	* @param {Object3D} scene - The scene or 3D object to render.
	* @param {Camera} camera - The camera.
	* @return {Promise} A Promise that resolves when the render has been finished.
	*/
	async renderAsync(scene, camera) {
		warnOnce("Renderer: \"renderAsync()\" has been deprecated. Use \"render()\" and \"await renderer.init();\" when creating the renderer.");
		await this.init();
		this.render(scene, camera);
	}
	/**
	* Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
	* the CPU waits for the GPU to complete its operation (e.g. a compute task).
	*
	* @async
	* @deprecated
	* @return {Promise} A Promise that resolves when synchronization has been finished.
	*/
	async waitForGPU() {
		error("Renderer: waitForGPU() has been removed. Read https://github.com/mrdoob/three.js/issues/32012 for more information.");
	}
	/**
	* Sets the inspector instance. The inspector can be any class that extends from `InspectorBase`.
	*
	* @param {InspectorBase} value - The new inspector.
	*/
	set inspector(value) {
		if (this._inspector !== null) this._inspector.setRenderer(null);
		this._inspector = value;
		this._inspector.setRenderer(this);
	}
	get inspector() {
		return this._inspector;
	}
	/**
	* Enables or disables high precision for model-view and normal-view matrices.
	* When enabled, will use CPU 64-bit precision for higher precision instead of GPU 32-bit for higher performance.
	*
	* NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.
	*
	* @param {boolean} value - Whether to enable or disable high precision.
	* @type {boolean}
	*/
	set highPrecision(value) {
		if (value === true) {
			this.overrideNodes.modelViewMatrix = highpModelViewMatrix$1;
			this.overrideNodes.modelNormalViewMatrix = highpModelNormalViewMatrix$1;
		} else if (this.highPrecision) {
			this.overrideNodes.modelViewMatrix = null;
			this.overrideNodes.modelNormalViewMatrix = null;
		}
	}
	/**
	* Returns whether high precision is enabled or not.
	*
	* @return {boolean} Whether high precision is enabled or not.
	* @type {boolean}
	*/
	get highPrecision() {
		return this.overrideNodes.modelViewMatrix === highpModelViewMatrix$1 && this.overrideNodes.modelNormalViewMatrix === highpModelNormalViewMatrix$1;
	}
	/**
	* Sets the given MRT configuration.
	*
	* @param {MRTNode} mrt - The MRT node to set.
	* @return {Renderer} A reference to this renderer.
	*/
	setMRT(mrt$2) {
		this._mrt = mrt$2;
		return this;
	}
	/**
	* Returns the MRT configuration.
	*
	* @return {MRTNode} The MRT configuration.
	*/
	getMRT() {
		return this._mrt;
	}
	/**
	* Returns the color buffer type.
	*
	* @return {number} The color buffer type.
	*/
	getColorBufferType() {
		return this._colorBufferType;
	}
	/**
	* Default implementation of the device lost callback.
	*
	* @private
	* @param {Object} info - Information about the context lost.
	*/
	_onDeviceLost(info) {
		let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;
		if (info.reason) errorMessage += `\nReason: ${info.reason}`;
		error(errorMessage);
		this._isDeviceLost = true;
	}
	/**
	* Renders the given render bundle.
	*
	* @private
	* @param {Object} bundle - Render bundle data.
	* @param {Scene} sceneRef - The scene the render bundle belongs to.
	* @param {LightsNode} lightsNode - The lights node.
	*/
	_renderBundle(bundle, sceneRef, lightsNode) {
		const { bundleGroup, camera, renderList } = bundle;
		const renderContext = this._currentRenderContext;
		const renderBundle = this._bundles.get(bundleGroup, camera);
		const renderBundleData = this.backend.get(renderBundle);
		if (renderBundleData.renderContexts === void 0) renderBundleData.renderContexts = /* @__PURE__ */ new Set();
		const needsUpdate = bundleGroup.version !== renderBundleData.version;
		const renderBundleNeedsUpdate = renderBundleData.renderContexts.has(renderContext) === false || needsUpdate;
		renderBundleData.renderContexts.add(renderContext);
		if (renderBundleNeedsUpdate) {
			this.backend.beginBundle(renderContext);
			if (renderBundleData.renderObjects === void 0 || needsUpdate) renderBundleData.renderObjects = [];
			this._currentRenderBundle = renderBundle;
			const { transparentDoublePass: transparentDoublePassObjects, transparent: transparentObjects, opaque: opaqueObjects } = renderList;
			if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
			if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);
			this._currentRenderBundle = null;
			this.backend.finishBundle(renderContext, renderBundle);
			renderBundleData.version = bundleGroup.version;
		} else {
			const { renderObjects } = renderBundleData;
			for (let i = 0, l = renderObjects.length; i < l; i++) {
				const renderObject = renderObjects[i];
				if (this._nodes.needsRefresh(renderObject)) {
					this._nodes.updateBefore(renderObject);
					this._nodes.updateForRender(renderObject);
					this._bindings.updateForRender(renderObject);
					this._nodes.updateAfter(renderObject);
				}
			}
		}
		this.backend.addBundle(renderContext, renderBundle);
	}
	/**
	* Renders the scene or 3D object with the given camera. This method can only be called
	* if the renderer has been initialized. When using `render()` inside an animation loop,
	* it's guaranteed the renderer will be initialized. The animation loop must be defined
	* with {@link Renderer#setAnimationLoop} though.
	*
	* For all other use cases (like when using on-demand rendering), you must call
	* {@link Renderer#init} before rendering.
	*
	* The target of the method is the default framebuffer (meaning the canvas)
	* or alternatively a render target when specified via `setRenderTarget()`.
	*
	* @param {Object3D} scene - The scene or 3D object to render.
	* @param {Camera} camera - The camera to render the scene with.
	*/
	render(scene, camera) {
		if (this._initialized === false) throw new Error("Renderer: .render() called before the backend is initialized. Use \"await renderer.init();\" before rendering.");
		this._renderScene(scene, camera);
	}
	/**
	* Returns whether the renderer has been initialized or not.
	*
	* @readonly
	* @return {boolean} Whether the renderer has been initialized or not.
	*/
	get initialized() {
		return this._initialized;
	}
	/**
	* Returns an internal render target which is used when computing the output tone mapping
	* and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render
	* pass and not inline to achieve more correct results.
	*
	* @private
	* @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.
	*/
	_getFrameBufferTarget() {
		const { currentToneMapping, currentColorSpace } = this;
		const useToneMapping = currentToneMapping !== NoToneMapping;
		const useColorSpace = currentColorSpace !== ColorManagement.workingColorSpace;
		if (useToneMapping === false && useColorSpace === false) return null;
		const { width, height } = this.getDrawingBufferSize(_drawingBufferSize);
		const { depth: depth$2, stencil } = this;
		let frameBufferTarget = this._frameBufferTarget;
		if (frameBufferTarget === null) {
			frameBufferTarget = new RenderTarget(width, height, {
				depthBuffer: depth$2,
				stencilBuffer: stencil,
				type: this._colorBufferType,
				format: RGBAFormat,
				colorSpace: ColorManagement.workingColorSpace,
				generateMipmaps: false,
				minFilter: LinearFilter,
				magFilter: LinearFilter,
				samples: this.samples
			});
			frameBufferTarget.isPostProcessingRenderTarget = true;
			this._frameBufferTarget = frameBufferTarget;
		}
		const outputRenderTarget = this.getOutputRenderTarget();
		frameBufferTarget.depthBuffer = depth$2;
		frameBufferTarget.stencilBuffer = stencil;
		if (outputRenderTarget !== null) frameBufferTarget.setSize(outputRenderTarget.width, outputRenderTarget.height, outputRenderTarget.depth);
		else frameBufferTarget.setSize(width, height, 1);
		const canvasTarget = this._canvasTarget;
		frameBufferTarget.viewport.copy(canvasTarget._viewport);
		frameBufferTarget.scissor.copy(canvasTarget._scissor);
		frameBufferTarget.viewport.multiplyScalar(canvasTarget._pixelRatio);
		frameBufferTarget.scissor.multiplyScalar(canvasTarget._pixelRatio);
		frameBufferTarget.scissorTest = canvasTarget._scissorTest;
		frameBufferTarget.multiview = outputRenderTarget !== null ? outputRenderTarget.multiview : false;
		frameBufferTarget.resolveDepthBuffer = outputRenderTarget !== null ? outputRenderTarget.resolveDepthBuffer : true;
		frameBufferTarget._autoAllocateDepthBuffer = outputRenderTarget !== null ? outputRenderTarget._autoAllocateDepthBuffer : false;
		return frameBufferTarget;
	}
	/**
	* Renders the scene or 3D object with the given camera.
	*
	* @private
	* @param {Object3D} scene - The scene or 3D object to render.
	* @param {Camera} camera - The camera to render the scene with.
	* @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
	* @return {RenderContext} The current render context.
	*/
	_renderScene(scene, camera, useFrameBufferTarget = true) {
		if (this._isDeviceLost === true) return;
		const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;
		const nodeFrame = this._nodes.nodeFrame;
		const previousRenderId = nodeFrame.renderId;
		const previousRenderContext = this._currentRenderContext;
		const previousRenderObjectFunction = this._currentRenderObjectFunction;
		const sceneRef = scene.isScene === true ? scene : _scene;
		const outputRenderTarget = this._renderTarget || this._outputRenderTarget;
		const activeCubeFace = this._activeCubeFace;
		const activeMipmapLevel = this._activeMipmapLevel;
		let renderTarget;
		if (frameBufferTarget !== null) {
			renderTarget = frameBufferTarget;
			this.setRenderTarget(renderTarget);
		} else renderTarget = outputRenderTarget;
		const renderContext = this._renderContexts.get(scene, camera, renderTarget);
		this._currentRenderContext = renderContext;
		this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
		this.info.calls++;
		this.info.render.calls++;
		this.info.render.frameCalls++;
		nodeFrame.renderId = this.info.calls;
		this.backend.updateTimeStampUID(renderContext);
		this.inspector.beginRender(this.backend.getTimestampUID(renderContext), scene, camera, renderTarget);
		const coordinateSystem = this.coordinateSystem;
		const xr = this.xr;
		if (camera.coordinateSystem !== coordinateSystem && xr.isPresenting === false) {
			camera.coordinateSystem = coordinateSystem;
			camera.updateProjectionMatrix();
			if (camera.isArrayCamera) for (const subCamera of camera.cameras) {
				subCamera.coordinateSystem = coordinateSystem;
				subCamera.updateProjectionMatrix();
			}
		}
		if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
		if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
		if (xr.enabled === true && xr.isPresenting === true) {
			if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
			camera = xr.getCamera();
		}
		const canvasTarget = this._canvasTarget;
		let viewport$2 = canvasTarget._viewport;
		let scissor = canvasTarget._scissor;
		let pixelRatio = canvasTarget._pixelRatio;
		if (renderTarget !== null) {
			viewport$2 = renderTarget.viewport;
			scissor = renderTarget.scissor;
			pixelRatio = 1;
		}
		this.getDrawingBufferSize(_drawingBufferSize);
		_screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);
		const minDepth = viewport$2.minDepth === void 0 ? 0 : viewport$2.minDepth;
		const maxDepth = viewport$2.maxDepth === void 0 ? 1 : viewport$2.maxDepth;
		renderContext.viewportValue.copy(viewport$2).multiplyScalar(pixelRatio).floor();
		renderContext.viewportValue.width >>= activeMipmapLevel;
		renderContext.viewportValue.height >>= activeMipmapLevel;
		renderContext.viewportValue.minDepth = minDepth;
		renderContext.viewportValue.maxDepth = maxDepth;
		renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;
		renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();
		renderContext.scissor = canvasTarget._scissorTest && renderContext.scissorValue.equals(_screen) === false;
		renderContext.scissorValue.width >>= activeMipmapLevel;
		renderContext.scissorValue.height >>= activeMipmapLevel;
		if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();
		renderContext.clippingContext.updateGlobal(sceneRef, camera);
		sceneRef.onBeforeRender(this, scene, camera, renderTarget);
		const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
		if (!camera.isArrayCamera) {
			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			frustum.setFromProjectionMatrix(_projScreenMatrix, camera.coordinateSystem, camera.reversedDepth);
		}
		const renderList = this._renderLists.get(scene, camera);
		renderList.begin();
		this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
		renderList.finish();
		if (this.sortObjects === true) renderList.sort(this._opaqueSort, this._transparentSort);
		if (renderTarget !== null) {
			this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
			const renderTargetData = this._textures.get(renderTarget);
			renderContext.textures = renderTargetData.textures;
			renderContext.depthTexture = renderTargetData.depthTexture;
			renderContext.width = renderTargetData.width;
			renderContext.height = renderTargetData.height;
			renderContext.renderTarget = renderTarget;
			renderContext.depth = renderTarget.depthBuffer;
			renderContext.stencil = renderTarget.stencilBuffer;
		} else {
			renderContext.textures = null;
			renderContext.depthTexture = null;
			renderContext.width = _drawingBufferSize.width;
			renderContext.height = _drawingBufferSize.height;
			renderContext.depth = this.depth;
			renderContext.stencil = this.stencil;
		}
		renderContext.width >>= activeMipmapLevel;
		renderContext.height >>= activeMipmapLevel;
		renderContext.activeCubeFace = activeCubeFace;
		renderContext.activeMipmapLevel = activeMipmapLevel;
		renderContext.occlusionQueryCount = renderList.occlusionQueryCount;
		renderContext.scissorValue.max(_vector4.set(0, 0, 0, 0));
		if (renderContext.scissorValue.x + renderContext.scissorValue.width > renderContext.width) renderContext.scissorValue.width = Math.max(renderContext.width - renderContext.scissorValue.x, 0);
		if (renderContext.scissorValue.y + renderContext.scissorValue.height > renderContext.height) renderContext.scissorValue.height = Math.max(renderContext.height - renderContext.scissorValue.y, 0);
		this._background.update(sceneRef, renderList, renderContext);
		renderContext.camera = camera;
		this.backend.beginRender(renderContext);
		const { bundles, lightsNode, transparentDoublePass: transparentDoublePassObjects, transparent: transparentObjects, opaque: opaqueObjects } = renderList;
		if (bundles.length > 0) this._renderBundles(bundles, sceneRef, lightsNode);
		if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
		if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);
		this.backend.finishRender(renderContext);
		nodeFrame.renderId = previousRenderId;
		this._currentRenderContext = previousRenderContext;
		this._currentRenderObjectFunction = previousRenderObjectFunction;
		if (frameBufferTarget !== null) {
			this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);
			this._renderOutput(renderTarget);
		}
		sceneRef.onAfterRender(this, scene, camera, renderTarget);
		this.inspector.finishRender(this.backend.getTimestampUID(renderContext));
		return renderContext;
	}
	_setXRLayerSize(width, height) {
		this._canvasTarget._width = width;
		this._canvasTarget._height = height;
		this.setViewport(0, 0, width, height);
	}
	/**
	* The output pass performs tone mapping and color space conversion.
	*
	* @private
	* @param {RenderTarget} renderTarget - The current render target.
	*/
	_renderOutput(renderTarget) {
		const quad = this._quad;
		if (this._nodes.hasOutputChange(renderTarget.texture)) {
			quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
			quad.material.needsUpdate = true;
		}
		const currentAutoClear = this.autoClear;
		const currentXR = this.xr.enabled;
		this.autoClear = false;
		this.xr.enabled = false;
		this._renderScene(quad, quad.camera, false);
		this.autoClear = currentAutoClear;
		this.xr.enabled = currentXR;
	}
	/**
	* Returns the maximum available anisotropy for texture filtering.
	*
	* @return {number} The maximum available anisotropy.
	*/
	getMaxAnisotropy() {
		return this.backend.getMaxAnisotropy();
	}
	/**
	* Returns the active cube face.
	*
	* @return {number} The active cube face.
	*/
	getActiveCubeFace() {
		return this._activeCubeFace;
	}
	/**
	* Returns the active mipmap level.
	*
	* @return {number} The active mipmap level.
	*/
	getActiveMipmapLevel() {
		return this._activeMipmapLevel;
	}
	/**
	* Applications are advised to always define the animation loop
	* with this method and not manually with `requestAnimationFrame()`
	* for best compatibility.
	*
	* @async
	* @param {?onAnimationCallback} callback - The application's animation loop.
	* @return {Promise} A Promise that resolves when the set has been executed.
	*/
	async setAnimationLoop(callback) {
		if (this._initialized === false) await this.init();
		this._animation.setAnimationLoop(callback);
	}
	/**
	* Returns the current animation loop callback.
	*
	* @return {?Function} The current animation loop callback.
	*/
	getAnimationLoop() {
		return this._animation.getAnimationLoop();
	}
	/**
	* Can be used to transfer buffer data from a storage buffer attribute
	* from the GPU to the CPU in context of compute shaders.
	*
	* @async
	* @param {StorageBufferAttribute} attribute - The storage buffer attribute.
	* @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
	*/
	async getArrayBufferAsync(attribute$2) {
		return await this.backend.getArrayBufferAsync(attribute$2);
	}
	/**
	* Returns the rendering context.
	*
	* @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.
	*/
	getContext() {
		return this.backend.getContext();
	}
	/**
	* Returns the pixel ratio.
	*
	* @return {number} The pixel ratio.
	*/
	getPixelRatio() {
		return this._canvasTarget.getPixelRatio();
	}
	/**
	* Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
	*
	* @param {Vector2} target - The method writes the result in this target object.
	* @return {Vector2} The drawing buffer size.
	*/
	getDrawingBufferSize(target) {
		return this._canvasTarget.getDrawingBufferSize(target);
	}
	/**
	* Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
	*
	* @param {Vector2} target - The method writes the result in this target object.
	* @return {Vector2} The renderer's size in logical pixels.
	*/
	getSize(target) {
		return this._canvasTarget.getSize(target);
	}
	/**
	* Sets the given pixel ratio and resizes the canvas if necessary.
	*
	* @param {number} [value=1] - The pixel ratio.
	*/
	setPixelRatio(value = 1) {
		this._canvasTarget.setPixelRatio(value);
	}
	/**
	* This method allows to define the drawing buffer size by specifying
	* width, height and pixel ratio all at once. The size of the drawing
	* buffer is computed with this formula:
	* ```js
	* size.x = width * pixelRatio;
	* size.y = height * pixelRatio;
	* ```
	*
	* @param {number} width - The width in logical pixels.
	* @param {number} height - The height in logical pixels.
	* @param {number} pixelRatio - The pixel ratio.
	*/
	setDrawingBufferSize(width, height, pixelRatio) {
		if (this.xr && this.xr.isPresenting) return;
		this._canvasTarget.setDrawingBufferSize(width, height, pixelRatio);
	}
	/**
	* Sets the size of the renderer.
	*
	* @param {number} width - The width in logical pixels.
	* @param {number} height - The height in logical pixels.
	* @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
	*/
	setSize(width, height, updateStyle = true) {
		if (this.xr && this.xr.isPresenting) return;
		this._canvasTarget.setSize(width, height, updateStyle);
	}
	/**
	* Defines a manual sort function for the opaque render list.
	* Pass `null` to use the default sort.
	*
	* @param {Function} method - The sort function.
	*/
	setOpaqueSort(method) {
		this._opaqueSort = method;
	}
	/**
	* Defines a manual sort function for the transparent render list.
	* Pass `null` to use the default sort.
	*
	* @param {Function} method - The sort function.
	*/
	setTransparentSort(method) {
		this._transparentSort = method;
	}
	/**
	* Returns the scissor rectangle.
	*
	* @param {Vector4} target - The method writes the result in this target object.
	* @return {Vector4} The scissor rectangle.
	*/
	getScissor(target) {
		return this._canvasTarget.getScissor(target);
	}
	/**
	* Defines the scissor rectangle.
	*
	* @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
	* Instead of passing four arguments, the method also works with a single four-dimensional vector.
	* @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
	* @param {number} width - The width of the scissor box in logical pixel unit.
	* @param {number} height - The height of the scissor box in logical pixel unit.
	*/
	setScissor(x, y, width, height) {
		this._canvasTarget.setScissor(x, y, width, height);
	}
	/**
	* Returns the scissor test value.
	*
	* @return {boolean} Whether the scissor test should be enabled or not.
	*/
	getScissorTest() {
		return this._canvasTarget.getScissorTest();
	}
	/**
	* Defines the scissor test.
	*
	* @param {boolean} boolean - Whether the scissor test should be enabled or not.
	*/
	setScissorTest(boolean) {
		this._canvasTarget.setScissorTest(boolean);
		this.backend.setScissorTest(boolean);
	}
	/**
	* Returns the viewport definition.
	*
	* @param {Vector4} target - The method writes the result in this target object.
	* @return {Vector4} The viewport definition.
	*/
	getViewport(target) {
		return this._canvasTarget.getViewport(target);
	}
	/**
	* Defines the viewport.
	*
	* @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
	* @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
	* @param {number} width - The width of the viewport in logical pixel unit.
	* @param {number} height - The height of the viewport in logical pixel unit.
	* @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
	* @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
	*/
	setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
		this._canvasTarget.setViewport(x, y, width, height, minDepth, maxDepth);
	}
	/**
	* Returns the clear color.
	*
	* @param {Color} target - The method writes the result in this target object.
	* @return {Color} The clear color.
	*/
	getClearColor(target) {
		return target.copy(this._clearColor);
	}
	/**
	* Defines the clear color and optionally the clear alpha.
	*
	* @param {Color} color - The clear color.
	* @param {number} [alpha=1] - The clear alpha.
	*/
	setClearColor(color$2, alpha = 1) {
		this._clearColor.set(color$2);
		this._clearColor.a = alpha;
	}
	/**
	* Returns the clear alpha.
	*
	* @return {number} The clear alpha.
	*/
	getClearAlpha() {
		return this._clearColor.a;
	}
	/**
	* Defines the clear alpha.
	*
	* @param {number} alpha - The clear alpha.
	*/
	setClearAlpha(alpha) {
		this._clearColor.a = alpha;
	}
	/**
	* Returns the clear depth.
	*
	* @return {number} The clear depth.
	*/
	getClearDepth() {
		return this._clearDepth;
	}
	/**
	* Defines the clear depth.
	*
	* @param {number} depth - The clear depth.
	*/
	setClearDepth(depth$2) {
		this._clearDepth = depth$2;
	}
	/**
	* Returns the clear stencil.
	*
	* @return {number} The clear stencil.
	*/
	getClearStencil() {
		return this._clearStencil;
	}
	/**
	* Defines the clear stencil.
	*
	* @param {number} stencil - The clear stencil.
	*/
	setClearStencil(stencil) {
		this._clearStencil = stencil;
	}
	/**
	* This method performs an occlusion query for the given 3D object.
	* It returns `true` if the given 3D object is fully occluded by other
	* 3D objects in the scene.
	*
	* @param {Object3D} object - The 3D object to test.
	* @return {boolean} Whether the 3D object is fully occluded or not.
	*/
	isOccluded(object) {
		const renderContext = this._currentRenderContext;
		return renderContext && this.backend.isOccluded(renderContext, object);
	}
	/**
	* Performs a manual clear operation. This method ignores `autoClear` properties.
	*
	* @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
	* @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
	* @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
	*/
	clear(color$2 = true, depth$2 = true, stencil = true) {
		if (this._initialized === false) throw new Error("Renderer: .clear() called before the backend is initialized. Use \"await renderer.init();\" before before using this method.");
		const renderTarget = this._renderTarget || this._getFrameBufferTarget();
		let renderContext = null;
		if (renderTarget !== null) {
			this._textures.updateRenderTarget(renderTarget);
			const renderTargetData = this._textures.get(renderTarget);
			renderContext = this._renderContexts.getForClear(renderTarget);
			renderContext.textures = renderTargetData.textures;
			renderContext.depthTexture = renderTargetData.depthTexture;
			renderContext.width = renderTargetData.width;
			renderContext.height = renderTargetData.height;
			renderContext.renderTarget = renderTarget;
			renderContext.depth = renderTarget.depthBuffer;
			renderContext.stencil = renderTarget.stencilBuffer;
			renderContext.clearColorValue = this.backend.getClearColor();
			renderContext.activeCubeFace = this.getActiveCubeFace();
			renderContext.activeMipmapLevel = this.getActiveMipmapLevel();
		}
		this.backend.clear(color$2, depth$2, stencil, renderContext);
		if (renderTarget !== null && this._renderTarget === null) this._renderOutput(renderTarget);
	}
	/**
	* Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.
	*/
	clearColor() {
		this.clear(true, false, false);
	}
	/**
	* Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.
	*/
	clearDepth() {
		this.clear(false, true, false);
	}
	/**
	* Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.
	*/
	clearStencil() {
		this.clear(false, false, true);
	}
	/**
	* Async version of {@link Renderer#clear}.
	*
	* @async
	* @deprecated
	* @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
	* @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
	* @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
	* @return {Promise} A Promise that resolves when the clear operation has been executed.
	*/
	async clearAsync(color$2 = true, depth$2 = true, stencil = true) {
		warnOnce("Renderer: \"clearAsync()\" has been deprecated. Use \"clear()\" and \"await renderer.init();\" when creating the renderer.");
		await this.init();
		this.clear(color$2, depth$2, stencil);
	}
	/**
	* Async version of {@link Renderer#clearColor}.
	*
	* @async
	* @deprecated
	* @return {Promise} A Promise that resolves when the clear operation has been executed.
	*/
	async clearColorAsync() {
		warnOnce("Renderer: \"clearColorAsync()\" has been deprecated. Use \"clearColor()\" and \"await renderer.init();\" when creating the renderer.");
		this.clear(true, false, false);
	}
	/**
	* Async version of {@link Renderer#clearDepth}.
	*
	* @async
	* @deprecated
	* @return {Promise} A Promise that resolves when the clear operation has been executed.
	*/
	async clearDepthAsync() {
		warnOnce("Renderer: \"clearDepthAsync()\" has been deprecated. Use \"clearDepth()\" and \"await renderer.init();\" when creating the renderer.");
		this.clear(false, true, false);
	}
	/**
	* Async version of {@link Renderer#clearStencil}.
	*
	* @async
	* @deprecated
	* @return {Promise} A Promise that resolves when the clear operation has been executed.
	*/
	async clearStencilAsync() {
		warnOnce("Renderer: \"clearStencilAsync()\" has been deprecated. Use \"clearStencil()\" and \"await renderer.init();\" when creating the renderer.");
		this.clear(false, false, true);
	}
	/**
	* Returns `true` if a framebuffer target is needed to perform tone mapping or color space conversion.
	* If this is the case, the renderer allocates an internal render target for that purpose.
	*
	*/
	get needsFrameBufferTarget() {
		const useToneMapping = this.currentToneMapping !== NoToneMapping;
		const useColorSpace = this.currentColorSpace !== ColorManagement.workingColorSpace;
		return useToneMapping || useColorSpace;
	}
	/**
	* The number of samples used for multi-sample anti-aliasing (MSAA).
	*
	* @type {number}
	* @default 0
	*/
	get samples() {
		return this._samples;
	}
	/**
	* The current number of samples used for multi-sample anti-aliasing (MSAA).
	*
	* When rendering to a custom render target, the number of samples of that render target is used.
	* If the renderer needs an internal framebuffer target for tone mapping or color space conversion,
	* the number of samples is set to 0.
	*
	* @type {number}
	*/
	get currentSamples() {
		let samples = this._samples;
		if (this._renderTarget !== null) samples = this._renderTarget.samples;
		else if (this.needsFrameBufferTarget) samples = 0;
		return samples;
	}
	/**
	* The current tone mapping of the renderer. When not producing screen output,
	* the tone mapping is always `NoToneMapping`.
	*
	* @type {number}
	*/
	get currentToneMapping() {
		return this.isOutputTarget ? this.toneMapping : NoToneMapping;
	}
	/**
	* The current color space of the renderer. When not producing screen output,
	* the color space is always the working color space.
	*
	* @type {string}
	*/
	get currentColorSpace() {
		return this.isOutputTarget ? this.outputColorSpace : ColorManagement.workingColorSpace;
	}
	/**
	* Returns `true` if the rendering settings are set to screen output.
	*
	* @returns {boolean} True if the current render target is the same of output render target or `null`, otherwise false.
	*/
	get isOutputTarget() {
		return this._renderTarget === this._outputRenderTarget || this._renderTarget === null;
	}
	/**
	* Frees all internal resources of the renderer. Call this method if the renderer
	* is no longer in use by your app.
	*/
	dispose() {
		if (this._initialized === true) {
			this.info.dispose();
			this.backend.dispose();
			this._animation.dispose();
			this._objects.dispose();
			this._geometries.dispose();
			this._pipelines.dispose();
			this._nodes.dispose();
			this._bindings.dispose();
			this._renderLists.dispose();
			this._renderContexts.dispose();
			this._textures.dispose();
			if (this._frameBufferTarget !== null) this._frameBufferTarget.dispose();
			Object.values(this.backend.timestampQueryPool).forEach((queryPool) => {
				if (queryPool !== null) queryPool.dispose();
			});
		}
		this.setRenderTarget(null);
		this.setAnimationLoop(null);
	}
	/**
	* Sets the given render target. Calling this method means the renderer does not
	* target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
	* Use `null` as the first argument to reset the state.
	*
	* @param {?RenderTarget} renderTarget - The render target to set.
	* @param {number} [activeCubeFace=0] - The active cube face.
	* @param {number} [activeMipmapLevel=0] - The active mipmap level.
	*/
	setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
		this._renderTarget = renderTarget;
		this._activeCubeFace = activeCubeFace;
		this._activeMipmapLevel = activeMipmapLevel;
	}
	/**
	* Returns the current render target.
	*
	* @return {?RenderTarget} The render target. Returns `null` if no render target is set.
	*/
	getRenderTarget() {
		return this._renderTarget;
	}
	/**
	* Sets the output render target for the renderer.
	*
	* @param {Object} renderTarget - The render target to set as the output target.
	*/
	setOutputRenderTarget(renderTarget) {
		this._outputRenderTarget = renderTarget;
	}
	/**
	* Returns the current output target.
	*
	* @return {?RenderTarget} The current output render target. Returns `null` if no output target is set.
	*/
	getOutputRenderTarget() {
		return this._outputRenderTarget;
	}
	/**
	* Sets the canvas target. The canvas target manages the HTML canvas
	* or the offscreen canvas the renderer draws into.
	*
	* @param {CanvasTarget} canvasTarget - The canvas target.
	*/
	setCanvasTarget(canvasTarget) {
		this._canvasTarget.removeEventListener("resize", this._onCanvasTargetResize);
		this._canvasTarget = canvasTarget;
		this._canvasTarget.addEventListener("resize", this._onCanvasTargetResize);
	}
	/**
	* Returns the current canvas target.
	*
	* @return {CanvasTarget} The current canvas target.
	*/
	getCanvasTarget() {
		return this._canvasTarget;
	}
	/**
	* Resets the renderer to the initial state before WebXR started.
	*
	*/
	_resetXRState() {
		this.backend.setXRTarget(null);
		this.setOutputRenderTarget(null);
		this.setRenderTarget(null);
		this._frameBufferTarget.dispose();
		this._frameBufferTarget = null;
	}
	/**
	* Callback for {@link Renderer#setRenderObjectFunction}.
	*
	* @callback renderObjectFunction
	* @param {Object3D} object - The 3D object.
	* @param {Scene} scene - The scene the 3D object belongs to.
	* @param {Camera} camera - The camera the object should be rendered with.
	* @param {BufferGeometry} geometry - The object's geometry.
	* @param {Material} material - The object's material.
	* @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
	* @param {LightsNode} lightsNode - The current lights node.
	* @param {ClippingContext} clippingContext - The clipping context.
	* @param {?string} [passId=null] - An optional ID for identifying the pass.
	*/
	/**
	* Sets the given render object function. Calling this method overwrites the default implementation
	* which is {@link Renderer#renderObject}. Defining a custom function can be useful
	* if you want to modify the way objects are rendered. For example you can define things like "every
	* object that has material of a certain type should perform a pre-pass with a special overwrite material".
	* The custom function must always call `renderObject()` in its implementation.
	*
	* Use `null` as the first argument to reset the state.
	*
	* @param {?renderObjectFunction} renderObjectFunction - The render object function.
	*/
	setRenderObjectFunction(renderObjectFunction) {
		this._renderObjectFunction = renderObjectFunction;
	}
	/**
	* Returns the current render object function.
	*
	* @return {?Function} The current render object function. Returns `null` if no function is set.
	*/
	getRenderObjectFunction() {
		return this._renderObjectFunction;
	}
	/**
	* Execute a single or an array of compute nodes. This method can only be called
	* if the renderer has been initialized.
	*
	* @param {Node|Array<Node>} computeNodes - The compute node(s).
	* @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
	* - A single number representing count, or
	* - An array [x, y, z] representing dispatch size, or
	* - A IndirectStorageBufferAttribute for indirect dispatch size.
	* @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
	*/
	compute(computeNodes, dispatchSize = null) {
		if (this._isDeviceLost === true) return;
		if (this._initialized === false) {
			warn("Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.");
			return this.computeAsync(computeNodes, dispatchSize);
		}
		const nodeFrame = this._nodes.nodeFrame;
		const previousRenderId = nodeFrame.renderId;
		this.info.calls++;
		this.info.compute.calls++;
		this.info.compute.frameCalls++;
		nodeFrame.renderId = this.info.calls;
		this.backend.updateTimeStampUID(computeNodes);
		this.inspector.beginCompute(this.backend.getTimestampUID(computeNodes), computeNodes);
		const backend = this.backend;
		const pipelines = this._pipelines;
		const bindings = this._bindings;
		const nodes = this._nodes;
		const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
		if (computeList[0] === void 0 || computeList[0].isComputeNode !== true) throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
		backend.beginCompute(computeNodes);
		for (const computeNode of computeList) {
			if (pipelines.has(computeNode) === false) {
				const dispose = () => {
					computeNode.removeEventListener("dispose", dispose);
					pipelines.delete(computeNode);
					bindings.deleteForCompute(computeNode);
					nodes.delete(computeNode);
				};
				computeNode.addEventListener("dispose", dispose);
				const onInitFn = computeNode.onInitFunction;
				if (onInitFn !== null) onInitFn.call(computeNode, { renderer: this });
			}
			nodes.updateForCompute(computeNode);
			bindings.updateForCompute(computeNode);
			const computeBindings = bindings.getForCompute(computeNode);
			const computePipeline = pipelines.getForCompute(computeNode, computeBindings);
			backend.compute(computeNodes, computeNode, computeBindings, computePipeline, dispatchSize);
		}
		backend.finishCompute(computeNodes);
		nodeFrame.renderId = previousRenderId;
		this.inspector.finishCompute(this.backend.getTimestampUID(computeNodes));
	}
	/**
	* Execute a single or an array of compute nodes.
	*
	* @async
	* @param {Node|Array<Node>} computeNodes - The compute node(s).
	* @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
	* - A single number representing count, or
	* - An array [x, y, z] representing dispatch size, or
	* - A IndirectStorageBufferAttribute for indirect dispatch size.
	* @return {Promise} A Promise that resolve when the compute has finished.
	*/
	async computeAsync(computeNodes, dispatchSize = null) {
		if (this._initialized === false) await this.init();
		this.compute(computeNodes, dispatchSize);
	}
	/**
	* Checks if the given feature is supported by the selected backend.
	*
	* @async
	* @deprecated
	* @param {string} name - The feature's name.
	* @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
	*/
	async hasFeatureAsync(name) {
		warnOnce("Renderer: \"hasFeatureAsync()\" has been deprecated. Use \"hasFeature()\" and \"await renderer.init();\" when creating the renderer.");
		await this.init();
		return this.hasFeature(name);
	}
	async resolveTimestampsAsync(type$1 = "render") {
		if (this._initialized === false) await this.init();
		return this.backend.resolveTimestampsAsync(type$1);
	}
	/**
	* Checks if the given feature is supported by the selected backend. If the
	* renderer has not been initialized, this method always returns `false`.
	*
	* @param {string} name - The feature's name.
	* @return {boolean} Whether the feature is supported or not.
	*/
	hasFeature(name) {
		if (this._initialized === false) throw new Error("Renderer: .hasFeature() called before the backend is initialized. Use \"await renderer.init();\" before before using this method.");
		return this.backend.hasFeature(name);
	}
	/**
	* Returns `true` when the renderer has been initialized.
	*
	* @return {boolean} Whether the renderer has been initialized or not.
	*/
	hasInitialized() {
		return this._initialized;
	}
	/**
	* Initializes the given textures. Useful for preloading a texture rather than waiting until first render
	* (which can cause noticeable lags due to decode and GPU upload overhead).
	*
	* @async
	* @deprecated
	* @param {Texture} texture - The texture.
	* @return {Promise} A Promise that resolves when the texture has been initialized.
	*/
	async initTextureAsync(texture$2) {
		warnOnce("Renderer: \"initTextureAsync()\" has been deprecated. Use \"initTexture()\" and \"await renderer.init();\" when creating the renderer.");
		await this.init();
		this.initTexture(texture$2);
	}
	/**
	* Initializes the given texture. Useful for preloading a texture rather than waiting until first render
	* (which can cause noticeable lags due to decode and GPU upload overhead).
	*
	* This method can only be used if the renderer has been initialized.
	*
	* @param {Texture} texture - The texture.
	*/
	initTexture(texture$2) {
		if (this._initialized === false) throw new Error("Renderer: .initTexture() called before the backend is initialized. Use \"await renderer.init();\" before before using this method.");
		this._textures.updateTexture(texture$2);
	}
	/**
	* Copies the current bound framebuffer into the given texture.
	*
	* @param {FramebufferTexture} framebufferTexture - The texture.
	* @param {?(Vector2|Vector4)} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
	*/
	copyFramebufferToTexture(framebufferTexture, rectangle = null) {
		if (rectangle !== null) if (rectangle.isVector2) rectangle = _vector4.set(rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height).floor();
		else if (rectangle.isVector4) rectangle = _vector4.copy(rectangle).floor();
		else {
			error("Renderer.copyFramebufferToTexture: Invalid rectangle.");
			return;
		}
		else rectangle = _vector4.set(0, 0, framebufferTexture.image.width, framebufferTexture.image.height);
		let renderContext = this._currentRenderContext;
		let renderTarget;
		if (renderContext !== null) renderTarget = renderContext.renderTarget;
		else {
			renderTarget = this._renderTarget || this._getFrameBufferTarget();
			if (renderTarget !== null) {
				this._textures.updateRenderTarget(renderTarget);
				renderContext = this._textures.get(renderTarget);
			}
		}
		this._textures.updateTexture(framebufferTexture, { renderTarget });
		this.backend.copyFramebufferToTexture(framebufferTexture, renderContext, rectangle);
		this._inspector.copyFramebufferToTexture(framebufferTexture);
	}
	/**
	* Copies data of the given source texture into a destination texture.
	*
	* @param {Texture} srcTexture - The source texture.
	* @param {Texture} dstTexture - The destination texture.
	* @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
	* @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
	* @param {number} [srcLevel=0] - The source mip level to copy from.
	* @param {number} [dstLevel=0] - The destination mip level to copy to.
	*/
	copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
		this._textures.updateTexture(srcTexture);
		this._textures.updateTexture(dstTexture);
		this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel);
		this._inspector.copyTextureToTexture(srcTexture, dstTexture);
	}
	/**
	* Reads pixel data from the given render target.
	*
	* @async
	* @param {RenderTarget} renderTarget - The render target to read from.
	* @param {number} x - The `x` coordinate of the copy region's origin.
	* @param {number} y - The `y` coordinate of the copy region's origin.
	* @param {number} width - The width of the copy region.
	* @param {number} height - The height of the copy region.
	* @param {number} [textureIndex=0] - The texture index of a MRT render target.
	* @param {number} [faceIndex=0] - The active cube face index.
	* @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
	*/
	async readRenderTargetPixelsAsync(renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0) {
		return this.backend.copyTextureToBuffer(renderTarget.textures[textureIndex], x, y, width, height, faceIndex);
	}
	/**
	* Analyzes the given 3D object's hierarchy and builds render lists from the
	* processed hierarchy.
	*
	* @param {Object3D} object - The 3D object to process (usually a scene).
	* @param {Camera} camera - The camera the object is rendered with.
	* @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.
	* @param {RenderList} renderList - The current render list.
	* @param {ClippingContext} clippingContext - The current clipping context.
	*/
	_projectObject(object, camera, groupOrder, renderList, clippingContext) {
		if (object.visible === false) return;
		if (object.layers.test(camera.layers)) {
			if (object.isGroup) {
				groupOrder = object.renderOrder;
				if (object.isClippingGroup && object.enabled) clippingContext = clippingContext.getGroupContext(object);
			} else if (object.isLOD) {
				if (object.autoUpdate === true) object.update(camera);
			} else if (object.isLight) renderList.pushLight(object);
			else if (object.isSprite) {
				const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
				if (!object.frustumCulled || frustum.intersectsSprite(object, camera)) {
					if (this.sortObjects === true) _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					const { geometry, material } = object;
					if (material.visible) renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);
				}
			} else if (object.isLineLoop) error("Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
			else if (object.isMesh || object.isLine || object.isPoints) {
				const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
				if (!object.frustumCulled || frustum.intersectsObject(object, camera)) {
					const { geometry, material } = object;
					if (this.sortObjects === true) {
						if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
						_vector4.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}
					if (Array.isArray(material)) {
						const groups = geometry.groups;
						for (let i = 0, l = groups.length; i < l; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							if (groupMaterial && groupMaterial.visible) renderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext);
						}
					} else if (material.visible) renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);
				}
			}
		}
		if (object.isBundleGroup === true && this.backend.beginBundle !== void 0) {
			const baseRenderList = renderList;
			renderList = this._renderLists.get(object, camera);
			renderList.begin();
			baseRenderList.pushBundle({
				bundleGroup: object,
				camera,
				renderList
			});
			renderList.finish();
		}
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) this._projectObject(children[i], camera, groupOrder, renderList, clippingContext);
	}
	/**
	* Renders the given render bundles.
	*
	* @private
	* @param {Array<Object>} bundles - Array with render bundle data.
	* @param {Scene} sceneRef - The scene the render bundles belong to.
	* @param {LightsNode} lightsNode - The current lights node.
	*/
	_renderBundles(bundles, sceneRef, lightsNode) {
		for (const bundle of bundles) this._renderBundle(bundle, sceneRef, lightsNode);
	}
	/**
	* Renders the transparent objects from the given render lists.
	*
	* @private
	* @param {Array<Object>} renderList - The transparent render list.
	* @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).
	* @param {Camera} camera - The camera the render list should be rendered with.
	* @param {Scene} scene - The scene the render list belongs to.
	* @param {LightsNode} lightsNode - The current lights node.
	*/
	_renderTransparents(renderList, doublePassList, camera, scene, lightsNode) {
		if (doublePassList.length > 0) {
			for (const { material } of doublePassList) material.side = BackSide;
			this._renderObjects(doublePassList, camera, scene, lightsNode, "backSide");
			for (const { material } of doublePassList) material.side = FrontSide;
			this._renderObjects(renderList, camera, scene, lightsNode);
			for (const { material } of doublePassList) material.side = DoubleSide;
		} else this._renderObjects(renderList, camera, scene, lightsNode);
	}
	/**
	* Renders the objects from the given render list.
	*
	* @private
	* @param {Array<Object>} renderList - The render list.
	* @param {Camera} camera - The camera the render list should be rendered with.
	* @param {Scene} scene - The scene the render list belongs to.
	* @param {LightsNode} lightsNode - The current lights node.
	* @param {?string} [passId=null] - An optional ID for identifying the pass.
	*/
	_renderObjects(renderList, camera, scene, lightsNode, passId = null) {
		for (let i = 0, il = renderList.length; i < il; i++) {
			const { object, geometry, material, group, clippingContext } = renderList[i];
			this._currentRenderObjectFunction(object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId);
		}
	}
	/**
	* Retrieves shadow nodes for the given material. This is used to setup shadow passes.
	* The result is cached per material and updated when the material's version changes.
	*
	* @param {Material} material
	* @returns {Object} - The shadow nodes for the material.
	*/
	_getShadowNodes(material) {
		const version = material.version;
		let cache$2 = this._cacheShadowNodes.get(material);
		if (cache$2 === void 0 || cache$2.version !== version) {
			const hasMap = material.map !== null;
			const hasColorNode = material.colorNode && material.colorNode.isNode;
			const hasCastShadowNode = material.castShadowNode && material.castShadowNode.isNode;
			let positionNode = null;
			let colorNode = null;
			let depthNode = null;
			if (hasMap || hasColorNode || hasCastShadowNode) {
				let shadowRGB;
				let shadowAlpha;
				if (hasCastShadowNode) {
					shadowRGB = material.castShadowNode.rgb;
					shadowAlpha = material.castShadowNode.a;
				} else {
					shadowRGB = vec3$1(0);
					shadowAlpha = float$1(1);
				}
				if (hasMap) shadowAlpha = shadowAlpha.mul(reference$2("map", "texture", material).a);
				if (hasColorNode) shadowAlpha = shadowAlpha.mul(material.colorNode.a);
				colorNode = vec4$1(shadowRGB, shadowAlpha);
			}
			if (material.depthNode && material.depthNode.isNode) depthNode = material.depthNode;
			if (material.castShadowPositionNode && material.castShadowPositionNode.isNode) positionNode = material.castShadowPositionNode;
			else if (material.positionNode && material.positionNode.isNode) positionNode = material.positionNode;
			cache$2 = {
				version,
				colorNode,
				depthNode,
				positionNode
			};
			this._cacheShadowNodes.set(material, cache$2);
		}
		return cache$2;
	}
	/**
	* This method represents the default render object function that manages the render lifecycle
	* of the object.
	*
	* @param {Object3D} object - The 3D object.
	* @param {Scene} scene - The scene the 3D object belongs to.
	* @param {Camera} camera - The camera the object should be rendered with.
	* @param {BufferGeometry} geometry - The object's geometry.
	* @param {Material} material - The object's material.
	* @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
	* @param {LightsNode} lightsNode - The current lights node.
	* @param {?ClippingContext} clippingContext - The clipping context.
	* @param {?string} [passId=null] - An optional ID for identifying the pass.
	*/
	renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null) {
		let materialOverride = false;
		let materialColorNode;
		let materialDepthNode;
		let materialPositionNode;
		let materialSide;
		object.onBeforeRender(this, scene, camera, geometry, material, group);
		if (material.allowOverride === true && scene.overrideMaterial !== null) {
			const overrideMaterial = scene.overrideMaterial;
			materialOverride = true;
			materialColorNode = scene.overrideMaterial.colorNode;
			materialDepthNode = scene.overrideMaterial.depthNode;
			materialPositionNode = scene.overrideMaterial.positionNode;
			materialSide = scene.overrideMaterial.side;
			if (material.positionNode && material.positionNode.isNode) overrideMaterial.positionNode = material.positionNode;
			overrideMaterial.alphaTest = material.alphaTest;
			overrideMaterial.alphaMap = material.alphaMap;
			overrideMaterial.transparent = material.transparent || material.transmission > 0 || material.transmissionNode && material.transmissionNode.isNode || material.backdropNode && material.backdropNode.isNode;
			if (overrideMaterial.isShadowPassMaterial) {
				const { colorNode, depthNode, positionNode } = this._getShadowNodes(material);
				overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;
				if (colorNode !== null) overrideMaterial.colorNode = colorNode;
				if (depthNode !== null) overrideMaterial.depthNode = depthNode;
				if (positionNode !== null) overrideMaterial.positionNode = positionNode;
			}
			material = overrideMaterial;
		}
		if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
			material.side = BackSide;
			this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, "backSide");
			material.side = FrontSide;
			this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId);
			material.side = DoubleSide;
		} else this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId);
		if (materialOverride) {
			scene.overrideMaterial.colorNode = materialColorNode;
			scene.overrideMaterial.depthNode = materialDepthNode;
			scene.overrideMaterial.positionNode = materialPositionNode;
			scene.overrideMaterial.side = materialSide;
		}
		object.onAfterRender(this, scene, camera, geometry, material, group);
	}
	/**
	* This method represents the default `_handleObjectFunction` implementation which creates
	* a render object from the given data and performs the draw command with the selected backend.
	*
	* @private
	* @param {Object3D} object - The 3D object.
	* @param {Material} material - The object's material.
	* @param {Scene} scene - The scene the 3D object belongs to.
	* @param {Camera} camera - The camera the object should be rendered with.
	* @param {LightsNode} lightsNode - The current lights node.
	* @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
	* @param {ClippingContext} clippingContext - The clipping context.
	* @param {string} [passId] - An optional ID for identifying the pass.
	*/
	_renderObjectDirect(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
		const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);
		renderObject.drawRange = object.geometry.drawRange;
		renderObject.group = group;
		const needsRefresh = this._nodes.needsRefresh(renderObject);
		if (needsRefresh) {
			this._nodes.updateBefore(renderObject);
			this._geometries.updateForRender(renderObject);
			this._nodes.updateForRender(renderObject);
			this._bindings.updateForRender(renderObject);
		}
		this._pipelines.updateForRender(renderObject);
		if (this._currentRenderBundle !== null) {
			this.backend.get(this._currentRenderBundle).renderObjects.push(renderObject);
			renderObject.bundle = this._currentRenderBundle.bundleGroup;
		}
		this.backend.draw(renderObject, this.info);
		if (needsRefresh) this._nodes.updateAfter(renderObject);
	}
	/**
	* A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.
	* Used in `compileAsync()`.
	*
	* @private
	* @param {Object3D} object - The 3D object.
	* @param {Material} material - The object's material.
	* @param {Scene} scene - The scene the 3D object belongs to.
	* @param {Camera} camera - The camera the object should be rendered with.
	* @param {LightsNode} lightsNode - The current lights node.
	* @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
	* @param {ClippingContext} clippingContext - The clipping context.
	* @param {string} [passId] - An optional ID for identifying the pass.
	*/
	_createObjectPipeline(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
		const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);
		renderObject.drawRange = object.geometry.drawRange;
		renderObject.group = group;
		this._nodes.updateBefore(renderObject);
		this._geometries.updateForRender(renderObject);
		this._nodes.updateForRender(renderObject);
		this._bindings.updateForRender(renderObject);
		this._pipelines.getForRender(renderObject, this._compilationPromises);
		this._nodes.updateAfter(renderObject);
	}
	/**
	* Callback when the canvas has been resized.
	*
	* @private
	*/
	_onCanvasTargetResize() {
		if (this._initialized) this.backend.updateSize();
	}
	/**
	* Alias for `compileAsync()`.
	*
	* @method
	* @param {Object3D} scene - The scene or 3D object to precompile.
	* @param {Camera} camera - The camera that is used to render the scene.
	* @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
	* @return {function(Object3D, Camera, ?Scene): Promise|undefined} A Promise that resolves when the compile has been finished.
	*/
	get compile() {
		return this.compileAsync;
	}
};
/**
* A binding represents the connection between a resource (like a texture, sampler
* or uniform buffer) and the resource definition in a shader stage.
*
* This module is an abstract base class for all concrete bindings types.
*
* @abstract
* @private
*/
var Binding = class {
	/**
	* Constructs a new binding.
	*
	* @param {string} [name=''] - The binding's name.
	*/
	constructor(name = "") {
		/**
		* The binding's name.
		*
		* @type {string}
		*/
		this.name = name;
		/**
		* A bitmask that defines in what shader stages the
		* binding's resource is accessible.
		*
		* @type {number}
		*/
		this.visibility = 0;
	}
	/**
	* Makes sure binding's resource is visible for the given shader stage.
	*
	* @param {number} visibility - The shader stage.
	*/
	setVisibility(visibility) {
		this.visibility |= visibility;
	}
	/**
	* Clones the binding.
	*
	* @return {Binding} The cloned binding.
	*/
	clone() {
		return Object.assign(new this.constructor(), this);
	}
};
/**
* This function is usually called with the length in bytes of an array buffer.
* It returns an padded value which ensure chunk size alignment according to STD140 layout.
*
* @function
* @param {number} floatLength - The buffer length.
* @return {number} The padded length.
*/
function getFloatLength(floatLength) {
	return floatLength + (GPU_CHUNK_BYTES - floatLength % GPU_CHUNK_BYTES) % GPU_CHUNK_BYTES;
}
/**
* Represents a buffer binding type.
*
* @private
* @abstract
* @augments Binding
*/
var Buffer = class extends Binding {
	/**
	* Constructs a new buffer.
	*
	* @param {string} name - The buffer's name.
	* @param {TypedArray} [buffer=null] - The buffer.
	*/
	constructor(name, buffer$2 = null) {
		super(name);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isBuffer = true;
		/**
		* The bytes per element.
		*
		* @type {number}
		*/
		this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;
		/**
		* A reference to the internal buffer.
		*
		* @private
		* @type {TypedArray}
		*/
		this._buffer = buffer$2;
	}
	/**
	* The buffer's byte length.
	*
	* @type {number}
	* @readonly
	*/
	get byteLength() {
		return getFloatLength(this._buffer.byteLength);
	}
	/**
	* A reference to the internal buffer.
	*
	* @type {Float32Array}
	* @readonly
	*/
	get buffer() {
		return this._buffer;
	}
	/**
	* Updates the binding.
	*
	* @return {boolean} Whether the buffer has been updated and must be
	* uploaded to the GPU.
	*/
	update() {
		return true;
	}
};
/**
* Represents a uniform buffer binding type.
*
* @private
* @augments Buffer
*/
var UniformBuffer = class extends Buffer {
	/**
	* Constructs a new uniform buffer.
	*
	* @param {string} name - The buffer's name.
	* @param {TypedArray} [buffer=null] - The buffer.
	*/
	constructor(name, buffer$2 = null) {
		super(name, buffer$2);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isUniformBuffer = true;
	}
};
var _id$4 = 0;
/**
* A special form of uniform buffer binding type.
* It's buffer value is managed by a node object.
*
* @private
* @augments UniformBuffer
*/
var NodeUniformBuffer = class extends UniformBuffer {
	/**
	* Constructs a new node-based uniform buffer.
	*
	* @param {BufferNode} nodeUniform - The uniform buffer node.
	* @param {UniformGroupNode} groupNode - The uniform group node.
	*/
	constructor(nodeUniform, groupNode) {
		super("UniformBuffer_" + _id$4++, nodeUniform ? nodeUniform.value : null);
		/**
		* The uniform buffer node.
		*
		* @type {BufferNode}
		*/
		this.nodeUniform = nodeUniform;
		/**
		* The uniform group node.
		*
		* @type {UniformGroupNode}
		*/
		this.groupNode = groupNode;
	}
	/**
	* The uniform buffer.
	*
	* @type {Float32Array}
	*/
	get buffer() {
		return this.nodeUniform.value;
	}
};
/**
* This class represents a uniform buffer binding but with
* an API that allows to maintain individual uniform objects.
*
* @private
* @augments UniformBuffer
*/
var UniformsGroup$1 = class extends UniformBuffer {
	/**
	* Constructs a new uniforms group.
	*
	* @param {string} name - The group's name.
	*/
	constructor(name) {
		super(name);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isUniformsGroup = true;
		/**
		* An array with the raw uniform values.
		*
		* @private
		* @type {?Array<number>}
		* @default null
		*/
		this._values = null;
		/**
		* An array of uniform objects.
		*
		* The order of uniforms in this array must match the order of uniforms in the shader.
		*
		* @type {Array<Uniform>}
		*/
		this.uniforms = [];
	}
	/**
	* Adds a uniform to this group.
	*
	* @param {Uniform} uniform - The uniform to add.
	* @return {UniformsGroup} A reference to this group.
	*/
	addUniform(uniform$2) {
		this.uniforms.push(uniform$2);
		return this;
	}
	/**
	* Removes a uniform from this group.
	*
	* @param {Uniform} uniform - The uniform to remove.
	* @return {UniformsGroup} A reference to this group.
	*/
	removeUniform(uniform$2) {
		const index = this.uniforms.indexOf(uniform$2);
		if (index !== -1) this.uniforms.splice(index, 1);
		return this;
	}
	/**
	* An array with the raw uniform values.
	*
	* @type {Array<number>}
	*/
	get values() {
		if (this._values === null) this._values = Array.from(this.buffer);
		return this._values;
	}
	/**
	* A Float32 array buffer with the uniform values.
	*
	* @type {Float32Array}
	*/
	get buffer() {
		let buffer$2 = this._buffer;
		if (buffer$2 === null) {
			const byteLength = this.byteLength;
			buffer$2 = new Float32Array(new ArrayBuffer(byteLength));
			this._buffer = buffer$2;
		}
		return buffer$2;
	}
	/**
	* The byte length of the buffer with correct buffer alignment.
	*
	* @type {number}
	*/
	get byteLength() {
		const bytesPerElement = this.bytesPerElement;
		let offset = 0;
		for (let i = 0, l = this.uniforms.length; i < l; i++) {
			const uniform$2 = this.uniforms[i];
			const boundary = uniform$2.boundary;
			const itemSize = uniform$2.itemSize * bytesPerElement;
			const chunkOffset = offset % GPU_CHUNK_BYTES;
			const chunkPadding = chunkOffset % boundary;
			const chunkStart = chunkOffset + chunkPadding;
			offset += chunkPadding;
			if (chunkStart !== 0 && GPU_CHUNK_BYTES - chunkStart < itemSize) offset += GPU_CHUNK_BYTES - chunkStart;
			uniform$2.offset = offset / bytesPerElement;
			offset += itemSize;
		}
		return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;
	}
	/**
	* Updates this group by updating each uniform object of
	* the internal uniform list. The uniform objects check if their
	* values has actually changed so this method only returns
	* `true` if there is a real value change.
	*
	* @return {boolean} Whether the uniforms have been updated and
	* must be uploaded to the GPU.
	*/
	update() {
		let updated = false;
		for (const uniform$2 of this.uniforms) if (this.updateByType(uniform$2) === true) updated = true;
		return updated;
	}
	/**
	* Updates a given uniform by calling an update method matching
	* the uniforms type.
	*
	* @param {Uniform} uniform - The uniform to update.
	* @return {boolean} Whether the uniform has been updated or not.
	*/
	updateByType(uniform$2) {
		if (uniform$2.isNumberUniform) return this.updateNumber(uniform$2);
		if (uniform$2.isVector2Uniform) return this.updateVector2(uniform$2);
		if (uniform$2.isVector3Uniform) return this.updateVector3(uniform$2);
		if (uniform$2.isVector4Uniform) return this.updateVector4(uniform$2);
		if (uniform$2.isColorUniform) return this.updateColor(uniform$2);
		if (uniform$2.isMatrix3Uniform) return this.updateMatrix3(uniform$2);
		if (uniform$2.isMatrix4Uniform) return this.updateMatrix4(uniform$2);
		error("WebGPUUniformsGroup: Unsupported uniform type.", uniform$2);
	}
	/**
	* Updates a given Number uniform.
	*
	* @param {NumberUniform} uniform - The Number uniform.
	* @return {boolean} Whether the uniform has been updated or not.
	*/
	updateNumber(uniform$2) {
		let updated = false;
		const a$1 = this.values;
		const v = uniform$2.getValue();
		const offset = uniform$2.offset;
		const type$1 = uniform$2.getType();
		if (a$1[offset] !== v) {
			const b$2 = this._getBufferForType(type$1);
			b$2[offset] = a$1[offset] = v;
			updated = true;
		}
		return updated;
	}
	/**
	* Updates a given Vector2 uniform.
	*
	* @param {Vector2Uniform} uniform - The Vector2 uniform.
	* @return {boolean} Whether the uniform has been updated or not.
	*/
	updateVector2(uniform$2) {
		let updated = false;
		const a$1 = this.values;
		const v = uniform$2.getValue();
		const offset = uniform$2.offset;
		const type$1 = uniform$2.getType();
		if (a$1[offset + 0] !== v.x || a$1[offset + 1] !== v.y) {
			const b$2 = this._getBufferForType(type$1);
			b$2[offset + 0] = a$1[offset + 0] = v.x;
			b$2[offset + 1] = a$1[offset + 1] = v.y;
			updated = true;
		}
		return updated;
	}
	/**
	* Updates a given Vector3 uniform.
	*
	* @param {Vector3Uniform} uniform - The Vector3 uniform.
	* @return {boolean} Whether the uniform has been updated or not.
	*/
	updateVector3(uniform$2) {
		let updated = false;
		const a$1 = this.values;
		const v = uniform$2.getValue();
		const offset = uniform$2.offset;
		const type$1 = uniform$2.getType();
		if (a$1[offset + 0] !== v.x || a$1[offset + 1] !== v.y || a$1[offset + 2] !== v.z) {
			const b$2 = this._getBufferForType(type$1);
			b$2[offset + 0] = a$1[offset + 0] = v.x;
			b$2[offset + 1] = a$1[offset + 1] = v.y;
			b$2[offset + 2] = a$1[offset + 2] = v.z;
			updated = true;
		}
		return updated;
	}
	/**
	* Updates a given Vector4 uniform.
	*
	* @param {Vector4Uniform} uniform - The Vector4 uniform.
	* @return {boolean} Whether the uniform has been updated or not.
	*/
	updateVector4(uniform$2) {
		let updated = false;
		const a$1 = this.values;
		const v = uniform$2.getValue();
		const offset = uniform$2.offset;
		const type$1 = uniform$2.getType();
		if (a$1[offset + 0] !== v.x || a$1[offset + 1] !== v.y || a$1[offset + 2] !== v.z || a$1[offset + 4] !== v.w) {
			const b$2 = this._getBufferForType(type$1);
			b$2[offset + 0] = a$1[offset + 0] = v.x;
			b$2[offset + 1] = a$1[offset + 1] = v.y;
			b$2[offset + 2] = a$1[offset + 2] = v.z;
			b$2[offset + 3] = a$1[offset + 3] = v.w;
			updated = true;
		}
		return updated;
	}
	/**
	* Updates a given Color uniform.
	*
	* @param {ColorUniform} uniform - The Color uniform.
	* @return {boolean} Whether the uniform has been updated or not.
	*/
	updateColor(uniform$2) {
		let updated = false;
		const a$1 = this.values;
		const c$1 = uniform$2.getValue();
		const offset = uniform$2.offset;
		if (a$1[offset + 0] !== c$1.r || a$1[offset + 1] !== c$1.g || a$1[offset + 2] !== c$1.b) {
			const b$2 = this.buffer;
			b$2[offset + 0] = a$1[offset + 0] = c$1.r;
			b$2[offset + 1] = a$1[offset + 1] = c$1.g;
			b$2[offset + 2] = a$1[offset + 2] = c$1.b;
			updated = true;
		}
		return updated;
	}
	/**
	* Updates a given Matrix3 uniform.
	*
	* @param {Matrix3Uniform} uniform - The Matrix3 uniform.
	* @return {boolean} Whether the uniform has been updated or not.
	*/
	updateMatrix3(uniform$2) {
		let updated = false;
		const a$1 = this.values;
		const e = uniform$2.getValue().elements;
		const offset = uniform$2.offset;
		if (a$1[offset + 0] !== e[0] || a$1[offset + 1] !== e[1] || a$1[offset + 2] !== e[2] || a$1[offset + 4] !== e[3] || a$1[offset + 5] !== e[4] || a$1[offset + 6] !== e[5] || a$1[offset + 8] !== e[6] || a$1[offset + 9] !== e[7] || a$1[offset + 10] !== e[8]) {
			const b$2 = this.buffer;
			b$2[offset + 0] = a$1[offset + 0] = e[0];
			b$2[offset + 1] = a$1[offset + 1] = e[1];
			b$2[offset + 2] = a$1[offset + 2] = e[2];
			b$2[offset + 4] = a$1[offset + 4] = e[3];
			b$2[offset + 5] = a$1[offset + 5] = e[4];
			b$2[offset + 6] = a$1[offset + 6] = e[5];
			b$2[offset + 8] = a$1[offset + 8] = e[6];
			b$2[offset + 9] = a$1[offset + 9] = e[7];
			b$2[offset + 10] = a$1[offset + 10] = e[8];
			updated = true;
		}
		return updated;
	}
	/**
	* Updates a given Matrix4 uniform.
	*
	* @param {Matrix4Uniform} uniform - The Matrix4 uniform.
	* @return {boolean} Whether the uniform has been updated or not.
	*/
	updateMatrix4(uniform$2) {
		let updated = false;
		const a$1 = this.values;
		const e = uniform$2.getValue().elements;
		const offset = uniform$2.offset;
		if (arraysEqual$1(a$1, e, offset) === false) {
			this.buffer.set(e, offset);
			setArray(a$1, e, offset);
			updated = true;
		}
		return updated;
	}
	/**
	* Returns a typed array that matches the given data type.
	*
	* @param {string} type - The data type.
	* @return {TypedArray} The typed array.
	*/
	_getBufferForType(type$1) {
		if (type$1 === "int" || type$1 === "ivec2" || type$1 === "ivec3" || type$1 === "ivec4") return new Int32Array(this.buffer.buffer);
		if (type$1 === "uint" || type$1 === "uvec2" || type$1 === "uvec3" || type$1 === "uvec4") return new Uint32Array(this.buffer.buffer);
		return this.buffer;
	}
};
/**
* Sets the values of the second array to the first array.
*
* @private
* @param {TypedArray} a - The first array.
* @param {TypedArray} b - The second array.
* @param {number} offset - An index offset for the first array.
*/
function setArray(a$1, b$2, offset) {
	for (let i = 0, l = b$2.length; i < l; i++) a$1[offset + i] = b$2[i];
}
/**
* Returns `true` if the given arrays are equal.
*
* @private
* @param {TypedArray} a - The first array.
* @param {TypedArray} b - The second array.
* @param {number} offset - An index offset for the first array.
* @return {boolean} Whether the given arrays are equal or not.
*/
function arraysEqual$1(a$1, b$2, offset) {
	for (let i = 0, l = b$2.length; i < l; i++) if (a$1[offset + i] !== b$2[i]) return false;
	return true;
}
var _id$3 = 0;
/**
* A special form of uniforms group that represents
* the individual uniforms as node-based uniforms.
*
* @private
* @augments UniformsGroup
*/
var NodeUniformsGroup = class extends UniformsGroup$1 {
	/**
	* Constructs a new node-based uniforms group.
	*
	* @param {string} name - The group's name.
	* @param {UniformGroupNode} groupNode - The uniform group node.
	*/
	constructor(name, groupNode) {
		super(name);
		/**
		* The group's ID.
		*
		* @type {number}
		*/
		this.id = _id$3++;
		/**
		* The uniform group node.
		*
		* @type {UniformGroupNode}
		*/
		this.groupNode = groupNode;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isNodeUniformsGroup = true;
	}
};
/**
* Represents a sampler binding type.
*
* @private
* @augments Binding
*/
var Sampler = class extends Binding {
	/**
	* Constructs a new sampler.
	*
	* @param {string} name - The samplers's name.
	* @param {?Texture} texture - The texture this binding is referring to.
	*/
	constructor(name, texture$2) {
		super(name);
		/**
		* The texture the sampler is referring to.
		*
		* @private
		* @type {?Texture}
		*/
		this._texture = null;
		/**
		* An event listener which is added to {@link texture}'s dispose event.
		*
		* @private
		* @type {Function}
		*/
		this._onTextureDispose = () => {
			this.generation = null;
			this.version = 0;
		};
		this.texture = texture$2;
		/**
		* The binding's version.
		*
		* @type {number}
		*/
		this.version = texture$2 ? texture$2.version : 0;
		/**
		* The binding's generation which is an additional version
		* qualifier.
		*
		* @type {?number}
		* @default null
		*/
		this.generation = null;
		/**
		* The binding's sampler key.
		*
		* @type {string}
		* @default ''
		*/
		this.samplerKey = "";
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSampler = true;
	}
	/**
	* Sets the texture of this sampler.
	*
	* @param {Texture} value - The texture to set.
	*/
	set texture(value) {
		if (this._texture === value) return;
		if (this._texture) this._texture.removeEventListener("dispose", this._onTextureDispose);
		this._texture = value;
		this.generation = null;
		this.version = 0;
		if (this._texture) this._texture.addEventListener("dispose", this._onTextureDispose);
	}
	/**
	* Gets the texture of this sampler.
	* @return {?Texture} The texture.
	*/
	get texture() {
		return this._texture;
	}
	/**
	* Updates the binding.
	*
	* @return {boolean} Whether the texture has been updated and must be
	* uploaded to the GPU.
	*/
	update() {
		const { texture: texture$2, version } = this;
		if (version !== texture$2.version) {
			this.version = texture$2.version;
			return true;
		}
		return false;
	}
	clone() {
		const clonedSampler = super.clone();
		clonedSampler._texture = null;
		clonedSampler._onTextureDispose = () => {
			clonedSampler.generation = null;
			clonedSampler.version = 0;
		};
		clonedSampler.texture = this.texture;
		return clonedSampler;
	}
};
var _id$2 = 0;
/**
* Represents a sampled texture binding type.
*
* @private
* @augments Sampler
*/
var SampledTexture = class extends Sampler {
	/**
	* Constructs a new sampled texture.
	*
	* @param {string} name - The sampled texture's name.
	* @param {?Texture} texture - The texture this binding is referring to.
	*/
	constructor(name, texture$2) {
		super(name, texture$2);
		/**
		* This identifier.
		*
		* @type {number}
		*/
		this.id = _id$2++;
		/**
		* Whether the texture is a storage texture or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.store = false;
		/**
		* The mip level to bind for storage textures.
		*
		* @type {number}
		* @default 0
		*/
		this.mipLevel = 0;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSampledTexture = true;
	}
};
/**
* A special form of sampled texture binding type.
* It's texture value is managed by a node object.
*
* @private
* @augments SampledTexture
*/
var NodeSampledTexture = class extends SampledTexture {
	/**
	* Constructs a new node-based sampled texture.
	*
	* @param {string} name - The textures's name.
	* @param {TextureNode} textureNode - The texture node.
	* @param {UniformGroupNode} groupNode - The uniform group node.
	* @param {?string} [access=null] - The access type.
	*/
	constructor(name, textureNode, groupNode, access = null) {
		super(name, textureNode ? textureNode.value : null);
		/**
		* The texture node.
		*
		* @type {TextureNode}
		*/
		this.textureNode = textureNode;
		/**
		* The uniform group node.
		*
		* @type {UniformGroupNode}
		*/
		this.groupNode = groupNode;
		/**
		* The access type.
		*
		* @type {?string}
		* @default null
		*/
		this.access = access;
	}
	/**
	* Updates the binding.
	*
	* @return {boolean} Whether the texture has been updated and must be
	* uploaded to the GPU.
	*/
	update() {
		const { textureNode } = this;
		if (this.texture !== textureNode.value) {
			this.texture = textureNode.value;
			return true;
		}
		return super.update();
	}
};
/**
* A special form of sampled cube texture binding type.
* It's texture value is managed by a node object.
*
* @private
* @augments NodeSampledTexture
*/
var NodeSampledCubeTexture = class extends NodeSampledTexture {
	/**
	* Constructs a new node-based sampled cube texture.
	*
	* @param {string} name - The textures's name.
	* @param {TextureNode} textureNode - The texture node.
	* @param {UniformGroupNode} groupNode - The uniform group node.
	* @param {?string} [access=null] - The access type.
	*/
	constructor(name, textureNode, groupNode, access = null) {
		super(name, textureNode, groupNode, access);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSampledCubeTexture = true;
	}
};
/**
* A special form of sampled 3D texture binding type.
* It's texture value is managed by a node object.
*
* @private
* @augments NodeSampledTexture
*/
var NodeSampledTexture3D = class extends NodeSampledTexture {
	/**
	* Constructs a new node-based sampled 3D texture.
	*
	* @param {string} name - The textures's name.
	* @param {TextureNode} textureNode - The texture node.
	* @param {UniformGroupNode} groupNode - The uniform group node.
	* @param {?string} [access=null] - The access type.
	*/
	constructor(name, textureNode, groupNode, access = null) {
		super(name, textureNode, groupNode, access);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isSampledTexture3D = true;
	}
};
var glslPolyfills = {
	bitcast_int_uint: new CodeNode("uint tsl_bitcast_uint_to_int ( int x ) { return floatBitsToInt( uintBitsToFloat( x ) ); }"),
	bitcast_uint_int: new CodeNode("uint tsl_bitcast_int_to_uint ( int x ) { return floatBitsToUint( intBitsToFloat ( x ) ); }")
};
var glslMethods = {
	textureDimensions: "textureSize",
	equals: "equal",
	bitcast_float_int: "floatBitsToInt",
	bitcast_int_float: "intBitsToFloat",
	bitcast_uint_float: "uintBitsToFloat",
	bitcast_float_uint: "floatBitsToUint",
	bitcast_uint_int: "tsl_bitcast_uint_to_int",
	bitcast_int_uint: "tsl_bitcast_int_to_uint"
};
var precisionLib = {
	low: "lowp",
	medium: "mediump",
	high: "highp"
};
var supports$1 = {
	swizzleAssign: true,
	storageBuffer: false
};
var interpolationTypeMap = {
	perspective: "smooth",
	linear: "noperspective"
};
var interpolationModeMap = { "centroid": "centroid" };
var defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
precision lowp sampler2DArrayShadow;
precision lowp samplerCubeShadow;
`;
/**
* A node builder targeting GLSL.
*
* This module generates GLSL shader code from node materials and also
* generates the respective bindings and vertex buffer definitions. These
* data are later used by the renderer to create render and compute pipelines
* for render objects.
*
* @augments NodeBuilder
*/
var GLSLNodeBuilder = class extends NodeBuilder {
	/**
	* Constructs a new GLSL node builder renderer.
	*
	* @param {Object3D} object - The 3D object.
	* @param {Renderer} renderer - The renderer.
	*/
	constructor(object, renderer) {
		super(object, renderer, new GLSLNodeParser());
		/**
		* A dictionary holds for each shader stage ('vertex', 'fragment', 'compute')
		* another dictionary which manages UBOs per group ('render','frame','object').
		*
		* @type {Object<string,Object<string,NodeUniformsGroup>>}
		*/
		this.uniformGroups = {};
		/**
		* An array that holds objects defining the varying and attribute data in
		* context of Transform Feedback.
		*
		* @type {Array<Object<string,AttributeNode|string>>}
		*/
		this.transforms = [];
		/**
		* A dictionary that holds for each shader stage a Map of used extensions.
		*
		* @type {Object<string,Map<string,Object>>}
		*/
		this.extensions = {};
		/**
		* A dictionary that holds for each shader stage an Array of used builtins.
		*
		* @type {Object<string,Array<string>>}
		*/
		this.builtins = {
			vertex: [],
			fragment: [],
			compute: []
		};
	}
	/**
	* Checks if the given texture requires a manual conversion to the working color space.
	*
	* @param {Texture} texture - The texture to check.
	* @return {boolean} Whether the given texture requires a conversion to working color space or not.
	*/
	needsToWorkingColorSpace(texture$2) {
		return texture$2.isVideoTexture === true && texture$2.colorSpace !== NoColorSpace;
	}
	/**
	* Includes the given method name into the current
	* function node.
	*
	* @private
	* @param {string} name - The method name to include.
	* @return {CodeNode} The respective code node.
	*/
	_include(name) {
		const codeNode = glslPolyfills[name];
		codeNode.build(this);
		this.addInclude(codeNode);
		return codeNode;
	}
	/**
	* Returns the native shader method name for a given generic name.
	*
	* @param {string} method - The method name to resolve.
	* @return {string} The resolved GLSL method name.
	*/
	getMethod(method) {
		if (glslPolyfills[method] !== void 0) this._include(method);
		return glslMethods[method] || method;
	}
	/**
	* Returns the bitcast method name for a given input and outputType.
	*
	* @param {string} type - The output type to bitcast to.
	* @param {string} inputType - The input type of the.
	* @return {string} The resolved WGSL bitcast invocation.
	*/
	getBitcastMethod(type$1, inputType) {
		return this.getMethod(`bitcast_${inputType}_${type$1}`);
	}
	/**
	* Returns the native snippet for a ternary operation.
	*
	* @param {string} condSnippet - The condition determining which expression gets resolved.
	* @param {string} ifSnippet - The expression to resolve to if the condition is true.
	* @param {string} elseSnippet - The expression to resolve to if the condition is false.
	* @return {string} The resolved method name.
	*/
	getTernary(condSnippet, ifSnippet, elseSnippet) {
		return `${condSnippet} ? ${ifSnippet} : ${elseSnippet}`;
	}
	/**
	* Returns the output struct name. Not relevant for GLSL.
	*
	* @return {string}
	*/
	getOutputStructName() {
		return "";
	}
	/**
	* Builds the given shader node.
	*
	* @param {ShaderNodeInternal} shaderNode - The shader node.
	* @return {string} The GLSL function code.
	*/
	buildFunctionCode(shaderNode) {
		const layout = shaderNode.layout;
		const flowData = this.flowShaderNode(shaderNode);
		const parameters = [];
		for (const input of layout.inputs) parameters.push(this.getType(input.type) + " " + input.name);
		return `${this.getType(layout.type)} ${layout.name}( ${parameters.join(", ")} ) {

	${flowData.vars}

${flowData.code}
	return ${flowData.result};

}`;
	}
	/**
	* Setups the Pixel Buffer Object (PBO) for the given storage
	* buffer node.
	*
	* @param {StorageBufferNode} storageBufferNode - The storage buffer node.
	*/
	setupPBO(storageBufferNode) {
		const attribute$2 = storageBufferNode.value;
		if (attribute$2.pbo === void 0) {
			const originalArray = attribute$2.array;
			const numElements = attribute$2.count * attribute$2.itemSize;
			const { itemSize } = attribute$2;
			const isInteger = attribute$2.array.constructor.name.toLowerCase().includes("int");
			let format = isInteger ? RedIntegerFormat : RedFormat;
			if (itemSize === 2) format = isInteger ? RGIntegerFormat : RGFormat;
			else if (itemSize === 3) format = isInteger ? RGBIntegerFormat : RGBFormat;
			else if (itemSize === 4) format = isInteger ? RGBAIntegerFormat : RGBAFormat;
			const typeMap = {
				Float32Array: FloatType,
				Uint8Array: UnsignedByteType,
				Uint16Array: UnsignedShortType,
				Uint32Array: UnsignedIntType,
				Int8Array: ByteType,
				Int16Array: ShortType,
				Int32Array: IntType,
				Uint8ClampedArray: UnsignedByteType
			};
			const width = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(numElements / itemSize))));
			let height = Math.ceil(numElements / itemSize / width);
			if (width * height * itemSize < numElements) height++;
			const newSize = width * height * itemSize;
			const newArray = new originalArray.constructor(newSize);
			newArray.set(originalArray, 0);
			attribute$2.array = newArray;
			const pboTexture = new DataTexture(attribute$2.array, width, height, format, typeMap[attribute$2.array.constructor.name] || FloatType);
			pboTexture.needsUpdate = true;
			pboTexture.isPBOTexture = true;
			const pbo = new TextureNode(pboTexture, null, null);
			pbo.setPrecision("high");
			attribute$2.pboNode = pbo;
			attribute$2.pbo = pbo.value;
			this.getUniformFromNode(attribute$2.pboNode, "texture", this.shaderStage, this.context.nodeName);
		}
	}
	/**
	* Returns a GLSL snippet that represents the property name of the given node.
	*
	* @param {Node} node - The node.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {string} The property name.
	*/
	getPropertyName(node, shaderStage = this.shaderStage) {
		if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) return shaderStage.charAt(0) + "_" + node.name;
		return super.getPropertyName(node, shaderStage);
	}
	/**
	* Setups the Pixel Buffer Object (PBO) for the given storage
	* buffer node.
	*
	* @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.
	* @return {string} The property name.
	*/
	generatePBO(storageArrayElementNode) {
		const { node, indexNode } = storageArrayElementNode;
		const attribute$2 = node.value;
		if (this.renderer.backend.has(attribute$2)) {
			const attributeData = this.renderer.backend.get(attribute$2);
			attributeData.pbo = attribute$2.pbo;
		}
		const nodeUniform = this.getUniformFromNode(attribute$2.pboNode, "texture", this.shaderStage, this.context.nodeName);
		const textureName = this.getPropertyName(nodeUniform);
		this.increaseUsage(indexNode);
		const indexSnippet = indexNode.build(this, "uint");
		const elementNodeData = this.getDataFromNode(storageArrayElementNode);
		let propertyName = elementNodeData.propertyName;
		if (propertyName === void 0) {
			const nodeVar = this.getVarFromNode(storageArrayElementNode);
			propertyName = this.getPropertyName(nodeVar);
			const bufferNodeData = this.getDataFromNode(node);
			let propertySizeName = bufferNodeData.propertySizeName;
			if (propertySizeName === void 0) {
				propertySizeName = propertyName + "Size";
				this.getVarFromNode(node, propertySizeName, "uint");
				this.addLineFlowCode(`${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`, storageArrayElementNode);
				bufferNodeData.propertySizeName = propertySizeName;
			}
			const { itemSize } = attribute$2;
			const channel = "." + vectorComponents$1.join("").slice(0, itemSize);
			const uvSnippet = `ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`;
			const snippet = this.generateTextureLoad(null, textureName, uvSnippet, "0", null, null);
			let prefix = "vec4";
			if (attribute$2.pbo.type === UnsignedIntType) prefix = "uvec4";
			else if (attribute$2.pbo.type === IntType) prefix = "ivec4";
			this.addLineFlowCode(`${propertyName} = ${prefix}(${snippet})${channel}`, storageArrayElementNode);
			elementNodeData.propertyName = propertyName;
		}
		return propertyName;
	}
	/**
	* Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.
	*
	* @param {?Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.
	* @param {?string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
	* @param {?string} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @return {string} The GLSL snippet.
	*/
	generateTextureLoad(texture$2, textureProperty, uvIndexSnippet, levelSnippet, depthSnippet, offsetSnippet) {
		if (levelSnippet === null) levelSnippet = "0";
		let snippet;
		if (depthSnippet) if (offsetSnippet) snippet = `texelFetchOffset( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet}, ${offsetSnippet} )`;
		else snippet = `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
		else if (offsetSnippet) snippet = `texelFetchOffset( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
		else snippet = `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;
		if (texture$2 !== null && texture$2.isDepthTexture) snippet += ".x";
		return snippet;
	}
	/**
	* Generates the GLSL snippet for sampling/loading the given texture.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
	* @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @return {string} The GLSL snippet.
	*/
	generateTexture(texture$2, textureProperty, uvSnippet, depthSnippet, offsetSnippet) {
		if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;
		if (texture$2.isDepthTexture) {
			if (offsetSnippet) return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet} ).x`;
			return `texture( ${textureProperty}, ${uvSnippet} ).x`;
		}
		if (offsetSnippet) return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet} )`;
		return `texture( ${textureProperty}, ${uvSnippet} )`;
	}
	/**
	* Generates the GLSL snippet when sampling textures with explicit mip level.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
	* @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
	* @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @return {string} The GLSL snippet.
	*/
	generateTextureLevel(texture$2, textureProperty, uvSnippet, levelSnippet, offsetSnippet) {
		if (offsetSnippet) return `textureLodOffset( ${textureProperty}, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
		return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
	}
	/**
	* Generates the GLSL snippet when sampling textures with a bias to the mip level.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
	* @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.
	* @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @return {string} The GLSL snippet.
	*/
	generateTextureBias(texture$2, textureProperty, uvSnippet, biasSnippet, offsetSnippet) {
		if (offsetSnippet) return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet}, ${biasSnippet} )`;
		return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;
	}
	/**
	* Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
	* @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.
	* @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @return {string} The GLSL snippet.
	*/
	generateTextureGrad(texture$2, textureProperty, uvSnippet, gradSnippet, offsetSnippet) {
		if (offsetSnippet) return `textureGradOffset( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]}, ${offsetSnippet} )`;
		return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;
	}
	/**
	* Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values
	* against a reference value.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
	* @param {string} compareSnippet -  A GLSL snippet that represents the reference value.
	* @param {?string} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {string} The GLSL snippet.
	*/
	generateTextureCompare(texture$2, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
		if (shaderStage === "fragment") {
			if (depthSnippet) {
				if (offsetSnippet) return `textureOffset( ${textureProperty}, vec4( ${uvSnippet}, ${depthSnippet}, ${compareSnippet} ), ${offsetSnippet} )`;
				return `texture( ${textureProperty}, vec4( ${uvSnippet}, ${depthSnippet}, ${compareSnippet} ) )`;
			}
			if (offsetSnippet) return `textureOffset( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ), ${offsetSnippet} )`;
			return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;
		} else error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
	}
	/**
	* Returns the variables of the given shader stage as a GLSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The GLSL snippet that defines the variables.
	*/
	getVars(shaderStage) {
		const snippets = [];
		const vars = this.vars[shaderStage];
		if (vars !== void 0) for (const variable of vars) snippets.push(`${this.getVar(variable.type, variable.name, variable.count)};`);
		return snippets.join("\n	");
	}
	/**
	* Returns the uniforms of the given shader stage as a GLSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The GLSL snippet that defines the uniforms.
	*/
	getUniforms(shaderStage) {
		const uniforms = this.uniforms[shaderStage];
		const bindingSnippets = [];
		const uniformGroups = {};
		for (const uniform$2 of uniforms) {
			let snippet = null;
			let group = false;
			if (uniform$2.type === "texture" || uniform$2.type === "texture3D") {
				const texture$2 = uniform$2.node.value;
				let typePrefix = "";
				if (texture$2.isDataTexture === true || texture$2.isData3DTexture === true) {
					if (texture$2.type === UnsignedIntType) typePrefix = "u";
					else if (texture$2.type === IntType) typePrefix = "i";
				}
				if (uniform$2.type === "texture3D" && texture$2.isArrayTexture === false) snippet = `${typePrefix}sampler3D ${uniform$2.name};`;
				else if (texture$2.compareFunction) if (texture$2.isArrayTexture === true) snippet = `sampler2DArrayShadow ${uniform$2.name};`;
				else snippet = `sampler2DShadow ${uniform$2.name};`;
				else if (texture$2.isArrayTexture === true || texture$2.isDataArrayTexture === true || texture$2.isCompressedArrayTexture === true) snippet = `${typePrefix}sampler2DArray ${uniform$2.name};`;
				else snippet = `${typePrefix}sampler2D ${uniform$2.name};`;
			} else if (uniform$2.type === "cubeTexture") snippet = `samplerCube ${uniform$2.name};`;
			else if (uniform$2.type === "buffer") {
				const bufferNode = uniform$2.node;
				const bufferType = this.getType(bufferNode.bufferType);
				const bufferCount = bufferNode.bufferCount;
				const bufferCountSnippet = bufferCount > 0 ? bufferCount : "";
				snippet = `${bufferNode.name} {\n\t${bufferType} ${uniform$2.name}[${bufferCountSnippet}];\n};\n`;
			} else {
				snippet = `${this.getVectorType(uniform$2.type)} ${this.getPropertyName(uniform$2, shaderStage)};`;
				group = true;
			}
			const precision = uniform$2.node.precision;
			if (precision !== null) snippet = precisionLib[precision] + " " + snippet;
			if (group) {
				snippet = "	" + snippet;
				const groupName = uniform$2.groupNode.name;
				(uniformGroups[groupName] || (uniformGroups[groupName] = [])).push(snippet);
			} else {
				snippet = "uniform " + snippet;
				bindingSnippets.push(snippet);
			}
		}
		let output$2 = "";
		for (const name in uniformGroups) {
			const groupSnippets = uniformGroups[name];
			output$2 += this._getGLSLUniformStruct(shaderStage + "_" + name, groupSnippets.join("\n")) + "\n";
		}
		output$2 += bindingSnippets.join("\n");
		return output$2;
	}
	/**
	* Returns the type for a given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	* @return {string} The type.
	*/
	getTypeFromAttribute(attribute$2) {
		let nodeType = super.getTypeFromAttribute(attribute$2);
		if (/^[iu]/.test(nodeType) && attribute$2.gpuType !== IntType) {
			let dataAttribute = attribute$2;
			if (attribute$2.isInterleavedBufferAttribute) dataAttribute = attribute$2.data;
			const array$2 = dataAttribute.array;
			if ((array$2 instanceof Uint32Array || array$2 instanceof Int32Array) === false) nodeType = nodeType.slice(1);
		}
		return nodeType;
	}
	/**
	* Returns the shader attributes of the given shader stage as a GLSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The GLSL snippet that defines the shader attributes.
	*/
	getAttributes(shaderStage) {
		let snippet = "";
		if (shaderStage === "vertex" || shaderStage === "compute") {
			const attributes = this.getAttributesArray();
			let location = 0;
			for (const attribute$2 of attributes) snippet += `layout( location = ${location++} ) in ${attribute$2.type} ${attribute$2.name};\n`;
		}
		return snippet;
	}
	/**
	* Returns the members of the given struct type node as a GLSL string.
	*
	* @param {StructTypeNode} struct - The struct type node.
	* @return {string} The GLSL snippet that defines the struct members.
	*/
	getStructMembers(struct$2) {
		const snippets = [];
		for (const member of struct$2.members) snippets.push(`\t${member.type} ${member.name};`);
		return snippets.join("\n");
	}
	/**
	* Returns the structs of the given shader stage as a GLSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The GLSL snippet that defines the structs.
	*/
	getStructs(shaderStage) {
		const snippets = [];
		const structs = this.structs[shaderStage];
		const outputSnippet = [];
		for (const struct$2 of structs) if (struct$2.output) for (const member of struct$2.members) outputSnippet.push(`layout( location = ${member.index} ) out ${member.type} ${member.name};`);
		else {
			let snippet = "struct " + struct$2.name + " {\n";
			snippet += this.getStructMembers(struct$2);
			snippet += "\n};\n";
			snippets.push(snippet);
		}
		if (outputSnippet.length === 0) outputSnippet.push("layout( location = 0 ) out vec4 fragColor;");
		return "\n" + outputSnippet.join("\n") + "\n\n" + snippets.join("\n");
	}
	/**
	* Returns the varyings of the given shader stage as a GLSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The GLSL snippet that defines the varyings.
	*/
	getVaryings(shaderStage) {
		let snippet = "";
		const varyings = this.varyings;
		if (shaderStage === "vertex" || shaderStage === "compute") for (const varying$2 of varyings) {
			if (shaderStage === "compute") varying$2.needsInterpolation = true;
			const type$1 = this.getType(varying$2.type);
			if (varying$2.needsInterpolation) if (varying$2.interpolationType) {
				const interpolationType = interpolationTypeMap[varying$2.interpolationType] || varying$2.interpolationType;
				const sampling = interpolationModeMap[varying$2.interpolationSampling] || "";
				snippet += `${interpolationType} ${sampling} out ${type$1} ${varying$2.name};\n`;
			} else {
				const flat = type$1.includes("int") || type$1.includes("uv") || type$1.includes("iv") ? "flat " : "";
				snippet += `${flat}out ${type$1} ${varying$2.name};\n`;
			}
			else snippet += `${type$1} ${varying$2.name};\n`;
		}
		else if (shaderStage === "fragment") {
			for (const varying$2 of varyings) if (varying$2.needsInterpolation) {
				const type$1 = this.getType(varying$2.type);
				if (varying$2.interpolationType) {
					const interpolationType = interpolationTypeMap[varying$2.interpolationType] || varying$2.interpolationType;
					const sampling = interpolationModeMap[varying$2.interpolationSampling] || "";
					snippet += `${interpolationType} ${sampling} in ${type$1} ${varying$2.name};\n`;
				} else {
					const flat = type$1.includes("int") || type$1.includes("uv") || type$1.includes("iv") ? "flat " : "";
					snippet += `${flat}in ${type$1} ${varying$2.name};\n`;
				}
			}
		}
		for (const builtin$2 of this.builtins[shaderStage]) snippet += `${builtin$2};\n`;
		return snippet;
	}
	/**
	* Returns the vertex index builtin.
	*
	* @return {string} The vertex index.
	*/
	getVertexIndex() {
		return "uint( gl_VertexID )";
	}
	/**
	* Contextually returns either the vertex stage instance index builtin
	* or the linearized index of an compute invocation within a grid of workgroups.
	*
	* @return {string} The instance index.
	*/
	getInstanceIndex() {
		return "uint( gl_InstanceID )";
	}
	/**
	* Returns a builtin representing the index of an invocation within its workgroup.
	*
	* @return {string} The invocation local index.
	*/
	getInvocationLocalIndex() {
		return `uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce((acc, curr) => acc * curr, 1)}u`;
	}
	/**
	* Returns a builtin representing the size of a subgroup within the current shader.
	*/
	getSubgroupSize() {
		error("GLSLNodeBuilder: WebGLBackend does not support the subgroupSize node");
	}
	/**
	* Returns a builtin representing the index of an invocation within its subgroup.
	*/
	getInvocationSubgroupIndex() {
		error("GLSLNodeBuilder: WebGLBackend does not support the invocationSubgroupIndex node");
	}
	/**
	* Returns a builtin representing the index of the current invocation's subgroup within its workgroup.
	*/
	getSubgroupIndex() {
		error("GLSLNodeBuilder: WebGLBackend does not support the subgroupIndex node");
	}
	/**
	* Returns the draw index builtin.
	*
	* @return {?string} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.
	*/
	getDrawIndex() {
		if (this.renderer.backend.extensions.has("WEBGL_multi_draw")) return "uint( gl_DrawID )";
		return null;
	}
	/**
	* Returns the front facing builtin.
	*
	* @return {string} The front facing builtin.
	*/
	getFrontFacing() {
		return "gl_FrontFacing";
	}
	/**
	* Returns the frag coord builtin.
	*
	* @return {string} The frag coord builtin.
	*/
	getFragCoord() {
		return "gl_FragCoord.xy";
	}
	/**
	* Returns the frag depth builtin.
	*
	* @return {string} The frag depth builtin.
	*/
	getFragDepth() {
		return "gl_FragDepth";
	}
	/**
	* Enables the given extension.
	*
	* @param {string} name - The extension name.
	* @param {string} behavior - The extension behavior.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage.
	*/
	enableExtension(name, behavior, shaderStage = this.shaderStage) {
		const map = this.extensions[shaderStage] || (this.extensions[shaderStage] = /* @__PURE__ */ new Map());
		if (map.has(name) === false) map.set(name, {
			name,
			behavior
		});
	}
	/**
	* Returns the enabled extensions of the given shader stage as a GLSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The GLSL snippet that defines the enabled extensions.
	*/
	getExtensions(shaderStage) {
		const snippets = [];
		if (shaderStage === "vertex") {
			const ext = this.renderer.backend.extensions;
			if (this.object.isBatchedMesh && ext.has("WEBGL_multi_draw")) this.enableExtension("GL_ANGLE_multi_draw", "require", shaderStage);
		}
		const extensions = this.extensions[shaderStage];
		if (extensions !== void 0) for (const { name, behavior } of extensions.values()) snippets.push(`#extension ${name} : ${behavior}`);
		return snippets.join("\n");
	}
	/**
	* Returns the clip distances builtin.
	*
	* @return {string} The clip distances builtin.
	*/
	getClipDistance() {
		return "gl_ClipDistance";
	}
	/**
	* Whether the requested feature is available or not.
	*
	* @param {string} name - The requested feature.
	* @return {boolean} Whether the requested feature is supported or not.
	*/
	isAvailable(name) {
		let result = supports$1[name];
		if (result === void 0) {
			let extensionName;
			result = false;
			switch (name) {
				case "float32Filterable":
					extensionName = "OES_texture_float_linear";
					break;
				case "clipDistance":
					extensionName = "WEBGL_clip_cull_distance";
					break;
			}
			if (extensionName !== void 0) {
				const extensions = this.renderer.backend.extensions;
				if (extensions.has(extensionName)) {
					extensions.get(extensionName);
					result = true;
				}
			}
			supports$1[name] = result;
		}
		return result;
	}
	/**
	* Whether to flip texture data along its vertical axis or not.
	*
	* @return {boolean} Returns always `true` in context of GLSL.
	*/
	isFlipY() {
		return true;
	}
	/**
	* Enables hardware clipping.
	*
	* @param {string} planeCount - The clipping plane count.
	*/
	enableHardwareClipping(planeCount) {
		this.enableExtension("GL_ANGLE_clip_cull_distance", "require");
		this.builtins["vertex"].push(`out float gl_ClipDistance[ ${planeCount} ]`);
	}
	/**
	* Enables multiview.
	*/
	enableMultiview() {
		this.enableExtension("GL_OVR_multiview2", "require", "fragment");
		this.enableExtension("GL_OVR_multiview2", "require", "vertex");
		this.builtins["vertex"].push("layout(num_views = 2) in");
	}
	/**
	* Registers a transform in context of Transform Feedback.
	*
	* @param {string} varyingName - The varying name.
	* @param {AttributeNode} attributeNode - The attribute node.
	*/
	registerTransform(varyingName, attributeNode) {
		this.transforms.push({
			varyingName,
			attributeNode
		});
	}
	/**
	* Returns the transforms of the given shader stage as a GLSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The GLSL snippet that defines the transforms.
	*/
	getTransforms() {
		const transforms = this.transforms;
		let snippet = "";
		for (let i = 0; i < transforms.length; i++) {
			const transform = transforms[i];
			const attributeName = this.getPropertyName(transform.attributeNode);
			if (attributeName) snippet += `${transform.varyingName} = ${attributeName};\n\t`;
		}
		return snippet;
	}
	/**
	* Returns a GLSL struct based on the given name and variables.
	*
	* @private
	* @param {string} name - The struct name.
	* @param {string} vars - The struct variables.
	* @return {string} The GLSL snippet representing a struct.
	*/
	_getGLSLUniformStruct(name, vars) {
		return `
layout( std140 ) uniform ${name} {
${vars}
};`;
	}
	/**
	* Returns a GLSL vertex shader based on the given shader data.
	*
	* @private
	* @param {Object} shaderData - The shader data.
	* @return {string} The vertex shader.
	*/
	_getGLSLVertexCode(shaderData) {
		return `#version 300 es

${this.getSignature()}

// extensions
${shaderData.extensions}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;
	}
	/**
	* Returns a GLSL fragment shader based on the given shader data.
	*
	* @private
	* @param {Object} shaderData - The shader data.
	* @return {string} The vertex shader.
	*/
	_getGLSLFragmentCode(shaderData) {
		return `#version 300 es

${this.getSignature()}

// extensions
${shaderData.extensions}

// precision
${defaultPrecisions}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
	}
	/**
	* Controls the code build of the shader stages.
	*/
	buildCode() {
		const shadersData = this.material !== null ? {
			fragment: {},
			vertex: {}
		} : { compute: {} };
		this.sortBindingGroups();
		for (const shaderStage in shadersData) {
			let flow = "// code\n\n";
			flow += this.flowCode[shaderStage];
			const flowNodes = this.flowNodes[shaderStage];
			const mainNode = flowNodes[flowNodes.length - 1];
			for (const node of flowNodes) {
				const flowSlotData = this.getFlowData(node);
				const slotName = node.name;
				if (slotName) {
					if (flow.length > 0) flow += "\n";
					flow += `\t// flow -> ${slotName}\n\t`;
				}
				flow += `${flowSlotData.code}\n\t`;
				if (node === mainNode && shaderStage !== "compute") {
					flow += "// result\n	";
					if (shaderStage === "vertex") {
						flow += "gl_Position = ";
						flow += `${flowSlotData.result};`;
					} else if (shaderStage === "fragment") {
						if (!node.outputNode.isOutputStructNode) {
							flow += "fragColor = ";
							flow += `${flowSlotData.result};`;
						}
					}
				}
			}
			const stageData = shadersData[shaderStage];
			stageData.extensions = this.getExtensions(shaderStage);
			stageData.uniforms = this.getUniforms(shaderStage);
			stageData.attributes = this.getAttributes(shaderStage);
			stageData.varyings = this.getVaryings(shaderStage);
			stageData.vars = this.getVars(shaderStage);
			stageData.structs = this.getStructs(shaderStage);
			stageData.codes = this.getCodes(shaderStage);
			stageData.transforms = this.getTransforms(shaderStage);
			stageData.flow = flow;
		}
		if (this.material !== null) {
			this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
			this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
		} else this.computeShader = this._getGLSLVertexCode(shadersData.compute);
	}
	/**
	* This method is one of the more important ones since it's responsible
	* for generating a matching binding instance for the given uniform node.
	*
	* These bindings are later used in the renderer to create bind groups
	* and layouts.
	*
	* @param {UniformNode} node - The uniform node.
	* @param {string} type - The node data type.
	* @param {string} shaderStage - The shader stage.
	* @param {?string} [name=null] - An optional uniform name.
	* @return {NodeUniform} The node uniform object.
	*/
	getUniformFromNode(node, type$1, shaderStage, name = null) {
		const uniformNode = super.getUniformFromNode(node, type$1, shaderStage, name);
		const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
		let uniformGPU = nodeData.uniformGPU;
		if (uniformGPU === void 0) {
			const group = node.groupNode;
			const groupName = group.name;
			const bindings = this.getBindGroupArray(groupName, shaderStage);
			if (type$1 === "texture") {
				uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node, group);
				bindings.push(uniformGPU);
			} else if (type$1 === "cubeTexture") {
				uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group);
				bindings.push(uniformGPU);
			} else if (type$1 === "texture3D") {
				uniformGPU = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group);
				bindings.push(uniformGPU);
			} else if (type$1 === "buffer") {
				node.name = `NodeBuffer_${node.id}`;
				uniformNode.name = `buffer${node.id}`;
				const buffer$2 = new NodeUniformBuffer(node, group);
				buffer$2.name = node.name;
				bindings.push(buffer$2);
				uniformGPU = buffer$2;
			} else {
				const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
				let uniformsGroup = uniformsStage[groupName];
				if (uniformsGroup === void 0) {
					uniformsGroup = new NodeUniformsGroup(shaderStage + "_" + groupName, group);
					uniformsStage[groupName] = uniformsGroup;
					bindings.push(uniformsGroup);
				}
				uniformGPU = this.getNodeUniform(uniformNode, type$1);
				uniformsGroup.addUniform(uniformGPU);
			}
			nodeData.uniformGPU = uniformGPU;
		}
		return uniformNode;
	}
};
var _vector2 = null;
var _color4 = null;
/**
* Most of the rendering related logic is implemented in the
* {@link Renderer} module and related management components.
* Sometimes it is required though to execute commands which are
* specific to the current 3D backend (which is WebGPU or WebGL 2).
* This abstract base class defines an interface that encapsulates
* all backend-related logic. Derived classes for each backend must
* implement the interface.
*
* @abstract
* @private
*/
var Backend = class {
	/**
	* Constructs a new backend.
	*
	* @param {Object} parameters - An object holding parameters for the backend.
	*/
	constructor(parameters = {}) {
		/**
		* The parameters of the backend.
		*
		* @type {Object}
		*/
		this.parameters = Object.assign({}, parameters);
		/**
		* This weak map holds backend-specific data of objects
		* like textures, attributes or render targets.
		*
		* @type {WeakMap<Object, Object>}
		*/
		this.data = /* @__PURE__ */ new WeakMap();
		/**
		* A reference to the renderer.
		*
		* @type {?Renderer}
		* @default null
		*/
		this.renderer = null;
		/**
		* A reference to the canvas element the renderer is drawing to.
		*
		* @type {?(HTMLCanvasElement|OffscreenCanvas)}
		* @default null
		*/
		this.domElement = null;
		/**
		* A reference to the timestamp query pool.
		*
		* @type {{render: ?TimestampQueryPool, compute: ?TimestampQueryPool}}
		*/
		this.timestampQueryPool = {
			[TimestampQuery.RENDER]: null,
			[TimestampQuery.COMPUTE]: null
		};
		/**
		* Whether to track timestamps with a Timestamp Query API or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.trackTimestamp = parameters.trackTimestamp === true;
	}
	/**
	* Initializes the backend so it is ready for usage. Concrete backends
	* are supposed to implement their rendering context creation and related
	* operations in this method.
	*
	* @async
	* @param {Renderer} renderer - The renderer.
	* @return {Promise} A Promise that resolves when the backend has been initialized.
	*/
	async init(renderer) {
		this.renderer = renderer;
	}
	/**
	* The coordinate system of the backend.
	*
	* @abstract
	* @type {number}
	* @readonly
	*/
	get coordinateSystem() {}
	/**
	* This method is executed at the beginning of a render call and
	* can be used by the backend to prepare the state for upcoming
	* draw calls.
	*
	* @abstract
	* @param {RenderContext} renderContext - The render context.
	*/
	beginRender() {}
	/**
	* This method is executed at the end of a render call and
	* can be used by the backend to finalize work after draw
	* calls.
	*
	* @abstract
	* @param {RenderContext} renderContext - The render context.
	*/
	finishRender() {}
	/**
	* This method is executed at the beginning of a compute call and
	* can be used by the backend to prepare the state for upcoming
	* compute tasks.
	*
	* @abstract
	* @param {Node|Array<Node>} computeGroup - The compute node(s).
	*/
	beginCompute() {}
	/**
	* This method is executed at the end of a compute call and
	* can be used by the backend to finalize work after compute
	* tasks.
	*
	* @abstract
	* @param {Node|Array<Node>} computeGroup - The compute node(s).
	*/
	finishCompute() {}
	/**
	* Executes a draw command for the given render object.
	*
	* @abstract
	* @param {RenderObject} renderObject - The render object to draw.
	* @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
	*/
	draw() {}
	/**
	* Executes a compute command for the given compute node.
	*
	* @abstract
	* @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
	* @param {Node} computeNode - The compute node.
	* @param {Array<BindGroup>} bindings - The bindings.
	* @param {ComputePipeline} computePipeline - The compute pipeline.
	*/
	compute() {}
	/**
	* Creates a shader program from the given programmable stage.
	*
	* @abstract
	* @param {ProgrammableStage} program - The programmable stage.
	*/
	createProgram() {}
	/**
	* Destroys the shader program of the given programmable stage.
	*
	* @abstract
	* @param {ProgrammableStage} program - The programmable stage.
	*/
	destroyProgram() {}
	/**
	* Creates bindings from the given bind group definition.
	*
	* @abstract
	* @param {BindGroup} bindGroup - The bind group.
	* @param {Array<BindGroup>} bindings - Array of bind groups.
	* @param {number} cacheIndex - The cache index.
	* @param {number} version - The version.
	*/
	createBindings() {}
	/**
	* Updates the given bind group definition.
	*
	* @abstract
	* @param {BindGroup} bindGroup - The bind group.
	* @param {Array<BindGroup>} bindings - Array of bind groups.
	* @param {number} cacheIndex - The cache index.
	* @param {number} version - The version.
	*/
	updateBindings() {}
	/**
	* Updates a buffer binding.
	*
	* @abstract
	* @param {Buffer} binding - The buffer binding to update.
	*/
	updateBinding() {}
	/**
	* Creates a render pipeline for the given render object.
	*
	* @abstract
	* @param {RenderObject} renderObject - The render object.
	* @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
	*/
	createRenderPipeline() {}
	/**
	* Creates a compute pipeline for the given compute node.
	*
	* @abstract
	* @param {ComputePipeline} computePipeline - The compute pipeline.
	* @param {Array<BindGroup>} bindings - The bindings.
	*/
	createComputePipeline() {}
	/**
	* Returns `true` if the render pipeline requires an update.
	*
	* @abstract
	* @param {RenderObject} renderObject - The render object.
	* @return {boolean} Whether the render pipeline requires an update or not.
	*/
	needsRenderUpdate() {}
	/**
	* Returns a cache key that is used to identify render pipelines.
	*
	* @abstract
	* @param {RenderObject} renderObject - The render object.
	* @return {string} The cache key.
	*/
	getRenderCacheKey() {}
	/**
	* Returns a node builder for the given render object.
	*
	* @abstract
	* @param {RenderObject} renderObject - The render object.
	* @param {Renderer} renderer - The renderer.
	* @return {NodeBuilder} The node builder.
	*/
	createNodeBuilder() {}
	/**
	* Updates a GPU sampler for the given texture.
	*
	* @abstract
	* @param {Texture} texture - The texture to update the sampler for.
	* @return {string} The current sampler key.
	*/
	updateSampler() {}
	/**
	* Creates a default texture for the given texture that can be used
	* as a placeholder until the actual texture is ready for usage.
	*
	* @abstract
	* @param {Texture} texture - The texture to create a default texture for.
	*/
	createDefaultTexture() {}
	/**
	* Defines a texture on the GPU for the given texture object.
	*
	* @abstract
	* @param {Texture} texture - The texture.
	* @param {Object} [options={}] - Optional configuration parameter.
	*/
	createTexture() {}
	/**
	* Uploads the updated texture data to the GPU.
	*
	* @abstract
	* @param {Texture} texture - The texture.
	* @param {Object} [options={}] - Optional configuration parameter.
	*/
	updateTexture() {}
	/**
	* Generates mipmaps for the given texture.
	*
	* @abstract
	* @param {Texture} texture - The texture.
	*/
	generateMipmaps() {}
	/**
	* Destroys the GPU data for the given texture object.
	*
	* @abstract
	* @param {Texture} texture - The texture.
	* @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
	*/
	destroyTexture() {}
	/**
	* Returns texture data as a typed array.
	*
	* @abstract
	* @async
	* @param {Texture} texture - The texture to copy.
	* @param {number} x - The x coordinate of the copy origin.
	* @param {number} y - The y coordinate of the copy origin.
	* @param {number} width - The width of the copy.
	* @param {number} height - The height of the copy.
	* @param {number} faceIndex - The face index.
	* @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
	*/
	async copyTextureToBuffer() {}
	/**
	* Copies data of the given source texture to the given destination texture.
	*
	* @abstract
	* @param {Texture} srcTexture - The source texture.
	* @param {Texture} dstTexture - The destination texture.
	* @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
	* @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
	* @param {number} [srcLevel=0] - The source mip level to copy from.
	* @param {number} [dstLevel=0] - The destination mip level to copy to.
	*/
	copyTextureToTexture() {}
	/**
	* Copies the current bound framebuffer to the given texture.
	*
	* @abstract
	* @param {Texture} texture - The destination texture.
	* @param {RenderContext} renderContext - The render context.
	* @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
	*/
	copyFramebufferToTexture() {}
	/**
	* Creates the GPU buffer of a shader attribute.
	*
	* @abstract
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	createAttribute() {}
	/**
	* Creates the GPU buffer of an indexed shader attribute.
	*
	* @abstract
	* @param {BufferAttribute} attribute - The indexed buffer attribute.
	*/
	createIndexAttribute() {}
	/**
	* Creates the GPU buffer of a storage attribute.
	*
	* @abstract
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	createStorageAttribute() {}
	/**
	* Updates the GPU buffer of a shader attribute.
	*
	* @abstract
	* @param {BufferAttribute} attribute - The buffer attribute to update.
	*/
	updateAttribute() {}
	/**
	* Destroys the GPU buffer of a shader attribute.
	*
	* @abstract
	* @param {BufferAttribute} attribute - The buffer attribute to destroy.
	*/
	destroyAttribute() {}
	/**
	* Returns the backend's rendering context.
	*
	* @abstract
	* @return {Object} The rendering context.
	*/
	getContext() {}
	/**
	* Backends can use this method if they have to run
	* logic when the renderer gets resized.
	*
	* @abstract
	*/
	updateSize() {}
	/**
	* Updates the viewport with the values from the given render context.
	*
	* @abstract
	* @param {RenderContext} renderContext - The render context.
	*/
	updateViewport() {}
	/**
	* Updates a unique identifier for the given render context that can be used
	* to allocate resources like occlusion queries or timestamp queries.
	*
	* @param {RenderContext|ComputeNode} abstractRenderContext - The render context.
	*/
	updateTimeStampUID(abstractRenderContext) {
		const contextData = this.get(abstractRenderContext);
		const frame = this.renderer.info.frame;
		let prefix;
		if (abstractRenderContext.isComputeNode === true) prefix = "c:" + this.renderer.info.compute.frameCalls;
		else prefix = "r:" + this.renderer.info.render.frameCalls;
		contextData.timestampUID = prefix + ":" + abstractRenderContext.id + ":f" + frame;
	}
	/**
	* Returns a unique identifier for the given render context that can be used
	* to allocate resources like occlusion queries or timestamp queries.
	*
	* @param {RenderContext|ComputeNode} abstractRenderContext - The render context.
	* @return {string} The unique identifier.
	*/
	getTimestampUID(abstractRenderContext) {
		return this.get(abstractRenderContext).timestampUID;
	}
	/**
	* Returns all timestamp frames for the given type.
	*
	* @param {string} type - The type of the time stamp.
	* @return {Array<number>} The timestamp frames.
	*/
	getTimestampFrames(type$1) {
		const queryPool = this.timestampQueryPool[type$1];
		return queryPool ? queryPool.getTimestampFrames() : [];
	}
	/**
	* Returns the query pool for the given uid.
	*
	* @param {string} uid - The unique identifier.
	* @return {TimestampQueryPool} The query pool.
	*/
	_getQueryPool(uid) {
		const type$1 = uid.startsWith("c:") ? TimestampQuery.COMPUTE : TimestampQuery.RENDER;
		return this.timestampQueryPool[type$1];
	}
	/**
	* Returns the timestamp for the given uid.
	*
	* @param {string} uid - The unique identifier.
	* @return {number} The timestamp.
	*/
	getTimestamp(uid) {
		return this._getQueryPool(uid).getTimestamp(uid);
	}
	/**
	* Returns `true` if a timestamp for the given uid is available.
	*
	* @param {string} uid - The unique identifier.
	* @return {boolean} Whether the timestamp is available or not.
	*/
	hasTimestamp(uid) {
		return this._getQueryPool(uid).hasTimestamp(uid);
	}
	/**
	* Returns `true` if the given 3D object is fully occluded by other
	* 3D objects in the scene. Backends must implement this method by using
	* a Occlusion Query API.
	*
	* @abstract
	* @param {RenderContext} renderContext - The render context.
	* @param {Object3D} object - The 3D object to test.
	* @return {boolean} Whether the 3D object is fully occluded or not.
	*/
	isOccluded() {}
	/**
	* Resolves the time stamp for the given render context and type.
	*
	* @async
	* @abstract
	* @param {string} [type='render'] - The type of the time stamp.
	* @return {Promise<number>} A Promise that resolves with the time stamp.
	*/
	async resolveTimestampsAsync(type$1 = "render") {
		if (!this.trackTimestamp) {
			warnOnce("WebGPURenderer: Timestamp tracking is disabled.");
			return;
		}
		const queryPool = this.timestampQueryPool[type$1];
		if (!queryPool) return;
		const duration = await queryPool.resolveQueriesAsync();
		this.renderer.info[type$1].timestamp = duration;
		return duration;
	}
	/**
	* This method performs a readback operation by moving buffer data from
	* a storage buffer attribute from the GPU to the CPU.
	*
	* @async
	* @param {StorageBufferAttribute} attribute - The storage buffer attribute.
	* @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
	*/
	async getArrayBufferAsync() {}
	/**
	* Checks if the given feature is supported by the backend.
	*
	* @async
	* @abstract
	* @param {string} name - The feature's name.
	* @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
	*/
	async hasFeatureAsync() {}
	/**
	* Checks if the given feature is supported  by the backend.
	*
	* @abstract
	* @param {string} name - The feature's name.
	* @return {boolean} Whether the feature is supported or not.
	*/
	hasFeature() {}
	/**
	* Returns the maximum anisotropy texture filtering value.
	*
	* @abstract
	* @return {number} The maximum anisotropy texture filtering value.
	*/
	getMaxAnisotropy() {}
	/**
	* Returns the drawing buffer size.
	*
	* @return {Vector2} The drawing buffer size.
	*/
	getDrawingBufferSize() {
		_vector2 = _vector2 || new Vector2();
		return this.renderer.getDrawingBufferSize(_vector2);
	}
	/**
	* Defines the scissor test.
	*
	* @abstract
	* @param {boolean} boolean - Whether the scissor test should be enabled or not.
	*/
	setScissorTest() {}
	/**
	* Returns the clear color and alpha into a single
	* color object.
	*
	* @return {Color4} The clear color.
	*/
	getClearColor() {
		const renderer = this.renderer;
		_color4 = _color4 || new Color4();
		renderer.getClearColor(_color4);
		_color4.getRGB(_color4);
		return _color4;
	}
	/**
	* Returns the DOM element. If no DOM element exists, the backend
	* creates a new one.
	*
	* @return {HTMLCanvasElement} The DOM element.
	*/
	getDomElement() {
		let domElement = this.domElement;
		if (domElement === null) {
			domElement = this.parameters.canvas !== void 0 ? this.parameters.canvas : createCanvasElement();
			if ("setAttribute" in domElement) domElement.setAttribute("data-engine", `three.js r${REVISION} webgpu`);
			this.domElement = domElement;
		}
		return domElement;
	}
	/**
	* Sets a dictionary for the given object into the
	* internal data structure.
	*
	* @param {Object} object - The object.
	* @param {Object} value - The dictionary to set.
	*/
	set(object, value) {
		this.data.set(object, value);
	}
	/**
	* Returns the dictionary for the given object.
	*
	* @param {Object} object - The object.
	* @return {Object} The object's dictionary.
	*/
	get(object) {
		let map = this.data.get(object);
		if (map === void 0) {
			map = {};
			this.data.set(object, map);
		}
		return map;
	}
	/**
	* Checks if the given object has a dictionary
	* with data defined.
	*
	* @param {Object} object - The object.
	* @return {boolean} Whether a dictionary for the given object as been defined or not.
	*/
	has(object) {
		return this.data.has(object);
	}
	/**
	* Deletes an object from the internal data structure.
	*
	* @param {Object} object - The object to delete.
	*/
	delete(object) {
		this.data.delete(object);
	}
	/**
	* Frees internal resources.
	*
	* @abstract
	*/
	dispose() {}
};
var _id$1 = 0;
/**
* This module is internally used in context of compute shaders.
* This type of shader is not natively supported in WebGL 2 and
* thus implemented via Transform Feedback. `DualAttributeData`
* manages the related data.
*
* @private
*/
var DualAttributeData = class {
	constructor(attributeData, dualBuffer) {
		this.buffers = [attributeData.bufferGPU, dualBuffer];
		this.type = attributeData.type;
		this.bufferType = attributeData.bufferType;
		this.pbo = attributeData.pbo;
		this.byteLength = attributeData.byteLength;
		this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
		this.version = attributeData.version;
		this.isInteger = attributeData.isInteger;
		this.activeBufferIndex = 0;
		this.baseId = attributeData.id;
	}
	get id() {
		return `${this.baseId}|${this.activeBufferIndex}`;
	}
	get bufferGPU() {
		return this.buffers[this.activeBufferIndex];
	}
	get transformBuffer() {
		return this.buffers[this.activeBufferIndex ^ 1];
	}
	switchBuffers() {
		this.activeBufferIndex ^= 1;
	}
};
/**
* A WebGL 2 backend utility module for managing shader attributes.
*
* @private
*/
var WebGLAttributeUtils = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGLBackend} backend - The WebGL 2 backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGL 2 backend.
		*
		* @type {WebGLBackend}
		*/
		this.backend = backend;
	}
	/**
	* Creates the GPU buffer for the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	* @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
	*/
	createAttribute(attribute$2, bufferType) {
		const backend = this.backend;
		const { gl } = backend;
		const array$2 = attribute$2.array;
		const usage = attribute$2.usage || gl.STATIC_DRAW;
		const bufferAttribute$2 = attribute$2.isInterleavedBufferAttribute ? attribute$2.data : attribute$2;
		const bufferData = backend.get(bufferAttribute$2);
		let bufferGPU = bufferData.bufferGPU;
		if (bufferGPU === void 0) {
			bufferGPU = this._createBuffer(gl, bufferType, array$2, usage);
			bufferData.bufferGPU = bufferGPU;
			bufferData.bufferType = bufferType;
			bufferData.version = bufferAttribute$2.version;
		}
		let type$1;
		if (array$2 instanceof Float32Array) type$1 = gl.FLOAT;
		else if (typeof Float16Array !== "undefined" && array$2 instanceof Float16Array) type$1 = gl.HALF_FLOAT;
		else if (array$2 instanceof Uint16Array) if (attribute$2.isFloat16BufferAttribute) type$1 = gl.HALF_FLOAT;
		else type$1 = gl.UNSIGNED_SHORT;
		else if (array$2 instanceof Int16Array) type$1 = gl.SHORT;
		else if (array$2 instanceof Uint32Array) type$1 = gl.UNSIGNED_INT;
		else if (array$2 instanceof Int32Array) type$1 = gl.INT;
		else if (array$2 instanceof Int8Array) type$1 = gl.BYTE;
		else if (array$2 instanceof Uint8Array) type$1 = gl.UNSIGNED_BYTE;
		else if (array$2 instanceof Uint8ClampedArray) type$1 = gl.UNSIGNED_BYTE;
		else throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + array$2);
		let attributeData = {
			bufferGPU,
			bufferType,
			type: type$1,
			byteLength: array$2.byteLength,
			bytesPerElement: array$2.BYTES_PER_ELEMENT,
			version: attribute$2.version,
			pbo: attribute$2.pbo,
			isInteger: type$1 === gl.INT || type$1 === gl.UNSIGNED_INT || attribute$2.gpuType === IntType,
			id: _id$1++
		};
		if (attribute$2.isStorageBufferAttribute || attribute$2.isStorageInstancedBufferAttribute) {
			const bufferGPUDual = this._createBuffer(gl, bufferType, array$2, usage);
			attributeData = new DualAttributeData(attributeData, bufferGPUDual);
		}
		backend.set(attribute$2, attributeData);
	}
	/**
	* Updates the GPU buffer of the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	updateAttribute(attribute$2) {
		const backend = this.backend;
		const { gl } = backend;
		const array$2 = attribute$2.array;
		const bufferAttribute$2 = attribute$2.isInterleavedBufferAttribute ? attribute$2.data : attribute$2;
		const bufferData = backend.get(bufferAttribute$2);
		const bufferType = bufferData.bufferType;
		const updateRanges = attribute$2.isInterleavedBufferAttribute ? attribute$2.data.updateRanges : attribute$2.updateRanges;
		gl.bindBuffer(bufferType, bufferData.bufferGPU);
		if (updateRanges.length === 0) gl.bufferSubData(bufferType, 0, array$2);
		else {
			for (let i = 0, l = updateRanges.length; i < l; i++) {
				const range$3 = updateRanges[i];
				gl.bufferSubData(bufferType, range$3.start * array$2.BYTES_PER_ELEMENT, array$2, range$3.start, range$3.count);
			}
			bufferAttribute$2.clearUpdateRanges();
		}
		gl.bindBuffer(bufferType, null);
		bufferData.version = bufferAttribute$2.version;
	}
	/**
	* Destroys the GPU buffer of the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	destroyAttribute(attribute$2) {
		const backend = this.backend;
		const { gl } = backend;
		if (attribute$2.isInterleavedBufferAttribute) backend.delete(attribute$2.data);
		const attributeData = backend.get(attribute$2);
		gl.deleteBuffer(attributeData.bufferGPU);
		backend.delete(attribute$2);
	}
	/**
	* This method performs a readback operation by moving buffer data from
	* a storage buffer attribute from the GPU to the CPU.
	*
	* @async
	* @param {StorageBufferAttribute} attribute - The storage buffer attribute.
	* @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
	*/
	async getArrayBufferAsync(attribute$2) {
		const backend = this.backend;
		const { gl } = backend;
		const bufferAttribute$2 = attribute$2.isInterleavedBufferAttribute ? attribute$2.data : attribute$2;
		const { bufferGPU } = backend.get(bufferAttribute$2);
		const array$2 = attribute$2.array;
		const byteLength = array$2.byteLength;
		gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);
		const writeBuffer = gl.createBuffer();
		gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
		gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);
		gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength);
		await backend.utils._clientWaitAsync();
		const dstBuffer = new attribute$2.array.constructor(array$2.length);
		gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
		gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);
		gl.deleteBuffer(writeBuffer);
		gl.bindBuffer(gl.COPY_READ_BUFFER, null);
		gl.bindBuffer(gl.COPY_WRITE_BUFFER, null);
		return dstBuffer.buffer;
	}
	/**
	* Creates a WebGL buffer with the given data.
	*
	* @private
	* @param {WebGL2RenderingContext} gl - The rendering context.
	* @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
	* @param {TypedArray} array - The array of the buffer attribute.
	* @param {GLenum} usage - The usage.
	* @return {WebGLBuffer} The WebGL buffer.
	*/
	_createBuffer(gl, bufferType, array$2, usage) {
		const bufferGPU = gl.createBuffer();
		gl.bindBuffer(bufferType, bufferGPU);
		gl.bufferData(bufferType, array$2, usage);
		gl.bindBuffer(bufferType, null);
		return bufferGPU;
	}
};
var equationToGL, factorToGL;
/**
* A WebGL 2 backend utility module for managing the WebGL state.
*
* The major goal of this module is to reduce the number of state changes
* by caching the WEbGL state with a series of variables. In this way, the
* renderer only executes state change commands when necessary which
* improves the overall performance.
*
* @private
*/
var WebGLState$1 = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGLBackend} backend - The WebGL 2 backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGL 2 backend.
		*
		* @type {WebGLBackend}
		*/
		this.backend = backend;
		/**
		* A reference to the rendering context.
		*
		* @type {WebGL2RenderingContext}
		*/
		this.gl = this.backend.gl;
		this.enabled = {};
		this.currentFlipSided = null;
		this.currentCullFace = null;
		this.currentProgram = null;
		this.currentBlendingEnabled = false;
		this.currentBlending = null;
		this.currentBlendSrc = null;
		this.currentBlendDst = null;
		this.currentBlendSrcAlpha = null;
		this.currentBlendDstAlpha = null;
		this.currentPremultipledAlpha = null;
		this.currentPolygonOffsetFactor = null;
		this.currentPolygonOffsetUnits = null;
		this.currentColorMask = null;
		this.currentDepthFunc = null;
		this.currentDepthMask = null;
		this.currentStencilFunc = null;
		this.currentStencilRef = null;
		this.currentStencilFuncMask = null;
		this.currentStencilFail = null;
		this.currentStencilZFail = null;
		this.currentStencilZPass = null;
		this.currentStencilMask = null;
		this.currentLineWidth = null;
		this.currentClippingPlanes = 0;
		this.currentVAO = null;
		this.currentIndex = null;
		this.currentBoundFramebuffers = {};
		this.currentDrawbuffers = /* @__PURE__ */ new WeakMap();
		this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
		this.currentTextureSlot = null;
		this.currentBoundTextures = {};
		this.currentBoundBufferBases = {};
		this._init();
	}
	/**
	* Inits the state of the utility.
	*
	* @private
	*/
	_init() {
		const gl = this.gl;
		equationToGL = {
			[AddEquation]: gl.FUNC_ADD,
			[SubtractEquation]: gl.FUNC_SUBTRACT,
			[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
		};
		factorToGL = {
			[ZeroFactor]: gl.ZERO,
			[OneFactor]: gl.ONE,
			[SrcColorFactor]: gl.SRC_COLOR,
			[SrcAlphaFactor]: gl.SRC_ALPHA,
			[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
			[DstColorFactor]: gl.DST_COLOR,
			[DstAlphaFactor]: gl.DST_ALPHA,
			[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
			[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
			[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
			[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
		};
		const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
		const viewportParam = gl.getParameter(gl.VIEWPORT);
		this.currentScissor = new Vector4().fromArray(scissorParam);
		this.currentViewport = new Vector4().fromArray(viewportParam);
		this._tempVec4 = new Vector4();
	}
	/**
	* Enables the given WebGL capability.
	*
	* This method caches the capability state so
	* `gl.enable()` is only called when necessary.
	*
	* @param {GLenum} id - The capability to enable.
	*/
	enable(id) {
		const { enabled } = this;
		if (enabled[id] !== true) {
			this.gl.enable(id);
			enabled[id] = true;
		}
	}
	/**
	* Disables the given WebGL capability.
	*
	* This method caches the capability state so
	* `gl.disable()` is only called when necessary.
	*
	* @param {GLenum} id - The capability to enable.
	*/
	disable(id) {
		const { enabled } = this;
		if (enabled[id] !== false) {
			this.gl.disable(id);
			enabled[id] = false;
		}
	}
	/**
	* Specifies whether polygons are front- or back-facing
	* by setting the winding orientation.
	*
	* This method caches the state so `gl.frontFace()` is only
	* called when necessary.
	*
	* @param {boolean} flipSided - Whether triangles flipped their sides or not.
	*/
	setFlipSided(flipSided) {
		if (this.currentFlipSided !== flipSided) {
			const { gl } = this;
			if (flipSided) gl.frontFace(gl.CW);
			else gl.frontFace(gl.CCW);
			this.currentFlipSided = flipSided;
		}
	}
	/**
	* Specifies whether or not front- and/or back-facing
	* polygons can be culled.
	*
	* This method caches the state so `gl.cullFace()` is only
	* called when necessary.
	*
	* @param {number} cullFace - Defines which polygons are candidates for culling.
	*/
	setCullFace(cullFace) {
		const { gl } = this;
		if (cullFace !== CullFaceNone) {
			this.enable(gl.CULL_FACE);
			if (cullFace !== this.currentCullFace) if (cullFace === CullFaceBack) gl.cullFace(gl.BACK);
			else if (cullFace === CullFaceFront) gl.cullFace(gl.FRONT);
			else gl.cullFace(gl.FRONT_AND_BACK);
		} else this.disable(gl.CULL_FACE);
		this.currentCullFace = cullFace;
	}
	/**
	* Specifies the width of line primitives.
	*
	* This method caches the state so `gl.lineWidth()` is only
	* called when necessary.
	*
	* @param {number} width - The line width.
	*/
	setLineWidth(width) {
		const { currentLineWidth, gl } = this;
		if (width !== currentLineWidth) {
			gl.lineWidth(width);
			this.currentLineWidth = width;
		}
	}
	/**
	* Defines the blending.
	*
	* This method caches the state so `gl.blendEquation()`, `gl.blendEquationSeparate()`,
	* `gl.blendFunc()` and  `gl.blendFuncSeparate()` are only called when necessary.
	*
	* @param {number} blending - The blending type.
	* @param {number} blendEquation - The blending equation.
	* @param {number} blendSrc - Only relevant for custom blending. The RGB source blending factor.
	* @param {number} blendDst - Only relevant for custom blending. The RGB destination blending factor.
	* @param {number} blendEquationAlpha - Only relevant for custom blending. The blending equation for alpha.
	* @param {number} blendSrcAlpha - Only relevant for custom blending. The alpha source blending factor.
	* @param {number} blendDstAlpha - Only relevant for custom blending. The alpha destination blending factor.
	* @param {boolean} premultipliedAlpha - Whether premultiplied alpha is enabled or not.
	*/
	setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
		const { gl } = this;
		if (blending === NoBlending) {
			if (this.currentBlendingEnabled === true) {
				this.disable(gl.BLEND);
				this.currentBlendingEnabled = false;
			}
			return;
		}
		if (this.currentBlendingEnabled === false) {
			this.enable(gl.BLEND);
			this.currentBlendingEnabled = true;
		}
		if (blending !== CustomBlending) {
			if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
				if (this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation) {
					gl.blendEquation(gl.FUNC_ADD);
					this.currentBlendEquation = AddEquation;
					this.currentBlendEquationAlpha = AddEquation;
				}
				if (premultipliedAlpha) switch (blending) {
					case NormalBlending:
						gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
						break;
					case AdditiveBlending:
						gl.blendFunc(gl.ONE, gl.ONE);
						break;
					case SubtractiveBlending:
						gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
						break;
					case MultiplyBlending:
						gl.blendFuncSeparate(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
						break;
					default:
						error("WebGLState: Invalid blending: ", blending);
						break;
				}
				else switch (blending) {
					case NormalBlending:
						gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
						break;
					case AdditiveBlending:
						gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);
						break;
					case SubtractiveBlending:
						error("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
						break;
					case MultiplyBlending:
						error("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
						break;
					default:
						error("WebGLState: Invalid blending: ", blending);
						break;
				}
				this.currentBlendSrc = null;
				this.currentBlendDst = null;
				this.currentBlendSrcAlpha = null;
				this.currentBlendDstAlpha = null;
				this.currentBlending = blending;
				this.currentPremultipledAlpha = premultipliedAlpha;
			}
			return;
		}
		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;
		if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
			gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
			this.currentBlendEquation = blendEquation;
			this.currentBlendEquationAlpha = blendEquationAlpha;
		}
		if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {
			gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
			this.currentBlendSrc = blendSrc;
			this.currentBlendDst = blendDst;
			this.currentBlendSrcAlpha = blendSrcAlpha;
			this.currentBlendDstAlpha = blendDstAlpha;
		}
		this.currentBlending = blending;
		this.currentPremultipledAlpha = false;
	}
	/**
	* Specifies whether colors can be written when rendering
	* into a framebuffer or not.
	*
	* This method caches the state so `gl.colorMask()` is only
	* called when necessary.
	*
	* @param {boolean} colorMask - The color mask.
	*/
	setColorMask(colorMask) {
		if (this.currentColorMask !== colorMask) {
			this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
			this.currentColorMask = colorMask;
		}
	}
	/**
	* Specifies whether the depth test is enabled or not.
	*
	* @param {boolean} depthTest - Whether the depth test is enabled or not.
	*/
	setDepthTest(depthTest) {
		const { gl } = this;
		if (depthTest) this.enable(gl.DEPTH_TEST);
		else this.disable(gl.DEPTH_TEST);
	}
	/**
	* Specifies whether depth values can be written when rendering
	* into a framebuffer or not.
	*
	* This method caches the state so `gl.depthMask()` is only
	* called when necessary.
	*
	* @param {boolean} depthMask - The depth mask.
	*/
	setDepthMask(depthMask) {
		if (this.currentDepthMask !== depthMask) {
			this.gl.depthMask(depthMask);
			this.currentDepthMask = depthMask;
		}
	}
	/**
	* Specifies the depth compare function.
	*
	* This method caches the state so `gl.depthFunc()` is only
	* called when necessary.
	*
	* @param {number} depthFunc - The depth compare function.
	*/
	setDepthFunc(depthFunc) {
		if (this.currentDepthFunc !== depthFunc) {
			const { gl } = this;
			switch (depthFunc) {
				case NeverDepth:
					gl.depthFunc(gl.NEVER);
					break;
				case AlwaysDepth:
					gl.depthFunc(gl.ALWAYS);
					break;
				case LessDepth:
					gl.depthFunc(gl.LESS);
					break;
				case LessEqualDepth:
					gl.depthFunc(gl.LEQUAL);
					break;
				case EqualDepth:
					gl.depthFunc(gl.EQUAL);
					break;
				case GreaterEqualDepth:
					gl.depthFunc(gl.GEQUAL);
					break;
				case GreaterDepth:
					gl.depthFunc(gl.GREATER);
					break;
				case NotEqualDepth:
					gl.depthFunc(gl.NOTEQUAL);
					break;
				default: gl.depthFunc(gl.LEQUAL);
			}
			this.currentDepthFunc = depthFunc;
		}
	}
	/**
	* Specifies the scissor box.
	*
	* @param {number} x - The x-coordinate of the lower left corner of the viewport.
	* @param {number} y - The y-coordinate of the lower left corner of the viewport.
	* @param {number} width - The width of the viewport.
	* @param {number} height - The height of the viewport.
	*
	*/
	scissor(x, y, width, height) {
		const scissor = this._tempVec4.set(x, y, width, height);
		if (this.currentScissor.equals(scissor) === false) {
			const { gl } = this;
			gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
			this.currentScissor.copy(scissor);
		}
	}
	/**
	* Specifies the viewport.
	*
	* @param {number} x - The x-coordinate of the lower left corner of the viewport.
	* @param {number} y - The y-coordinate of the lower left corner of the viewport.
	* @param {number} width - The width of the viewport.
	* @param {number} height - The height of the viewport.
	*
	*/
	viewport(x, y, width, height) {
		const viewport$2 = this._tempVec4.set(x, y, width, height);
		if (this.currentViewport.equals(viewport$2) === false) {
			const { gl } = this;
			gl.viewport(viewport$2.x, viewport$2.y, viewport$2.z, viewport$2.w);
			this.currentViewport.copy(viewport$2);
		}
	}
	/**
	* Defines the scissor test.
	*
	* @param {boolean} boolean - Whether the scissor test should be enabled or not.
	*/
	setScissorTest(boolean) {
		const gl = this.gl;
		if (boolean) gl.enable(gl.SCISSOR_TEST);
		else gl.disable(gl.SCISSOR_TEST);
	}
	/**
	* Specifies whether the stencil test is enabled or not.
	*
	* @param {boolean} stencilTest - Whether the stencil test is enabled or not.
	*/
	setStencilTest(stencilTest) {
		const { gl } = this;
		if (stencilTest) this.enable(gl.STENCIL_TEST);
		else this.disable(gl.STENCIL_TEST);
	}
	/**
	* Specifies whether stencil values can be written when rendering
	* into a framebuffer or not.
	*
	* This method caches the state so `gl.stencilMask()` is only
	* called when necessary.
	*
	* @param {boolean} stencilMask - The stencil mask.
	*/
	setStencilMask(stencilMask) {
		if (this.currentStencilMask !== stencilMask) {
			this.gl.stencilMask(stencilMask);
			this.currentStencilMask = stencilMask;
		}
	}
	/**
	* Specifies whether the stencil test functions.
	*
	* This method caches the state so `gl.stencilFunc()` is only
	* called when necessary.
	*
	* @param {number} stencilFunc - The stencil compare function.
	* @param {number} stencilRef - The reference value for the stencil test.
	* @param {number} stencilMask - A bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done.
	*/
	setStencilFunc(stencilFunc, stencilRef, stencilMask) {
		if (this.currentStencilFunc !== stencilFunc || this.currentStencilRef !== stencilRef || this.currentStencilFuncMask !== stencilMask) {
			this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
			this.currentStencilFunc = stencilFunc;
			this.currentStencilRef = stencilRef;
			this.currentStencilFuncMask = stencilMask;
		}
	}
	/**
	* Specifies whether the stencil test operation.
	*
	* This method caches the state so `gl.stencilOp()` is only
	* called when necessary.
	*
	* @param {number} stencilFail - The function to use when the stencil test fails.
	* @param {number} stencilZFail - The function to use when the stencil test passes, but the depth test fail.
	* @param {number} stencilZPass - The function to use when both the stencil test and the depth test pass,
	* or when the stencil test passes and there is no depth buffer or depth testing is disabled.
	*/
	setStencilOp(stencilFail, stencilZFail, stencilZPass) {
		if (this.currentStencilFail !== stencilFail || this.currentStencilZFail !== stencilZFail || this.currentStencilZPass !== stencilZPass) {
			this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
			this.currentStencilFail = stencilFail;
			this.currentStencilZFail = stencilZFail;
			this.currentStencilZPass = stencilZPass;
		}
	}
	/**
	* Configures the WebGL state for the given material.
	*
	* @param {Material} material - The material to configure the state for.
	* @param {number} frontFaceCW - Whether the front faces are counter-clockwise or not.
	* @param {number} hardwareClippingPlanes - The number of hardware clipping planes.
	*/
	setMaterial(material, frontFaceCW, hardwareClippingPlanes) {
		const { gl } = this;
		material.side === DoubleSide ? this.disable(gl.CULL_FACE) : this.enable(gl.CULL_FACE);
		let flipSided = material.side === BackSide;
		if (frontFaceCW) flipSided = !flipSided;
		this.setFlipSided(flipSided);
		material.blending === NormalBlending && material.transparent === false ? this.setBlending(NoBlending) : this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
		this.setDepthFunc(material.depthFunc);
		this.setDepthTest(material.depthTest);
		this.setDepthMask(material.depthWrite);
		this.setColorMask(material.colorWrite);
		const stencilWrite = material.stencilWrite;
		this.setStencilTest(stencilWrite);
		if (stencilWrite) {
			this.setStencilMask(material.stencilWriteMask);
			this.setStencilFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
			this.setStencilOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
		}
		this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
		material.alphaToCoverage === true && this.backend.renderer.currentSamples > 0 ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
		if (hardwareClippingPlanes > 0) {
			if (this.currentClippingPlanes !== hardwareClippingPlanes) {
				const CLIP_DISTANCE0_WEBGL = 12288;
				for (let i = 0; i < 8; i++) if (i < hardwareClippingPlanes) this.enable(CLIP_DISTANCE0_WEBGL + i);
				else this.disable(CLIP_DISTANCE0_WEBGL + i);
			}
		}
	}
	/**
	* Specifies the polygon offset.
	*
	* This method caches the state so `gl.polygonOffset()` is only
	* called when necessary.
	*
	* @param {boolean} polygonOffset - Whether polygon offset is enabled or not.
	* @param {number} factor - The scale factor for the variable depth offset for each polygon.
	* @param {number} units - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.
	*/
	setPolygonOffset(polygonOffset, factor, units) {
		const { gl } = this;
		if (polygonOffset) {
			this.enable(gl.POLYGON_OFFSET_FILL);
			if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
				gl.polygonOffset(factor, units);
				this.currentPolygonOffsetFactor = factor;
				this.currentPolygonOffsetUnits = units;
			}
		} else this.disable(gl.POLYGON_OFFSET_FILL);
	}
	/**
	* Defines the usage of the given WebGL program.
	*
	* This method caches the state so `gl.useProgram()` is only
	* called when necessary.
	*
	* @param {WebGLProgram} program - The WebGL program to use.
	* @return {boolean} Whether a program change has been executed or not.
	*/
	useProgram(program) {
		if (this.currentProgram !== program) {
			this.gl.useProgram(program);
			this.currentProgram = program;
			return true;
		}
		return false;
	}
	/**
	* Sets the vertex state by binding the given VAO and element buffer.
	*
	* @param {WebGLVertexArrayObject} vao - The VAO.
	* @param {?WebGLBuffer} indexBuffer - The index buffer.
	* @return {boolean} Whether a vertex state has been changed or not.
	*/
	setVertexState(vao, indexBuffer = null) {
		const gl = this.gl;
		if (this.currentVAO !== vao || this.currentIndex !== indexBuffer) {
			gl.bindVertexArray(vao);
			if (indexBuffer !== null) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
			this.currentVAO = vao;
			this.currentIndex = indexBuffer;
			return true;
		}
		return false;
	}
	/**
	* Resets the vertex array state by resetting the VAO and element buffer.
	*/
	resetVertexState() {
		const gl = this.gl;
		gl.bindVertexArray(null);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
		this.currentVAO = null;
		this.currentIndex = null;
	}
	/**
	* Binds the given framebuffer.
	*
	* This method caches the state so `gl.bindFramebuffer()` is only
	* called when necessary.
	*
	* @param {number} target - The binding point (target).
	* @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer to bind.
	* @return {boolean} Whether a bind has been executed or not.
	*/
	bindFramebuffer(target, framebuffer) {
		const { gl, currentBoundFramebuffers } = this;
		if (currentBoundFramebuffers[target] !== framebuffer) {
			gl.bindFramebuffer(target, framebuffer);
			currentBoundFramebuffers[target] = framebuffer;
			if (target === gl.DRAW_FRAMEBUFFER) currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
			if (target === gl.FRAMEBUFFER) currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
			return true;
		}
		return false;
	}
	/**
	* Defines draw buffers to which fragment colors are written into.
	* Configures the MRT setup of custom framebuffers.
	*
	* This method caches the state so `gl.drawBuffers()` is only
	* called when necessary.
	*
	* @param {RenderContext} renderContext - The render context.
	* @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer.
	*/
	drawBuffers(renderContext, framebuffer) {
		const { gl } = this;
		let drawBuffers = [];
		let needsUpdate = false;
		if (renderContext.textures !== null) {
			drawBuffers = this.currentDrawbuffers.get(framebuffer);
			if (drawBuffers === void 0) {
				drawBuffers = [];
				this.currentDrawbuffers.set(framebuffer, drawBuffers);
			}
			const textures = renderContext.textures;
			if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
				for (let i = 0, il = textures.length; i < il; i++) drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
				drawBuffers.length = textures.length;
				needsUpdate = true;
			}
		} else if (drawBuffers[0] !== gl.BACK) {
			drawBuffers[0] = gl.BACK;
			needsUpdate = true;
		}
		if (needsUpdate) gl.drawBuffers(drawBuffers);
	}
	/**
	* Makes the given texture unit active.
	*
	* This method caches the state so `gl.activeTexture()` is only
	* called when necessary.
	*
	* @param {number} webglSlot - The texture unit to make active.
	*/
	activeTexture(webglSlot) {
		const { gl, currentTextureSlot, maxTextures } = this;
		if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
		if (currentTextureSlot !== webglSlot) {
			gl.activeTexture(webglSlot);
			this.currentTextureSlot = webglSlot;
		}
	}
	/**
	* Binds the given WebGL texture to a target.
	*
	* This method caches the state so `gl.bindTexture()` is only
	* called when necessary.
	*
	* @param {number} webglType - The binding point (target).
	* @param {WebGLTexture} webglTexture - The WebGL texture to bind.
	* @param {number} webglSlot - The texture.
	*/
	bindTexture(webglType, webglTexture, webglSlot) {
		const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;
		if (webglSlot === void 0) if (currentTextureSlot === null) webglSlot = gl.TEXTURE0 + maxTextures - 1;
		else webglSlot = currentTextureSlot;
		let boundTexture = currentBoundTextures[webglSlot];
		if (boundTexture === void 0) {
			boundTexture = {
				type: void 0,
				texture: void 0
			};
			currentBoundTextures[webglSlot] = boundTexture;
		}
		if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				this.currentTextureSlot = webglSlot;
			}
			gl.bindTexture(webglType, webglTexture);
			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;
		}
	}
	/**
	* Binds a given WebGL buffer to a given binding point (target) at a given index.
	*
	* This method caches the state so `gl.bindBufferBase()` is only
	* called when necessary.
	*
	* @param {number} target - The target for the bind operation.
	* @param {number} index - The index of the target.
	* @param {WebGLBuffer} buffer - The WebGL buffer.
	* @return {boolean} Whether a bind has been executed or not.
	*/
	bindBufferBase(target, index, buffer$2) {
		const { gl } = this;
		const key = `${target}-${index}`;
		if (this.currentBoundBufferBases[key] !== buffer$2) {
			gl.bindBufferBase(target, index, buffer$2);
			this.currentBoundBufferBases[key] = buffer$2;
			return true;
		}
		return false;
	}
	/**
	* Unbinds the current bound texture.
	*
	* This method caches the state so `gl.bindTexture()` is only
	* called when necessary.
	*/
	unbindTexture() {
		const { gl, currentTextureSlot, currentBoundTextures } = this;
		const boundTexture = currentBoundTextures[currentTextureSlot];
		if (boundTexture !== void 0 && boundTexture.type !== void 0) {
			gl.bindTexture(boundTexture.type, null);
			boundTexture.type = void 0;
			boundTexture.texture = void 0;
		}
	}
};
/**
* A WebGL 2 backend utility module with common helpers.
*
* @private
*/
var WebGLUtils$1 = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGLBackend} backend - The WebGL 2 backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGL 2 backend.
		*
		* @type {WebGLBackend}
		*/
		this.backend = backend;
		/**
		* A reference to the rendering context.
		*
		* @type {WebGL2RenderingContext}
		*/
		this.gl = this.backend.gl;
		/**
		* A reference to a backend module holding extension-related
		* utility functions.
		*
		* @type {WebGLExtensions}
		*/
		this.extensions = backend.extensions;
	}
	/**
	* Converts the given three.js constant into a WebGL constant.
	* The method currently supports the conversion of texture formats
	* and types.
	*
	* @param {number} p - The three.js constant.
	* @param {string} [colorSpace=NoColorSpace] - The color space.
	* @return {?number} The corresponding WebGL constant.
	*/
	convert(p$1, colorSpace = NoColorSpace) {
		const { gl, extensions } = this;
		let extension;
		const transfer = ColorManagement.getTransfer(colorSpace);
		if (p$1 === UnsignedByteType) return gl.UNSIGNED_BYTE;
		if (p$1 === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
		if (p$1 === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
		if (p$1 === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
		if (p$1 === UnsignedInt101111Type) return gl.UNSIGNED_INT_10F_11F_11F_REV;
		if (p$1 === ByteType) return gl.BYTE;
		if (p$1 === ShortType) return gl.SHORT;
		if (p$1 === UnsignedShortType) return gl.UNSIGNED_SHORT;
		if (p$1 === IntType) return gl.INT;
		if (p$1 === UnsignedIntType) return gl.UNSIGNED_INT;
		if (p$1 === FloatType) return gl.FLOAT;
		if (p$1 === HalfFloatType) return gl.HALF_FLOAT;
		if (p$1 === AlphaFormat) return gl.ALPHA;
		if (p$1 === RGBFormat) return gl.RGB;
		if (p$1 === RGBAFormat) return gl.RGBA;
		if (p$1 === DepthFormat) return gl.DEPTH_COMPONENT;
		if (p$1 === DepthStencilFormat) return gl.DEPTH_STENCIL;
		if (p$1 === RedFormat) return gl.RED;
		if (p$1 === RedIntegerFormat) return gl.RED_INTEGER;
		if (p$1 === RGFormat) return gl.RG;
		if (p$1 === RGIntegerFormat) return gl.RG_INTEGER;
		if (p$1 === RGBAIntegerFormat) return gl.RGBA_INTEGER;
		if (p$1 === RGB_S3TC_DXT1_Format || p$1 === RGBA_S3TC_DXT1_Format || p$1 === RGBA_S3TC_DXT3_Format || p$1 === RGBA_S3TC_DXT5_Format) if (transfer === SRGBTransfer) {
			extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
			if (extension !== null) {
				if (p$1 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
				if (p$1 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
				if (p$1 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
				if (p$1 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
			} else return null;
		} else {
			extension = extensions.get("WEBGL_compressed_texture_s3tc");
			if (extension !== null) {
				if (p$1 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if (p$1 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if (p$1 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if (p$1 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
			} else return null;
		}
		if (p$1 === RGB_PVRTC_4BPPV1_Format || p$1 === RGB_PVRTC_2BPPV1_Format || p$1 === RGBA_PVRTC_4BPPV1_Format || p$1 === RGBA_PVRTC_2BPPV1_Format) {
			extension = extensions.get("WEBGL_compressed_texture_pvrtc");
			if (extension !== null) {
				if (p$1 === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (p$1 === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (p$1 === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (p$1 === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
			} else return null;
		}
		if (p$1 === RGB_ETC1_Format || p$1 === RGB_ETC2_Format || p$1 === RGBA_ETC2_EAC_Format) {
			extension = extensions.get("WEBGL_compressed_texture_etc");
			if (extension !== null) {
				if (p$1 === RGB_ETC1_Format || p$1 === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if (p$1 === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
			} else return null;
		}
		if (p$1 === RGBA_ASTC_4x4_Format || p$1 === RGBA_ASTC_5x4_Format || p$1 === RGBA_ASTC_5x5_Format || p$1 === RGBA_ASTC_6x5_Format || p$1 === RGBA_ASTC_6x6_Format || p$1 === RGBA_ASTC_8x5_Format || p$1 === RGBA_ASTC_8x6_Format || p$1 === RGBA_ASTC_8x8_Format || p$1 === RGBA_ASTC_10x5_Format || p$1 === RGBA_ASTC_10x6_Format || p$1 === RGBA_ASTC_10x8_Format || p$1 === RGBA_ASTC_10x10_Format || p$1 === RGBA_ASTC_12x10_Format || p$1 === RGBA_ASTC_12x12_Format) {
			extension = extensions.get("WEBGL_compressed_texture_astc");
			if (extension !== null) {
				if (p$1 === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if (p$1 === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if (p$1 === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if (p$1 === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if (p$1 === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if (p$1 === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if (p$1 === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if (p$1 === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if (p$1 === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if (p$1 === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if (p$1 === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if (p$1 === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if (p$1 === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if (p$1 === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
			} else return null;
		}
		if (p$1 === RGBA_BPTC_Format) {
			extension = extensions.get("EXT_texture_compression_bptc");
			if (extension !== null) {
				if (p$1 === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
			} else return null;
		}
		if (p$1 === RED_RGTC1_Format || p$1 === SIGNED_RED_RGTC1_Format || p$1 === RED_GREEN_RGTC2_Format || p$1 === SIGNED_RED_GREEN_RGTC2_Format) {
			extension = extensions.get("EXT_texture_compression_rgtc");
			if (extension !== null) {
				if (p$1 === RED_RGTC1_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
				if (p$1 === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if (p$1 === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if (p$1 === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
			} else return null;
		}
		if (p$1 === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;
		return gl[p$1] !== void 0 ? gl[p$1] : null;
	}
	/**
	* This method can be used to synchronize the CPU with the GPU by waiting until
	* ongoing GPU commands have been completed.
	*
	* @private
	* @return {Promise} A promise that resolves when all ongoing GPU commands have been completed.
	*/
	_clientWaitAsync() {
		const { gl } = this;
		const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
		gl.flush();
		return new Promise((resolve, reject) => {
			function test() {
				const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);
				if (res === gl.WAIT_FAILED) {
					gl.deleteSync(sync);
					reject();
					return;
				}
				if (res === gl.TIMEOUT_EXPIRED) {
					requestAnimationFrame(test);
					return;
				}
				gl.deleteSync(sync);
				resolve();
			}
			test();
		});
	}
};
var initialized = false, wrappingToGL, filterToGL, compareToGL;
/**
* A WebGL 2 backend utility module for managing textures.
*
* @private
*/
var WebGLTextureUtils = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGLBackend} backend - The WebGL 2 backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGL 2 backend.
		*
		* @type {WebGLBackend}
		*/
		this.backend = backend;
		/**
		* A reference to the rendering context.
		*
		* @type {WebGL2RenderingContext}
		*/
		this.gl = backend.gl;
		/**
		* A reference to a backend module holding extension-related
		* utility functions.
		*
		* @type {WebGLExtensions}
		*/
		this.extensions = backend.extensions;
		/**
		* A dictionary for managing default textures. The key
		* is the binding point (target), the value the WEbGL texture object.
		*
		* @type {Object<GLenum,WebGLTexture>}
		*/
		this.defaultTextures = {};
		/**
		* A scratch framebuffer used for attaching the source texture in
		* {@link copyTextureToTexture}.
		*
		* @private
		* @type {?WebGLFramebuffer}
		*/
		this._srcFramebuffer = null;
		/**
		* A scratch framebuffer used for attaching the destination texture in
		* {@link copyTextureToTexture}.
		*
		* @private
		* @type {?WebGLFramebuffer}
		*/
		this._dstFramebuffer = null;
		if (initialized === false) {
			this._init();
			initialized = true;
		}
	}
	/**
	* Inits the state of the utility.
	*
	* @private
	*/
	_init() {
		const gl = this.gl;
		wrappingToGL = {
			[RepeatWrapping]: gl.REPEAT,
			[ClampToEdgeWrapping]: gl.CLAMP_TO_EDGE,
			[MirroredRepeatWrapping]: gl.MIRRORED_REPEAT
		};
		filterToGL = {
			[NearestFilter]: gl.NEAREST,
			[NearestMipmapNearestFilter]: gl.NEAREST_MIPMAP_NEAREST,
			[NearestMipmapLinearFilter]: gl.NEAREST_MIPMAP_LINEAR,
			[LinearFilter]: gl.LINEAR,
			[LinearMipmapNearestFilter]: gl.LINEAR_MIPMAP_NEAREST,
			[LinearMipmapLinearFilter]: gl.LINEAR_MIPMAP_LINEAR
		};
		compareToGL = {
			[NeverCompare]: gl.NEVER,
			[AlwaysCompare]: gl.ALWAYS,
			[LessCompare]: gl.LESS,
			[LessEqualCompare]: gl.LEQUAL,
			[EqualCompare]: gl.EQUAL,
			[GreaterEqualCompare]: gl.GEQUAL,
			[GreaterCompare]: gl.GREATER,
			[NotEqualCompare]: gl.NOTEQUAL
		};
	}
	/**
	* Returns the native texture type for the given texture.
	*
	* @param {Texture} texture - The texture.
	* @return {GLenum} The native texture type.
	*/
	getGLTextureType(texture$2) {
		const { gl } = this;
		let glTextureType;
		if (texture$2.isCubeTexture === true) glTextureType = gl.TEXTURE_CUBE_MAP;
		else if (texture$2.isArrayTexture === true || texture$2.isDataArrayTexture === true || texture$2.isCompressedArrayTexture === true) glTextureType = gl.TEXTURE_2D_ARRAY;
		else if (texture$2.isData3DTexture === true) glTextureType = gl.TEXTURE_3D;
		else glTextureType = gl.TEXTURE_2D;
		return glTextureType;
	}
	/**
	* Returns the native texture type for the given texture.
	*
	* @param {?string} internalFormatName - The internal format name. When `null`, the internal format is derived from the subsequent parameters.
	* @param {GLenum} glFormat - The WebGL format.
	* @param {GLenum} glType - The WebGL type.
	* @param {string} colorSpace - The texture's color space.
	* @param {boolean} [forceLinearTransfer=false] - Whether to force a linear transfer or not.
	* @return {GLenum} The internal format.
	*/
	getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
		const { gl, extensions } = this;
		if (internalFormatName !== null) {
			if (gl[internalFormatName] !== void 0) return gl[internalFormatName];
			warn("WebGLBackend: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
		}
		let internalFormat = glFormat;
		if (glFormat === gl.RED) {
			if (glType === gl.FLOAT) internalFormat = gl.R32F;
			if (glType === gl.HALF_FLOAT) internalFormat = gl.R16F;
			if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8;
			if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16;
			if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
			if (glType === gl.BYTE) internalFormat = gl.R8I;
			if (glType === gl.SHORT) internalFormat = gl.R16I;
			if (glType === gl.INT) internalFormat = gl.R32I;
		}
		if (glFormat === gl.RED_INTEGER) {
			if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8UI;
			if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16UI;
			if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
			if (glType === gl.BYTE) internalFormat = gl.R8I;
			if (glType === gl.SHORT) internalFormat = gl.R16I;
			if (glType === gl.INT) internalFormat = gl.R32I;
		}
		if (glFormat === gl.RG) {
			if (glType === gl.FLOAT) internalFormat = gl.RG32F;
			if (glType === gl.HALF_FLOAT) internalFormat = gl.RG16F;
			if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8;
			if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16;
			if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
			if (glType === gl.BYTE) internalFormat = gl.RG8I;
			if (glType === gl.SHORT) internalFormat = gl.RG16I;
			if (glType === gl.INT) internalFormat = gl.RG32I;
		}
		if (glFormat === gl.RG_INTEGER) {
			if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8UI;
			if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16UI;
			if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
			if (glType === gl.BYTE) internalFormat = gl.RG8I;
			if (glType === gl.SHORT) internalFormat = gl.RG16I;
			if (glType === gl.INT) internalFormat = gl.RG32I;
		}
		if (glFormat === gl.RGB) {
			const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
			if (glType === gl.FLOAT) internalFormat = gl.RGB32F;
			if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;
			if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;
			if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;
			if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
			if (glType === gl.BYTE) internalFormat = gl.RGB8I;
			if (glType === gl.SHORT) internalFormat = gl.RGB16I;
			if (glType === gl.INT) internalFormat = gl.RGB32I;
			if (glType === gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? gl.SRGB8 : gl.RGB8;
			if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;
			if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
			if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;
			if (glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;
			if (glType === gl.UNSIGNED_INT_10F_11F_11F_REV) internalFormat = gl.R11F_G11F_B10F;
		}
		if (glFormat === gl.RGB_INTEGER) {
			if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8UI;
			if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16UI;
			if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
			if (glType === gl.BYTE) internalFormat = gl.RGB8I;
			if (glType === gl.SHORT) internalFormat = gl.RGB16I;
			if (glType === gl.INT) internalFormat = gl.RGB32I;
		}
		if (glFormat === gl.RGBA) {
			const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
			if (glType === gl.FLOAT) internalFormat = gl.RGBA32F;
			if (glType === gl.HALF_FLOAT) internalFormat = gl.RGBA16F;
			if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8;
			if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16;
			if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
			if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
			if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
			if (glType === gl.INT) internalFormat = gl.RGBA32I;
			if (glType === gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? gl.SRGB8_ALPHA8 : gl.RGBA8;
			if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;
			if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
		}
		if (glFormat === gl.RGBA_INTEGER) {
			if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8UI;
			if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16UI;
			if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
			if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
			if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
			if (glType === gl.INT) internalFormat = gl.RGBA32I;
		}
		if (glFormat === gl.DEPTH_COMPONENT) {
			if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.DEPTH_COMPONENT16;
			if (glType === gl.UNSIGNED_INT) internalFormat = gl.DEPTH_COMPONENT24;
			if (glType === gl.FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;
		}
		if (glFormat === gl.DEPTH_STENCIL) {
			if (glType === gl.UNSIGNED_INT_24_8) internalFormat = gl.DEPTH24_STENCIL8;
		}
		if (internalFormat === gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) extensions.get("EXT_color_buffer_float");
		return internalFormat;
	}
	/**
	* Sets the texture parameters for the given texture.
	*
	* @param {GLenum} textureType - The texture type.
	* @param {Texture} texture - The texture.
	*/
	setTextureParameters(textureType, texture$2) {
		const { gl, extensions, backend } = this;
		const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
		const texturePrimaries = texture$2.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture$2.colorSpace);
		const unpackConversion = texture$2.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? gl.NONE : gl.BROWSER_DEFAULT_WEBGL;
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture$2.flipY);
		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture$2.premultiplyAlpha);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture$2.unpackAlignment);
		gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
		gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrappingToGL[texture$2.wrapS]);
		gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrappingToGL[texture$2.wrapT]);
		if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {
			if (!texture$2.isArrayTexture) gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, wrappingToGL[texture$2.wrapR]);
		}
		gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, filterToGL[texture$2.magFilter]);
		const hasMipmaps = texture$2.mipmaps !== void 0 && texture$2.mipmaps.length > 0;
		const minFilter = texture$2.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture$2.minFilter;
		gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[minFilter]);
		if (texture$2.compareFunction) {
			gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
			gl.texParameteri(textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[texture$2.compareFunction]);
		}
		if (extensions.has("EXT_texture_filter_anisotropic") === true) {
			if (texture$2.magFilter === NearestFilter) return;
			if (texture$2.minFilter !== NearestMipmapLinearFilter && texture$2.minFilter !== LinearMipmapLinearFilter) return;
			if (texture$2.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
			if (texture$2.anisotropy > 1) {
				const extension = extensions.get("EXT_texture_filter_anisotropic");
				gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture$2.anisotropy, backend.getMaxAnisotropy()));
			}
		}
	}
	/**
	* Creates a default texture for the given texture that can be used
	* as a placeholder until the actual texture is ready for usage.
	*
	* @param {Texture} texture - The texture to create a default texture for.
	*/
	createDefaultTexture(texture$2) {
		const { gl, backend, defaultTextures } = this;
		const glTextureType = this.getGLTextureType(texture$2);
		let textureGPU = defaultTextures[glTextureType];
		if (textureGPU === void 0) {
			textureGPU = gl.createTexture();
			backend.state.bindTexture(glTextureType, textureGPU);
			gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			defaultTextures[glTextureType] = textureGPU;
		}
		backend.set(texture$2, {
			textureGPU,
			glTextureType
		});
	}
	/**
	* Defines a texture on the GPU for the given texture object.
	*
	* @param {Texture} texture - The texture.
	* @param {Object} [options={}] - Optional configuration parameter.
	* @return {undefined}
	*/
	createTexture(texture$2, options) {
		const { gl, backend } = this;
		const { levels, width, height, depth: depth$2 } = options;
		const glFormat = backend.utils.convert(texture$2.format, texture$2.colorSpace);
		const glType = backend.utils.convert(texture$2.type);
		const glInternalFormat = this.getInternalFormat(texture$2.internalFormat, glFormat, glType, texture$2.colorSpace, texture$2.isVideoTexture);
		const textureGPU = gl.createTexture();
		const glTextureType = this.getGLTextureType(texture$2);
		backend.state.bindTexture(glTextureType, textureGPU);
		this.setTextureParameters(glTextureType, texture$2);
		if (texture$2.isArrayTexture || texture$2.isDataArrayTexture || texture$2.isCompressedArrayTexture) gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth$2);
		else if (texture$2.isData3DTexture) gl.texStorage3D(gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth$2);
		else if (!texture$2.isVideoTexture) gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);
		backend.set(texture$2, {
			textureGPU,
			glTextureType,
			glFormat,
			glType,
			glInternalFormat
		});
	}
	/**
	* Uploads texture buffer data to the GPU memory.
	*
	* @param {WebGLBuffer} buffer - The buffer data.
	* @param {Texture} texture - The texture,
	*/
	copyBufferToTexture(buffer$2, texture$2) {
		const { gl, backend } = this;
		const { textureGPU, glTextureType, glFormat, glType } = backend.get(texture$2);
		const { width, height } = texture$2.source.data;
		gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer$2);
		backend.state.bindTexture(glTextureType, textureGPU);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
		gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, 0);
		gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
		backend.state.unbindTexture();
	}
	/**
	* Uploads the updated texture data to the GPU.
	*
	* @param {Texture} texture - The texture.
	* @param {Object} [options={}] - Optional configuration parameter.
	*/
	updateTexture(texture$2, options) {
		const { gl } = this;
		const { width, height } = options;
		const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get(texture$2);
		if (texture$2.isRenderTargetTexture || textureGPU === void 0) return;
		this.backend.state.bindTexture(glTextureType, textureGPU);
		this.setTextureParameters(glTextureType, texture$2);
		if (texture$2.isCompressedTexture) {
			const mipmaps = texture$2.mipmaps;
			const image = options.image;
			for (let i = 0; i < mipmaps.length; i++) {
				const mipmap = mipmaps[i];
				if (texture$2.isCompressedArrayTexture) if (texture$2.format !== gl.RGBA) if (glFormat !== null) gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
				else warn("WebGLBackend: Attempt to load unsupported compressed texture format in .uploadTexture()");
				else gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
				else if (glFormat !== null) gl.compressedTexSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
				else warn("WebGLBackend: Unsupported compressed texture format");
			}
		} else if (texture$2.isCubeTexture) {
			const images = options.images;
			const mipmaps = texture$2.mipmaps;
			for (let i = 0; i < 6; i++) {
				const image = getImage(images[i]);
				gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image);
				for (let j = 0; j < mipmaps.length; j++) {
					const mipmap = mipmaps[j];
					const image$1 = getImage(mipmap.images[i]);
					gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, image$1.width, image$1.height, glFormat, glType, image$1);
				}
			}
		} else if (texture$2.isDataArrayTexture || texture$2.isArrayTexture) {
			const image = options.image;
			if (texture$2.layerUpdates.size > 0) {
				const layerByteLength = getByteLength(image.width, image.height, texture$2.format, texture$2.type);
				for (const layerIndex of texture$2.layerUpdates) {
					const layerData = image.data.subarray(layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT, (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT);
					gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);
				}
				texture$2.clearLayerUpdates();
			} else gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
		} else if (texture$2.isData3DTexture) {
			const image = options.image;
			gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
		} else if (texture$2.isVideoTexture) {
			texture$2.update();
			gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, options.image);
		} else {
			const mipmaps = texture$2.mipmaps;
			if (mipmaps.length > 0) for (let i = 0, il = mipmaps.length; i < il; i++) {
				const mipmap = mipmaps[i];
				const image = getImage(mipmap);
				gl.texSubImage2D(glTextureType, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, image);
			}
			else {
				const image = getImage(options.image);
				gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, image);
			}
		}
	}
	/**
	* Generates mipmaps for the given texture.
	*
	* @param {Texture} texture - The texture.
	*/
	generateMipmaps(texture$2) {
		const { gl, backend } = this;
		const { textureGPU, glTextureType } = backend.get(texture$2);
		backend.state.bindTexture(glTextureType, textureGPU);
		gl.generateMipmap(glTextureType);
	}
	/**
	* Deallocates the render buffers of the given render target.
	*
	* @param {RenderTarget} renderTarget - The render target.
	*/
	deallocateRenderBuffers(renderTarget) {
		const { gl, backend } = this;
		if (renderTarget) {
			const renderContextData = backend.get(renderTarget);
			renderContextData.renderBufferStorageSetup = void 0;
			if (renderContextData.framebuffers) {
				for (const cacheKey in renderContextData.framebuffers) gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);
				delete renderContextData.framebuffers;
			}
			if (renderContextData.depthRenderbuffer) {
				gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);
				delete renderContextData.depthRenderbuffer;
			}
			if (renderContextData.stencilRenderbuffer) {
				gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);
				delete renderContextData.stencilRenderbuffer;
			}
			if (renderContextData.msaaFrameBuffer) {
				gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);
				delete renderContextData.msaaFrameBuffer;
			}
			if (renderContextData.msaaRenderbuffers) {
				for (let i = 0; i < renderContextData.msaaRenderbuffers.length; i++) gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i]);
				delete renderContextData.msaaRenderbuffers;
			}
		}
	}
	/**
	* Destroys the GPU data for the given texture object.
	*
	* @param {Texture} texture - The texture.
	* @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
	*/
	destroyTexture(texture$2, isDefaultTexture = false) {
		const { gl, backend } = this;
		const { textureGPU, renderTarget } = backend.get(texture$2);
		this.deallocateRenderBuffers(renderTarget);
		if (isDefaultTexture === false) gl.deleteTexture(textureGPU);
		backend.delete(texture$2);
	}
	/**
	* Copies data of the given source texture to the given destination texture.
	*
	* @param {Texture} srcTexture - The source texture.
	* @param {Texture} dstTexture - The destination texture.
	* @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
	* @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
	* @param {number} [srcLevel=0] - The source mip level to copy from.
	* @param {number} [dstLevel=0] - The destination mip level to copy to.
	*/
	copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
		const { gl, backend } = this;
		const { state } = this.backend;
		const { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get(dstTexture);
		state.bindTexture(glTextureType, dstTextureGPU);
		let width, height, depth$2, minX, minY, minZ;
		let dstX, dstY, dstZ;
		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[dstLevel] : srcTexture.image;
		if (srcRegion !== null) {
			width = srcRegion.max.x - srcRegion.min.x;
			height = srcRegion.max.y - srcRegion.min.y;
			depth$2 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
			minX = srcRegion.min.x;
			minY = srcRegion.min.y;
			minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
		} else {
			const levelScale = Math.pow(2, -srcLevel);
			width = Math.floor(image.width * levelScale);
			height = Math.floor(image.height * levelScale);
			if (srcTexture.isDataArrayTexture || srcTexture.isArrayTexture) depth$2 = image.depth;
			else if (srcTexture.isData3DTexture) depth$2 = Math.floor(image.depth * levelScale);
			else depth$2 = 1;
			minX = 0;
			minY = 0;
			minZ = 0;
		}
		if (dstPosition !== null) {
			dstX = dstPosition.x;
			dstY = dstPosition.y;
			dstZ = dstPosition.z;
		} else {
			dstX = 0;
			dstY = 0;
			dstZ = 0;
		}
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
		const currentUnpackRowLen = gl.getParameter(gl.UNPACK_ROW_LENGTH);
		const currentUnpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);
		const currentUnpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);
		const currentUnpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);
		const currentUnpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);
		gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);
		gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);
		gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);
		gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);
		gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, minZ);
		const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture || dstTexture.isArrayTexture;
		const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture || dstTexture.isArrayTexture;
		if (srcTexture.isDepthTexture) {
			const srcTextureData = backend.get(srcTexture);
			const dstTextureData = backend.get(dstTexture);
			const srcRenderContextData = backend.get(srcTextureData.renderTarget);
			const dstRenderContextData = backend.get(dstTextureData.renderTarget);
			const srcFramebuffer = srcRenderContextData.framebuffers[srcTextureData.cacheKey];
			const dstFramebuffer = dstRenderContextData.framebuffers[dstTextureData.cacheKey];
			state.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);
			state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);
			for (let i = 0; i < depth$2; i++) {
				if (isSrc3D) {
					gl.framebufferTextureLayer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, srcTextureData.textureGPU, srcLevel, minZ + i);
					gl.framebufferTextureLayer(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, dstTextureGPU, dstLevel, dstZ + i);
				}
				gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);
			}
			state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
			state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
		} else if (srcLevel !== 0 || srcTexture.isRenderTargetTexture || backend.has(srcTexture)) {
			const srcTextureData = backend.get(srcTexture);
			if (this._srcFramebuffer === null) this._srcFramebuffer = gl.createFramebuffer();
			if (this._dstFramebuffer === null) this._dstFramebuffer = gl.createFramebuffer();
			state.bindFramebuffer(gl.READ_FRAMEBUFFER, this._srcFramebuffer);
			state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._dstFramebuffer);
			for (let i = 0; i < depth$2; i++) {
				if (isSrc3D) gl.framebufferTextureLayer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, srcTextureData.textureGPU, srcLevel, minZ + i);
				else gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, srcTextureData.textureGPU, srcLevel);
				if (isDst3D) gl.framebufferTextureLayer(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, dstTextureGPU, dstLevel, dstZ + i);
				else gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dstTextureGPU, dstLevel);
				if (srcLevel !== 0) gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
				else if (isDst3D) gl.copyTexSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ + i, minX, minY, width, height);
				else gl.copyTexSubImage2D(glTextureType, dstLevel, dstX, dstY, minX, minY, width, height);
			}
			state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
			state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
		} else if (isDst3D) if (srcTexture.isDataTexture || srcTexture.isData3DTexture) gl.texSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth$2, glFormat, glType, image.data);
		else if (dstTexture.isCompressedArrayTexture) gl.compressedTexSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth$2, glFormat, image.data);
		else gl.texSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth$2, glFormat, glType, image);
		else if (srcTexture.isDataTexture) gl.texSubImage2D(gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data);
		else if (srcTexture.isCompressedTexture) gl.compressedTexSubImage2D(gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data);
		else gl.texSubImage2D(gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image);
		gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
		gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
		gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
		gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
		gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
		if (dstLevel === 0 && dstTexture.generateMipmaps) gl.generateMipmap(glTextureType);
		state.unbindTexture();
	}
	/**
	* Copies the current bound framebuffer to the given texture.
	*
	* @param {Texture} texture - The destination texture.
	* @param {RenderContext} renderContext - The render context.
	* @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
	*/
	copyFramebufferToTexture(texture$2, renderContext, rectangle) {
		const { gl } = this;
		const { state } = this.backend;
		const { textureGPU } = this.backend.get(texture$2);
		const { x, y, z: width, w: height } = rectangle;
		const requireDrawFrameBuffer = texture$2.isDepthTexture === true || renderContext.renderTarget && renderContext.renderTarget.samples > 0;
		const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.getDrawingBufferSize().y;
		if (requireDrawFrameBuffer) {
			const partial = x !== 0 || y !== 0;
			let mask;
			let attachment;
			if (texture$2.isDepthTexture === true) {
				mask = gl.DEPTH_BUFFER_BIT;
				attachment = gl.DEPTH_ATTACHMENT;
				if (renderContext.stencil) mask |= gl.STENCIL_BUFFER_BIT;
			} else {
				mask = gl.COLOR_BUFFER_BIT;
				attachment = gl.COLOR_ATTACHMENT0;
			}
			if (partial) {
				const renderTargetContextData = this.backend.get(renderContext.renderTarget);
				const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
				state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
				state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
				const flippedY = srcHeight - y - height;
				gl.blitFramebuffer(x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST);
				state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
				state.bindTexture(gl.TEXTURE_2D, textureGPU);
				gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height);
				state.unbindTexture();
			} else {
				const fb = gl.createFramebuffer();
				state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
				gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0);
				gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
				gl.deleteFramebuffer(fb);
			}
		} else {
			state.bindTexture(gl.TEXTURE_2D, textureGPU);
			gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height);
			state.unbindTexture();
		}
		if (texture$2.generateMipmaps) this.generateMipmaps(texture$2);
		this.backend._setFramebuffer(renderContext);
	}
	/**
	* SetupS storage for internal depth/stencil buffers and bind to correct framebuffer.
	*
	* @param {WebGLRenderbuffer} renderbuffer - The render buffer.
	* @param {RenderContext} renderContext - The render context.
	* @param {number} samples - The MSAA sample count.
	* @param {boolean} [useMultisampledRTT=false] - Whether to use WEBGL_multisampled_render_to_texture or not.
	*/
	setupRenderBufferStorage(renderbuffer, renderContext, samples, useMultisampledRTT = false) {
		const { gl } = this;
		const renderTarget = renderContext.renderTarget;
		const { depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;
		gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
		if (depthBuffer && !stencilBuffer) {
			let glInternalFormat = gl.DEPTH_COMPONENT24;
			if (useMultisampledRTT === true) this.extensions.get("WEBGL_multisampled_render_to_texture").renderbufferStorageMultisampleEXT(gl.RENDERBUFFER, renderTarget.samples, glInternalFormat, width, height);
			else if (samples > 0) {
				if (depthTexture && depthTexture.isDepthTexture) {
					if (depthTexture.type === gl.FLOAT) glInternalFormat = gl.DEPTH_COMPONENT32F;
				}
				gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, glInternalFormat, width, height);
			} else gl.renderbufferStorage(gl.RENDERBUFFER, glInternalFormat, width, height);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
		} else if (depthBuffer && stencilBuffer) {
			if (samples > 0) gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height);
			else gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
		}
		gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	}
	/**
	* Returns texture data as a typed array.
	*
	* @async
	* @param {Texture} texture - The texture to copy.
	* @param {number} x - The x coordinate of the copy origin.
	* @param {number} y - The y coordinate of the copy origin.
	* @param {number} width - The width of the copy.
	* @param {number} height - The height of the copy.
	* @param {number} faceIndex - The face index.
	* @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
	*/
	async copyTextureToBuffer(texture$2, x, y, width, height, faceIndex) {
		const { backend, gl } = this;
		const { textureGPU, glFormat, glType } = this.backend.get(texture$2);
		const fb = gl.createFramebuffer();
		gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
		const target = texture$2.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;
		gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0);
		const typedArrayType = this._getTypedArrayType(glType);
		const bytesPerTexel = this._getBytesPerTexel(glType, glFormat);
		const byteLength = width * height * bytesPerTexel;
		const buffer$2 = gl.createBuffer();
		gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer$2);
		gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);
		gl.readPixels(x, y, width, height, glFormat, glType, 0);
		gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
		await backend.utils._clientWaitAsync();
		const dstBuffer = new typedArrayType(byteLength / typedArrayType.BYTES_PER_ELEMENT);
		gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer$2);
		gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);
		gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
		gl.deleteFramebuffer(fb);
		return dstBuffer;
	}
	/**
	* Returns the corresponding typed array type for the given WebGL data type.
	*
	* @private
	* @param {GLenum} glType - The WebGL data type.
	* @return {TypedArray.constructor} The typed array type.
	*/
	_getTypedArrayType(glType) {
		const { gl } = this;
		if (glType === gl.UNSIGNED_BYTE) return Uint8Array;
		if (glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;
		if (glType === gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;
		if (glType === gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;
		if (glType === gl.UNSIGNED_SHORT) return Uint16Array;
		if (glType === gl.UNSIGNED_INT) return Uint32Array;
		if (glType === gl.HALF_FLOAT) return Uint16Array;
		if (glType === gl.FLOAT) return Float32Array;
		throw new Error(`Unsupported WebGL type: ${glType}`);
	}
	/**
	* Returns the bytes-per-texel value for the given WebGL data type and texture format.
	*
	* @private
	* @param {GLenum} glType - The WebGL data type.
	* @param {GLenum} glFormat - The WebGL texture format.
	* @return {number} The bytes-per-texel.
	*/
	_getBytesPerTexel(glType, glFormat) {
		const { gl } = this;
		let bytesPerComponent = 0;
		if (glType === gl.UNSIGNED_BYTE) bytesPerComponent = 1;
		if (glType === gl.UNSIGNED_SHORT_4_4_4_4 || glType === gl.UNSIGNED_SHORT_5_5_5_1 || glType === gl.UNSIGNED_SHORT_5_6_5 || glType === gl.UNSIGNED_SHORT || glType === gl.HALF_FLOAT) bytesPerComponent = 2;
		if (glType === gl.UNSIGNED_INT || glType === gl.FLOAT) bytesPerComponent = 4;
		if (glFormat === gl.RGBA) return bytesPerComponent * 4;
		if (glFormat === gl.RGB) return bytesPerComponent * 3;
		if (glFormat === gl.ALPHA) return bytesPerComponent;
	}
	/**
	* Frees the internal resources.
	*/
	dispose() {
		const { gl } = this;
		if (this._srcFramebuffer !== null) gl.deleteFramebuffer(this._srcFramebuffer);
		if (this._dstFramebuffer !== null) gl.deleteFramebuffer(this._dstFramebuffer);
	}
};
function getImage(source) {
	if (source.isDataTexture) return source.image.data;
	else if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && source instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && source instanceof ImageBitmap || typeof OffscreenCanvas !== "undefined" && source instanceof OffscreenCanvas) return source;
	return source.data;
}
/**
* A WebGL 2 backend utility module for managing extensions.
*
* @private
*/
var WebGLExtensions$1 = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGLBackend} backend - The WebGL 2 backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGL 2 backend.
		*
		* @type {WebGLBackend}
		*/
		this.backend = backend;
		/**
		* A reference to the rendering context.
		*
		* @type {WebGL2RenderingContext}
		*/
		this.gl = this.backend.gl;
		/**
		* A list with all the supported WebGL extensions.
		*
		* @type {Array<string>}
		*/
		this.availableExtensions = this.gl.getSupportedExtensions();
		/**
		* A dictionary with requested WebGL extensions.
		* The key is the name of the extension, the value
		* the requested extension object.
		*
		* @type {Object<string,Object>}
		*/
		this.extensions = {};
	}
	/**
	* Returns the extension object for the given extension name.
	*
	* @param {string} name - The extension name.
	* @return {Object} The extension object.
	*/
	get(name) {
		let extension = this.extensions[name];
		if (extension === void 0) {
			extension = this.gl.getExtension(name);
			this.extensions[name] = extension;
		}
		return extension;
	}
	/**
	* Returns `true` if the requested extension is available.
	*
	* @param {string} name - The extension name.
	* @return {boolean} Whether the given extension is available or not.
	*/
	has(name) {
		return this.availableExtensions.includes(name);
	}
};
/**
* A WebGL 2 backend utility module for managing the device's capabilities.
*
* @private
*/
var WebGLCapabilities$1 = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGLBackend} backend - The WebGL 2 backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGL 2 backend.
		*
		* @type {WebGLBackend}
		*/
		this.backend = backend;
		/**
		* This value holds the cached max anisotropy value.
		*
		* @type {?number}
		* @default null
		*/
		this.maxAnisotropy = null;
	}
	/**
	* Returns the maximum anisotropy texture filtering value. This value
	* depends on the device and is reported by the `EXT_texture_filter_anisotropic`
	* WebGL extension.
	*
	* @return {number} The maximum anisotropy texture filtering value.
	*/
	getMaxAnisotropy() {
		if (this.maxAnisotropy !== null) return this.maxAnisotropy;
		const gl = this.backend.gl;
		const extensions = this.backend.extensions;
		if (extensions.has("EXT_texture_filter_anisotropic") === true) {
			const extension = extensions.get("EXT_texture_filter_anisotropic");
			this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
		} else this.maxAnisotropy = 0;
		return this.maxAnisotropy;
	}
};
var GLFeatureName = {
	"WEBGL_multi_draw": "WEBGL_multi_draw",
	"WEBGL_compressed_texture_astc": "texture-compression-astc",
	"WEBGL_compressed_texture_etc": "texture-compression-etc2",
	"WEBGL_compressed_texture_etc1": "texture-compression-etc1",
	"WEBGL_compressed_texture_pvrtc": "texture-compression-pvrtc",
	"WEBGL_compressed_texture_s3tc": "texture-compression-s3tc",
	"EXT_texture_compression_bptc": "texture-compression-bc",
	"EXT_disjoint_timer_query_webgl2": "timestamp-query",
	"OVR_multiview2": "OVR_multiview2"
};
var WebGLBufferRenderer$1 = class {
	constructor(backend) {
		this.gl = backend.gl;
		this.extensions = backend.extensions;
		this.info = backend.renderer.info;
		this.mode = null;
		this.index = 0;
		this.type = null;
		this.object = null;
	}
	render(start, count) {
		const { gl, mode, object, type: type$1, info, index } = this;
		if (index !== 0) gl.drawElements(mode, count, type$1, start);
		else gl.drawArrays(mode, start, count);
		info.update(object, count, 1);
	}
	renderInstances(start, count, primcount) {
		const { gl, mode, type: type$1, index, object, info } = this;
		if (primcount === 0) return;
		if (index !== 0) gl.drawElementsInstanced(mode, count, type$1, start, primcount);
		else gl.drawArraysInstanced(mode, start, count, primcount);
		info.update(object, count, primcount);
	}
	renderMultiDraw(starts, counts, drawCount) {
		const { extensions, mode, object, info } = this;
		if (drawCount === 0) return;
		const extension = extensions.get("WEBGL_multi_draw");
		if (extension === null) for (let i = 0; i < drawCount; i++) this.render(starts[i], counts[i]);
		else {
			if (this.index !== 0) extension.multiDrawElementsWEBGL(mode, counts, 0, this.type, starts, 0, drawCount);
			else extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
			let elementCount = 0;
			for (let i = 0; i < drawCount; i++) elementCount += counts[i];
			info.update(object, elementCount, 1);
		}
	}
	renderMultiDrawInstances(starts, counts, drawCount, primcount) {
		const { extensions, mode, object, info } = this;
		if (drawCount === 0) return;
		const extension = extensions.get("WEBGL_multi_draw");
		if (extension === null) for (let i = 0; i < drawCount; i++) this.renderInstances(starts[i], counts[i], primcount[i]);
		else {
			if (this.index !== 0) extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount);
			else extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
			let elementCount = 0;
			for (let i = 0; i < drawCount; i++) elementCount += counts[i] * primcount[i];
			info.update(object, elementCount, 1);
		}
	}
};
/**
* Abstract base class of a timestamp query pool.
*
* @abstract
*/
var TimestampQueryPool = class {
	/**
	* Creates a new timestamp query pool.
	*
	* @param {number} [maxQueries=256] - Maximum number of queries this pool can hold.
	*/
	constructor(maxQueries = 256) {
		/**
		* Whether to track timestamps or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.trackTimestamp = true;
		/**
		* Maximum number of queries this pool can hold.
		*
		* @type {number}
		* @default 256
		*/
		this.maxQueries = maxQueries;
		/**
		* How many queries allocated so far.
		*
		* @type {number}
		* @default 0
		*/
		this.currentQueryIndex = 0;
		/**
		* Tracks offsets for different contexts.
		*
		* @type {Map<string, number>}
		*/
		this.queryOffsets = /* @__PURE__ */ new Map();
		/**
		* Whether the pool has been disposed or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.isDisposed = false;
		/**
		* TODO
		*
		* @type {number}
		* @default 0
		*/
		this.lastValue = 0;
		/**
		* Stores all timestamp frames.
		*
		* @type {Array<number>}
		*/
		this.frames = [];
		/**
		* TODO
		*
		* @type {boolean}
		* @default false
		*/
		this.pendingResolve = false;
		/**
		* Stores the latest timestamp for each render context.
		*
		* @type {Map<string, number>}
		*/
		this.timestamps = /* @__PURE__ */ new Map();
	}
	/**
	* Returns all timestamp frames.
	*
	* @return {Array<number>} The timestamp frames.
	*/
	getTimestampFrames() {
		return this.frames;
	}
	/**
	* Returns the timestamp for a given render context.
	*
	* @param {string} uid - A unique identifier for the render context.
	* @return {?number} The timestamp, or undefined if not available.
	*/
	getTimestamp(uid) {
		let timestamp = this.timestamps.get(uid);
		if (timestamp === void 0) {
			warn(`TimestampQueryPool: No timestamp available for uid ${uid}.`);
			timestamp = 0;
		}
		return timestamp;
	}
	/**
	* Returns whether a timestamp is available for a given render context.
	*
	* @param {string} uid - A unique identifier for the render context.
	* @return {boolean} True if a timestamp is available, false otherwise.
	*/
	hasTimestamp(uid) {
		return this.timestamps.has(uid);
	}
	/**
	* Allocate queries for a specific uid.
	*
	* @abstract
	* @param {string} uid - A unique identifier for the render context.
	* @param {number} frameId - The current frame identifier.
	* @returns {?number}
	*/
	allocateQueriesForContext() {}
	/**
	* Resolve all timestamps and return data (or process them).
	*
	* @abstract
	* @async
	* @returns {Promise<number>|number} The resolved timestamp value.
	*/
	async resolveQueriesAsync() {}
	/**
	* Dispose of the query pool.
	*
	* @abstract
	*/
	dispose() {}
};
/**
* Manages a pool of WebGL timestamp queries for performance measurement.
* Handles creation, execution, and resolution of timer queries using WebGL extensions.
*
* @augments TimestampQueryPool
*/
var WebGLTimestampQueryPool = class extends TimestampQueryPool {
	/**
	* Creates a new WebGL timestamp query pool.
	*
	* @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context.
	* @param {string} type - The type identifier for this query pool.
	* @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
	*/
	constructor(gl, type$1, maxQueries = 2048) {
		super(maxQueries);
		this.gl = gl;
		this.type = type$1;
		this.ext = gl.getExtension("EXT_disjoint_timer_query_webgl2") || gl.getExtension("EXT_disjoint_timer_query");
		if (!this.ext) {
			warn("EXT_disjoint_timer_query not supported; timestamps will be disabled.");
			this.trackTimestamp = false;
			return;
		}
		this.queries = [];
		for (let i = 0; i < this.maxQueries; i++) this.queries.push(gl.createQuery());
		this.activeQuery = null;
		this.queryStates = /* @__PURE__ */ new Map();
	}
	/**
	* Allocates a pair of queries for a given render context.
	*
	* @param {string} uid - A unique identifier for the render context.
	* @returns {?number} The base offset for the allocated queries, or null if allocation failed.
	*/
	allocateQueriesForContext(uid) {
		if (!this.trackTimestamp) return null;
		if (this.currentQueryIndex + 2 > this.maxQueries) {
			warnOnce(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`);
			return null;
		}
		const baseOffset = this.currentQueryIndex;
		this.currentQueryIndex += 2;
		this.queryStates.set(baseOffset, "inactive");
		this.queryOffsets.set(uid, baseOffset);
		return baseOffset;
	}
	/**
	* Begins a timestamp query for the specified render context.
	*
	* @param {string} uid - A unique identifier for the render context.
	*/
	beginQuery(uid) {
		if (!this.trackTimestamp || this.isDisposed) return;
		const baseOffset = this.queryOffsets.get(uid);
		if (baseOffset == null) return;
		if (this.activeQuery !== null) return;
		const query = this.queries[baseOffset];
		if (!query) return;
		try {
			if (this.queryStates.get(baseOffset) === "inactive") {
				this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);
				this.activeQuery = baseOffset;
				this.queryStates.set(baseOffset, "started");
			}
		} catch (error$1) {
			error$1("Error in beginQuery:", error$1);
			this.activeQuery = null;
			this.queryStates.set(baseOffset, "inactive");
		}
	}
	/**
	* Ends the active timestamp query for the specified render context.
	*
	* @param {string} uid - A unique identifier for the render context.
	*/
	endQuery(uid) {
		if (!this.trackTimestamp || this.isDisposed) return;
		const baseOffset = this.queryOffsets.get(uid);
		if (baseOffset == null) return;
		if (this.activeQuery !== baseOffset) return;
		try {
			this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
			this.queryStates.set(baseOffset, "ended");
			this.activeQuery = null;
		} catch (error$1) {
			error$1("Error in endQuery:", error$1);
			this.queryStates.set(baseOffset, "inactive");
			this.activeQuery = null;
		}
	}
	/**
	* Asynchronously resolves all completed queries and returns the total duration.
	*
	* @async
	* @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
	*/
	async resolveQueriesAsync() {
		if (!this.trackTimestamp || this.pendingResolve) return this.lastValue;
		this.pendingResolve = true;
		try {
			const resolvePromises = /* @__PURE__ */ new Map();
			for (const [uid, baseOffset] of this.queryOffsets) if (this.queryStates.get(baseOffset) === "ended") {
				const query = this.queries[baseOffset];
				resolvePromises.set(uid, this.resolveQuery(query));
			}
			if (resolvePromises.size === 0) return this.lastValue;
			const framesDuration = {};
			const frames = [];
			for (const [uid, promise] of resolvePromises) {
				const match = uid.match(/^(.*):f(\d+)$/);
				const frame = parseInt(match[2]);
				if (frames.includes(frame) === false) frames.push(frame);
				if (framesDuration[frame] === void 0) framesDuration[frame] = 0;
				const duration = await promise;
				this.timestamps.set(uid, duration);
				framesDuration[frame] += duration;
			}
			const totalDuration = framesDuration[frames[frames.length - 1]];
			this.lastValue = totalDuration;
			this.frames = frames;
			this.currentQueryIndex = 0;
			this.queryOffsets.clear();
			this.queryStates.clear();
			this.activeQuery = null;
			return totalDuration;
		} catch (error$1) {
			error$1("Error resolving queries:", error$1);
			return this.lastValue;
		} finally {
			this.pendingResolve = false;
		}
	}
	/**
	* Resolves a single query, checking for completion and disjoint operation.
	*
	* @async
	* @param {WebGLQuery} query - The query object to resolve.
	* @returns {Promise<number>} The elapsed time in milliseconds.
	*/
	async resolveQuery(query) {
		return new Promise((resolve) => {
			if (this.isDisposed) {
				resolve(this.lastValue);
				return;
			}
			let timeoutId;
			let isResolved = false;
			const cleanup = () => {
				if (timeoutId) {
					clearTimeout(timeoutId);
					timeoutId = null;
				}
			};
			const finalizeResolution = (value) => {
				if (!isResolved) {
					isResolved = true;
					cleanup();
					resolve(value);
				}
			};
			const checkQuery = () => {
				if (this.isDisposed) {
					finalizeResolution(this.lastValue);
					return;
				}
				try {
					if (this.gl.getParameter(this.ext.GPU_DISJOINT_EXT)) {
						finalizeResolution(this.lastValue);
						return;
					}
					if (!this.gl.getQueryParameter(query, this.gl.QUERY_RESULT_AVAILABLE)) {
						timeoutId = setTimeout(checkQuery, 1);
						return;
					}
					const elapsed = this.gl.getQueryParameter(query, this.gl.QUERY_RESULT);
					resolve(Number(elapsed) / 1e6);
				} catch (error$1) {
					error$1("Error checking query:", error$1);
					resolve(this.lastValue);
				}
			};
			checkQuery();
		});
	}
	/**
	* Releases all resources held by this query pool.
	* This includes deleting all query objects and clearing internal state.
	*/
	dispose() {
		if (this.isDisposed) return;
		this.isDisposed = true;
		if (!this.trackTimestamp) return;
		for (const query of this.queries) this.gl.deleteQuery(query);
		this.queries = [];
		this.queryStates.clear();
		this.queryOffsets.clear();
		this.lastValue = 0;
		this.activeQuery = null;
	}
};
/**
* A backend implementation targeting WebGL 2.
*
* @private
* @augments Backend
*/
var WebGLBackend = class extends Backend {
	/**
	* WebGLBackend options.
	*
	* @typedef {Object} WebGLBackend~Options
	* @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
	* @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
	* @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
	* @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
	* @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
	* @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
	* @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
	* @property {WebGL2RenderingContext} [context=undefined] - A WebGL 2 rendering context.
	*/
	/**
	* Constructs a new WebGPU backend.
	*
	* @param {WebGLBackend~Options} [parameters] - The configuration parameter.
	*/
	constructor(parameters = {}) {
		super(parameters);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isWebGLBackend = true;
		/**
		* A reference to a backend module holding shader attribute-related
		* utility functions.
		*
		* @type {?WebGLAttributeUtils}
		* @default null
		*/
		this.attributeUtils = null;
		/**
		* A reference to a backend module holding extension-related
		* utility functions.
		*
		* @type {?WebGLExtensions}
		* @default null
		*/
		this.extensions = null;
		/**
		* A reference to a backend module holding capability-related
		* utility functions.
		*
		* @type {?WebGLCapabilities}
		* @default null
		*/
		this.capabilities = null;
		/**
		* A reference to a backend module holding texture-related
		* utility functions.
		*
		* @type {?WebGLTextureUtils}
		* @default null
		*/
		this.textureUtils = null;
		/**
		* A reference to a backend module holding renderer-related
		* utility functions.
		*
		* @type {?WebGLBufferRenderer}
		* @default null
		*/
		this.bufferRenderer = null;
		/**
		* A reference to the rendering context.
		*
		* @type {?WebGL2RenderingContext}
		* @default null
		*/
		this.gl = null;
		/**
		* A reference to a backend module holding state-related
		* utility functions.
		*
		* @type {?WebGLState}
		* @default null
		*/
		this.state = null;
		/**
		* A reference to a backend module holding common
		* utility functions.
		*
		* @type {?WebGLUtils}
		* @default null
		*/
		this.utils = null;
		/**
		* Dictionary for caching VAOs.
		*
		* @type {Object<string,WebGLVertexArrayObject>}
		*/
		this.vaoCache = {};
		/**
		* Dictionary for caching transform feedback objects.
		*
		* @type {Object<string,WebGLTransformFeedback>}
		*/
		this.transformFeedbackCache = {};
		/**
		* Controls if `gl.RASTERIZER_DISCARD` should be enabled or not.
		* Only relevant when using compute shaders.
		*
		* @type {boolean}
		* @default false
		*/
		this.discard = false;
		/**
		* A reference to the `EXT_disjoint_timer_query_webgl2` extension. `null` if the
		* device does not support the extension.
		*
		* @type {?EXTDisjointTimerQueryWebGL2}
		* @default null
		*/
		this.disjoint = null;
		/**
		* A reference to the `KHR_parallel_shader_compile` extension. `null` if the
		* device does not support the extension.
		*
		* @type {?KHRParallelShaderCompile}
		* @default null
		*/
		this.parallel = null;
		/**
		* A reference to the current render context.
		*
		* @private
		* @type {RenderContext}
		* @default null
		*/
		this._currentContext = null;
		/**
		* A unique collection of bindings.
		*
		* @private
		* @type {WeakSet<Array<BindGroup>>}
		*/
		this._knownBindings = /* @__PURE__ */ new WeakSet();
		/**
		* Whether the device supports framebuffers invalidation or not.
		*
		* @private
		* @type {boolean}
		*/
		this._supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
		/**
		* The target framebuffer when rendering with
		* the WebXR device API.
		*
		* @private
		* @type {?WebGLFramebuffer}
		* @default null
		*/
		this._xrFramebuffer = null;
	}
	/**
	* Initializes the backend so it is ready for usage.
	*
	* @param {Renderer} renderer - The renderer.
	*/
	init(renderer) {
		super.init(renderer);
		const parameters = this.parameters;
		const contextAttributes = {
			antialias: renderer.currentSamples > 0,
			alpha: true,
			depth: renderer.depth,
			stencil: renderer.stencil
		};
		const glContext = parameters.context !== void 0 ? parameters.context : renderer.domElement.getContext("webgl2", contextAttributes);
		function onContextLost(event) {
			event.preventDefault();
			const contextLossInfo = {
				api: "WebGL",
				message: event.statusMessage || "Unknown reason",
				reason: null,
				originalEvent: event
			};
			renderer.onDeviceLost(contextLossInfo);
		}
		this._onContextLost = onContextLost;
		renderer.domElement.addEventListener("webglcontextlost", onContextLost, false);
		this.gl = glContext;
		this.extensions = new WebGLExtensions$1(this);
		this.capabilities = new WebGLCapabilities$1(this);
		this.attributeUtils = new WebGLAttributeUtils(this);
		this.textureUtils = new WebGLTextureUtils(this);
		this.bufferRenderer = new WebGLBufferRenderer$1(this);
		this.state = new WebGLState$1(this);
		this.utils = new WebGLUtils$1(this);
		this.extensions.get("EXT_color_buffer_float");
		this.extensions.get("WEBGL_clip_cull_distance");
		this.extensions.get("OES_texture_float_linear");
		this.extensions.get("EXT_color_buffer_half_float");
		this.extensions.get("WEBGL_multisampled_render_to_texture");
		this.extensions.get("WEBGL_render_shared_exponent");
		this.extensions.get("WEBGL_multi_draw");
		this.extensions.get("OVR_multiview2");
		this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2");
		this.parallel = this.extensions.get("KHR_parallel_shader_compile");
	}
	/**
	* The coordinate system of the backend.
	*
	* @type {number}
	* @readonly
	*/
	get coordinateSystem() {
		return WebGLCoordinateSystem;
	}
	/**
	* This method performs a readback operation by moving buffer data from
	* a storage buffer attribute from the GPU to the CPU.
	*
	* @async
	* @param {StorageBufferAttribute} attribute - The storage buffer attribute.
	* @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
	*/
	async getArrayBufferAsync(attribute$2) {
		return await this.attributeUtils.getArrayBufferAsync(attribute$2);
	}
	/**
	* Ensures the backend is XR compatible.
	*
	* @async
	* @return {Promise} A Promise that resolve when the renderer is XR compatible.
	*/
	async makeXRCompatible() {
		if (this.gl.getContextAttributes().xrCompatible !== true) await this.gl.makeXRCompatible();
	}
	/**
	* Sets the XR rendering destination.
	*
	* @param {WebGLFramebuffer} xrFramebuffer - The XR framebuffer.
	*/
	setXRTarget(xrFramebuffer) {
		this._xrFramebuffer = xrFramebuffer;
	}
	/**
	* Configures the given XR render target with external textures.
	*
	* This method is only relevant when using the WebXR Layers API.
	*
	* @param {XRRenderTarget} renderTarget - The XR render target.
	* @param {WebGLTexture} colorTexture - A native color texture.
	* @param {?WebGLTexture} [depthTexture=null] - A native depth texture.
	*/
	setXRRenderTargetTextures(renderTarget, colorTexture, depthTexture = null) {
		const gl = this.gl;
		this.set(renderTarget.texture, {
			textureGPU: colorTexture,
			glInternalFormat: gl.RGBA8
		});
		if (depthTexture !== null) {
			const glInternalFormat = renderTarget.stencilBuffer ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
			this.set(renderTarget.depthTexture, {
				textureGPU: depthTexture,
				glInternalFormat
			});
			if (this.extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTarget._autoAllocateDepthBuffer === true && renderTarget.multiview === false) warn("WebGLBackend: Render-to-texture extension was disabled because an external texture was provided");
			renderTarget._autoAllocateDepthBuffer = false;
		}
	}
	/**
	* Inits a time stamp query for the given render context.
	*
	* @param {string} type - The type of the timestamp query.
	* @param {string} uid - A unique identifier for the timestamp query.
	*/
	initTimestampQuery(type$1, uid) {
		if (!this.disjoint || !this.trackTimestamp) return;
		if (!this.timestampQueryPool[type$1]) this.timestampQueryPool[type$1] = new WebGLTimestampQueryPool(this.gl, type$1, 2048);
		const timestampQueryPool = this.timestampQueryPool[type$1];
		if (timestampQueryPool.allocateQueriesForContext(uid) !== null) timestampQueryPool.beginQuery(uid);
	}
	/**
	* Prepares the timestamp buffer.
	*
	* @param {string} type - The type of the timestamp query.
	* @param {string} uid - A unique identifier for the timestamp query.
	*/
	prepareTimestampBuffer(type$1, uid) {
		if (!this.disjoint || !this.trackTimestamp) return;
		this.timestampQueryPool[type$1].endQuery(uid);
	}
	/**
	* Returns the backend's rendering context.
	*
	* @return {WebGL2RenderingContext} The rendering context.
	*/
	getContext() {
		return this.gl;
	}
	/**
	* This method is executed at the beginning of a render call and prepares
	* the WebGL state for upcoming render calls
	*
	* @param {RenderContext} renderContext - The render context.
	*/
	beginRender(renderContext) {
		const { state } = this;
		const renderContextData = this.get(renderContext);
		if (renderContext.viewport) this.updateViewport(renderContext);
		else {
			const { width, height } = this.getDrawingBufferSize();
			state.viewport(0, 0, width, height);
		}
		if (renderContext.scissor) {
			const { x, y, width, height } = renderContext.scissorValue;
			state.scissor(x, renderContext.height - height - y, width, height);
		}
		this.initTimestampQuery(TimestampQuery.RENDER, this.getTimestampUID(renderContext));
		renderContextData.previousContext = this._currentContext;
		this._currentContext = renderContext;
		this._setFramebuffer(renderContext);
		this.clear(renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false);
		const occlusionQueryCount = renderContext.occlusionQueryCount;
		if (occlusionQueryCount > 0) {
			renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
			renderContextData.lastOcclusionObject = null;
			renderContextData.occlusionQueries = new Array(occlusionQueryCount);
			renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
			renderContextData.occlusionQueryIndex = 0;
		}
	}
	/**
	* This method is executed at the end of a render call and finalizes work
	* after draw calls.
	*
	* @param {RenderContext} renderContext - The render context.
	*/
	finishRender(renderContext) {
		const { gl, state } = this;
		const renderContextData = this.get(renderContext);
		const previousContext = renderContextData.previousContext;
		state.resetVertexState();
		const occlusionQueryCount = renderContext.occlusionQueryCount;
		if (occlusionQueryCount > 0) {
			if (occlusionQueryCount > renderContextData.occlusionQueryIndex) gl.endQuery(gl.ANY_SAMPLES_PASSED);
			this.resolveOccludedAsync(renderContext);
		}
		const textures = renderContext.textures;
		if (textures !== null) for (let i = 0; i < textures.length; i++) {
			const texture$2 = textures[i];
			if (texture$2.generateMipmaps) this.generateMipmaps(texture$2);
		}
		this._currentContext = previousContext;
		this._resolveRenderTarget(renderContext);
		if (previousContext !== null) {
			this._setFramebuffer(previousContext);
			if (previousContext.viewport) this.updateViewport(previousContext);
			else {
				const { width, height } = this.getDrawingBufferSize();
				state.viewport(0, 0, width, height);
			}
		}
		this.prepareTimestampBuffer(TimestampQuery.RENDER, this.getTimestampUID(renderContext));
	}
	/**
	* This method processes the result of occlusion queries and writes it
	* into render context data.
	*
	* @async
	* @param {RenderContext} renderContext - The render context.
	*/
	resolveOccludedAsync(renderContext) {
		const renderContextData = this.get(renderContext);
		const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;
		if (currentOcclusionQueries && currentOcclusionQueryObjects) {
			const occluded = /* @__PURE__ */ new WeakSet();
			const { gl } = this;
			renderContextData.currentOcclusionQueryObjects = null;
			renderContextData.currentOcclusionQueries = null;
			const check = () => {
				let completed = 0;
				for (let i = 0; i < currentOcclusionQueries.length; i++) {
					const query = currentOcclusionQueries[i];
					if (query === null) continue;
					if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {
						if (gl.getQueryParameter(query, gl.QUERY_RESULT) === 0) occluded.add(currentOcclusionQueryObjects[i]);
						currentOcclusionQueries[i] = null;
						gl.deleteQuery(query);
						completed++;
					}
				}
				if (completed < currentOcclusionQueries.length) requestAnimationFrame(check);
				else renderContextData.occluded = occluded;
			};
			check();
		}
	}
	/**
	* Returns `true` if the given 3D object is fully occluded by other
	* 3D objects in the scene.
	*
	* @param {RenderContext} renderContext - The render context.
	* @param {Object3D} object - The 3D object to test.
	* @return {boolean} Whether the 3D object is fully occluded or not.
	*/
	isOccluded(renderContext, object) {
		const renderContextData = this.get(renderContext);
		return renderContextData.occluded && renderContextData.occluded.has(object);
	}
	/**
	* Updates the viewport with the values from the given render context.
	*
	* @param {RenderContext} renderContext - The render context.
	*/
	updateViewport(renderContext) {
		const { state } = this;
		const { x, y, width, height } = renderContext.viewportValue;
		state.viewport(x, renderContext.height - height - y, width, height);
	}
	/**
	* Defines the scissor test.
	*
	* @param {boolean} boolean - Whether the scissor test should be enabled or not.
	*/
	setScissorTest(boolean) {
		this.state.setScissorTest(boolean);
	}
	/**
	* Returns the clear color and alpha into a single
	* color object.
	*
	* @return {Color4} The clear color.
	*/
	getClearColor() {
		const clearColor = super.getClearColor();
		clearColor.r *= clearColor.a;
		clearColor.g *= clearColor.a;
		clearColor.b *= clearColor.a;
		return clearColor;
	}
	/**
	* Performs a clear operation.
	*
	* @param {boolean} color - Whether the color buffer should be cleared or not.
	* @param {boolean} depth - Whether the depth buffer should be cleared or not.
	* @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
	* @param {?Object} [descriptor=null] - The render context of the current set render target.
	* @param {boolean} [setFrameBuffer=true] - Controls whether the intermediate framebuffer should be set or not.
	* @param {boolean} [resolveRenderTarget=true] - Controls whether an active render target should be resolved
	* or not. Only relevant for explicit clears.
	*/
	clear(color$2, depth$2, stencil, descriptor = null, setFrameBuffer = true, resolveRenderTarget = true) {
		const { gl, renderer } = this;
		if (descriptor === null) descriptor = {
			textures: null,
			clearColorValue: this.getClearColor()
		};
		let clear = 0;
		if (color$2) clear |= gl.COLOR_BUFFER_BIT;
		if (depth$2) clear |= gl.DEPTH_BUFFER_BIT;
		if (stencil) clear |= gl.STENCIL_BUFFER_BIT;
		if (clear !== 0) {
			let clearColor;
			if (descriptor.clearColorValue) clearColor = descriptor.clearColorValue;
			else clearColor = this.getClearColor();
			const clearDepth = renderer.getClearDepth();
			const clearStencil = renderer.getClearStencil();
			if (depth$2) this.state.setDepthMask(true);
			if (descriptor.textures === null) {
				gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
				gl.clear(clear);
			} else {
				if (setFrameBuffer) this._setFramebuffer(descriptor);
				if (color$2) for (let i = 0; i < descriptor.textures.length; i++) if (i === 0) gl.clearBufferfv(gl.COLOR, i, [
					clearColor.r,
					clearColor.g,
					clearColor.b,
					clearColor.a
				]);
				else gl.clearBufferfv(gl.COLOR, i, [
					0,
					0,
					0,
					1
				]);
				if (depth$2 && stencil) gl.clearBufferfi(gl.DEPTH_STENCIL, 0, clearDepth, clearStencil);
				else if (depth$2) gl.clearBufferfv(gl.DEPTH, 0, [clearDepth]);
				else if (stencil) gl.clearBufferiv(gl.STENCIL, 0, [clearStencil]);
				if (setFrameBuffer && resolveRenderTarget) this._resolveRenderTarget(descriptor);
			}
		}
	}
	/**
	* This method is executed at the beginning of a compute call and
	* prepares the state for upcoming compute tasks.
	*
	* @param {Node|Array<Node>} computeGroup - The compute node(s).
	*/
	beginCompute(computeGroup) {
		const { state, gl } = this;
		state.bindFramebuffer(gl.FRAMEBUFFER, null);
		this.initTimestampQuery(TimestampQuery.COMPUTE, this.getTimestampUID(computeGroup));
	}
	/**
	* Executes a compute command for the given compute node.
	*
	* @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
	* @param {Node} computeNode - The compute node.
	* @param {Array<BindGroup>} bindings - The bindings.
	* @param {ComputePipeline} pipeline - The compute pipeline.
	* @param {?number} [count=null] - The count of compute invocations. If `null`, the count is determined by the compute node.
	*/
	compute(computeGroup, computeNode, bindings, pipeline, count = null) {
		const { state, gl } = this;
		if (this.discard === false) {
			gl.enable(gl.RASTERIZER_DISCARD);
			this.discard = true;
		}
		const { programGPU, transformBuffers, attributes } = this.get(pipeline);
		const vaoKey = this._getVaoKey(attributes);
		const vaoGPU = this.vaoCache[vaoKey];
		if (vaoGPU === void 0) this.vaoCache[vaoKey] = this._createVao(attributes);
		else state.setVertexState(vaoGPU);
		state.useProgram(programGPU);
		this._bindUniforms(bindings);
		const transformFeedbackGPU = this._getTransformFeedback(transformBuffers);
		gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
		gl.beginTransformFeedback(gl.POINTS);
		count = count !== null ? count : computeNode.count;
		if (Array.isArray(count)) {
			warnOnce("WebGLBackend.compute(): The count parameter must be a single number, not an array.");
			count = count[0];
		} else if (count && typeof count === "object" && count.isIndirectStorageBufferAttribute) {
			warnOnce("WebGLBackend.compute(): The count parameter must be a single number, not IndirectStorageBufferAttribute");
			count = computeNode.count;
		}
		if (attributes[0].isStorageInstancedBufferAttribute) gl.drawArraysInstanced(gl.POINTS, 0, 1, count);
		else gl.drawArrays(gl.POINTS, 0, count);
		gl.endTransformFeedback();
		gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
		for (let i = 0; i < transformBuffers.length; i++) {
			const dualAttributeData = transformBuffers[i];
			if (dualAttributeData.pbo && this.has(dualAttributeData.pbo)) this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer, dualAttributeData.pbo);
			dualAttributeData.switchBuffers();
		}
	}
	/**
	* This method is executed at the end of a compute call and
	* finalizes work after compute tasks.
	*
	* @param {Node|Array<Node>} computeGroup - The compute node(s).
	*/
	finishCompute(computeGroup) {
		const gl = this.gl;
		this.discard = false;
		gl.disable(gl.RASTERIZER_DISCARD);
		this.prepareTimestampBuffer(TimestampQuery.COMPUTE, this.getTimestampUID(computeGroup));
		if (this._currentContext) this._setFramebuffer(this._currentContext);
	}
	/**
	* Internal to determine if the current render target is a render target array with depth 2D array texture.
	*
	* @param {RenderContext} renderContext - The render context.
	* @return {boolean} Whether the render target is a render target array with depth 2D array texture.
	*
	* @private
	*/
	_isRenderCameraDepthArray(renderContext) {
		return renderContext.depthTexture && renderContext.depthTexture.isArrayTexture && renderContext.camera.isArrayCamera;
	}
	/**
	* Executes a draw command for the given render object.
	*
	* @param {RenderObject} renderObject - The render object to draw.
	* @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
	*/
	draw(renderObject) {
		const { object, pipeline, material, context: context$2, hardwareClippingPlanes } = renderObject;
		const { programGPU } = this.get(pipeline);
		const { gl, state } = this;
		const contextData = this.get(context$2);
		const drawParams = renderObject.getDrawParameters();
		if (drawParams === null) return;
		this._bindUniforms(renderObject.getBindings());
		const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
		state.setMaterial(material, frontFaceCW, hardwareClippingPlanes);
		state.useProgram(programGPU);
		const attributes = renderObject.getAttributes();
		const attributesData = this.get(attributes);
		let vaoGPU = attributesData.vaoGPU;
		if (vaoGPU === void 0) {
			const vaoKey = this._getVaoKey(attributes);
			vaoGPU = this.vaoCache[vaoKey];
			if (vaoGPU === void 0) {
				vaoGPU = this._createVao(attributes);
				this.vaoCache[vaoKey] = vaoGPU;
				attributesData.vaoGPU = vaoGPU;
			}
		}
		const index = renderObject.getIndex();
		const indexGPU = index !== null ? this.get(index).bufferGPU : null;
		state.setVertexState(vaoGPU, indexGPU);
		const lastObject = contextData.lastOcclusionObject;
		if (lastObject !== object && lastObject !== void 0) {
			if (lastObject !== null && lastObject.occlusionTest === true) {
				gl.endQuery(gl.ANY_SAMPLES_PASSED);
				contextData.occlusionQueryIndex++;
			}
			if (object.occlusionTest === true) {
				const query = gl.createQuery();
				gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);
				contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;
				contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;
			}
			contextData.lastOcclusionObject = object;
		}
		const renderer = this.bufferRenderer;
		if (object.isPoints) renderer.mode = gl.POINTS;
		else if (object.isLineSegments) renderer.mode = gl.LINES;
		else if (object.isLine) renderer.mode = gl.LINE_STRIP;
		else if (object.isLineLoop) renderer.mode = gl.LINE_LOOP;
		else if (material.wireframe === true) {
			state.setLineWidth(material.wireframeLinewidth * this.renderer.getPixelRatio());
			renderer.mode = gl.LINES;
		} else renderer.mode = gl.TRIANGLES;
		const { vertexCount, instanceCount } = drawParams;
		let { firstVertex } = drawParams;
		renderer.object = object;
		if (index !== null) {
			firstVertex *= index.array.BYTES_PER_ELEMENT;
			const indexData = this.get(index);
			renderer.index = index.count;
			renderer.type = indexData.type;
		} else renderer.index = 0;
		const draw = () => {
			if (object.isBatchedMesh) if (object._multiDrawInstances !== null) {
				warnOnce("WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");
				renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
			} else if (!this.hasFeature("WEBGL_multi_draw")) warnOnce("WebGLBackend: WEBGL_multi_draw not supported.");
			else renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
			else if (instanceCount > 1) renderer.renderInstances(firstVertex, vertexCount, instanceCount);
			else renderer.render(firstVertex, vertexCount);
		};
		if (renderObject.camera.isArrayCamera === true && renderObject.camera.cameras.length > 0 && renderObject.camera.isMultiViewCamera === false) {
			const cameraData = this.get(renderObject.camera);
			const cameras = renderObject.camera.cameras;
			const cameraIndex$2 = renderObject.getBindingGroup("cameraIndex").bindings[0];
			if (cameraData.indexesGPU === void 0 || cameraData.indexesGPU.length !== cameras.length) {
				const data = new Uint32Array([
					0,
					0,
					0,
					0
				]);
				const indexesGPU = [];
				for (let i = 0, len = cameras.length; i < len; i++) {
					const bufferGPU = gl.createBuffer();
					data[0] = i;
					gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
					gl.bufferData(gl.UNIFORM_BUFFER, data, gl.STATIC_DRAW);
					indexesGPU.push(bufferGPU);
				}
				cameraData.indexesGPU = indexesGPU;
			}
			const cameraIndexData = this.get(cameraIndex$2);
			const pixelRatio = this.renderer.getPixelRatio();
			const renderTarget = this._currentContext.renderTarget;
			const isRenderCameraDepthArray = this._isRenderCameraDepthArray(this._currentContext);
			const prevActiveCubeFace = this._currentContext.activeCubeFace;
			if (isRenderCameraDepthArray) {
				const textureData = this.get(renderTarget.depthTexture);
				if (textureData.clearedRenderId !== this.renderer._nodes.nodeFrame.renderId) {
					textureData.clearedRenderId = this.renderer._nodes.nodeFrame.renderId;
					const { stencilBuffer } = renderTarget;
					for (let i = 0, len = cameras.length; i < len; i++) {
						this.renderer._activeCubeFace = i;
						this._currentContext.activeCubeFace = i;
						this._setFramebuffer(this._currentContext);
						this.clear(false, true, stencilBuffer, this._currentContext, false, false);
					}
					this.renderer._activeCubeFace = prevActiveCubeFace;
					this._currentContext.activeCubeFace = prevActiveCubeFace;
				}
			}
			for (let i = 0, len = cameras.length; i < len; i++) {
				const subCamera = cameras[i];
				if (object.layers.test(subCamera.layers)) {
					if (isRenderCameraDepthArray) {
						this.renderer._activeCubeFace = i;
						this._currentContext.activeCubeFace = i;
						this._setFramebuffer(this._currentContext);
					}
					const vp = subCamera.viewport;
					if (vp !== void 0) {
						const x = vp.x * pixelRatio;
						const y = vp.y * pixelRatio;
						const width = vp.width * pixelRatio;
						const height = vp.height * pixelRatio;
						state.viewport(Math.floor(x), Math.floor(renderObject.context.height - height - y), Math.floor(width), Math.floor(height));
					}
					state.bindBufferBase(gl.UNIFORM_BUFFER, cameraIndexData.index, cameraData.indexesGPU[i]);
					draw();
				}
				this._currentContext.activeCubeFace = prevActiveCubeFace;
				this.renderer._activeCubeFace = prevActiveCubeFace;
			}
		} else draw();
	}
	/**
	* Explain why always null is returned.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {boolean} Whether the render pipeline requires an update or not.
	*/
	needsRenderUpdate() {
		return false;
	}
	/**
	* Explain why no cache key is computed.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {string} The cache key.
	*/
	getRenderCacheKey() {
		return "";
	}
	/**
	* Creates a default texture for the given texture that can be used
	* as a placeholder until the actual texture is ready for usage.
	*
	* @param {Texture} texture - The texture to create a default texture for.
	*/
	createDefaultTexture(texture$2) {
		this.textureUtils.createDefaultTexture(texture$2);
	}
	/**
	* Defines a texture on the GPU for the given texture object.
	*
	* @param {Texture} texture - The texture.
	* @param {Object} [options={}] - Optional configuration parameter.
	*/
	createTexture(texture$2, options) {
		this.textureUtils.createTexture(texture$2, options);
	}
	/**
	* Uploads the updated texture data to the GPU.
	*
	* @param {Texture} texture - The texture.
	* @param {Object} [options={}] - Optional configuration parameter.
	*/
	updateTexture(texture$2, options) {
		this.textureUtils.updateTexture(texture$2, options);
	}
	/**
	* Generates mipmaps for the given texture.
	*
	* @param {Texture} texture - The texture.
	*/
	generateMipmaps(texture$2) {
		this.textureUtils.generateMipmaps(texture$2);
	}
	/**
	* Destroys the GPU data for the given texture object.
	*
	* @param {Texture} texture - The texture.
	* @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
	*/
	destroyTexture(texture$2, isDefaultTexture = false) {
		this.textureUtils.destroyTexture(texture$2, isDefaultTexture);
	}
	/**
	* Returns texture data as a typed array.
	*
	* @async
	* @param {Texture} texture - The texture to copy.
	* @param {number} x - The x coordinate of the copy origin.
	* @param {number} y - The y coordinate of the copy origin.
	* @param {number} width - The width of the copy.
	* @param {number} height - The height of the copy.
	* @param {number} faceIndex - The face index.
	* @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
	*/
	async copyTextureToBuffer(texture$2, x, y, width, height, faceIndex) {
		return this.textureUtils.copyTextureToBuffer(texture$2, x, y, width, height, faceIndex);
	}
	/**
	* This method does nothing since WebGL 2 has no concept of samplers.
	*
	* @param {Texture} texture - The texture to update the sampler for.
	* @return {string} The current sampler key.
	*/
	updateSampler() {
		return "";
	}
	/**
	* Returns a node builder for the given render object.
	*
	* @param {RenderObject} object - The render object.
	* @param {Renderer} renderer - The renderer.
	* @return {GLSLNodeBuilder} The node builder.
	*/
	createNodeBuilder(object, renderer) {
		return new GLSLNodeBuilder(object, renderer);
	}
	/**
	* Creates a shader program from the given programmable stage.
	*
	* @param {ProgrammableStage} program - The programmable stage.
	*/
	createProgram(program) {
		const gl = this.gl;
		const { stage, code: code$2 } = program;
		const shader = stage === "fragment" ? gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(shader, code$2);
		gl.compileShader(shader);
		this.set(program, { shaderGPU: shader });
	}
	/**
	* Destroys the shader program of the given programmable stage.
	*
	* @param {ProgrammableStage} program - The programmable stage.
	*/
	destroyProgram(program) {
		this.delete(program);
	}
	/**
	* Creates a render pipeline for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	* @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
	*/
	createRenderPipeline(renderObject, promises) {
		const gl = this.gl;
		const pipeline = renderObject.pipeline;
		const { fragmentProgram, vertexProgram } = pipeline;
		const programGPU = gl.createProgram();
		const fragmentShader = this.get(fragmentProgram).shaderGPU;
		const vertexShader = this.get(vertexProgram).shaderGPU;
		gl.attachShader(programGPU, fragmentShader);
		gl.attachShader(programGPU, vertexShader);
		gl.linkProgram(programGPU);
		this.set(pipeline, {
			programGPU,
			fragmentShader,
			vertexShader
		});
		if (promises !== null && this.parallel) {
			const p$1 = new Promise((resolve) => {
				const parallel = this.parallel;
				const checkStatus = () => {
					if (gl.getProgramParameter(programGPU, parallel.COMPLETION_STATUS_KHR)) {
						this._completeCompile(renderObject, pipeline);
						resolve();
					} else requestAnimationFrame(checkStatus);
				};
				checkStatus();
			});
			promises.push(p$1);
			return;
		}
		this._completeCompile(renderObject, pipeline);
	}
	/**
	* Formats the source code of error messages.
	*
	* @private
	* @param {string} string - The code.
	* @param {number} errorLine - The error line.
	* @return {string} The formatted code.
	*/
	_handleSource(string$2, errorLine) {
		const lines = string$2.split("\n");
		const lines2 = [];
		const from = Math.max(errorLine - 6, 0);
		const to$1 = Math.min(errorLine + 6, lines.length);
		for (let i = from; i < to$1; i++) {
			const line = i + 1;
			lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
		}
		return lines2.join("\n");
	}
	/**
	* Gets the shader compilation errors from the info log.
	*
	* @private
	* @param {WebGL2RenderingContext} gl - The rendering context.
	* @param {WebGLShader} shader - The WebGL shader object.
	* @param {string} type - The shader type.
	* @return {string} The shader errors.
	*/
	_getShaderErrors(gl, shader, type$1) {
		const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
		const errors = (gl.getShaderInfoLog(shader) || "").trim();
		if (status && errors === "") return "";
		const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
		if (errorMatches) {
			const errorLine = parseInt(errorMatches[1]);
			return type$1.toUpperCase() + "\n\n" + errors + "\n\n" + this._handleSource(gl.getShaderSource(shader), errorLine);
		} else return errors;
	}
	/**
	* Logs shader compilation errors.
	*
	* @private
	* @param {WebGLProgram} programGPU - The WebGL program.
	* @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.
	* @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.
	*/
	_logProgramError(programGPU, glFragmentShader, glVertexShader) {
		if (this.renderer.debug.checkShaderErrors) {
			const gl = this.gl;
			const programLog = (gl.getProgramInfoLog(programGPU) || "").trim();
			if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) if (typeof this.renderer.debug.onShaderError === "function") this.renderer.debug.onShaderError(gl, programGPU, glVertexShader, glFragmentShader);
			else {
				const vertexErrors = this._getShaderErrors(gl, glVertexShader, "vertex");
				const fragmentErrors = this._getShaderErrors(gl, glFragmentShader, "fragment");
				error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(programGPU, gl.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
			}
			else if (programLog !== "") warn("WebGLProgram: Program Info Log:", programLog);
		}
	}
	/**
	* Completes the shader program setup for the given render object.
	*
	* @private
	* @param {RenderObject} renderObject - The render object.
	* @param {RenderPipeline} pipeline - The render pipeline.
	*/
	_completeCompile(renderObject, pipeline) {
		const { state, gl } = this;
		const { programGPU, fragmentShader, vertexShader } = this.get(pipeline);
		if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) this._logProgramError(programGPU, fragmentShader, vertexShader);
		state.useProgram(programGPU);
		const bindings = renderObject.getBindings();
		this._setupBindings(bindings, programGPU);
		this.set(pipeline, { programGPU });
	}
	/**
	* Creates a compute pipeline for the given compute node.
	*
	* @param {ComputePipeline} computePipeline - The compute pipeline.
	* @param {Array<BindGroup>} bindings - The bindings.
	*/
	createComputePipeline(computePipeline, bindings) {
		const { state, gl } = this;
		const fragmentProgram = {
			stage: "fragment",
			code: "#version 300 es\nprecision highp float;\nvoid main() {}"
		};
		this.createProgram(fragmentProgram);
		const { computeProgram } = computePipeline;
		const programGPU = gl.createProgram();
		const fragmentShader = this.get(fragmentProgram).shaderGPU;
		const vertexShader = this.get(computeProgram).shaderGPU;
		const transforms = computeProgram.transforms;
		const transformVaryingNames = [];
		const transformAttributeNodes = [];
		for (let i = 0; i < transforms.length; i++) {
			const transform = transforms[i];
			transformVaryingNames.push(transform.varyingName);
			transformAttributeNodes.push(transform.attributeNode);
		}
		gl.attachShader(programGPU, fragmentShader);
		gl.attachShader(programGPU, vertexShader);
		gl.transformFeedbackVaryings(programGPU, transformVaryingNames, gl.SEPARATE_ATTRIBS);
		gl.linkProgram(programGPU);
		if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) this._logProgramError(programGPU, fragmentShader, vertexShader);
		state.useProgram(programGPU);
		this._setupBindings(bindings, programGPU);
		const attributeNodes = computeProgram.attributes;
		const attributes = [];
		const transformBuffers = [];
		for (let i = 0; i < attributeNodes.length; i++) {
			const attribute$2 = attributeNodes[i].node.attribute;
			attributes.push(attribute$2);
			if (!this.has(attribute$2)) this.attributeUtils.createAttribute(attribute$2, gl.ARRAY_BUFFER);
		}
		for (let i = 0; i < transformAttributeNodes.length; i++) {
			const attribute$2 = transformAttributeNodes[i].attribute;
			if (!this.has(attribute$2)) this.attributeUtils.createAttribute(attribute$2, gl.ARRAY_BUFFER);
			const attributeData = this.get(attribute$2);
			transformBuffers.push(attributeData);
		}
		this.set(computePipeline, {
			programGPU,
			transformBuffers,
			attributes
		});
	}
	/**
	* Creates bindings from the given bind group definition.
	*
	* @param {BindGroup} bindGroup - The bind group.
	* @param {Array<BindGroup>} bindings - Array of bind groups.
	* @param {number} cacheIndex - The cache index.
	* @param {number} version - The version.
	*/
	createBindings(bindGroup, bindings) {
		if (this._knownBindings.has(bindings) === false) {
			this._knownBindings.add(bindings);
			let uniformBuffers = 0;
			let textures = 0;
			for (const bindGroup$1 of bindings) {
				this.set(bindGroup$1, {
					textures,
					uniformBuffers
				});
				for (const binding of bindGroup$1.bindings) {
					if (binding.isUniformBuffer) uniformBuffers++;
					if (binding.isSampledTexture) textures++;
				}
			}
		}
		this.updateBindings(bindGroup, bindings);
	}
	/**
	* Updates the given bind group definition.
	*
	* @param {BindGroup} bindGroup - The bind group.
	* @param {Array<BindGroup>} bindings - Array of bind groups.
	* @param {number} cacheIndex - The cache index.
	* @param {number} version - The version.
	*/
	updateBindings(bindGroup) {
		const { gl } = this;
		const bindGroupData = this.get(bindGroup);
		let i = bindGroupData.uniformBuffers;
		let t = bindGroupData.textures;
		for (const binding of bindGroup.bindings) {
			const map = this.get(binding);
			if (binding.isUniformsGroup || binding.isUniformBuffer) {
				const data = binding.buffer;
				let { bufferGPU } = this.get(data);
				if (bufferGPU === void 0) {
					bufferGPU = gl.createBuffer();
					gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
					gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
					this.set(data, { bufferGPU });
				} else {
					gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
					gl.bufferSubData(gl.UNIFORM_BUFFER, 0, data);
				}
				map.index = i++;
				map.bufferGPU = bufferGPU;
				this.set(binding, map);
			} else if (binding.isSampledTexture) {
				const { textureGPU, glTextureType } = this.get(binding.texture);
				map.index = t++;
				map.textureGPU = textureGPU;
				map.glTextureType = glTextureType;
				this.set(binding, map);
			}
		}
	}
	/**
	* Updates a buffer binding.
	*
	*  @param {Buffer} binding - The buffer binding to update.
	*/
	updateBinding(binding) {
		const gl = this.gl;
		if (binding.isUniformsGroup || binding.isUniformBuffer) {
			const bufferGPU = this.get(binding).bufferGPU;
			const data = binding.buffer;
			gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
			gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
		}
	}
	/**
	* Creates the GPU buffer of an indexed shader attribute.
	*
	* @param {BufferAttribute} attribute - The indexed buffer attribute.
	*/
	createIndexAttribute(attribute$2) {
		const gl = this.gl;
		this.attributeUtils.createAttribute(attribute$2, gl.ELEMENT_ARRAY_BUFFER);
	}
	/**
	* Creates the GPU buffer of a shader attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	createAttribute(attribute$2) {
		if (this.has(attribute$2)) return;
		const gl = this.gl;
		this.attributeUtils.createAttribute(attribute$2, gl.ARRAY_BUFFER);
	}
	/**
	* Creates the GPU buffer of a storage attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	createStorageAttribute(attribute$2) {
		if (this.has(attribute$2)) return;
		const gl = this.gl;
		this.attributeUtils.createAttribute(attribute$2, gl.ARRAY_BUFFER);
	}
	/**
	* Updates the GPU buffer of a shader attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute to update.
	*/
	updateAttribute(attribute$2) {
		this.attributeUtils.updateAttribute(attribute$2);
	}
	/**
	* Destroys the GPU buffer of a shader attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute to destroy.
	*/
	destroyAttribute(attribute$2) {
		this.attributeUtils.destroyAttribute(attribute$2);
	}
	/**
	* Checks if the given feature is supported  by the backend.
	*
	* @param {string} name - The feature's name.
	* @return {boolean} Whether the feature is supported or not.
	*/
	hasFeature(name) {
		const keysMatching = Object.keys(GLFeatureName).filter((key) => GLFeatureName[key] === name);
		const extensions = this.extensions;
		for (let i = 0; i < keysMatching.length; i++) if (extensions.has(keysMatching[i])) return true;
		return false;
	}
	/**
	* Returns the maximum anisotropy texture filtering value.
	*
	* @return {number} The maximum anisotropy texture filtering value.
	*/
	getMaxAnisotropy() {
		return this.capabilities.getMaxAnisotropy();
	}
	/**
	* Copies data of the given source texture to the given destination texture.
	*
	* @param {Texture} srcTexture - The source texture.
	* @param {Texture} dstTexture - The destination texture.
	* @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
	* @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
	* @param {number} [srcLevel=0] - The source mip level to copy from.
	* @param {number} [dstLevel=0] - The destination mip level to copy to.
	*/
	copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
		this.textureUtils.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel);
	}
	/**
	* Copies the current bound framebuffer to the given texture.
	*
	* @param {Texture} texture - The destination texture.
	* @param {RenderContext} renderContext - The render context.
	* @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
	*/
	copyFramebufferToTexture(texture$2, renderContext, rectangle) {
		this.textureUtils.copyFramebufferToTexture(texture$2, renderContext, rectangle);
	}
	/**
	* Configures the active framebuffer from the given render context.
	*
	* @private
	* @param {RenderContext} descriptor - The render context.
	*/
	_setFramebuffer(descriptor) {
		const { gl, state } = this;
		let currentFrameBuffer = null;
		if (descriptor.textures !== null) {
			const renderTarget = descriptor.renderTarget;
			const renderTargetContextData = this.get(renderTarget);
			const { samples, depthBuffer, stencilBuffer } = renderTarget;
			const isCube = renderTarget.isWebGLCubeRenderTarget === true;
			const isRenderTarget3D = renderTarget.isRenderTarget3D === true;
			const isRenderTargetArray = renderTarget.depth > 1;
			const isXRRenderTarget = renderTarget.isXRRenderTarget === true;
			const _hasExternalTextures = isXRRenderTarget === true && renderTarget._hasExternalTextures === true;
			let msaaFb = renderTargetContextData.msaaFrameBuffer;
			let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;
			const multisampledRTTExt = this.extensions.get("WEBGL_multisampled_render_to_texture");
			const multiviewExt = this.extensions.get("OVR_multiview2");
			const useMultisampledRTT = this._useMultisampledExtension(renderTarget);
			const cacheKey = getCacheKey(descriptor);
			let fb;
			if (isCube) {
				renderTargetContextData.cubeFramebuffers || (renderTargetContextData.cubeFramebuffers = {});
				fb = renderTargetContextData.cubeFramebuffers[cacheKey];
			} else if (isXRRenderTarget && _hasExternalTextures === false) fb = this._xrFramebuffer;
			else {
				renderTargetContextData.framebuffers || (renderTargetContextData.framebuffers = {});
				fb = renderTargetContextData.framebuffers[cacheKey];
			}
			if (fb === void 0) {
				fb = gl.createFramebuffer();
				state.bindFramebuffer(gl.FRAMEBUFFER, fb);
				const textures = descriptor.textures;
				const depthInvalidationArray = [];
				if (isCube) {
					renderTargetContextData.cubeFramebuffers[cacheKey] = fb;
					const { textureGPU } = this.get(textures[0]);
					const cubeFace = this.renderer._activeCubeFace;
					const mipLevel = this.renderer._activeMipmapLevel;
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, mipLevel);
				} else {
					renderTargetContextData.framebuffers[cacheKey] = fb;
					for (let i = 0; i < textures.length; i++) {
						const texture$2 = textures[i];
						const textureData = this.get(texture$2);
						textureData.renderTarget = descriptor.renderTarget;
						textureData.cacheKey = cacheKey;
						const attachment = gl.COLOR_ATTACHMENT0 + i;
						if (renderTarget.multiview) multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, samples, 0, 2);
						else if (isRenderTarget3D || isRenderTargetArray) {
							const layer = this.renderer._activeCubeFace;
							const mipLevel = this.renderer._activeMipmapLevel;
							gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, textureData.textureGPU, mipLevel, layer);
						} else if (useMultisampledRTT) multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
						else {
							const mipLevel = this.renderer._activeMipmapLevel;
							gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, mipLevel);
						}
					}
				}
				const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
				if (renderTarget._autoAllocateDepthBuffer === true) {
					const renderbuffer = gl.createRenderbuffer();
					this.textureUtils.setupRenderBufferStorage(renderbuffer, descriptor, 0, useMultisampledRTT);
					renderTargetContextData.xrDepthRenderbuffer = renderbuffer;
					depthInvalidationArray.push(stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
					gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer);
				} else if (descriptor.depthTexture !== null) {
					depthInvalidationArray.push(stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
					const textureData = this.get(descriptor.depthTexture);
					textureData.renderTarget = descriptor.renderTarget;
					textureData.cacheKey = cacheKey;
					if (renderTarget.multiview) multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2);
					else if (_hasExternalTextures && useMultisampledRTT) multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
					else if (descriptor.depthTexture.isArrayTexture) {
						const layer = this.renderer._activeCubeFace;
						gl.framebufferTextureLayer(gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, layer);
					} else gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0);
				}
				renderTargetContextData.depthInvalidationArray = depthInvalidationArray;
			} else {
				if (this._isRenderCameraDepthArray(descriptor)) {
					state.bindFramebuffer(gl.FRAMEBUFFER, fb);
					const layer = this.renderer._activeCubeFace;
					const depthData = this.get(descriptor.depthTexture);
					const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
					gl.framebufferTextureLayer(gl.FRAMEBUFFER, depthStyle, depthData.textureGPU, 0, layer);
				}
				if ((isXRRenderTarget || useMultisampledRTT || renderTarget.multiview) && renderTarget._isOpaqueFramebuffer !== true) {
					state.bindFramebuffer(gl.FRAMEBUFFER, fb);
					const textureData = this.get(descriptor.textures[0]);
					if (renderTarget.multiview) multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, textureData.textureGPU, 0, samples, 0, 2);
					else if (useMultisampledRTT) multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
					else gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0);
					const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
					if (renderTarget._autoAllocateDepthBuffer === true) {
						const renderbuffer = renderTargetContextData.xrDepthRenderbuffer;
						gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer);
					} else {
						const textureData$1 = this.get(descriptor.depthTexture);
						if (renderTarget.multiview) multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, depthStyle, textureData$1.textureGPU, 0, samples, 0, 2);
						else if (useMultisampledRTT) multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData$1.textureGPU, 0, samples);
						else gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData$1.textureGPU, 0);
					}
				}
			}
			if (samples > 0 && useMultisampledRTT === false && !renderTarget.multiview) {
				if (msaaFb === void 0) {
					const invalidationArray = [];
					msaaFb = gl.createFramebuffer();
					state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);
					const msaaRenderbuffers = [];
					const textures = descriptor.textures;
					for (let i = 0; i < textures.length; i++) {
						msaaRenderbuffers[i] = gl.createRenderbuffer();
						gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[i]);
						invalidationArray.push(gl.COLOR_ATTACHMENT0 + i);
						const texture$2 = descriptor.textures[i];
						const textureData = this.get(texture$2);
						gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[i]);
					}
					gl.bindRenderbuffer(gl.RENDERBUFFER, null);
					renderTargetContextData.msaaFrameBuffer = msaaFb;
					renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;
					if (depthBuffer && depthRenderbuffer === void 0) {
						depthRenderbuffer = gl.createRenderbuffer();
						this.textureUtils.setupRenderBufferStorage(depthRenderbuffer, descriptor, samples);
						renderTargetContextData.depthRenderbuffer = depthRenderbuffer;
						const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
						invalidationArray.push(depthStyle);
					}
					renderTargetContextData.invalidationArray = invalidationArray;
				}
				currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;
			} else currentFrameBuffer = fb;
			state.drawBuffers(descriptor, fb);
		}
		state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);
	}
	/**
	* Computes the VAO key for the given index and attributes.
	*
	* @private
	* @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
	* @return {string} The VAO key.
	*/
	_getVaoKey(attributes) {
		let key = "";
		for (let i = 0; i < attributes.length; i++) {
			const attributeData = this.get(attributes[i]);
			key += ":" + attributeData.id;
		}
		return key;
	}
	/**
	* Creates a VAO from the index and attributes.
	*
	* @private
	* @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
	* @return {Object} The VAO data.
	*/
	_createVao(attributes) {
		const { gl } = this;
		const vaoGPU = gl.createVertexArray();
		gl.bindVertexArray(vaoGPU);
		for (let i = 0; i < attributes.length; i++) {
			const attribute$2 = attributes[i];
			const attributeData = this.get(attribute$2);
			gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);
			gl.enableVertexAttribArray(i);
			let stride, offset;
			if (attribute$2.isInterleavedBufferAttribute === true) {
				stride = attribute$2.data.stride * attributeData.bytesPerElement;
				offset = attribute$2.offset * attributeData.bytesPerElement;
			} else {
				stride = 0;
				offset = 0;
			}
			if (attributeData.isInteger) gl.vertexAttribIPointer(i, attribute$2.itemSize, attributeData.type, stride, offset);
			else gl.vertexAttribPointer(i, attribute$2.itemSize, attributeData.type, attribute$2.normalized, stride, offset);
			if (attribute$2.isInstancedBufferAttribute && !attribute$2.isInterleavedBufferAttribute) gl.vertexAttribDivisor(i, attribute$2.meshPerAttribute);
			else if (attribute$2.isInterleavedBufferAttribute && attribute$2.data.isInstancedInterleavedBuffer) gl.vertexAttribDivisor(i, attribute$2.data.meshPerAttribute);
		}
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
		return vaoGPU;
	}
	/**
	* Creates a transform feedback from the given transform buffers.
	*
	* @private
	* @param {Array<DualAttributeData>} transformBuffers - The transform buffers.
	* @return {WebGLTransformFeedback} The transform feedback.
	*/
	_getTransformFeedback(transformBuffers) {
		let key = "";
		for (let i = 0; i < transformBuffers.length; i++) key += ":" + transformBuffers[i].id;
		let transformFeedbackGPU = this.transformFeedbackCache[key];
		if (transformFeedbackGPU !== void 0) return transformFeedbackGPU;
		const { gl } = this;
		transformFeedbackGPU = gl.createTransformFeedback();
		gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
		for (let i = 0; i < transformBuffers.length; i++) {
			const attributeData = transformBuffers[i];
			gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer);
		}
		gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
		this.transformFeedbackCache[key] = transformFeedbackGPU;
		return transformFeedbackGPU;
	}
	/**
	* Setups the given bindings.
	*
	* @private
	* @param {Array<BindGroup>} bindings - The bindings.
	* @param {WebGLProgram} programGPU - The WebGL program.
	*/
	_setupBindings(bindings, programGPU) {
		const gl = this.gl;
		for (const bindGroup of bindings) for (const binding of bindGroup.bindings) {
			const index = this.get(binding).index;
			if (binding.isUniformsGroup || binding.isUniformBuffer) {
				const location = gl.getUniformBlockIndex(programGPU, binding.name);
				gl.uniformBlockBinding(programGPU, location, index);
			} else if (binding.isSampledTexture) {
				const location = gl.getUniformLocation(programGPU, binding.name);
				gl.uniform1i(location, index);
			}
		}
	}
	/**
	* Binds the given uniforms.
	*
	* @private
	* @param {Array<BindGroup>} bindings - The bindings.
	*/
	_bindUniforms(bindings) {
		const { gl, state } = this;
		for (const bindGroup of bindings) for (const binding of bindGroup.bindings) {
			const bindingData = this.get(binding);
			const index = bindingData.index;
			if (binding.isUniformsGroup || binding.isUniformBuffer) state.bindBufferBase(gl.UNIFORM_BUFFER, index, bindingData.bufferGPU);
			else if (binding.isSampledTexture) state.bindTexture(bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index);
		}
	}
	/**
	* The method ensures multisampled render targets are resolved.
	*
	* @private
	* @param {RenderContext} renderContext - The render context.
	*/
	_resolveRenderTarget(renderContext) {
		const { gl, state } = this;
		const renderTarget = renderContext.renderTarget;
		if (renderContext.textures !== null && renderTarget) {
			const renderTargetContextData = this.get(renderTarget);
			if (renderTarget.samples > 0 && this._useMultisampledExtension(renderTarget) === false) {
				const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
				let mask = gl.COLOR_BUFFER_BIT;
				if (renderTarget.resolveDepthBuffer) {
					if (renderTarget.depthBuffer) mask |= gl.DEPTH_BUFFER_BIT;
					if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= gl.STENCIL_BUFFER_BIT;
				}
				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
				const msaaRenderbuffers = renderTargetContextData.msaaRenderbuffers;
				const textures = renderContext.textures;
				const isMRT = textures.length > 1;
				state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
				state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
				if (isMRT) for (let i = 0; i < textures.length; i++) {
					gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, null);
					gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, null, 0);
				}
				for (let i = 0; i < textures.length; i++) {
					if (isMRT) {
						const { textureGPU } = this.get(textures[i]);
						gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, msaaRenderbuffers[i]);
						gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureGPU, 0);
					}
					if (renderContext.scissor) {
						const { x, y, width, height } = renderContext.scissorValue;
						const viewY = renderContext.height - height - y;
						gl.blitFramebuffer(x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST);
					} else gl.blitFramebuffer(0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST);
				}
				if (isMRT) for (let i = 0; i < textures.length; i++) {
					const { textureGPU } = this.get(textures[i]);
					gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[i]);
					gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, textureGPU, 0);
				}
				if (this._supportsInvalidateFramebuffer === true) gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray);
			} else if (renderTarget.resolveDepthBuffer === false && renderTargetContextData.framebuffers) {
				const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
				state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
				gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, renderTargetContextData.depthInvalidationArray);
			}
		}
	}
	/**
	* Returns `true` if the `WEBGL_multisampled_render_to_texture` extension
	* should be used when MSAA is enabled.
	*
	* @private
	* @param {RenderTarget} renderTarget - The render target that should be multisampled.
	* @return {boolean} Whether to use the `WEBGL_multisampled_render_to_texture` extension for MSAA or not.
	*/
	_useMultisampledExtension(renderTarget) {
		if (renderTarget.multiview === true) return true;
		return renderTarget.samples > 0 && this.extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTarget._autoAllocateDepthBuffer !== false;
	}
	/**
	* Frees internal resources.
	*/
	dispose() {
		if (this.textureUtils !== null) this.textureUtils.dispose();
		const extension = this.extensions.get("WEBGL_lose_context");
		if (extension) extension.loseContext();
		this.renderer.domElement.removeEventListener("webglcontextlost", this._onContextLost);
	}
};
var GPUPrimitiveTopology = {
	PointList: "point-list",
	LineList: "line-list",
	LineStrip: "line-strip",
	TriangleList: "triangle-list",
	TriangleStrip: "triangle-strip"
};
var GPUCompareFunction = {
	Never: "never",
	Less: "less",
	Equal: "equal",
	LessEqual: "less-equal",
	Greater: "greater",
	NotEqual: "not-equal",
	GreaterEqual: "greater-equal",
	Always: "always"
};
var GPUStoreOp = { Store: "store" };
var GPULoadOp = {
	Load: "load",
	Clear: "clear"
};
var GPUFrontFace = {
	CCW: "ccw",
	CW: "cw"
};
var GPUCullMode = {
	None: "none",
	Back: "back"
};
var GPUIndexFormat = {
	Uint16: "uint16",
	Uint32: "uint32"
};
var GPUTextureFormat = {
	R8Unorm: "r8unorm",
	R8Snorm: "r8snorm",
	R8Uint: "r8uint",
	R8Sint: "r8sint",
	R16Uint: "r16uint",
	R16Sint: "r16sint",
	R16Float: "r16float",
	RG8Unorm: "rg8unorm",
	RG8Snorm: "rg8snorm",
	RG8Uint: "rg8uint",
	RG8Sint: "rg8sint",
	R32Uint: "r32uint",
	R32Sint: "r32sint",
	R32Float: "r32float",
	RG16Uint: "rg16uint",
	RG16Sint: "rg16sint",
	RG16Float: "rg16float",
	RGBA8Unorm: "rgba8unorm",
	RGBA8UnormSRGB: "rgba8unorm-srgb",
	RGBA8Snorm: "rgba8snorm",
	RGBA8Uint: "rgba8uint",
	RGBA8Sint: "rgba8sint",
	BGRA8Unorm: "bgra8unorm",
	BGRA8UnormSRGB: "bgra8unorm-srgb",
	RGB9E5UFloat: "rgb9e5ufloat",
	RGB10A2Unorm: "rgb10a2unorm",
	RG11B10UFloat: "rg11b10ufloat",
	RG32Uint: "rg32uint",
	RG32Sint: "rg32sint",
	RG32Float: "rg32float",
	RGBA16Uint: "rgba16uint",
	RGBA16Sint: "rgba16sint",
	RGBA16Float: "rgba16float",
	RGBA32Uint: "rgba32uint",
	RGBA32Sint: "rgba32sint",
	RGBA32Float: "rgba32float",
	Depth16Unorm: "depth16unorm",
	Depth24Plus: "depth24plus",
	Depth24PlusStencil8: "depth24plus-stencil8",
	Depth32Float: "depth32float",
	Depth32FloatStencil8: "depth32float-stencil8",
	BC1RGBAUnorm: "bc1-rgba-unorm",
	BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
	BC2RGBAUnorm: "bc2-rgba-unorm",
	BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
	BC3RGBAUnorm: "bc3-rgba-unorm",
	BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
	BC4RUnorm: "bc4-r-unorm",
	BC4RSnorm: "bc4-r-snorm",
	BC5RGUnorm: "bc5-rg-unorm",
	BC5RGSnorm: "bc5-rg-snorm",
	BC6HRGBUFloat: "bc6h-rgb-ufloat",
	BC6HRGBFloat: "bc6h-rgb-float",
	BC7RGBAUnorm: "bc7-rgba-unorm",
	BC7RGBAUnormSRGB: "bc7-rgba-unorm-srgb",
	ETC2RGB8Unorm: "etc2-rgb8unorm",
	ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
	ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
	ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
	ETC2RGBA8Unorm: "etc2-rgba8unorm",
	ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
	EACR11Unorm: "eac-r11unorm",
	EACR11Snorm: "eac-r11snorm",
	EACRG11Unorm: "eac-rg11unorm",
	EACRG11Snorm: "eac-rg11snorm",
	ASTC4x4Unorm: "astc-4x4-unorm",
	ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
	ASTC5x4Unorm: "astc-5x4-unorm",
	ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
	ASTC5x5Unorm: "astc-5x5-unorm",
	ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
	ASTC6x5Unorm: "astc-6x5-unorm",
	ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
	ASTC6x6Unorm: "astc-6x6-unorm",
	ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
	ASTC8x5Unorm: "astc-8x5-unorm",
	ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
	ASTC8x6Unorm: "astc-8x6-unorm",
	ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
	ASTC8x8Unorm: "astc-8x8-unorm",
	ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
	ASTC10x5Unorm: "astc-10x5-unorm",
	ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
	ASTC10x6Unorm: "astc-10x6-unorm",
	ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
	ASTC10x8Unorm: "astc-10x8-unorm",
	ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
	ASTC10x10Unorm: "astc-10x10-unorm",
	ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
	ASTC12x10Unorm: "astc-12x10-unorm",
	ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
	ASTC12x12Unorm: "astc-12x12-unorm",
	ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
};
var GPUAddressMode = {
	ClampToEdge: "clamp-to-edge",
	Repeat: "repeat",
	MirrorRepeat: "mirror-repeat"
};
var GPUFilterMode = {
	Linear: "linear",
	Nearest: "nearest"
};
var GPUBlendFactor = {
	Zero: "zero",
	One: "one",
	Src: "src",
	OneMinusSrc: "one-minus-src",
	SrcAlpha: "src-alpha",
	OneMinusSrcAlpha: "one-minus-src-alpha",
	Dst: "dst",
	OneMinusDst: "one-minus-dst",
	DstAlpha: "dst-alpha",
	OneMinusDstAlpha: "one-minus-dst-alpha",
	SrcAlphaSaturated: "src-alpha-saturated",
	Constant: "constant",
	OneMinusConstant: "one-minus-constant"
};
var GPUBlendOperation = {
	Add: "add",
	Subtract: "subtract",
	ReverseSubtract: "reverse-subtract",
	Min: "min",
	Max: "max"
};
var GPUColorWriteFlags = {
	None: 0,
	All: 15
};
var GPUStencilOperation = {
	Keep: "keep",
	Zero: "zero",
	Replace: "replace",
	Invert: "invert",
	IncrementClamp: "increment-clamp",
	DecrementClamp: "decrement-clamp",
	IncrementWrap: "increment-wrap",
	DecrementWrap: "decrement-wrap"
};
var GPUBufferBindingType = {
	Storage: "storage",
	ReadOnlyStorage: "read-only-storage"
};
var GPUStorageTextureAccess = {
	WriteOnly: "write-only",
	ReadOnly: "read-only",
	ReadWrite: "read-write"
};
var GPUSamplerBindingType = {
	NonFiltering: "non-filtering",
	Comparison: "comparison"
};
var GPUTextureSampleType = {
	Float: "float",
	UnfilterableFloat: "unfilterable-float",
	Depth: "depth",
	SInt: "sint",
	UInt: "uint"
};
var GPUTextureDimension = {
	TwoD: "2d",
	ThreeD: "3d"
};
var GPUTextureViewDimension = {
	TwoD: "2d",
	TwoDArray: "2d-array",
	Cube: "cube",
	ThreeD: "3d"
};
var GPUTextureAspect = { All: "all" };
var GPUInputStepMode = {
	Vertex: "vertex",
	Instance: "instance"
};
var GPUFeatureName = {
	CoreFeaturesAndLimits: "core-features-and-limits",
	DepthClipControl: "depth-clip-control",
	Depth32FloatStencil8: "depth32float-stencil8",
	TextureCompressionBC: "texture-compression-bc",
	TextureCompressionBCSliced3D: "texture-compression-bc-sliced-3d",
	TextureCompressionETC2: "texture-compression-etc2",
	TextureCompressionASTC: "texture-compression-astc",
	TextureCompressionASTCSliced3D: "texture-compression-astc-sliced-3d",
	TimestampQuery: "timestamp-query",
	IndirectFirstInstance: "indirect-first-instance",
	ShaderF16: "shader-f16",
	RG11B10UFloat: "rg11b10ufloat-renderable",
	BGRA8UNormStorage: "bgra8unorm-storage",
	Float32Filterable: "float32-filterable",
	Float32Blendable: "float32-blendable",
	ClipDistances: "clip-distances",
	DualSourceBlending: "dual-source-blending",
	Subgroups: "subgroups",
	TextureFormatsTier1: "texture-formats-tier1",
	TextureFormatsTier2: "texture-formats-tier2"
};
var GPUFeatureMap = {
	"texture-compression-s3tc": "texture-compression-bc",
	"texture-compression-etc1": "texture-compression-etc2"
};
/**
* A special form of sampler binding type.
* It's texture value is managed by a node object.
*
* @private
* @augments Sampler
*/
var NodeSampler = class extends Sampler {
	/**
	* Constructs a new node-based sampler.
	*
	* @param {string} name - The samplers's name.
	* @param {TextureNode} textureNode - The texture node.
	* @param {UniformGroupNode} groupNode - The uniform group node.
	*/
	constructor(name, textureNode, groupNode) {
		super(name, textureNode ? textureNode.value : null);
		/**
		* The texture node.
		*
		* @type {TextureNode}
		*/
		this.textureNode = textureNode;
		/**
		* The uniform group node.
		*
		* @type {UniformGroupNode}
		*/
		this.groupNode = groupNode;
	}
	/**
	* Updates the texture value of this sampler.
	*
	* @return {boolean} Whether the sampler needs an update or not.
	*/
	update() {
		const { textureNode } = this;
		if (this.texture !== textureNode.value) {
			this.texture = textureNode.value;
			return true;
		}
		return super.update();
	}
};
/**
* Represents a storage buffer binding type.
*
* @private
* @augments Buffer
*/
var StorageBuffer = class extends Buffer {
	/**
	* Constructs a new uniform buffer.
	*
	* @param {string} name - The buffer's name.
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	constructor(name, attribute$2) {
		super(name, attribute$2 ? attribute$2.array : null);
		/**
		* This flag can be used for type testing.
		*
		* @type {BufferAttribute}
		*/
		this.attribute = attribute$2;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isStorageBuffer = true;
	}
};
var _id$10 = 0;
/**
* A special form of storage buffer binding type.
* It's buffer value is managed by a node object.
*
* @private
* @augments StorageBuffer
*/
var NodeStorageBuffer = class extends StorageBuffer {
	/**
	* Constructs a new node-based storage buffer.
	*
	* @param {StorageBufferNode} nodeUniform - The storage buffer node.
	* @param {UniformGroupNode} groupNode - The uniform group node.
	*/
	constructor(nodeUniform, groupNode) {
		super("StorageBuffer_" + _id$10++, nodeUniform ? nodeUniform.value : null);
		/**
		* The node uniform.
		*
		* @type {StorageBufferNode}
		*/
		this.nodeUniform = nodeUniform;
		/**
		* The access type.
		*
		* @type {string}
		*/
		this.access = nodeUniform ? nodeUniform.access : NodeAccess$1.READ_WRITE;
		/**
		* The uniform group node.
		*
		* @type {UniformGroupNode}
		*/
		this.groupNode = groupNode;
	}
	/**
	* The storage buffer.
	*
	* @type {BufferAttribute}
	*/
	get buffer() {
		return this.nodeUniform.value;
	}
};
/**
* A WebGPU backend utility module used by {@link WebGPUTextureUtils}.
*
* @private
*/
var WebGPUTexturePassUtils = class extends DataMap {
	/**
	* Constructs a new utility object.
	*
	* @param {GPUDevice} device - The WebGPU device.
	*/
	constructor(device) {
		super();
		/**
		* The WebGPU device.
		*
		* @type {GPUDevice}
		*/
		this.device = device;
		const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;
		const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;
		const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
		/**
		* The mipmap GPU sampler.
		*
		* @type {GPUSampler}
		*/
		this.mipmapSampler = device.createSampler({ minFilter: GPUFilterMode.Linear });
		/**
		* The flipY GPU sampler.
		*
		* @type {GPUSampler}
		*/
		this.flipYSampler = device.createSampler({ minFilter: GPUFilterMode.Nearest });
		/**
		* A cache for GPU render pipelines used for copy/transfer passes.
		* Every texture format requires a unique pipeline.
		*
		* @type {Object<string,GPURenderPipeline>}
		*/
		this.transferPipelines = {};
		/**
		* A cache for GPU render pipelines used for flipY passes.
		* Every texture format requires a unique pipeline.
		*
		* @type {Object<string,GPURenderPipeline>}
		*/
		this.flipYPipelines = {};
		/**
		* The mipmap vertex shader module.
		*
		* @type {GPUShaderModule}
		*/
		this.mipmapVertexShaderModule = device.createShaderModule({
			label: "mipmapVertex",
			code: mipmapVertexSource
		});
		/**
		* The mipmap fragment shader module.
		*
		* @type {GPUShaderModule}
		*/
		this.mipmapFragmentShaderModule = device.createShaderModule({
			label: "mipmapFragment",
			code: mipmapFragmentSource
		});
		/**
		* The flipY fragment shader module.
		*
		* @type {GPUShaderModule}
		*/
		this.flipYFragmentShaderModule = device.createShaderModule({
			label: "flipYFragment",
			code: flipYFragmentSource
		});
	}
	/**
	* Returns a render pipeline for the internal copy render pass. The pass
	* requires a unique render pipeline for each texture format.
	*
	* @param {string} format - The GPU texture format
	* @return {GPURenderPipeline} The GPU render pipeline.
	*/
	getTransferPipeline(format) {
		let pipeline = this.transferPipelines[format];
		if (pipeline === void 0) {
			pipeline = this.device.createRenderPipeline({
				label: `mipmap-${format}`,
				vertex: {
					module: this.mipmapVertexShaderModule,
					entryPoint: "main"
				},
				fragment: {
					module: this.mipmapFragmentShaderModule,
					entryPoint: "main",
					targets: [{ format }]
				},
				primitive: {
					topology: GPUPrimitiveTopology.TriangleStrip,
					stripIndexFormat: GPUIndexFormat.Uint32
				},
				layout: "auto"
			});
			this.transferPipelines[format] = pipeline;
		}
		return pipeline;
	}
	/**
	* Returns a render pipeline for the flipY render pass. The pass
	* requires a unique render pipeline for each texture format.
	*
	* @param {string} format - The GPU texture format
	* @return {GPURenderPipeline} The GPU render pipeline.
	*/
	getFlipYPipeline(format) {
		let pipeline = this.flipYPipelines[format];
		if (pipeline === void 0) {
			pipeline = this.device.createRenderPipeline({
				label: `flipY-${format}`,
				vertex: {
					module: this.mipmapVertexShaderModule,
					entryPoint: "main"
				},
				fragment: {
					module: this.flipYFragmentShaderModule,
					entryPoint: "main",
					targets: [{ format }]
				},
				primitive: {
					topology: GPUPrimitiveTopology.TriangleStrip,
					stripIndexFormat: GPUIndexFormat.Uint32
				},
				layout: "auto"
			});
			this.flipYPipelines[format] = pipeline;
		}
		return pipeline;
	}
	/**
	* Flip the contents of the given GPU texture along its vertical axis.
	*
	* @param {GPUTexture} textureGPU - The GPU texture object.
	* @param {Object} textureGPUDescriptor - The texture descriptor.
	* @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
	*/
	flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
		const format = textureGPUDescriptor.format;
		const { width, height } = textureGPUDescriptor.size;
		const transferPipeline = this.getTransferPipeline(format);
		const flipYPipeline = this.getFlipYPipeline(format);
		const tempTexture = this.device.createTexture({
			size: {
				width,
				height,
				depthOrArrayLayers: 1
			},
			format,
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
		});
		const srcView = textureGPU.createView({
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer
		});
		const dstView = tempTexture.createView({
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer: 0
		});
		const commandEncoder = this.device.createCommandEncoder({});
		const pass$2 = (pipeline, sourceView, destinationView) => {
			const bindGroupLayout = pipeline.getBindGroupLayout(0);
			const bindGroup = this.device.createBindGroup({
				layout: bindGroupLayout,
				entries: [{
					binding: 0,
					resource: this.flipYSampler
				}, {
					binding: 1,
					resource: sourceView
				}]
			});
			const passEncoder = commandEncoder.beginRenderPass({ colorAttachments: [{
				view: destinationView,
				loadOp: GPULoadOp.Clear,
				storeOp: GPUStoreOp.Store,
				clearValue: [
					0,
					0,
					0,
					0
				]
			}] });
			passEncoder.setPipeline(pipeline);
			passEncoder.setBindGroup(0, bindGroup);
			passEncoder.draw(4, 1, 0, 0);
			passEncoder.end();
		};
		pass$2(transferPipeline, srcView, dstView);
		pass$2(flipYPipeline, dstView, srcView);
		this.device.queue.submit([commandEncoder.finish()]);
		tempTexture.destroy();
	}
	/**
	* Generates mipmaps for the given GPU texture.
	*
	* @param {GPUTexture} textureGPU - The GPU texture object.
	* @param {Object} textureGPUDescriptor - The texture descriptor.
	* @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
	* @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.
	*/
	generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0, encoder = null) {
		const textureData = this.get(textureGPU);
		if (textureData.layers === void 0) textureData.layers = [];
		const passes = textureData.layers[baseArrayLayer] || this._mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer);
		const commandEncoder = encoder || this.device.createCommandEncoder({ label: "mipmapEncoder" });
		this._mipmapRunBundles(commandEncoder, passes);
		if (encoder === null) this.device.queue.submit([commandEncoder.finish()]);
		textureData.layers[baseArrayLayer] = passes;
	}
	/**
	* Since multiple copy render passes are required to generate mipmaps, the passes
	* are managed as render bundles to improve performance.
	*
	* @param {GPUTexture} textureGPU - The GPU texture object.
	* @param {Object} textureGPUDescriptor - The texture descriptor.
	* @param {number} baseArrayLayer - The index of the first array layer accessible to the texture view.
	* @return {Array<Object>} An array of render bundles.
	*/
	_mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer) {
		const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);
		const bindGroupLayout = pipeline.getBindGroupLayout(0);
		let srcView = textureGPU.createView({
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer
		});
		const passes = [];
		for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {
			const bindGroup = this.device.createBindGroup({
				layout: bindGroupLayout,
				entries: [{
					binding: 0,
					resource: this.mipmapSampler
				}, {
					binding: 1,
					resource: srcView
				}]
			});
			const dstView = textureGPU.createView({
				baseMipLevel: i,
				mipLevelCount: 1,
				dimension: GPUTextureViewDimension.TwoD,
				baseArrayLayer
			});
			const passDescriptor = { colorAttachments: [{
				view: dstView,
				loadOp: GPULoadOp.Clear,
				storeOp: GPUStoreOp.Store,
				clearValue: [
					0,
					0,
					0,
					0
				]
			}] };
			const passEncoder = this.device.createRenderBundleEncoder({ colorFormats: [textureGPUDescriptor.format] });
			passEncoder.setPipeline(pipeline);
			passEncoder.setBindGroup(0, bindGroup);
			passEncoder.draw(4, 1, 0, 0);
			passes.push({
				renderBundles: [passEncoder.finish()],
				passDescriptor
			});
			srcView = dstView;
		}
		return passes;
	}
	/**
	* Executes the render bundles.
	*
	* @param {GPUCommandEncoder} commandEncoder - The GPU command encoder.
	* @param {Array<Object>} passes - An array of render bundles.
	*/
	_mipmapRunBundles(commandEncoder, passes) {
		const levels = passes.length;
		for (let i = 0; i < levels; i++) {
			const pass$2 = passes[i];
			const passEncoder = commandEncoder.beginRenderPass(pass$2.passDescriptor);
			passEncoder.executeBundles(pass$2.renderBundles);
			passEncoder.end();
		}
	}
};
var _compareToWebGPU = {
	[NeverCompare]: "never",
	[LessCompare]: "less",
	[EqualCompare]: "equal",
	[LessEqualCompare]: "less-equal",
	[GreaterCompare]: "greater",
	[GreaterEqualCompare]: "greater-equal",
	[AlwaysCompare]: "always",
	[NotEqualCompare]: "not-equal"
};
var _flipMap = [
	0,
	1,
	3,
	2,
	4,
	5
];
/**
* A WebGPU backend utility module for managing textures.
*
* @private
*/
var WebGPUTextureUtils = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGPUBackend} backend - The WebGPU backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGPU backend.
		*
		* @type {WebGPUBackend}
		*/
		this.backend = backend;
		/**
		* A reference to the pass utils.
		*
		* @type {?WebGPUTexturePassUtils}
		* @default null
		*/
		this._passUtils = null;
		/**
		* A dictionary for managing default textures. The key
		* is the texture format, the value the texture object.
		*
		* @type {Object<string,Texture>}
		*/
		this.defaultTexture = {};
		/**
		* A dictionary for managing default cube textures. The key
		* is the texture format, the value the texture object.
		*
		* @type {Object<string,CubeTexture>}
		*/
		this.defaultCubeTexture = {};
		/**
		* A default video frame.
		*
		* @type {?VideoFrame}
		* @default null
		*/
		this.defaultVideoFrame = null;
		/**
		* A cache of shared texture samplers.
		*
		* @type {Map<string, Object>}
		*/
		this._samplerCache = /* @__PURE__ */ new Map();
	}
	/**
	* Creates a GPU sampler for the given texture.
	*
	* @param {Texture} texture - The texture to create the sampler for.
	* @return {string} The current sampler key.
	*/
	updateSampler(texture$2) {
		const backend = this.backend;
		const samplerKey = texture$2.minFilter + "-" + texture$2.magFilter + "-" + texture$2.wrapS + "-" + texture$2.wrapT + "-" + (texture$2.wrapR || "0") + "-" + texture$2.anisotropy + "-" + (texture$2.compareFunction || 0);
		let samplerData = this._samplerCache.get(samplerKey);
		if (samplerData === void 0) {
			const samplerDescriptorGPU = {
				addressModeU: this._convertAddressMode(texture$2.wrapS),
				addressModeV: this._convertAddressMode(texture$2.wrapT),
				addressModeW: this._convertAddressMode(texture$2.wrapR),
				magFilter: this._convertFilterMode(texture$2.magFilter),
				minFilter: this._convertFilterMode(texture$2.minFilter),
				mipmapFilter: this._convertFilterMode(texture$2.minFilter),
				maxAnisotropy: 1
			};
			if (samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear) samplerDescriptorGPU.maxAnisotropy = texture$2.anisotropy;
			if (texture$2.isDepthTexture && texture$2.compareFunction !== null) samplerDescriptorGPU.compare = _compareToWebGPU[texture$2.compareFunction];
			samplerData = {
				sampler: backend.device.createSampler(samplerDescriptorGPU),
				usedTimes: 0
			};
			this._samplerCache.set(samplerKey, samplerData);
		}
		const textureData = backend.get(texture$2);
		if (textureData.sampler !== samplerData.sampler) {
			if (textureData.sampler !== void 0) {
				const oldSamplerData = this._samplerCache.get(textureData.samplerKey);
				oldSamplerData.usedTimes--;
				if (oldSamplerData.usedTimes === 0) this._samplerCache.delete(textureData.samplerKey);
			}
			textureData.samplerKey = samplerKey;
			textureData.sampler = samplerData.sampler;
			samplerData.usedTimes++;
		}
		return samplerKey;
	}
	/**
	* Creates a default texture for the given texture that can be used
	* as a placeholder until the actual texture is ready for usage.
	*
	* @param {Texture} texture - The texture to create a default texture for.
	*/
	createDefaultTexture(texture$2) {
		let textureGPU;
		const format = getFormat(texture$2);
		if (texture$2.isCubeTexture) textureGPU = this._getDefaultCubeTextureGPU(format);
		else textureGPU = this._getDefaultTextureGPU(format);
		this.backend.get(texture$2).texture = textureGPU;
	}
	/**
	* Defines a texture on the GPU for the given texture object.
	*
	* @param {Texture} texture - The texture.
	* @param {Object} [options={}] - Optional configuration parameter.
	*/
	createTexture(texture$2, options = {}) {
		const backend = this.backend;
		const textureData = backend.get(texture$2);
		if (textureData.initialized) throw new Error("WebGPUTextureUtils: Texture already initialized.");
		if (texture$2.isExternalTexture) {
			textureData.texture = texture$2.sourceTexture;
			textureData.initialized = true;
			return;
		}
		if (options.needsMipmaps === void 0) options.needsMipmaps = false;
		if (options.levels === void 0) options.levels = 1;
		if (options.depth === void 0) options.depth = 1;
		const { width, height, depth: depth$2, levels } = options;
		if (texture$2.isFramebufferTexture) if (options.renderTarget) options.format = this.backend.utils.getCurrentColorFormat(options.renderTarget);
		else options.format = this.backend.utils.getPreferredCanvasFormat();
		const dimension = this._getDimension(texture$2);
		const format = texture$2.internalFormat || options.format || getFormat(texture$2, backend.device);
		textureData.format = format;
		const { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData(texture$2);
		let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
		if (texture$2.isStorageTexture === true) usage |= GPUTextureUsage.STORAGE_BINDING;
		if (texture$2.isCompressedTexture !== true && texture$2.isCompressedArrayTexture !== true && format !== GPUTextureFormat.RGB9E5UFloat) usage |= GPUTextureUsage.RENDER_ATTACHMENT;
		const textureDescriptorGPU = {
			label: texture$2.name,
			size: {
				width,
				height,
				depthOrArrayLayers: depth$2
			},
			mipLevelCount: levels,
			sampleCount: primarySamples,
			dimension,
			format,
			usage
		};
		if (format === void 0) {
			warn("WebGPURenderer: Texture format not supported.");
			this.createDefaultTexture(texture$2);
			return;
		}
		if (texture$2.isCubeTexture) textureDescriptorGPU.textureBindingViewDimension = GPUTextureViewDimension.Cube;
		textureData.texture = backend.device.createTexture(textureDescriptorGPU);
		if (isMSAA) {
			const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);
			msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + "-msaa";
			msaaTextureDescriptorGPU.sampleCount = samples;
			msaaTextureDescriptorGPU.mipLevelCount = 1;
			textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);
		}
		textureData.initialized = true;
		textureData.textureDescriptorGPU = textureDescriptorGPU;
	}
	/**
	* Destroys the GPU data for the given texture object.
	*
	* @param {Texture} texture - The texture.
	* @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
	*/
	destroyTexture(texture$2, isDefaultTexture = false) {
		const backend = this.backend;
		const textureData = backend.get(texture$2);
		if (textureData.texture !== void 0 && isDefaultTexture === false) textureData.texture.destroy();
		if (textureData.msaaTexture !== void 0) textureData.msaaTexture.destroy();
		backend.delete(texture$2);
	}
	/**
	* Generates mipmaps for the given texture.
	*
	* @param {Texture} texture - The texture.
	* @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.
	*/
	generateMipmaps(texture$2, encoder = null) {
		const textureData = this.backend.get(texture$2);
		if (texture$2.isCubeTexture) for (let i = 0; i < 6; i++) this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i, encoder);
		else {
			const depth$2 = texture$2.image.depth || 1;
			for (let i = 0; i < depth$2; i++) this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i, encoder);
		}
	}
	/**
	* Returns the color buffer representing the color
	* attachment of the default framebuffer.
	*
	* @return {GPUTexture} The color buffer.
	*/
	getColorBuffer() {
		const backend = this.backend;
		const canvasTarget = backend.renderer.getCanvasTarget();
		const { width, height } = backend.getDrawingBufferSize();
		const samples = backend.renderer.currentSamples;
		const colorTexture = canvasTarget.colorTexture;
		const colorTextureData = backend.get(colorTexture);
		if (colorTexture.width === width && colorTexture.height === height && colorTexture.samples === samples) return colorTextureData.texture;
		let colorBuffer = colorTextureData.texture;
		if (colorBuffer) colorBuffer.destroy();
		colorBuffer = backend.device.createTexture({
			label: "colorBuffer",
			size: {
				width,
				height,
				depthOrArrayLayers: 1
			},
			sampleCount: backend.utils.getSampleCount(backend.renderer.currentSamples),
			format: backend.utils.getPreferredCanvasFormat(),
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
		});
		colorTexture.source.width = width;
		colorTexture.source.height = height;
		colorTexture.samples = samples;
		colorTextureData.texture = colorBuffer;
		return colorBuffer;
	}
	/**
	* Returns the depth buffer representing the depth
	* attachment of the default framebuffer.
	*
	* @param {boolean} [depth=true] - Whether depth is enabled or not.
	* @param {boolean} [stencil=false] -  Whether stencil is enabled or not.
	* @return {GPUTexture} The depth buffer.
	*/
	getDepthBuffer(depth$2 = true, stencil = false) {
		const backend = this.backend;
		const canvasTarget = backend.renderer.getCanvasTarget();
		const { width, height } = backend.getDrawingBufferSize();
		const samples = backend.renderer.currentSamples;
		const depthTexture = canvasTarget.depthTexture;
		if (depthTexture.width === width && depthTexture.height === height && depthTexture.samples === samples && depthTexture.depth === depth$2 && depthTexture.stencil === stencil) return backend.get(depthTexture).texture;
		const depthTextureGPU = backend.get(depthTexture).texture;
		let format, type$1;
		if (stencil) {
			format = DepthStencilFormat;
			type$1 = UnsignedInt248Type;
		} else if (depth$2) {
			format = DepthFormat;
			type$1 = UnsignedIntType;
		}
		if (depthTextureGPU !== void 0) {
			if (depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type$1 && depthTexture.samples === samples) return depthTextureGPU;
			this.destroyTexture(depthTexture);
		}
		depthTexture.name = "depthBuffer";
		depthTexture.format = format;
		depthTexture.type = type$1;
		depthTexture.image.width = width;
		depthTexture.image.height = height;
		depthTexture.samples = samples;
		this.createTexture(depthTexture, {
			width,
			height
		});
		return backend.get(depthTexture).texture;
	}
	/**
	* Uploads the updated texture data to the GPU.
	*
	* @param {Texture} texture - The texture.
	* @param {Object} [options={}] - Optional configuration parameter.
	*/
	updateTexture(texture$2, options) {
		const textureData = this.backend.get(texture$2);
		const mipmaps = texture$2.mipmaps;
		const { textureDescriptorGPU } = textureData;
		if (texture$2.isRenderTargetTexture || textureDescriptorGPU === void 0) return;
		if (texture$2.isDataTexture) if (mipmaps.length > 0) for (let i = 0, il = mipmaps.length; i < il; i++) {
			const mipmap = mipmaps[i];
			this._copyBufferToTexture(mipmap, textureData.texture, textureDescriptorGPU, 0, texture$2.flipY, 0, i);
		}
		else this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture$2.flipY);
		else if (texture$2.isArrayTexture || texture$2.isDataArrayTexture || texture$2.isData3DTexture) for (let i = 0; i < options.image.depth; i++) this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, i, texture$2.flipY, i);
		else if (texture$2.isCompressedTexture || texture$2.isCompressedArrayTexture) this._copyCompressedBufferToTexture(texture$2.mipmaps, textureData.texture, textureDescriptorGPU);
		else if (texture$2.isCubeTexture) this._copyCubeMapToTexture(texture$2, textureData.texture, textureDescriptorGPU);
		else if (mipmaps.length > 0) for (let i = 0, il = mipmaps.length; i < il; i++) {
			const mipmap = mipmaps[i];
			this._copyImageToTexture(mipmap, textureData.texture, textureDescriptorGPU, 0, texture$2.flipY, texture$2.premultiplyAlpha, i);
		}
		else this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture$2.flipY, texture$2.premultiplyAlpha);
		textureData.version = texture$2.version;
	}
	/**
	* Returns texture data as a typed array.
	*
	* @async
	* @param {Texture} texture - The texture to copy.
	* @param {number} x - The x coordinate of the copy origin.
	* @param {number} y - The y coordinate of the copy origin.
	* @param {number} width - The width of the copy.
	* @param {number} height - The height of the copy.
	* @param {number} faceIndex - The face index.
	* @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
	*/
	async copyTextureToBuffer(texture$2, x, y, width, height, faceIndex) {
		const device = this.backend.device;
		const textureData = this.backend.get(texture$2);
		const textureGPU = textureData.texture;
		const format = textureData.textureDescriptorGPU.format;
		const bytesPerTexel = this._getBytesPerTexel(format);
		let bytesPerRow = width * bytesPerTexel;
		bytesPerRow = Math.ceil(bytesPerRow / 256) * 256;
		const readBuffer = device.createBuffer({
			size: (height - 1) * bytesPerRow + width * bytesPerTexel,
			usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
		});
		const encoder = device.createCommandEncoder();
		encoder.copyTextureToBuffer({
			texture: textureGPU,
			origin: {
				x,
				y,
				z: faceIndex
			}
		}, {
			buffer: readBuffer,
			bytesPerRow
		}, {
			width,
			height
		});
		const typedArrayType = this._getTypedArrayType(format);
		device.queue.submit([encoder.finish()]);
		await readBuffer.mapAsync(GPUMapMode.READ);
		const buffer$2 = readBuffer.getMappedRange();
		return new typedArrayType(buffer$2);
	}
	/**
	* Frees all internal resources.
	*/
	dispose() {
		this._samplerCache.clear();
	}
	/**
	* Returns the default GPU texture for the given format.
	*
	* @private
	* @param {string} format - The GPU format.
	* @return {GPUTexture} The GPU texture.
	*/
	_getDefaultTextureGPU(format) {
		let defaultTexture = this.defaultTexture[format];
		if (defaultTexture === void 0) {
			const texture$2 = new Texture();
			texture$2.minFilter = NearestFilter;
			texture$2.magFilter = NearestFilter;
			this.createTexture(texture$2, {
				width: 1,
				height: 1,
				format
			});
			this.defaultTexture[format] = defaultTexture = texture$2;
		}
		return this.backend.get(defaultTexture).texture;
	}
	/**
	* Returns the default GPU cube texture for the given format.
	*
	* @private
	* @param {string} format - The GPU format.
	* @return {GPUTexture} The GPU texture.
	*/
	_getDefaultCubeTextureGPU(format) {
		let defaultCubeTexture = this.defaultTexture[format];
		if (defaultCubeTexture === void 0) {
			const texture$2 = new CubeTexture();
			texture$2.minFilter = NearestFilter;
			texture$2.magFilter = NearestFilter;
			this.createTexture(texture$2, {
				width: 1,
				height: 1,
				depth: 6
			});
			this.defaultCubeTexture[format] = defaultCubeTexture = texture$2;
		}
		return this.backend.get(defaultCubeTexture).texture;
	}
	/**
	* Uploads cube texture image data to the GPU memory.
	*
	* @private
	* @param {CubeTexture} texture - The cube texture.
	* @param {GPUTexture} textureGPU - The GPU texture.
	* @param {Object} textureDescriptorGPU - The GPU texture descriptor.
	*/
	_copyCubeMapToTexture(texture$2, textureGPU, textureDescriptorGPU) {
		const images = texture$2.images;
		const mipmaps = texture$2.mipmaps;
		for (let i = 0; i < 6; i++) {
			const image = images[i];
			const flipIndex = texture$2.flipY === true ? _flipMap[i] : i;
			if (image.isDataTexture) this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, texture$2.flipY);
			else this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, texture$2.flipY, texture$2.premultiplyAlpha);
			for (let j = 0; j < mipmaps.length; j++) {
				const image$1 = mipmaps[j].images[i];
				if (image$1.isDataTexture) this._copyBufferToTexture(image$1.image, textureGPU, textureDescriptorGPU, flipIndex, texture$2.flipY, 0, j + 1);
				else this._copyImageToTexture(image$1, textureGPU, textureDescriptorGPU, flipIndex, texture$2.flipY, texture$2.premultiplyAlpha, j + 1);
			}
		}
	}
	/**
	* Uploads texture image data to the GPU memory.
	*
	* @private
	* @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.
	* @param {GPUTexture} textureGPU - The GPU texture.
	* @param {Object} textureDescriptorGPU - The GPU texture descriptor.
	* @param {number} originDepth - The origin depth.
	* @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
	* @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.
	* @param {number} [mipLevel=0] - The mip level where the data should be copied to.
	*/
	_copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, premultiplyAlpha$2, mipLevel = 0) {
		const device = this.backend.device;
		const width = mipLevel > 0 ? image.width : textureDescriptorGPU.size.width;
		const height = mipLevel > 0 ? image.height : textureDescriptorGPU.size.height;
		device.queue.copyExternalImageToTexture({
			source: image,
			flipY
		}, {
			texture: textureGPU,
			mipLevel,
			origin: {
				x: 0,
				y: 0,
				z: originDepth
			},
			premultipliedAlpha: premultiplyAlpha$2
		}, {
			width,
			height,
			depthOrArrayLayers: 1
		});
	}
	/**
	* Returns the pass utils singleton.
	*
	* @private
	* @return {WebGPUTexturePassUtils} The utils instance.
	*/
	_getPassUtils() {
		let passUtils = this._passUtils;
		if (passUtils === null) this._passUtils = passUtils = new WebGPUTexturePassUtils(this.backend.device);
		return passUtils;
	}
	/**
	* Generates mipmaps for the given GPU texture.
	*
	* @private
	* @param {GPUTexture} textureGPU - The GPU texture object.
	* @param {Object} textureDescriptorGPU - The texture descriptor.
	* @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
	* @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.
	*/
	_generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0, encoder = null) {
		this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer, encoder);
	}
	/**
	* Flip the contents of the given GPU texture along its vertical axis.
	*
	* @private
	* @param {GPUTexture} textureGPU - The GPU texture object.
	* @param {Object} textureDescriptorGPU - The texture descriptor.
	* @param {number} [originDepth=0] - The origin depth.
	*/
	_flipY(textureGPU, textureDescriptorGPU, originDepth = 0) {
		this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);
	}
	/**
	* Uploads texture buffer data to the GPU memory.
	*
	* @private
	* @param {Object} image - An object defining the image buffer data.
	* @param {GPUTexture} textureGPU - The GPU texture.
	* @param {Object} textureDescriptorGPU - The GPU texture descriptor.
	* @param {number} originDepth - The origin depth.
	* @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
	* @param {number} [depth=0] - The depth offset when copying array or 3D texture data.
	* @param {number} [mipLevel=0] - The mip level where the data should be copied to.
	*/
	_copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth$2 = 0, mipLevel = 0) {
		const device = this.backend.device;
		const data = image.data;
		const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);
		const bytesPerRow = image.width * bytesPerTexel;
		device.queue.writeTexture({
			texture: textureGPU,
			mipLevel,
			origin: {
				x: 0,
				y: 0,
				z: originDepth
			}
		}, data, {
			offset: image.width * image.height * bytesPerTexel * depth$2,
			bytesPerRow
		}, {
			width: image.width,
			height: image.height,
			depthOrArrayLayers: 1
		});
		if (flipY === true) this._flipY(textureGPU, textureDescriptorGPU, originDepth);
	}
	/**
	* Uploads compressed texture data to the GPU memory.
	*
	* @private
	* @param {Array<Object>} mipmaps - An array with mipmap data.
	* @param {GPUTexture} textureGPU - The GPU texture.
	* @param {Object} textureDescriptorGPU - The GPU texture descriptor.
	*/
	_copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {
		const device = this.backend.device;
		const blockData = this._getBlockData(textureDescriptorGPU.format);
		const isArrayTexture = textureDescriptorGPU.size.depthOrArrayLayers > 1;
		for (let i = 0; i < mipmaps.length; i++) {
			const mipmap = mipmaps[i];
			const width = mipmap.width;
			const height = mipmap.height;
			const depth$2 = isArrayTexture ? textureDescriptorGPU.size.depthOrArrayLayers : 1;
			const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;
			const bytesPerImage = bytesPerRow * Math.ceil(height / blockData.height);
			for (let j = 0; j < depth$2; j++) device.queue.writeTexture({
				texture: textureGPU,
				mipLevel: i,
				origin: {
					x: 0,
					y: 0,
					z: j
				}
			}, mipmap.data, {
				offset: j * bytesPerImage,
				bytesPerRow,
				rowsPerImage: Math.ceil(height / blockData.height)
			}, {
				width: Math.ceil(width / blockData.width) * blockData.width,
				height: Math.ceil(height / blockData.height) * blockData.height,
				depthOrArrayLayers: 1
			});
		}
	}
	/**
	* This method is only relevant for compressed texture formats. It returns a block
	* data descriptor for the given GPU compressed texture format.
	*
	* @private
	* @param {string} format - The GPU compressed texture format.
	* @return {Object} The block data descriptor.
	*/
	_getBlockData(format) {
		if (format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB) return {
			byteLength: 8,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB) return {
			byteLength: 16,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB) return {
			byteLength: 16,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSnorm) return {
			byteLength: 8,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm) return {
			byteLength: 16,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat) return {
			byteLength: 16,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB) return {
			byteLength: 16,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB) return {
			byteLength: 8,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB) return {
			byteLength: 8,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB) return {
			byteLength: 16,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.EACR11Unorm) return {
			byteLength: 8,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.EACR11Snorm) return {
			byteLength: 8,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.EACRG11Unorm) return {
			byteLength: 16,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.EACRG11Snorm) return {
			byteLength: 16,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB) return {
			byteLength: 16,
			width: 4,
			height: 4
		};
		if (format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB) return {
			byteLength: 16,
			width: 5,
			height: 4
		};
		if (format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB) return {
			byteLength: 16,
			width: 5,
			height: 5
		};
		if (format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB) return {
			byteLength: 16,
			width: 6,
			height: 5
		};
		if (format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB) return {
			byteLength: 16,
			width: 6,
			height: 6
		};
		if (format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB) return {
			byteLength: 16,
			width: 8,
			height: 5
		};
		if (format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB) return {
			byteLength: 16,
			width: 8,
			height: 6
		};
		if (format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB) return {
			byteLength: 16,
			width: 8,
			height: 8
		};
		if (format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB) return {
			byteLength: 16,
			width: 10,
			height: 5
		};
		if (format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB) return {
			byteLength: 16,
			width: 10,
			height: 6
		};
		if (format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB) return {
			byteLength: 16,
			width: 10,
			height: 8
		};
		if (format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB) return {
			byteLength: 16,
			width: 10,
			height: 10
		};
		if (format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB) return {
			byteLength: 16,
			width: 12,
			height: 10
		};
		if (format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB) return {
			byteLength: 16,
			width: 12,
			height: 12
		};
	}
	/**
	* Converts the three.js uv wrapping constants to GPU address mode constants.
	*
	* @private
	* @param {number} value - The three.js constant defining a uv wrapping mode.
	* @return {string} The GPU address mode.
	*/
	_convertAddressMode(value) {
		let addressMode = GPUAddressMode.ClampToEdge;
		if (value === RepeatWrapping) addressMode = GPUAddressMode.Repeat;
		else if (value === MirroredRepeatWrapping) addressMode = GPUAddressMode.MirrorRepeat;
		return addressMode;
	}
	/**
	* Converts the three.js filter constants to GPU filter constants.
	*
	* @private
	* @param {number} value - The three.js constant defining a filter mode.
	* @return {string} The GPU filter mode.
	*/
	_convertFilterMode(value) {
		let filterMode = GPUFilterMode.Linear;
		if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) filterMode = GPUFilterMode.Nearest;
		return filterMode;
	}
	/**
	* Returns the bytes-per-texel value for the given GPU texture format.
	*
	* @private
	* @param {string} format - The GPU texture format.
	* @return {number} The bytes-per-texel.
	*/
	_getBytesPerTexel(format) {
		if (format === GPUTextureFormat.R8Unorm || format === GPUTextureFormat.R8Snorm || format === GPUTextureFormat.R8Uint || format === GPUTextureFormat.R8Sint) return 1;
		if (format === GPUTextureFormat.R16Uint || format === GPUTextureFormat.R16Sint || format === GPUTextureFormat.R16Float || format === GPUTextureFormat.RG8Unorm || format === GPUTextureFormat.RG8Snorm || format === GPUTextureFormat.RG8Uint || format === GPUTextureFormat.RG8Sint) return 2;
		if (format === GPUTextureFormat.R32Uint || format === GPUTextureFormat.R32Sint || format === GPUTextureFormat.R32Float || format === GPUTextureFormat.RG16Uint || format === GPUTextureFormat.RG16Sint || format === GPUTextureFormat.RG16Float || format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB || format === GPUTextureFormat.RGBA8Snorm || format === GPUTextureFormat.RGBA8Uint || format === GPUTextureFormat.RGBA8Sint || format === GPUTextureFormat.BGRA8Unorm || format === GPUTextureFormat.BGRA8UnormSRGB || format === GPUTextureFormat.RGB9E5UFloat || format === GPUTextureFormat.RGB10A2Unorm || format === GPUTextureFormat.RG11B10UFloat || format === GPUTextureFormat.Depth32Float || format === GPUTextureFormat.Depth24Plus || format === GPUTextureFormat.Depth24PlusStencil8 || format === GPUTextureFormat.Depth32FloatStencil8) return 4;
		if (format === GPUTextureFormat.RG32Uint || format === GPUTextureFormat.RG32Sint || format === GPUTextureFormat.RG32Float || format === GPUTextureFormat.RGBA16Uint || format === GPUTextureFormat.RGBA16Sint || format === GPUTextureFormat.RGBA16Float) return 8;
		if (format === GPUTextureFormat.RGBA32Uint || format === GPUTextureFormat.RGBA32Sint || format === GPUTextureFormat.RGBA32Float) return 16;
	}
	/**
	* Returns the corresponding typed array type for the given GPU texture format.
	*
	* @private
	* @param {string} format - The GPU texture format.
	* @return {TypedArray.constructor} The typed array type.
	*/
	_getTypedArrayType(format) {
		if (format === GPUTextureFormat.R8Uint) return Uint8Array;
		if (format === GPUTextureFormat.R8Sint) return Int8Array;
		if (format === GPUTextureFormat.R8Unorm) return Uint8Array;
		if (format === GPUTextureFormat.R8Snorm) return Int8Array;
		if (format === GPUTextureFormat.RG8Uint) return Uint8Array;
		if (format === GPUTextureFormat.RG8Sint) return Int8Array;
		if (format === GPUTextureFormat.RG8Unorm) return Uint8Array;
		if (format === GPUTextureFormat.RG8Snorm) return Int8Array;
		if (format === GPUTextureFormat.RGBA8Uint) return Uint8Array;
		if (format === GPUTextureFormat.RGBA8Sint) return Int8Array;
		if (format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB) return Uint8Array;
		if (format === GPUTextureFormat.RGBA8Snorm) return Int8Array;
		if (format === GPUTextureFormat.R16Uint) return Uint16Array;
		if (format === GPUTextureFormat.R16Sint) return Int16Array;
		if (format === GPUTextureFormat.RG16Uint) return Uint16Array;
		if (format === GPUTextureFormat.RG16Sint) return Int16Array;
		if (format === GPUTextureFormat.RGBA16Uint) return Uint16Array;
		if (format === GPUTextureFormat.RGBA16Sint) return Int16Array;
		if (format === GPUTextureFormat.R16Float) return Uint16Array;
		if (format === GPUTextureFormat.RG16Float) return Uint16Array;
		if (format === GPUTextureFormat.RGBA16Float) return Uint16Array;
		if (format === GPUTextureFormat.R32Uint) return Uint32Array;
		if (format === GPUTextureFormat.R32Sint) return Int32Array;
		if (format === GPUTextureFormat.R32Float) return Float32Array;
		if (format === GPUTextureFormat.RG32Uint) return Uint32Array;
		if (format === GPUTextureFormat.RG32Sint) return Int32Array;
		if (format === GPUTextureFormat.RG32Float) return Float32Array;
		if (format === GPUTextureFormat.RGBA32Uint) return Uint32Array;
		if (format === GPUTextureFormat.RGBA32Sint) return Int32Array;
		if (format === GPUTextureFormat.RGBA32Float) return Float32Array;
		if (format === GPUTextureFormat.BGRA8Unorm || format === GPUTextureFormat.BGRA8UnormSRGB) return Uint8Array;
		if (format === GPUTextureFormat.RGB10A2Unorm) return Uint32Array;
		if (format === GPUTextureFormat.RGB9E5UFloat) return Uint32Array;
		if (format === GPUTextureFormat.RG11B10UFloat) return Uint32Array;
		if (format === GPUTextureFormat.Depth32Float) return Float32Array;
		if (format === GPUTextureFormat.Depth24Plus) return Uint32Array;
		if (format === GPUTextureFormat.Depth24PlusStencil8) return Uint32Array;
		if (format === GPUTextureFormat.Depth32FloatStencil8) return Float32Array;
	}
	/**
	* Returns the GPU dimensions for the given texture.
	*
	* @private
	* @param {Texture} texture - The texture.
	* @return {string} The GPU dimension.
	*/
	_getDimension(texture$2) {
		let dimension;
		if (texture$2.is3DTexture || texture$2.isData3DTexture) dimension = GPUTextureDimension.ThreeD;
		else dimension = GPUTextureDimension.TwoD;
		return dimension;
	}
};
/**
* Returns the GPU format for the given texture.
*
* @param {Texture} texture - The texture.
* @param {?GPUDevice} [device=null] - The GPU device which is used for feature detection.
* It is not necessary to apply the device for most formats.
* @return {string} The GPU format.
*/
function getFormat(texture$2, device = null) {
	const format = texture$2.format;
	const type$1 = texture$2.type;
	const colorSpace = texture$2.colorSpace;
	const transfer = ColorManagement.getTransfer(colorSpace);
	let formatGPU;
	if (texture$2.isCompressedTexture === true || texture$2.isCompressedArrayTexture === true) switch (format) {
		case RGB_S3TC_DXT1_Format:
		case RGBA_S3TC_DXT1_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
			break;
		case RGBA_S3TC_DXT3_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
			break;
		case RGBA_S3TC_DXT5_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
			break;
		case RED_RGTC1_Format:
			formatGPU = GPUTextureFormat.BC4RUnorm;
			break;
		case SIGNED_RED_RGTC1_Format:
			formatGPU = GPUTextureFormat.BC4RSnorm;
			break;
		case RED_GREEN_RGTC2_Format:
			formatGPU = GPUTextureFormat.BC5RGUnorm;
			break;
		case SIGNED_RED_GREEN_RGTC2_Format:
			formatGPU = GPUTextureFormat.BC5RGSnorm;
			break;
		case RGBA_BPTC_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC7RGBAUnormSRGB : GPUTextureFormat.BC7RGBAUnorm;
			break;
		case RGB_ETC2_Format:
		case RGB_ETC1_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
			break;
		case RGBA_ETC2_EAC_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
			break;
		case RGBA_ASTC_4x4_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
			break;
		case RGBA_ASTC_5x4_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
			break;
		case RGBA_ASTC_5x5_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
			break;
		case RGBA_ASTC_6x5_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
			break;
		case RGBA_ASTC_6x6_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
			break;
		case RGBA_ASTC_8x5_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
			break;
		case RGBA_ASTC_8x6_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
			break;
		case RGBA_ASTC_8x8_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
			break;
		case RGBA_ASTC_10x5_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
			break;
		case RGBA_ASTC_10x6_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
			break;
		case RGBA_ASTC_10x8_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
			break;
		case RGBA_ASTC_10x10_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
			break;
		case RGBA_ASTC_12x10_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
			break;
		case RGBA_ASTC_12x12_Format:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
			break;
		case RGBAFormat:
			formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
			break;
		default: error("WebGPURenderer: Unsupported texture format.", format);
	}
	else switch (format) {
		case RGBAFormat:
			switch (type$1) {
				case ByteType:
					formatGPU = GPUTextureFormat.RGBA8Snorm;
					break;
				case ShortType:
					formatGPU = GPUTextureFormat.RGBA16Sint;
					break;
				case UnsignedShortType:
					formatGPU = GPUTextureFormat.RGBA16Uint;
					break;
				case UnsignedIntType:
					formatGPU = GPUTextureFormat.RGBA32Uint;
					break;
				case IntType:
					formatGPU = GPUTextureFormat.RGBA32Sint;
					break;
				case UnsignedByteType:
					formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
					break;
				case HalfFloatType:
					formatGPU = GPUTextureFormat.RGBA16Float;
					break;
				case FloatType:
					formatGPU = GPUTextureFormat.RGBA32Float;
					break;
				default: error("WebGPURenderer: Unsupported texture type with RGBAFormat.", type$1);
			}
			break;
		case RGBFormat:
			switch (type$1) {
				case UnsignedInt5999Type:
					formatGPU = GPUTextureFormat.RGB9E5UFloat;
					break;
				case UnsignedInt101111Type:
					formatGPU = GPUTextureFormat.RG11B10UFloat;
					break;
				default: error("WebGPURenderer: Unsupported texture type with RGBFormat.", type$1);
			}
			break;
		case RedFormat:
			switch (type$1) {
				case ByteType:
					formatGPU = GPUTextureFormat.R8Snorm;
					break;
				case ShortType:
					formatGPU = GPUTextureFormat.R16Sint;
					break;
				case UnsignedShortType:
					formatGPU = GPUTextureFormat.R16Uint;
					break;
				case UnsignedIntType:
					formatGPU = GPUTextureFormat.R32Uint;
					break;
				case IntType:
					formatGPU = GPUTextureFormat.R32Sint;
					break;
				case UnsignedByteType:
					formatGPU = GPUTextureFormat.R8Unorm;
					break;
				case HalfFloatType:
					formatGPU = GPUTextureFormat.R16Float;
					break;
				case FloatType:
					formatGPU = GPUTextureFormat.R32Float;
					break;
				default: error("WebGPURenderer: Unsupported texture type with RedFormat.", type$1);
			}
			break;
		case RGFormat:
			switch (type$1) {
				case ByteType:
					formatGPU = GPUTextureFormat.RG8Snorm;
					break;
				case ShortType:
					formatGPU = GPUTextureFormat.RG16Sint;
					break;
				case UnsignedShortType:
					formatGPU = GPUTextureFormat.RG16Uint;
					break;
				case UnsignedIntType:
					formatGPU = GPUTextureFormat.RG32Uint;
					break;
				case IntType:
					formatGPU = GPUTextureFormat.RG32Sint;
					break;
				case UnsignedByteType:
					formatGPU = GPUTextureFormat.RG8Unorm;
					break;
				case HalfFloatType:
					formatGPU = GPUTextureFormat.RG16Float;
					break;
				case FloatType:
					formatGPU = GPUTextureFormat.RG32Float;
					break;
				default: error("WebGPURenderer: Unsupported texture type with RGFormat.", type$1);
			}
			break;
		case DepthFormat:
			switch (type$1) {
				case UnsignedShortType:
					formatGPU = GPUTextureFormat.Depth16Unorm;
					break;
				case UnsignedIntType:
					formatGPU = GPUTextureFormat.Depth24Plus;
					break;
				case FloatType:
					formatGPU = GPUTextureFormat.Depth32Float;
					break;
				default: error("WebGPURenderer: Unsupported texture type with DepthFormat.", type$1);
			}
			break;
		case DepthStencilFormat:
			switch (type$1) {
				case UnsignedInt248Type:
					formatGPU = GPUTextureFormat.Depth24PlusStencil8;
					break;
				case FloatType:
					if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) error("WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.");
					formatGPU = GPUTextureFormat.Depth32FloatStencil8;
					break;
				default: error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", type$1);
			}
			break;
		case RedIntegerFormat:
			switch (type$1) {
				case IntType:
					formatGPU = GPUTextureFormat.R32Sint;
					break;
				case UnsignedIntType:
					formatGPU = GPUTextureFormat.R32Uint;
					break;
				default: error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", type$1);
			}
			break;
		case RGIntegerFormat:
			switch (type$1) {
				case IntType:
					formatGPU = GPUTextureFormat.RG32Sint;
					break;
				case UnsignedIntType:
					formatGPU = GPUTextureFormat.RG32Uint;
					break;
				default: error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", type$1);
			}
			break;
		case RGBAIntegerFormat:
			switch (type$1) {
				case IntType:
					formatGPU = GPUTextureFormat.RGBA32Sint;
					break;
				case UnsignedIntType:
					formatGPU = GPUTextureFormat.RGBA32Uint;
					break;
				default: error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", type$1);
			}
			break;
		default: error("WebGPURenderer: Unsupported texture format.", format);
	}
	return formatGPU;
}
var declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
var propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/gi;
var wgslTypeLib$1 = {
	"f32": "float",
	"i32": "int",
	"u32": "uint",
	"bool": "bool",
	"vec2<f32>": "vec2",
	"vec2<i32>": "ivec2",
	"vec2<u32>": "uvec2",
	"vec2<bool>": "bvec2",
	"vec2f": "vec2",
	"vec2i": "ivec2",
	"vec2u": "uvec2",
	"vec2b": "bvec2",
	"vec3<f32>": "vec3",
	"vec3<i32>": "ivec3",
	"vec3<u32>": "uvec3",
	"vec3<bool>": "bvec3",
	"vec3f": "vec3",
	"vec3i": "ivec3",
	"vec3u": "uvec3",
	"vec3b": "bvec3",
	"vec4<f32>": "vec4",
	"vec4<i32>": "ivec4",
	"vec4<u32>": "uvec4",
	"vec4<bool>": "bvec4",
	"vec4f": "vec4",
	"vec4i": "ivec4",
	"vec4u": "uvec4",
	"vec4b": "bvec4",
	"mat2x2<f32>": "mat2",
	"mat2x2f": "mat2",
	"mat3x3<f32>": "mat3",
	"mat3x3f": "mat3",
	"mat4x4<f32>": "mat4",
	"mat4x4f": "mat4",
	"sampler": "sampler",
	"texture_1d": "texture",
	"texture_2d": "texture",
	"texture_2d_array": "texture",
	"texture_multisampled_2d": "cubeTexture",
	"texture_depth_2d": "depthTexture",
	"texture_depth_2d_array": "depthTexture",
	"texture_depth_multisampled_2d": "depthTexture",
	"texture_depth_cube": "depthTexture",
	"texture_depth_cube_array": "depthTexture",
	"texture_3d": "texture3D",
	"texture_cube": "cubeTexture",
	"texture_cube_array": "cubeTexture",
	"texture_storage_1d": "storageTexture",
	"texture_storage_2d": "storageTexture",
	"texture_storage_2d_array": "storageTexture",
	"texture_storage_3d": "storageTexture"
};
var parse$2 = (source) => {
	source = source.trim();
	const declaration = source.match(declarationRegexp);
	if (declaration !== null && declaration.length === 4) {
		const inputsCode = declaration[2];
		const propsMatches = [];
		let match = null;
		while ((match = propertiesRegexp.exec(inputsCode)) !== null) propsMatches.push({
			name: match[1],
			type: match[2]
		});
		const inputs = [];
		for (let i = 0; i < propsMatches.length; i++) {
			const { name: name$1, type: type$1 } = propsMatches[i];
			let resolvedType = type$1;
			if (resolvedType.startsWith("ptr")) resolvedType = "pointer";
			else {
				if (resolvedType.startsWith("texture")) resolvedType = type$1.split("<")[0];
				resolvedType = wgslTypeLib$1[resolvedType];
			}
			inputs.push(new NodeFunctionInput(resolvedType, name$1));
		}
		const blockCode = source.substring(declaration[0].length);
		const outputType = declaration[3] || "void";
		const name = declaration[1] !== void 0 ? declaration[1] : "";
		return {
			type: wgslTypeLib$1[outputType] || outputType,
			inputs,
			name,
			inputsCode,
			blockCode,
			outputType
		};
	} else throw new Error("FunctionNode: Function is not a WGSL code.");
};
/**
* This class represents a WSL node function.
*
* @augments NodeFunction
*/
var WGSLNodeFunction = class extends NodeFunction {
	/**
	* Constructs a new WGSL node function.
	*
	* @param {string} source - The WGSL source.
	*/
	constructor(source) {
		const { type: type$1, inputs, name, inputsCode, blockCode, outputType } = parse$2(source);
		super(type$1, inputs, name);
		this.inputsCode = inputsCode;
		this.blockCode = blockCode;
		this.outputType = outputType;
	}
	/**
	* This method returns the WGSL code of the node function.
	*
	* @param {string} [name=this.name] - The function's name.
	* @return {string} The shader code.
	*/
	getCode(name = this.name) {
		const outputType = this.outputType !== "void" ? "-> " + this.outputType : "";
		return `fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}` + this.blockCode;
	}
};
/**
* A WGSL node parser.
*
* @augments NodeParser
*/
var WGSLNodeParser = class extends NodeParser {
	/**
	* The method parses the given WGSL code an returns a node function.
	*
	* @param {string} source - The WGSL code.
	* @return {WGSLNodeFunction} A node function.
	*/
	parseFunction(source) {
		return new WGSLNodeFunction(source);
	}
};
var GPUShaderStage = typeof self !== "undefined" ? self.GPUShaderStage : {
	VERTEX: 1,
	FRAGMENT: 2,
	COMPUTE: 4
};
var accessNames = {
	[NodeAccess$1.READ_ONLY]: "read",
	[NodeAccess$1.WRITE_ONLY]: "write",
	[NodeAccess$1.READ_WRITE]: "read_write"
};
var wrapNames = {
	[RepeatWrapping]: "repeat",
	[ClampToEdgeWrapping]: "clamp",
	[MirroredRepeatWrapping]: "mirror"
};
var gpuShaderStageLib = {
	"vertex": GPUShaderStage ? GPUShaderStage.VERTEX : 1,
	"fragment": GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
	"compute": GPUShaderStage ? GPUShaderStage.COMPUTE : 4
};
var supports = {
	instance: true,
	swizzleAssign: false,
	storageBuffer: true
};
var wgslFnOpLib = { "^^": "tsl_xor" };
var wgslTypeLib = {
	float: "f32",
	int: "i32",
	uint: "u32",
	bool: "bool",
	color: "vec3<f32>",
	vec2: "vec2<f32>",
	ivec2: "vec2<i32>",
	uvec2: "vec2<u32>",
	bvec2: "vec2<bool>",
	vec3: "vec3<f32>",
	ivec3: "vec3<i32>",
	uvec3: "vec3<u32>",
	bvec3: "vec3<bool>",
	vec4: "vec4<f32>",
	ivec4: "vec4<i32>",
	uvec4: "vec4<u32>",
	bvec4: "vec4<bool>",
	mat2: "mat2x2<f32>",
	mat3: "mat3x3<f32>",
	mat4: "mat4x4<f32>"
};
var wgslCodeCache = {};
var wgslPolyfill = {
	tsl_xor: new CodeNode("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
	mod_float: new CodeNode("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
	mod_vec2: new CodeNode("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
	mod_vec3: new CodeNode("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
	mod_vec4: new CodeNode("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
	equals_bool: new CodeNode("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
	equals_bvec2: new CodeNode("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
	equals_bvec3: new CodeNode("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
	equals_bvec4: new CodeNode("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
	repeatWrapping_float: new CodeNode("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),
	mirrorWrapping_float: new CodeNode("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),
	clampWrapping_float: new CodeNode("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),
	biquadraticTexture: new CodeNode(`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`)
};
var wgslMethods = {
	dFdx: "dpdx",
	dFdy: "- dpdy",
	mod_float: "tsl_mod_float",
	mod_vec2: "tsl_mod_vec2",
	mod_vec3: "tsl_mod_vec3",
	mod_vec4: "tsl_mod_vec4",
	equals_bool: "tsl_equals_bool",
	equals_bvec2: "tsl_equals_bvec2",
	equals_bvec3: "tsl_equals_bvec3",
	equals_bvec4: "tsl_equals_bvec4",
	inversesqrt: "inverseSqrt",
	bitcast: "bitcast<f32>"
};
var diagnostics = "";
if ((typeof navigator !== "undefined" && /Firefox|Deno/g.test(navigator.userAgent)) !== true) diagnostics += "diagnostic( off, derivative_uniformity );\n";
/**
* A node builder targeting WGSL.
*
* This module generates WGSL shader code from node materials and also
* generates the respective bindings and vertex buffer definitions. These
* data are later used by the renderer to create render and compute pipelines
* for render objects.
*
* @augments NodeBuilder
*/
var WGSLNodeBuilder = class extends NodeBuilder {
	/**
	* Constructs a new WGSL node builder renderer.
	*
	* @param {Object3D} object - The 3D object.
	* @param {Renderer} renderer - The renderer.
	*/
	constructor(object, renderer) {
		super(object, renderer, new WGSLNodeParser());
		/**
		* A dictionary that holds for each shader stage ('vertex', 'fragment', 'compute')
		* another dictionary which manages UBOs per group ('render','frame','object').
		*
		* @type {Object<string,Object<string,NodeUniformsGroup>>}
		*/
		this.uniformGroups = {};
		/**
		* A dictionary that holds for each shader stage a Map of builtins.
		*
		* @type {Object<string,Map<string,Object>>}
		*/
		this.builtins = {};
		/**
		* A dictionary that holds for each shader stage a Set of directives.
		*
		* @type {Object<string,Set<string>>}
		*/
		this.directives = {};
		/**
		* A map for managing scope arrays. Only relevant for when using
		* {@link WorkgroupInfoNode} in context of compute shaders.
		*
		* @type {Map<string,Object>}
		*/
		this.scopedArrays = /* @__PURE__ */ new Map();
	}
	/**
	* Generates the WGSL snippet for sampled textures.
	*
	* @private
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {string} The WGSL snippet.
	*/
	_generateTextureSample(texture$2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
		if (shaderStage === "fragment") if (depthSnippet) {
			if (offsetSnippet) return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${offsetSnippet} )`;
			return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
		} else {
			if (offsetSnippet) return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${offsetSnippet} )`;
			return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;
		}
		else return this.generateTextureSampleLevel(texture$2, textureProperty, uvSnippet, "0", depthSnippet);
	}
	/**
	* Generates the WGSL snippet when sampling textures with explicit mip level.
	*
	* @private
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
	* @param {string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @return {string} The WGSL snippet.
	*/
	generateTextureSampleLevel(texture$2, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet) {
		if (this.isUnfilterable(texture$2) === false) {
			if (offsetSnippet) return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
			return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
		} else if (this.isFilteredTexture(texture$2)) return this.generateFilteredTexture(texture$2, textureProperty, uvSnippet, offsetSnippet, levelSnippet);
		else return this.generateTextureLod(texture$2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet);
	}
	/**
	* Generates a wrap function used in context of textures.
	*
	* @param {Texture} texture - The texture to generate the function for.
	* @return {string} The name of the generated function.
	*/
	generateWrapFunction(texture$2) {
		const functionName = `tsl_coord_${wrapNames[texture$2.wrapS]}S_${wrapNames[texture$2.wrapT]}_${texture$2.isData3DTexture ? "3d" : "2d"}T`;
		let nodeCode = wgslCodeCache[functionName];
		if (nodeCode === void 0) {
			const includes = [];
			const coordType = texture$2.isData3DTexture ? "vec3f" : "vec2f";
			let code$2 = `fn ${functionName}( coord : ${coordType} ) -> ${coordType} {\n\n\treturn ${coordType}(\n`;
			const addWrapSnippet = (wrap, axis) => {
				if (wrap === RepeatWrapping) {
					includes.push(wgslPolyfill.repeatWrapping_float);
					code$2 += `\t\ttsl_repeatWrapping_float( coord.${axis} )`;
				} else if (wrap === ClampToEdgeWrapping) {
					includes.push(wgslPolyfill.clampWrapping_float);
					code$2 += `\t\ttsl_clampWrapping_float( coord.${axis} )`;
				} else if (wrap === MirroredRepeatWrapping) {
					includes.push(wgslPolyfill.mirrorWrapping_float);
					code$2 += `\t\ttsl_mirrorWrapping_float( coord.${axis} )`;
				} else {
					code$2 += `\t\tcoord.${axis}`;
					warn(`WebGPURenderer: Unsupported texture wrap type "${wrap}" for vertex shader.`);
				}
			};
			addWrapSnippet(texture$2.wrapS, "x");
			code$2 += ",\n";
			addWrapSnippet(texture$2.wrapT, "y");
			if (texture$2.isData3DTexture) {
				code$2 += ",\n";
				addWrapSnippet(texture$2.wrapR, "z");
			}
			code$2 += "\n	);\n\n}\n";
			wgslCodeCache[functionName] = nodeCode = new CodeNode(code$2, includes);
		}
		nodeCode.build(this);
		return functionName;
	}
	/**
	* Generates the array declaration string.
	*
	* @param {string} type - The type.
	* @param {?number} [count] - The count.
	* @return {string} The generated value as a shader string.
	*/
	generateArrayDeclaration(type$1, count) {
		return `array< ${this.getType(type$1)}, ${count} >`;
	}
	/**
	* Generates a WGSL variable that holds the texture dimension of the given texture.
	* It also returns information about the number of layers (elements) of an arrayed
	* texture as well as the cube face count of cube textures.
	*
	* @param {Texture} texture - The texture to generate the function for.
	* @param {string} textureProperty - The name of the video texture uniform in the shader.
	* @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
	* @return {string} The name of the dimension variable.
	*/
	generateTextureDimension(texture$2, textureProperty, levelSnippet) {
		const textureData = this.getDataFromNode(texture$2, this.shaderStage, this.globalCache);
		if (textureData.dimensionsSnippet === void 0) textureData.dimensionsSnippet = {};
		let textureDimensionNode = textureData.dimensionsSnippet[levelSnippet];
		if (textureData.dimensionsSnippet[levelSnippet] === void 0) {
			let textureDimensionsParams;
			let dimensionType;
			const { primarySamples } = this.renderer.backend.utils.getTextureSampleData(texture$2);
			const isMultisampled = primarySamples > 1;
			if (texture$2.isData3DTexture) dimensionType = "vec3<u32>";
			else dimensionType = "vec2<u32>";
			if (isMultisampled || texture$2.isStorageTexture) textureDimensionsParams = textureProperty;
			else textureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${levelSnippet} )` : ""}`;
			textureDimensionNode = new VarNode(new ExpressionNode(`textureDimensions( ${textureDimensionsParams} )`, dimensionType));
			textureData.dimensionsSnippet[levelSnippet] = textureDimensionNode;
			if (texture$2.isArrayTexture || texture$2.isDataArrayTexture || texture$2.isData3DTexture) textureData.arrayLayerCount = new VarNode(new ExpressionNode(`textureNumLayers(${textureProperty})`, "u32"));
			if (texture$2.isTextureCube) textureData.cubeFaceCount = new VarNode(new ExpressionNode("6u", "u32"));
		}
		return textureDimensionNode.build(this);
	}
	/**
	* Generates the WGSL snippet for a manual filtered texture.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
	* @return {string} The WGSL snippet.
	*/
	generateFilteredTexture(texture$2, textureProperty, uvSnippet, offsetSnippet, levelSnippet = "0u") {
		this._include("biquadraticTexture");
		const wrapFunction = this.generateWrapFunction(texture$2);
		const textureDimension = this.generateTextureDimension(texture$2, textureProperty, levelSnippet);
		if (offsetSnippet) uvSnippet = `${uvSnippet} + vec2<f32>(${offsetSnippet}) / ${textureDimension}`;
		return `tsl_biquadraticTexture( ${textureProperty}, ${wrapFunction}( ${uvSnippet} ), ${textureDimension}, u32( ${levelSnippet} ) )`;
	}
	/**
	* Generates the WGSL snippet for a texture lookup with explicit level-of-detail.
	* Since it's a lookup, no sampling or filtering is applied.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
	* @return {string} The WGSL snippet.
	*/
	generateTextureLod(texture$2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet = "0u") {
		const wrapFunction = this.generateWrapFunction(texture$2);
		const textureDimension = this.generateTextureDimension(texture$2, textureProperty, levelSnippet);
		const vecType = texture$2.isData3DTexture ? "vec3" : "vec2";
		if (offsetSnippet) uvSnippet = `${uvSnippet} + ${vecType}<f32>(${offsetSnippet}) / ${vecType}<f32>( ${textureDimension} )`;
		const coordSnippet = `${vecType}<u32>( ${wrapFunction}( ${uvSnippet} ) * ${vecType}<f32>( ${textureDimension} ) )`;
		return this.generateTextureLoad(texture$2, textureProperty, coordSnippet, levelSnippet, depthSnippet, null);
	}
	/**
	* Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {?string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
	* @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @return {string} The WGSL snippet.
	*/
	generateTextureLoad(texture$2, textureProperty, uvIndexSnippet, levelSnippet, depthSnippet, offsetSnippet) {
		if (levelSnippet === null) levelSnippet = "0u";
		if (offsetSnippet) uvIndexSnippet = `${uvIndexSnippet} + ${offsetSnippet}`;
		let snippet;
		if (depthSnippet) snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, u32( ${levelSnippet} ) )`;
		else {
			snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet}, u32( ${levelSnippet} ) )`;
			if (this.renderer.backend.compatibilityMode && texture$2.isDepthTexture) snippet += ".x";
		}
		return snippet;
	}
	/**
	* Generates the WGSL snippet that writes a single texel to a texture.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
	* @param {string} valueSnippet - A WGSL snippet that represent the new texel value.
	* @return {string} The WGSL snippet.
	*/
	generateTextureStore(texture$2, textureProperty, uvIndexSnippet, depthSnippet, valueSnippet) {
		let snippet;
		if (depthSnippet) snippet = `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, ${valueSnippet} )`;
		else snippet = `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`;
		return snippet;
	}
	/**
	* Returns `true` if the sampled values of the given texture should be compared against a reference value.
	*
	* @param {Texture} texture - The texture.
	* @return {boolean} Whether the sampled values of the given texture should be compared against a reference value or not.
	*/
	isSampleCompare(texture$2) {
		return texture$2.isDepthTexture === true && texture$2.compareFunction !== null;
	}
	/**
	* Returns `true` if the given texture is unfilterable.
	*
	* @param {Texture} texture - The texture.
	* @return {boolean} Whether the given texture is unfilterable or not.
	*/
	isUnfilterable(texture$2) {
		return this.getComponentTypeFromTexture(texture$2) !== "float" || !this.isAvailable("float32Filterable") && texture$2.isDataTexture === true && texture$2.type === FloatType || this.isSampleCompare(texture$2) === false && texture$2.minFilter === NearestFilter && texture$2.magFilter === NearestFilter || this.renderer.backend.utils.getTextureSampleData(texture$2).primarySamples > 1;
	}
	/**
	* Generates the WGSL snippet for sampling/loading the given texture.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {string} The WGSL snippet.
	*/
	generateTexture(texture$2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
		let snippet = null;
		if (this.isUnfilterable(texture$2)) snippet = this.generateTextureLod(texture$2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, "0", shaderStage);
		else snippet = this._generateTextureSample(texture$2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage);
		return snippet;
	}
	/**
	* Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {Array<string>} gradSnippet - An array holding both gradient WGSL snippets.
	* @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {string} The WGSL snippet.
	*/
	generateTextureGrad(texture$2, textureProperty, uvSnippet, gradSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
		if (shaderStage === "fragment") {
			if (offsetSnippet) return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]}, ${offsetSnippet} )`;
			return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;
		} else error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`);
	}
	/**
	* Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values
	* against a reference value.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {string} compareSnippet -  A WGSL snippet that represents the reference value.
	* @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {string} The WGSL snippet.
	*/
	generateTextureCompare(texture$2, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
		if (shaderStage === "fragment") {
			if (texture$2.isDepthTexture === true && texture$2.isArrayTexture === true) {
				if (offsetSnippet) return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${compareSnippet}, ${offsetSnippet} )`;
				return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${compareSnippet} )`;
			}
			if (offsetSnippet) return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet}, ${offsetSnippet} )`;
			return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;
		} else error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
	}
	/**
	* Generates the WGSL snippet when sampling textures with explicit mip level.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
	* @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {string} The WGSL snippet.
	*/
	generateTextureLevel(texture$2, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet) {
		if (this.isUnfilterable(texture$2) === false) {
			if (offsetSnippet) return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
			return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
		} else if (this.isFilteredTexture(texture$2)) return this.generateFilteredTexture(texture$2, textureProperty, uvSnippet, offsetSnippet, levelSnippet);
		else return this.generateTextureLod(texture$2, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet);
	}
	/**
	* Generates the WGSL snippet when sampling textures with a bias to the mip level.
	*
	* @param {Texture} texture - The texture.
	* @param {string} textureProperty - The name of the texture uniform in the shader.
	* @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
	* @param {string} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.
	* @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
	* @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {string} The WGSL snippet.
	*/
	generateTextureBias(texture$2, textureProperty, uvSnippet, biasSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
		if (shaderStage === "fragment") {
			if (offsetSnippet) return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet}, ${offsetSnippet} )`;
			return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;
		} else error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${shaderStage} shader.`);
	}
	/**
	* Returns a WGSL snippet that represents the property name of the given node.
	*
	* @param {Node} node - The node.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {string} The property name.
	*/
	getPropertyName(node, shaderStage = this.shaderStage) {
		if (node.isNodeVarying === true && node.needsInterpolation === true) {
			if (shaderStage === "vertex") return `varyings.${node.name}`;
		} else if (node.isNodeUniform === true) {
			const name = node.name;
			const type$1 = node.type;
			if (type$1 === "texture" || type$1 === "cubeTexture" || type$1 === "storageTexture" || type$1 === "texture3D") return name;
			else if (type$1 === "buffer" || type$1 === "storageBuffer" || type$1 === "indirectStorageBuffer") {
				if (this.isCustomStruct(node)) return name;
				return name + ".value";
			} else return node.groupNode.name + "." + name;
		}
		return super.getPropertyName(node);
	}
	/**
	* Returns the output struct name.
	*
	* @return {string} The name of the output struct.
	*/
	getOutputStructName() {
		return "output";
	}
	/**
	* Returns the native shader operator name for a given generic name.
	*
	* @param {string} op - The operator name to resolve.
	* @return {?string} The resolved operator name.
	*/
	getFunctionOperator(op) {
		const fnOp = wgslFnOpLib[op];
		if (fnOp !== void 0) {
			this._include(fnOp);
			return fnOp;
		}
		return null;
	}
	/**
	* Returns the node access for the given node and shader stage.
	*
	* @param {StorageTextureNode|StorageBufferNode} node - The storage node.
	* @param {string} shaderStage - The shader stage.
	* @return {string} The node access.
	*/
	getNodeAccess(node, shaderStage) {
		if (shaderStage !== "compute") {
			if (node.isAtomic === true) {
				warn("WebGPURenderer: Atomic operations are only supported in compute shaders.");
				return NodeAccess$1.READ_WRITE;
			}
			return NodeAccess$1.READ_ONLY;
		}
		return node.access;
	}
	/**
	* Returns A WGSL snippet representing the storage access.
	*
	* @param {StorageTextureNode|StorageBufferNode} node - The storage node.
	* @param {string} shaderStage - The shader stage.
	* @return {string} The WGSL snippet representing the storage access.
	*/
	getStorageAccess(node, shaderStage) {
		return accessNames[this.getNodeAccess(node, shaderStage)];
	}
	/**
	* This method is one of the more important ones since it's responsible
	* for generating a matching binding instance for the given uniform node.
	*
	* These bindings are later used in the renderer to create bind groups
	* and layouts.
	*
	* @param {UniformNode} node - The uniform node.
	* @param {string} type - The node data type.
	* @param {string} shaderStage - The shader stage.
	* @param {?string} [name=null] - An optional uniform name.
	* @return {NodeUniform} The node uniform object.
	*/
	getUniformFromNode(node, type$1, shaderStage, name = null) {
		const uniformNode = super.getUniformFromNode(node, type$1, shaderStage, name);
		const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
		if (nodeData.uniformGPU === void 0) {
			let uniformGPU;
			const group = node.groupNode;
			const groupName = group.name;
			const bindings = this.getBindGroupArray(groupName, shaderStage);
			if (type$1 === "texture" || type$1 === "cubeTexture" || type$1 === "storageTexture" || type$1 === "texture3D") {
				let texture$2 = null;
				const access = this.getNodeAccess(node, shaderStage);
				if (type$1 === "texture" || type$1 === "storageTexture") if (node.value.is3DTexture === true) texture$2 = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group, access);
				else texture$2 = new NodeSampledTexture(uniformNode.name, uniformNode.node, group, access);
				else if (type$1 === "cubeTexture") texture$2 = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group, access);
				else if (type$1 === "texture3D") texture$2 = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group, access);
				texture$2.store = node.isStorageTextureNode === true;
				texture$2.mipLevel = texture$2.store ? node.mipLevel : 0;
				texture$2.setVisibility(gpuShaderStageLib[shaderStage]);
				if (this.isUnfilterable(node.value) === false && texture$2.store === false) {
					const sampler$2 = new NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node, group);
					sampler$2.setVisibility(gpuShaderStageLib[shaderStage]);
					bindings.push(sampler$2, texture$2);
					uniformGPU = [sampler$2, texture$2];
				} else {
					bindings.push(texture$2);
					uniformGPU = [texture$2];
				}
			} else if (type$1 === "buffer" || type$1 === "storageBuffer" || type$1 === "indirectStorageBuffer") {
				const buffer$2 = new (type$1 === "buffer" ? NodeUniformBuffer : NodeStorageBuffer)(node, group);
				buffer$2.setVisibility(gpuShaderStageLib[shaderStage]);
				bindings.push(buffer$2);
				uniformGPU = buffer$2;
				uniformNode.name = name ? name : "NodeBuffer_" + uniformNode.id;
			} else {
				const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
				let uniformsGroup = uniformsStage[groupName];
				if (uniformsGroup === void 0) {
					uniformsGroup = new NodeUniformsGroup(groupName, group);
					uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);
					uniformsStage[groupName] = uniformsGroup;
					bindings.push(uniformsGroup);
				}
				uniformGPU = this.getNodeUniform(uniformNode, type$1);
				uniformsGroup.addUniform(uniformGPU);
			}
			nodeData.uniformGPU = uniformGPU;
		}
		return uniformNode;
	}
	/**
	* This method should be used whenever builtins are required in nodes.
	* The internal builtins data structure will make sure builtins are
	* defined in the WGSL source.
	*
	* @param {string} name - The builtin name.
	* @param {string} property - The property name.
	* @param {string} type - The node data type.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {string} The property name.
	*/
	getBuiltin(name, property$2, type$1, shaderStage = this.shaderStage) {
		const map = this.builtins[shaderStage] || (this.builtins[shaderStage] = /* @__PURE__ */ new Map());
		if (map.has(name) === false) map.set(name, {
			name,
			property: property$2,
			type: type$1
		});
		return property$2;
	}
	/**
	* Returns `true` if the given builtin is defined in the given shader stage.
	*
	* @param {string} name - The builtin name.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
	* @return {boolean} Whether the given builtin is defined in the given shader stage or not.
	*/
	hasBuiltin(name, shaderStage = this.shaderStage) {
		return this.builtins[shaderStage] !== void 0 && this.builtins[shaderStage].has(name);
	}
	/**
	* Returns the vertex index builtin.
	*
	* @return {string} The vertex index.
	*/
	getVertexIndex() {
		if (this.shaderStage === "vertex") return this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute");
		return "vertexIndex";
	}
	/**
	* Builds the given shader node.
	*
	* @param {ShaderNodeInternal} shaderNode - The shader node.
	* @return {string} The WGSL function code.
	*/
	buildFunctionCode(shaderNode) {
		const layout = shaderNode.layout;
		const flowData = this.flowShaderNode(shaderNode);
		const parameters = [];
		for (const input of layout.inputs) parameters.push(input.name + " : " + this.getType(input.type));
		let code$2 = `fn ${layout.name}( ${parameters.join(", ")} ) -> ${this.getType(layout.type)} {
${flowData.vars}
${flowData.code}
`;
		if (flowData.result) code$2 += `\treturn ${flowData.result};\n`;
		code$2 += "\n}\n";
		return code$2;
	}
	/**
	* Contextually returns either the vertex stage instance index builtin
	* or the linearized index of an compute invocation within a grid of workgroups.
	*
	* @return {string} The instance index.
	*/
	getInstanceIndex() {
		if (this.shaderStage === "vertex") return this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute");
		return "instanceIndex";
	}
	/**
	* Returns a builtin representing the index of a compute invocation within the scope of a workgroup load.
	*
	* @return {string} The invocation local index.
	*/
	getInvocationLocalIndex() {
		return this.getBuiltin("local_invocation_index", "invocationLocalIndex", "u32", "attribute");
	}
	/**
	* Returns a builtin representing the size of a subgroup within the current shader.
	*
	* @return {string} The subgroup size.
	*/
	getSubgroupSize() {
		this.enableSubGroups();
		return this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
	}
	/**
	* Returns a builtin representing the index of a compute invocation within the scope of a subgroup.
	*
	* @return {string} The invocation subgroup index.
	*/
	getInvocationSubgroupIndex() {
		this.enableSubGroups();
		return this.getBuiltin("subgroup_invocation_id", "invocationSubgroupIndex", "u32", "attribute");
	}
	/**
	* Returns a builtin representing the index of a compute invocation's subgroup within its workgroup.
	*
	* @return {string} The subgroup index.
	*/
	getSubgroupIndex() {
		this.enableSubGroups();
		return this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
	}
	/**
	* Overwritten as a NOP since this method is intended for the WebGL 2 backend.
	*
	* @return {null} Null.
	*/
	getDrawIndex() {
		return null;
	}
	/**
	* Returns the front facing builtin.
	*
	* @return {string} The front facing builtin.
	*/
	getFrontFacing() {
		return this.getBuiltin("front_facing", "isFront", "bool");
	}
	/**
	* Returns the frag coord builtin.
	*
	* @return {string} The frag coord builtin.
	*/
	getFragCoord() {
		return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
	}
	/**
	* Returns the frag depth builtin.
	*
	* @return {string} The frag depth builtin.
	*/
	getFragDepth() {
		return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
	}
	/**
	* Returns the clip distances builtin.
	*
	* @return {string} The clip distances builtin.
	*/
	getClipDistance() {
		return "varyings.hw_clip_distances";
	}
	/**
	* Whether to flip texture data along its vertical axis or not.
	*
	* @return {boolean} Returns always `false` in context of WGSL.
	*/
	isFlipY() {
		return false;
	}
	/**
	* Enables the given directive for the given shader stage.
	*
	* @param {string} name - The directive name.
	* @param {string} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.
	*/
	enableDirective(name, shaderStage = this.shaderStage) {
		(this.directives[shaderStage] || (this.directives[shaderStage] = /* @__PURE__ */ new Set())).add(name);
	}
	/**
	* Returns the directives of the given shader stage as a WGSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} A WGSL snippet that enables the directives of the given stage.
	*/
	getDirectives(shaderStage) {
		const snippets = [];
		const directives = this.directives[shaderStage];
		if (directives !== void 0) for (const directive of directives) snippets.push(`enable ${directive};`);
		return snippets.join("\n");
	}
	/**
	* Enables the 'subgroups' directive.
	*/
	enableSubGroups() {
		this.enableDirective("subgroups");
	}
	/**
	* Enables the 'subgroups-f16' directive.
	*/
	enableSubgroupsF16() {
		this.enableDirective("subgroups-f16");
	}
	/**
	* Enables the 'clip_distances' directive.
	*/
	enableClipDistances() {
		this.enableDirective("clip_distances");
	}
	/**
	* Enables the 'f16' directive.
	*/
	enableShaderF16() {
		this.enableDirective("f16");
	}
	/**
	* Enables the 'dual_source_blending' directive.
	*/
	enableDualSourceBlending() {
		this.enableDirective("dual_source_blending");
	}
	/**
	* Enables hardware clipping.
	*
	* @param {string} planeCount - The clipping plane count.
	*/
	enableHardwareClipping(planeCount) {
		this.enableClipDistances();
		this.getBuiltin("clip_distances", "hw_clip_distances", `array<f32, ${planeCount} >`, "vertex");
	}
	/**
	* Returns the builtins of the given shader stage as a WGSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} A WGSL snippet that represents the builtins of the given stage.
	*/
	getBuiltins(shaderStage) {
		const snippets = [];
		const builtins = this.builtins[shaderStage];
		if (builtins !== void 0) for (const { name, property: property$2, type: type$1 } of builtins.values()) snippets.push(`@builtin( ${name} ) ${property$2} : ${type$1}`);
		return snippets.join(",\n	");
	}
	/**
	* This method should be used when a new scoped buffer is used in context of
	* compute shaders. It adds the array to the internal data structure which is
	* later used to generate the respective WGSL.
	*
	* @param {string} name - The array name.
	* @param {string} scope - The scope.
	* @param {string} bufferType - The buffer type.
	* @param {string} bufferCount - The buffer count.
	* @return {string} The array name.
	*/
	getScopedArray(name, scope, bufferType, bufferCount) {
		if (this.scopedArrays.has(name) === false) this.scopedArrays.set(name, {
			name,
			scope,
			bufferType,
			bufferCount
		});
		return name;
	}
	/**
	* Returns the scoped arrays of the given shader stage as a WGSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string|undefined} The WGSL snippet that defines the scoped arrays.
	* Returns `undefined` when used in the vertex or fragment stage.
	*/
	getScopedArrays(shaderStage) {
		if (shaderStage !== "compute") return;
		const snippets = [];
		for (const { name, scope, bufferType, bufferCount } of this.scopedArrays.values()) {
			const type$1 = this.getType(bufferType);
			snippets.push(`var<${scope}> ${name}: array< ${type$1}, ${bufferCount} >;`);
		}
		return snippets.join("\n");
	}
	/**
	* Returns the shader attributes of the given shader stage as a WGSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The WGSL snippet that defines the shader attributes.
	*/
	getAttributes(shaderStage) {
		const snippets = [];
		if (shaderStage === "compute") {
			this.getBuiltin("global_invocation_id", "globalId", "vec3<u32>", "attribute");
			this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute");
			this.getBuiltin("local_invocation_id", "localId", "vec3<u32>", "attribute");
			this.getBuiltin("num_workgroups", "numWorkgroups", "vec3<u32>", "attribute");
			if (this.renderer.hasFeature("subgroups")) {
				this.enableDirective("subgroups", shaderStage);
				this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
			}
		}
		if (shaderStage === "vertex" || shaderStage === "compute") {
			const builtins = this.getBuiltins("attribute");
			if (builtins) snippets.push(builtins);
			const attributes = this.getAttributesArray();
			for (let index = 0, length$2 = attributes.length; index < length$2; index++) {
				const attribute$2 = attributes[index];
				const name = attribute$2.name;
				const type$1 = this.getType(attribute$2.type);
				snippets.push(`@location( ${index} ) ${name} : ${type$1}`);
			}
		}
		return snippets.join(",\n	");
	}
	/**
	* Returns the members of the given struct type node as a WGSL string.
	*
	* @param {StructTypeNode} struct - The struct type node.
	* @return {string} The WGSL snippet that defines the struct members.
	*/
	getStructMembers(struct$2) {
		const snippets = [];
		for (const member of struct$2.members) {
			const prefix = struct$2.output ? "@location( " + member.index + " ) " : "";
			let type$1 = this.getType(member.type);
			if (member.atomic) type$1 = "atomic< " + type$1 + " >";
			snippets.push(`\t${prefix + member.name} : ${type$1}`);
		}
		if (struct$2.output) snippets.push(`\t${this.getBuiltins("output")}`);
		return snippets.join(",\n");
	}
	/**
	* Returns the structs of the given shader stage as a WGSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The WGSL snippet that defines the structs.
	*/
	getStructs(shaderStage) {
		let result = "";
		const structs = this.structs[shaderStage];
		if (structs.length > 0) {
			const snippets = [];
			for (const struct$2 of structs) {
				let snippet = `struct ${struct$2.name} {\n`;
				snippet += this.getStructMembers(struct$2);
				snippet += "\n};";
				snippets.push(snippet);
			}
			result = "\n" + snippets.join("\n\n") + "\n";
		}
		return result;
	}
	/**
	* Returns a WGSL string representing a variable.
	*
	* @param {string} type - The variable's type.
	* @param {string} name - The variable's name.
	* @param {?number} [count=null] - The array length.
	* @return {string} The WGSL snippet that defines a variable.
	*/
	getVar(type$1, name, count = null) {
		let snippet = `var ${name} : `;
		if (count !== null) snippet += this.generateArrayDeclaration(type$1, count);
		else snippet += this.getType(type$1);
		return snippet;
	}
	/**
	* Returns the variables of the given shader stage as a WGSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The WGSL snippet that defines the variables.
	*/
	getVars(shaderStage) {
		const snippets = [];
		const vars = this.vars[shaderStage];
		if (vars !== void 0) for (const variable of vars) snippets.push(`\t${this.getVar(variable.type, variable.name, variable.count)};`);
		return `\n${snippets.join("\n")}\n`;
	}
	/**
	* Returns the varyings of the given shader stage as a WGSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The WGSL snippet that defines the varyings.
	*/
	getVaryings(shaderStage) {
		const snippets = [];
		if (shaderStage === "vertex") this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex");
		if (shaderStage === "vertex" || shaderStage === "fragment") {
			const varyings = this.varyings;
			const vars = this.vars[shaderStage];
			for (let index = 0; index < varyings.length; index++) {
				const varying$2 = varyings[index];
				if (varying$2.needsInterpolation) {
					let attributesSnippet = `@location( ${index} )`;
					if (varying$2.interpolationType) {
						const samplingSnippet = varying$2.interpolationSampling !== null ? `, ${varying$2.interpolationSampling} )` : " )";
						attributesSnippet += ` @interpolate( ${varying$2.interpolationType}${samplingSnippet}`;
					} else if (/^(int|uint|ivec|uvec)/.test(varying$2.type)) attributesSnippet += ` @interpolate( ${this.renderer.backend.compatibilityMode ? "flat, either" : "flat"} )`;
					snippets.push(`${attributesSnippet} ${varying$2.name} : ${this.getType(varying$2.type)}`);
				} else if (shaderStage === "vertex" && vars.includes(varying$2) === false) vars.push(varying$2);
			}
		}
		const builtins = this.getBuiltins(shaderStage);
		if (builtins) snippets.push(builtins);
		const code$2 = snippets.join(",\n	");
		return shaderStage === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + code$2) : code$2;
	}
	isCustomStruct(nodeUniform) {
		const attribute$2 = nodeUniform.value;
		const bufferNode = nodeUniform.node;
		const isAttributeStructType = (attribute$2.isBufferAttribute || attribute$2.isInstancedBufferAttribute) && bufferNode.structTypeNode !== null;
		const isStructArray = bufferNode.value && bufferNode.value.array && typeof bufferNode.value.itemSize === "number" && bufferNode.value.array.length > bufferNode.value.itemSize;
		return isAttributeStructType && !isStructArray;
	}
	/**
	* Returns the uniforms of the given shader stage as a WGSL string.
	*
	* @param {string} shaderStage - The shader stage.
	* @return {string} The WGSL snippet that defines the uniforms.
	*/
	getUniforms(shaderStage) {
		const uniforms = this.uniforms[shaderStage];
		const bindingSnippets = [];
		const bufferSnippets = [];
		const structSnippets = [];
		const uniformGroups = {};
		for (const uniform$2 of uniforms) {
			const groupName = uniform$2.groupNode.name;
			const uniformIndexes = this.bindingsIndexes[groupName];
			if (uniform$2.type === "texture" || uniform$2.type === "cubeTexture" || uniform$2.type === "storageTexture" || uniform$2.type === "texture3D") {
				const texture$2 = uniform$2.node.value;
				if (this.isUnfilterable(texture$2) === false && uniform$2.node.isStorageTextureNode !== true) if (this.isSampleCompare(texture$2)) bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform$2.name}_sampler : sampler_comparison;`);
				else bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform$2.name}_sampler : sampler;`);
				let textureType;
				let multisampled = "";
				const { primarySamples } = this.renderer.backend.utils.getTextureSampleData(texture$2);
				if (primarySamples > 1) multisampled = "_multisampled";
				if (texture$2.isCubeTexture === true) textureType = "texture_cube<f32>";
				else if (texture$2.isDepthTexture === true) if (this.renderer.backend.compatibilityMode && texture$2.compareFunction === null) textureType = `texture${multisampled}_2d<f32>`;
				else textureType = `texture_depth${multisampled}_2d${texture$2.isArrayTexture === true ? "_array" : ""}`;
				else if (uniform$2.node.isStorageTextureNode === true) {
					const format = getFormat(texture$2);
					const access = this.getStorageAccess(uniform$2.node, shaderStage);
					const is3D = uniform$2.node.value.is3DTexture;
					const isArrayTexture = uniform$2.node.value.isArrayTexture;
					textureType = `texture_storage_${is3D ? "3d" : `2d${isArrayTexture ? "_array" : ""}`}<${format}, ${access}>`;
				} else if (texture$2.isArrayTexture === true || texture$2.isDataArrayTexture === true || texture$2.isCompressedArrayTexture === true) textureType = "texture_2d_array<f32>";
				else if (texture$2.is3DTexture === true || texture$2.isData3DTexture === true) textureType = "texture_3d<f32>";
				else {
					const componentPrefix = this.getComponentTypeFromTexture(texture$2).charAt(0);
					textureType = `texture${multisampled}_2d<${componentPrefix}32>`;
				}
				bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform$2.name} : ${textureType};`);
			} else if (uniform$2.type === "buffer" || uniform$2.type === "storageBuffer" || uniform$2.type === "indirectStorageBuffer") {
				const bufferNode = uniform$2.node;
				const bufferType = this.getType(bufferNode.getNodeType(this));
				const bufferCount = bufferNode.bufferCount;
				const bufferCountSnippet = bufferCount > 0 && uniform$2.type === "buffer" ? ", " + bufferCount : "";
				const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${this.getStorageAccess(bufferNode, shaderStage)}` : "uniform";
				if (this.isCustomStruct(uniform$2)) bufferSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var<${bufferAccessMode}> ${uniform$2.name} : ${bufferType};`);
				else {
					const bufferSnippet = `\tvalue : array< ${bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`}${bufferCountSnippet} >`;
					bufferSnippets.push(this._getWGSLStructBinding(uniform$2.name, bufferSnippet, bufferAccessMode, uniformIndexes.binding++, uniformIndexes.group));
				}
			} else {
				const vectorType = this.getType(this.getVectorType(uniform$2.type));
				const groupName$1 = uniform$2.groupNode.name;
				(uniformGroups[groupName$1] || (uniformGroups[groupName$1] = {
					index: uniformIndexes.binding++,
					id: uniformIndexes.group,
					snippets: []
				})).snippets.push(`\t${uniform$2.name} : ${vectorType}`);
			}
		}
		for (const name in uniformGroups) {
			const group = uniformGroups[name];
			structSnippets.push(this._getWGSLStructBinding(name, group.snippets.join(",\n"), "uniform", group.index, group.id));
		}
		let code$2 = bindingSnippets.join("\n");
		code$2 += bufferSnippets.join("\n");
		code$2 += structSnippets.join("\n");
		return code$2;
	}
	/**
	* Controls the code build of the shader stages.
	*/
	buildCode() {
		const shadersData = this.material !== null ? {
			fragment: {},
			vertex: {}
		} : { compute: {} };
		this.sortBindingGroups();
		for (const shaderStage in shadersData) {
			this.shaderStage = shaderStage;
			const stageData = shadersData[shaderStage];
			stageData.uniforms = this.getUniforms(shaderStage);
			stageData.attributes = this.getAttributes(shaderStage);
			stageData.varyings = this.getVaryings(shaderStage);
			stageData.structs = this.getStructs(shaderStage);
			stageData.vars = this.getVars(shaderStage);
			stageData.codes = this.getCodes(shaderStage);
			stageData.directives = this.getDirectives(shaderStage);
			stageData.scopedArrays = this.getScopedArrays(shaderStage);
			let flow = "// code\n\n";
			flow += this.flowCode[shaderStage];
			const flowNodes = this.flowNodes[shaderStage];
			const mainNode = flowNodes[flowNodes.length - 1];
			const outputNode = mainNode.outputNode;
			const isOutputStruct = outputNode !== void 0 && outputNode.isOutputStructNode === true;
			for (const node of flowNodes) {
				const flowSlotData = this.getFlowData(node);
				const slotName = node.name;
				if (slotName) {
					if (flow.length > 0) flow += "\n";
					flow += `\t// flow -> ${slotName}\n`;
				}
				flow += `${flowSlotData.code}\n\t`;
				if (node === mainNode && shaderStage !== "compute") {
					flow += "// result\n\n	";
					if (shaderStage === "vertex") flow += `varyings.Vertex = ${flowSlotData.result};`;
					else if (shaderStage === "fragment") if (isOutputStruct) {
						stageData.returnType = outputNode.getNodeType(this);
						stageData.structs += "var<private> output : " + stageData.returnType + ";";
						flow += `return ${flowSlotData.result};`;
					} else {
						let structSnippet = "	@location(0) color: vec4<f32>";
						const builtins = this.getBuiltins("output");
						if (builtins) structSnippet += ",\n	" + builtins;
						stageData.returnType = "OutputStruct";
						stageData.structs += this._getWGSLStruct("OutputStruct", structSnippet);
						stageData.structs += "\nvar<private> output : OutputStruct;";
						flow += `output.color = ${flowSlotData.result};\n\n\treturn output;`;
					}
				}
			}
			stageData.flow = flow;
		}
		this.shaderStage = null;
		if (this.material !== null) {
			this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);
			this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);
		} else {
			const workgroupSize = this.object.workgroupSize;
			this.computeShader = this._getWGSLComputeCode(shadersData.compute, workgroupSize);
		}
	}
	/**
	* Returns the native shader method name for a given generic name.
	*
	* @param {string} method - The method name to resolve.
	* @param {?string} [output=null] - An optional output.
	* @return {string} The resolved WGSL method name.
	*/
	getMethod(method, output$2 = null) {
		let wgslMethod;
		if (output$2 !== null) wgslMethod = this._getWGSLMethod(method + "_" + output$2);
		if (wgslMethod === void 0) wgslMethod = this._getWGSLMethod(method);
		return wgslMethod || method;
	}
	/**
	* Returns the bitcast method name for a given input and outputType.
	*
	* @param {string} type - The output type to bitcast to.
	* @return {string} The resolved WGSL bitcast invocation.
	*/
	getBitcastMethod(type$1) {
		return `bitcast<${this.getType(type$1)}>`;
	}
	/**
	* Returns the native snippet for a ternary operation.
	*
	* @param {string} condSnippet - The condition determining which expression gets resolved.
	* @param {string} ifSnippet - The expression to resolve to if the condition is true.
	* @param {string} elseSnippet - The expression to resolve to if the condition is false.
	* @return {string} The resolved method name.
	*/
	getTernary(condSnippet, ifSnippet, elseSnippet) {
		return `select( ${elseSnippet}, ${ifSnippet}, ${condSnippet} )`;
	}
	/**
	* Returns the WGSL type of the given node data type.
	*
	* @param {string} type - The node data type.
	* @return {string} The WGSL type.
	*/
	getType(type$1) {
		return wgslTypeLib[type$1] || type$1;
	}
	/**
	* Whether the requested feature is available or not.
	*
	* @param {string} name - The requested feature.
	* @return {boolean} Whether the requested feature is supported or not.
	*/
	isAvailable(name) {
		let result = supports[name];
		if (result === void 0) {
			if (name === "float32Filterable") result = this.renderer.hasFeature("float32-filterable");
			else if (name === "clipDistance") result = this.renderer.hasFeature("clip-distances");
			supports[name] = result;
		}
		return result;
	}
	/**
	* Returns the native shader method name for a given generic name.
	*
	* @private
	* @param {string} method - The method name to resolve.
	* @return {string} The resolved WGSL method name.
	*/
	_getWGSLMethod(method) {
		if (wgslPolyfill[method] !== void 0) this._include(method);
		return wgslMethods[method];
	}
	/**
	* Includes the given method name into the current
	* function node.
	*
	* @private
	* @param {string} name - The method name to include.
	* @return {CodeNode} The respective code node.
	*/
	_include(name) {
		const codeNode = wgslPolyfill[name];
		codeNode.build(this);
		this.addInclude(codeNode);
		return codeNode;
	}
	/**
	* Returns a WGSL vertex shader based on the given shader data.
	*
	* @private
	* @param {Object} shaderData - The shader data.
	* @return {string} The vertex shader.
	*/
	_getWGSLVertexCode(shaderData) {
		return `${this.getSignature()}
// directives
${shaderData.directives}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;
	}
	/**
	* Returns a WGSL fragment shader based on the given shader data.
	*
	* @private
	* @param {Object} shaderData - The shader data.
	* @return {string} The vertex shader.
	*/
	_getWGSLFragmentCode(shaderData) {
		return `${this.getSignature()}
// global
${diagnostics}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
	}
	/**
	* Returns a WGSL compute shader based on the given shader data.
	*
	* @private
	* @param {Object} shaderData - The shader data.
	* @param {string} workgroupSize - The workgroup size.
	* @return {string} The vertex shader.
	*/
	_getWGSLComputeCode(shaderData, workgroupSize) {
		const [workgroupSizeX, workgroupSizeY, workgroupSizeZ] = workgroupSize;
		return `${this.getSignature()}
// directives
${shaderData.directives}

// system
var<private> instanceIndex : u32;

// locals
${shaderData.scopedArrays}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = globalId.x
		+ globalId.y * ( ${workgroupSizeX} * numWorkgroups.x )
		+ globalId.z * ( ${workgroupSizeX} * numWorkgroups.x ) * ( ${workgroupSizeY} * numWorkgroups.y );

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
	}
	/**
	* Returns a WGSL struct based on the given name and variables.
	*
	* @private
	* @param {string} name - The struct name.
	* @param {string} vars - The struct variables.
	* @return {string} The WGSL snippet representing a struct.
	*/
	_getWGSLStruct(name, vars) {
		return `
struct ${name} {
${vars}
};`;
	}
	/**
	* Returns a WGSL struct binding.
	*
	* @private
	* @param {string} name - The struct name.
	* @param {string} vars - The struct variables.
	* @param {string} access - The access.
	* @param {number} [binding=0] - The binding index.
	* @param {number} [group=0] - The group index.
	* @return {string} The WGSL snippet representing a struct binding.
	*/
	_getWGSLStructBinding(name, vars, access, binding = 0, group = 0) {
		const structName = name + "Struct";
		return `${this._getWGSLStruct(structName, vars)}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;
	}
};
/**
* A WebGPU backend utility module with common helpers.
*
* @private
*/
var WebGPUUtils = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGPUBackend} backend - The WebGPU backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGPU backend.
		*
		* @type {WebGPUBackend}
		*/
		this.backend = backend;
	}
	/**
	* Returns the depth/stencil GPU format for the given render context.
	*
	* @param {RenderContext} renderContext - The render context.
	* @return {string} The depth/stencil GPU texture format.
	*/
	getCurrentDepthStencilFormat(renderContext) {
		let format;
		if (renderContext.depthTexture !== null) format = this.getTextureFormatGPU(renderContext.depthTexture);
		else if (renderContext.depth && renderContext.stencil) format = GPUTextureFormat.Depth24PlusStencil8;
		else if (renderContext.depth) format = GPUTextureFormat.Depth24Plus;
		return format;
	}
	/**
	* Returns the GPU format for the given texture.
	*
	* @param {Texture} texture - The texture.
	* @return {string} The GPU texture format.
	*/
	getTextureFormatGPU(texture$2) {
		return this.backend.get(texture$2).format;
	}
	/**
	* Returns an object that defines the multi-sampling state of the given texture.
	*
	* @param {Texture} texture - The texture.
	* @return {Object} The multi-sampling state.
	*/
	getTextureSampleData(texture$2) {
		let samples;
		if (texture$2.isFramebufferTexture) samples = 1;
		else if (texture$2.isDepthTexture && !texture$2.renderTarget) {
			const renderer = this.backend.renderer;
			const renderTarget = renderer.getRenderTarget();
			samples = renderTarget ? renderTarget.samples : renderer.currentSamples;
		} else if (texture$2.renderTarget) samples = texture$2.renderTarget.samples;
		samples = samples || 1;
		const isMSAA = samples > 1 && texture$2.renderTarget !== null && texture$2.isDepthTexture !== true && texture$2.isFramebufferTexture !== true;
		return {
			samples,
			primarySamples: isMSAA ? 1 : samples,
			isMSAA
		};
	}
	/**
	* Returns the default color attachment's GPU format of the current render context.
	*
	* @param {RenderContext} renderContext - The render context.
	* @return {string} The GPU texture format of the default color attachment.
	*/
	getCurrentColorFormat(renderContext) {
		let format;
		if (renderContext.textures !== null) format = this.getTextureFormatGPU(renderContext.textures[0]);
		else format = this.getPreferredCanvasFormat();
		return format;
	}
	/**
	* Returns the GPU formats of all color attachments of the current render context.
	*
	* @param {RenderContext} renderContext - The render context.
	* @return {Array<string>} The GPU texture formats of all color attachments.
	*/
	getCurrentColorFormats(renderContext) {
		if (renderContext.textures !== null) return renderContext.textures.map((t) => this.getTextureFormatGPU(t));
		else return [this.getPreferredCanvasFormat()];
	}
	/**
	* Returns the output color space of the current render context.
	*
	* @param {RenderContext} renderContext - The render context.
	* @return {string} The output color space.
	*/
	getCurrentColorSpace(renderContext) {
		if (renderContext.textures !== null) return renderContext.textures[0].colorSpace;
		return this.backend.renderer.outputColorSpace;
	}
	/**
	* Returns GPU primitive topology for the given object and material.
	*
	* @param {Object3D} object - The 3D object.
	* @param {Material} material - The material.
	* @return {string} The GPU primitive topology.
	*/
	getPrimitiveTopology(object, material) {
		if (object.isPoints) return GPUPrimitiveTopology.PointList;
		else if (object.isLineSegments || object.isMesh && material.wireframe === true) return GPUPrimitiveTopology.LineList;
		else if (object.isLine) return GPUPrimitiveTopology.LineStrip;
		else if (object.isMesh) return GPUPrimitiveTopology.TriangleList;
	}
	/**
	* Returns a modified sample count from the given sample count value.
	*
	* That is required since WebGPU only supports either 1 or 4.
	*
	* @param {number} sampleCount - The input sample count.
	* @return {number} The (potentially updated) output sample count.
	*/
	getSampleCount(sampleCount) {
		return sampleCount >= 4 ? 4 : 1;
	}
	/**
	* Returns the sample count of the given render context.
	*
	* @param {RenderContext} renderContext - The render context.
	* @return {number} The sample count.
	*/
	getSampleCountRenderContext(renderContext) {
		if (renderContext.textures !== null) return this.getSampleCount(renderContext.sampleCount);
		return this.getSampleCount(this.backend.renderer.currentSamples);
	}
	/**
	* Returns the preferred canvas format.
	*
	* There is a separate method for this so it's possible to
	* honor edge cases for specific devices.
	*
	* @return {string} The GPU texture format of the canvas.
	*/
	getPreferredCanvasFormat() {
		const outputType = this.backend.parameters.outputType;
		if (outputType === void 0) return navigator.gpu.getPreferredCanvasFormat();
		else if (outputType === UnsignedByteType) return GPUTextureFormat.BGRA8Unorm;
		else if (outputType === HalfFloatType) return GPUTextureFormat.RGBA16Float;
		else throw new Error("Unsupported outputType");
	}
};
var typedArraysToVertexFormatPrefix = new Map([
	[Int8Array, ["sint8", "snorm8"]],
	[Uint8Array, ["uint8", "unorm8"]],
	[Int16Array, ["sint16", "snorm16"]],
	[Uint16Array, ["uint16", "unorm16"]],
	[Int32Array, ["sint32", "snorm32"]],
	[Uint32Array, ["uint32", "unorm32"]],
	[Float32Array, ["float32"]]
]);
if (typeof Float16Array !== "undefined") typedArraysToVertexFormatPrefix.set(Float16Array, ["float16"]);
var typedAttributeToVertexFormatPrefix = new Map([[Float16BufferAttribute, ["float16"]]]);
var typeArraysToVertexFormatPrefixForItemSize1 = new Map([
	[Int32Array, "sint32"],
	[Int16Array, "sint32"],
	[Uint32Array, "uint32"],
	[Uint16Array, "uint32"],
	[Float32Array, "float32"]
]);
/**
* A WebGPU backend utility module for managing shader attributes.
*
* @private
*/
var WebGPUAttributeUtils = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGPUBackend} backend - The WebGPU backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGPU backend.
		*
		* @type {WebGPUBackend}
		*/
		this.backend = backend;
	}
	/**
	* Creates the GPU buffer for the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	* @param {GPUBufferUsage} usage - A flag that indicates how the buffer may be used after its creation.
	*/
	createAttribute(attribute$2, usage) {
		const bufferAttribute$2 = this._getBufferAttribute(attribute$2);
		const backend = this.backend;
		const bufferData = backend.get(bufferAttribute$2);
		let buffer$2 = bufferData.buffer;
		if (buffer$2 === void 0) {
			const device = backend.device;
			let array$2 = bufferAttribute$2.array;
			if (attribute$2.normalized === false) {
				if (array$2.constructor === Int16Array || array$2.constructor === Int8Array) array$2 = new Int32Array(array$2);
				else if (array$2.constructor === Uint16Array || array$2.constructor === Uint8Array) {
					array$2 = new Uint32Array(array$2);
					if (usage & GPUBufferUsage.INDEX) {
						for (let i = 0; i < array$2.length; i++) if (array$2[i] === 65535) array$2[i] = 4294967295;
					}
				}
			}
			bufferAttribute$2.array = array$2;
			if ((bufferAttribute$2.isStorageBufferAttribute || bufferAttribute$2.isStorageInstancedBufferAttribute) && bufferAttribute$2.itemSize === 3) {
				array$2 = new array$2.constructor(bufferAttribute$2.count * 4);
				for (let i = 0; i < bufferAttribute$2.count; i++) array$2.set(bufferAttribute$2.array.subarray(i * 3, i * 3 + 3), i * 4);
				bufferAttribute$2.itemSize = 4;
				bufferAttribute$2.array = array$2;
				bufferData._force3to4BytesAlignment = true;
			}
			const byteLength = array$2.byteLength;
			const size = byteLength + (4 - byteLength % 4) % 4;
			buffer$2 = device.createBuffer({
				label: bufferAttribute$2.name,
				size,
				usage,
				mappedAtCreation: true
			});
			new array$2.constructor(buffer$2.getMappedRange()).set(array$2);
			buffer$2.unmap();
			bufferData.buffer = buffer$2;
		}
	}
	/**
	* Updates the GPU buffer of the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	updateAttribute(attribute$2) {
		const bufferAttribute$2 = this._getBufferAttribute(attribute$2);
		const backend = this.backend;
		const device = backend.device;
		const bufferData = backend.get(bufferAttribute$2);
		const buffer$2 = backend.get(bufferAttribute$2).buffer;
		let array$2 = bufferAttribute$2.array;
		if (bufferData._force3to4BytesAlignment === true) {
			array$2 = new array$2.constructor(bufferAttribute$2.count * 4);
			for (let i = 0; i < bufferAttribute$2.count; i++) array$2.set(bufferAttribute$2.array.subarray(i * 3, i * 3 + 3), i * 4);
			bufferAttribute$2.array = array$2;
		}
		const isTypedArray$1 = this._isTypedArray(array$2);
		const updateRanges = bufferAttribute$2.updateRanges;
		if (updateRanges.length === 0) device.queue.writeBuffer(buffer$2, 0, array$2, 0);
		else {
			const byteOffsetFactor = isTypedArray$1 ? 1 : array$2.BYTES_PER_ELEMENT;
			for (let i = 0, l = updateRanges.length; i < l; i++) {
				const range$3 = updateRanges[i];
				let dataOffset, size;
				if (bufferData._force3to4BytesAlignment === true) {
					const vertexStart = Math.floor(range$3.start / 3);
					const vertexCount = Math.ceil(range$3.count / 3);
					dataOffset = vertexStart * 4 * byteOffsetFactor;
					size = vertexCount * 4 * byteOffsetFactor;
				} else {
					dataOffset = range$3.start * byteOffsetFactor;
					size = range$3.count * byteOffsetFactor;
				}
				const bufferOffset = dataOffset * (isTypedArray$1 ? array$2.BYTES_PER_ELEMENT : 1);
				device.queue.writeBuffer(buffer$2, bufferOffset, array$2, dataOffset, size);
			}
			bufferAttribute$2.clearUpdateRanges();
		}
	}
	/**
	* This method creates the vertex buffer layout data which are
	* require when creating a render pipeline for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {Array<Object>} An array holding objects which describe the vertex buffer layout.
	*/
	createShaderVertexBuffers(renderObject) {
		const attributes = renderObject.getAttributes();
		const vertexBuffers = /* @__PURE__ */ new Map();
		for (let slot = 0; slot < attributes.length; slot++) {
			const geometryAttribute = attributes[slot];
			const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
			const bufferAttribute$2 = this._getBufferAttribute(geometryAttribute);
			let vertexBufferLayout = vertexBuffers.get(bufferAttribute$2);
			if (vertexBufferLayout === void 0) {
				let arrayStride, stepMode;
				if (geometryAttribute.isInterleavedBufferAttribute === true) {
					arrayStride = geometryAttribute.data.stride * bytesPerElement;
					stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
				} else {
					arrayStride = geometryAttribute.itemSize * bytesPerElement;
					stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
				}
				if (geometryAttribute.normalized === false && (geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array)) arrayStride = 4;
				vertexBufferLayout = {
					arrayStride,
					attributes: [],
					stepMode
				};
				vertexBuffers.set(bufferAttribute$2, vertexBufferLayout);
			}
			const format = this._getVertexFormat(geometryAttribute);
			const offset = geometryAttribute.isInterleavedBufferAttribute === true ? geometryAttribute.offset * bytesPerElement : 0;
			vertexBufferLayout.attributes.push({
				shaderLocation: slot,
				offset,
				format
			});
		}
		return Array.from(vertexBuffers.values());
	}
	/**
	* Destroys the GPU buffer of the given buffer attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	destroyAttribute(attribute$2) {
		const backend = this.backend;
		backend.get(this._getBufferAttribute(attribute$2)).buffer.destroy();
		backend.delete(attribute$2);
	}
	/**
	* This method performs a readback operation by moving buffer data from
	* a storage buffer attribute from the GPU to the CPU.
	*
	* @async
	* @param {StorageBufferAttribute} attribute - The storage buffer attribute.
	* @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
	*/
	async getArrayBufferAsync(attribute$2) {
		const backend = this.backend;
		const device = backend.device;
		const bufferGPU = backend.get(this._getBufferAttribute(attribute$2)).buffer;
		const size = bufferGPU.size;
		const readBufferGPU = device.createBuffer({
			label: `${attribute$2.name}_readback`,
			size,
			usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
		});
		const cmdEncoder = device.createCommandEncoder({ label: `readback_encoder_${attribute$2.name}` });
		cmdEncoder.copyBufferToBuffer(bufferGPU, 0, readBufferGPU, 0, size);
		const gpuCommands = cmdEncoder.finish();
		device.queue.submit([gpuCommands]);
		await readBufferGPU.mapAsync(GPUMapMode.READ);
		const arrayBuffer$2 = readBufferGPU.getMappedRange();
		const dstBuffer = new attribute$2.array.constructor(arrayBuffer$2.slice(0));
		readBufferGPU.unmap();
		return dstBuffer.buffer;
	}
	/**
	* Returns the vertex format of the given buffer attribute.
	*
	* @private
	* @param {BufferAttribute} geometryAttribute - The buffer attribute.
	* @return {string|undefined} The vertex format (e.g. 'float32x3').
	*/
	_getVertexFormat(geometryAttribute) {
		const { itemSize, normalized } = geometryAttribute;
		const ArrayType = geometryAttribute.array.constructor;
		const AttributeType$1 = geometryAttribute.constructor;
		let format;
		if (itemSize === 1) format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);
		else {
			const prefix = (typedAttributeToVertexFormatPrefix.get(AttributeType$1) || typedArraysToVertexFormatPrefix.get(ArrayType))[normalized ? 1 : 0];
			if (prefix) {
				const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
				const paddedItemSize = Math.floor((bytesPerUnit + 3) / 4) * 4 / ArrayType.BYTES_PER_ELEMENT;
				if (paddedItemSize % 1) throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
				format = `${prefix}x${paddedItemSize}`;
			}
		}
		if (!format) error("WebGPUAttributeUtils: Vertex format not supported yet.");
		return format;
	}
	/**
	* Returns `true` if the given array is a typed array.
	*
	* @private
	* @param {any} array - The array.
	* @return {boolean} Whether the given array is a typed array or not.
	*/
	_isTypedArray(array$2) {
		return ArrayBuffer.isView(array$2) && !(array$2 instanceof DataView);
	}
	/**
	* Utility method for handling interleaved buffer attributes correctly.
	* To process them, their `InterleavedBuffer` is returned.
	*
	* @private
	* @param {BufferAttribute} attribute - The attribute.
	* @return {BufferAttribute|InterleavedBuffer}
	*/
	_getBufferAttribute(attribute$2) {
		if (attribute$2.isInterleavedBufferAttribute) attribute$2 = attribute$2.data;
		return attribute$2;
	}
};
/**
* A WebGPU backend utility module for managing bindings.
*
* When reading the documentation it's helpful to keep in mind that
* all class definitions starting with 'GPU*' are modules from the
* WebGPU API. So for example `BindGroup` is a class from the engine
* whereas `GPUBindGroup` is a class from WebGPU.
*
* @private
*/
var WebGPUBindingUtils = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGPUBackend} backend - The WebGPU backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGPU backend.
		*
		* @type {WebGPUBackend}
		*/
		this.backend = backend;
		/**
		* A cache for managing bind group layouts.
		*
		* @type {WeakMap<Array<Binding>,GPUBindGroupLayout>}
		*/
		this.bindGroupLayoutCache = /* @__PURE__ */ new WeakMap();
	}
	/**
	* Creates a GPU bind group layout for the given bind group.
	*
	* @param {BindGroup} bindGroup - The bind group.
	* @return {GPUBindGroupLayout} The GPU bind group layout.
	*/
	createBindingsLayout(bindGroup) {
		const backend = this.backend;
		const device = backend.device;
		const entries = [];
		let index = 0;
		for (const binding of bindGroup.bindings) {
			const bindingGPU = {
				binding: index++,
				visibility: binding.visibility
			};
			if (binding.isUniformBuffer || binding.isStorageBuffer) {
				const buffer$2 = {};
				if (binding.isStorageBuffer) if (binding.visibility & 4) if (binding.access === NodeAccess$1.READ_WRITE || binding.access === NodeAccess$1.WRITE_ONLY) buffer$2.type = GPUBufferBindingType.Storage;
				else buffer$2.type = GPUBufferBindingType.ReadOnlyStorage;
				else buffer$2.type = GPUBufferBindingType.ReadOnlyStorage;
				bindingGPU.buffer = buffer$2;
			} else if (binding.isSampledTexture && binding.store) {
				const storageTexture$2 = {};
				storageTexture$2.format = this.backend.get(binding.texture).texture.format;
				const access = binding.access;
				if (access === NodeAccess$1.READ_WRITE) storageTexture$2.access = GPUStorageTextureAccess.ReadWrite;
				else if (access === NodeAccess$1.WRITE_ONLY) storageTexture$2.access = GPUStorageTextureAccess.WriteOnly;
				else storageTexture$2.access = GPUStorageTextureAccess.ReadOnly;
				if (binding.texture.isArrayTexture) storageTexture$2.viewDimension = GPUTextureViewDimension.TwoDArray;
				else if (binding.texture.is3DTexture) storageTexture$2.viewDimension = GPUTextureViewDimension.ThreeD;
				bindingGPU.storageTexture = storageTexture$2;
			} else if (binding.isSampledTexture) {
				const texture$2 = {};
				const { primarySamples } = backend.utils.getTextureSampleData(binding.texture);
				if (primarySamples > 1) {
					texture$2.multisampled = true;
					if (!binding.texture.isDepthTexture) texture$2.sampleType = GPUTextureSampleType.UnfilterableFloat;
				}
				if (binding.texture.isDepthTexture) if (backend.compatibilityMode && binding.texture.compareFunction === null) texture$2.sampleType = GPUTextureSampleType.UnfilterableFloat;
				else texture$2.sampleType = GPUTextureSampleType.Depth;
				else if (binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture) {
					const type$1 = binding.texture.type;
					if (type$1 === IntType) texture$2.sampleType = GPUTextureSampleType.SInt;
					else if (type$1 === UnsignedIntType) texture$2.sampleType = GPUTextureSampleType.UInt;
					else if (type$1 === FloatType) if (this.backend.hasFeature("float32-filterable")) texture$2.sampleType = GPUTextureSampleType.Float;
					else texture$2.sampleType = GPUTextureSampleType.UnfilterableFloat;
				}
				if (binding.isSampledCubeTexture) texture$2.viewDimension = GPUTextureViewDimension.Cube;
				else if (binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) texture$2.viewDimension = GPUTextureViewDimension.TwoDArray;
				else if (binding.isSampledTexture3D) texture$2.viewDimension = GPUTextureViewDimension.ThreeD;
				bindingGPU.texture = texture$2;
			} else if (binding.isSampler) {
				const sampler$2 = {};
				if (binding.texture.isDepthTexture) {
					if (binding.texture.compareFunction !== null) sampler$2.type = GPUSamplerBindingType.Comparison;
					else if (backend.compatibilityMode) sampler$2.type = GPUSamplerBindingType.NonFiltering;
				}
				bindingGPU.sampler = sampler$2;
			} else error(`WebGPUBindingUtils: Unsupported binding "${binding}".`);
			entries.push(bindingGPU);
		}
		return device.createBindGroupLayout({ entries });
	}
	/**
	* Creates bindings from the given bind group definition.
	*
	* @param {BindGroup} bindGroup - The bind group.
	* @param {Array<BindGroup>} bindings - Array of bind groups.
	* @param {number} cacheIndex - The cache index.
	* @param {number} version - The version.
	*/
	createBindings(bindGroup, bindings, cacheIndex, version = 0) {
		const { backend, bindGroupLayoutCache } = this;
		const bindingsData = backend.get(bindGroup);
		let bindLayoutGPU = bindGroupLayoutCache.get(bindGroup.bindingsReference);
		if (bindLayoutGPU === void 0) {
			bindLayoutGPU = this.createBindingsLayout(bindGroup);
			bindGroupLayoutCache.set(bindGroup.bindingsReference, bindLayoutGPU);
		}
		let bindGroupGPU;
		if (cacheIndex > 0) {
			if (bindingsData.groups === void 0) {
				bindingsData.groups = [];
				bindingsData.versions = [];
			}
			if (bindingsData.versions[cacheIndex] === version) bindGroupGPU = bindingsData.groups[cacheIndex];
		}
		if (bindGroupGPU === void 0) {
			bindGroupGPU = this.createBindGroup(bindGroup, bindLayoutGPU);
			if (cacheIndex > 0) {
				bindingsData.groups[cacheIndex] = bindGroupGPU;
				bindingsData.versions[cacheIndex] = version;
			}
		}
		bindingsData.group = bindGroupGPU;
		bindingsData.layout = bindLayoutGPU;
	}
	/**
	* Updates a buffer binding.
	*
	*  @param {Buffer} binding - The buffer binding to update.
	*/
	updateBinding(binding) {
		const backend = this.backend;
		const device = backend.device;
		const buffer$2 = binding.buffer;
		const bufferGPU = backend.get(binding).buffer;
		device.queue.writeBuffer(bufferGPU, 0, buffer$2, 0);
	}
	/**
	* Creates a GPU bind group for the camera index.
	*
	* @param {Uint32Array} data - The index data.
	* @param {GPUBindGroupLayout} layout - The GPU bind group layout.
	* @return {GPUBindGroup} The GPU bind group.
	*/
	createBindGroupIndex(data, layout) {
		const device = this.backend.device;
		const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
		const index = data[0];
		const buffer$2 = device.createBuffer({
			label: "bindingCameraIndex_" + index,
			size: 16,
			usage
		});
		device.queue.writeBuffer(buffer$2, 0, data, 0);
		const entries = [{
			binding: 0,
			resource: { buffer: buffer$2 }
		}];
		return device.createBindGroup({
			label: "bindGroupCameraIndex_" + index,
			layout,
			entries
		});
	}
	/**
	* Creates a GPU bind group for the given bind group and GPU layout.
	*
	* @param {BindGroup} bindGroup - The bind group.
	* @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.
	* @return {GPUBindGroup} The GPU bind group.
	*/
	createBindGroup(bindGroup, layoutGPU) {
		const backend = this.backend;
		const device = backend.device;
		let bindingPoint = 0;
		const entriesGPU = [];
		for (const binding of bindGroup.bindings) {
			if (binding.isUniformBuffer) {
				const bindingData = backend.get(binding);
				if (bindingData.buffer === void 0) {
					const byteLength = binding.byteLength;
					const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
					bindingData.buffer = device.createBuffer({
						label: "bindingBuffer_" + binding.name,
						size: byteLength,
						usage
					});
				}
				entriesGPU.push({
					binding: bindingPoint,
					resource: { buffer: bindingData.buffer }
				});
			} else if (binding.isStorageBuffer) {
				const bindingData = backend.get(binding);
				if (bindingData.buffer === void 0) {
					const attribute$2 = binding.attribute;
					bindingData.buffer = backend.get(attribute$2).buffer;
				}
				entriesGPU.push({
					binding: bindingPoint,
					resource: { buffer: bindingData.buffer }
				});
			} else if (binding.isSampledTexture) {
				const textureData = backend.get(binding.texture);
				let resourceGPU;
				if (textureData.externalTexture !== void 0) resourceGPU = device.importExternalTexture({ source: textureData.externalTexture });
				else {
					const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;
					const baseMipLevel = binding.store ? binding.mipLevel : 0;
					let propertyName = `view-${textureData.texture.width}-${textureData.texture.height}`;
					if (textureData.texture.depthOrArrayLayers > 1) propertyName += `-${textureData.texture.depthOrArrayLayers}`;
					propertyName += `-${mipLevelCount}-${baseMipLevel}`;
					resourceGPU = textureData[propertyName];
					if (resourceGPU === void 0) {
						const aspectGPU = GPUTextureAspect.All;
						let dimensionViewGPU;
						if (binding.isSampledCubeTexture) dimensionViewGPU = GPUTextureViewDimension.Cube;
						else if (binding.isSampledTexture3D) dimensionViewGPU = GPUTextureViewDimension.ThreeD;
						else if (binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) dimensionViewGPU = GPUTextureViewDimension.TwoDArray;
						else dimensionViewGPU = GPUTextureViewDimension.TwoD;
						resourceGPU = textureData[propertyName] = textureData.texture.createView({
							aspect: aspectGPU,
							dimension: dimensionViewGPU,
							mipLevelCount,
							baseMipLevel
						});
					}
				}
				entriesGPU.push({
					binding: bindingPoint,
					resource: resourceGPU
				});
			} else if (binding.isSampler) {
				const textureGPU = backend.get(binding.texture);
				entriesGPU.push({
					binding: bindingPoint,
					resource: textureGPU.sampler
				});
			}
			bindingPoint++;
		}
		return device.createBindGroup({
			label: "bindGroup_" + bindGroup.name,
			layout: layoutGPU,
			entries: entriesGPU
		});
	}
};
/**
* A WebGPU backend utility module for managing pipelines.
*
* @private
*/
var WebGPUPipelineUtils = class {
	/**
	* Constructs a new utility object.
	*
	* @param {WebGPUBackend} backend - The WebGPU backend.
	*/
	constructor(backend) {
		/**
		* A reference to the WebGPU backend.
		*
		* @type {WebGPUBackend}
		*/
		this.backend = backend;
		/**
		* A Weak Map that tracks the active pipeline for render or compute passes.
		*
		* @private
		* @type {WeakMap<(GPURenderPassEncoder|GPUComputePassEncoder),(GPURenderPipeline|GPUComputePipeline)>}
		*/
		this._activePipelines = /* @__PURE__ */ new WeakMap();
	}
	/**
	* Sets the given pipeline for the given pass. The method makes sure to only set the
	* pipeline when necessary.
	*
	* @param {(GPURenderPassEncoder|GPUComputePassEncoder)} pass - The pass encoder.
	* @param {(GPURenderPipeline|GPUComputePipeline)} pipeline - The pipeline.
	*/
	setPipeline(pass$2, pipeline) {
		if (this._activePipelines.get(pass$2) !== pipeline) {
			pass$2.setPipeline(pipeline);
			this._activePipelines.set(pass$2, pipeline);
		}
	}
	/**
	* Returns the sample count derived from the given render context.
	*
	* @private
	* @param {RenderContext} renderContext - The render context.
	* @return {number} The sample count.
	*/
	_getSampleCount(renderContext) {
		return this.backend.utils.getSampleCountRenderContext(renderContext);
	}
	/**
	* Creates a render pipeline for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	* @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
	*/
	createRenderPipeline(renderObject, promises) {
		const { object, material, geometry, pipeline } = renderObject;
		const { vertexProgram, fragmentProgram } = pipeline;
		const backend = this.backend;
		const device = backend.device;
		const utils = backend.utils;
		const pipelineData = backend.get(pipeline);
		const bindGroupLayouts = [];
		for (const bindGroup of renderObject.getBindings()) {
			const bindingsData = backend.get(bindGroup);
			bindGroupLayouts.push(bindingsData.layout);
		}
		const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers(renderObject);
		let blending;
		if (material.blending !== NoBlending && (material.blending !== NormalBlending || material.transparent !== false)) blending = this._getBlending(material);
		let stencilFront = {};
		if (material.stencilWrite === true) stencilFront = {
			compare: this._getStencilCompare(material),
			failOp: this._getStencilOperation(material.stencilFail),
			depthFailOp: this._getStencilOperation(material.stencilZFail),
			passOp: this._getStencilOperation(material.stencilZPass)
		};
		const colorWriteMask = this._getColorWriteMask(material);
		const targets = [];
		if (renderObject.context.textures !== null) {
			const textures = renderObject.context.textures;
			for (let i = 0; i < textures.length; i++) {
				const colorFormat = utils.getTextureFormatGPU(textures[i]);
				targets.push({
					format: colorFormat,
					blend: blending,
					writeMask: colorWriteMask
				});
			}
		} else {
			const colorFormat = utils.getCurrentColorFormat(renderObject.context);
			targets.push({
				format: colorFormat,
				blend: blending,
				writeMask: colorWriteMask
			});
		}
		const vertexModule = backend.get(vertexProgram).module;
		const fragmentModule = backend.get(fragmentProgram).module;
		const primitiveState = this._getPrimitiveState(object, geometry, material);
		const depthCompare = this._getDepthCompare(material);
		const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
		const sampleCount = this._getSampleCount(renderObject.context);
		const pipelineDescriptor = {
			label: `renderPipeline_${material.name || material.type}_${material.id}`,
			vertex: Object.assign({}, vertexModule, { buffers: vertexBuffers }),
			fragment: Object.assign({}, fragmentModule, { targets }),
			primitive: primitiveState,
			multisample: {
				count: sampleCount,
				alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1
			},
			layout: device.createPipelineLayout({ bindGroupLayouts })
		};
		const depthStencil = {};
		const renderDepth = renderObject.context.depth;
		const renderStencil = renderObject.context.stencil;
		if (renderDepth === true || renderStencil === true) {
			if (renderDepth === true) {
				depthStencil.format = depthStencilFormat;
				depthStencil.depthWriteEnabled = material.depthWrite;
				depthStencil.depthCompare = depthCompare;
			}
			if (renderStencil === true) {
				depthStencil.stencilFront = stencilFront;
				depthStencil.stencilBack = {};
				depthStencil.stencilReadMask = material.stencilFuncMask;
				depthStencil.stencilWriteMask = material.stencilWriteMask;
			}
			if (material.polygonOffset === true) {
				depthStencil.depthBias = material.polygonOffsetUnits;
				depthStencil.depthBiasSlopeScale = material.polygonOffsetFactor;
				depthStencil.depthBiasClamp = 0;
			}
			pipelineDescriptor.depthStencil = depthStencil;
		}
		device.pushErrorScope("validation");
		if (promises === null) {
			pipelineData.pipeline = device.createRenderPipeline(pipelineDescriptor);
			device.popErrorScope().then((err) => {
				if (err !== null) {
					pipelineData.error = true;
					error(err.message);
				}
			});
		} else {
			const p$1 = new Promise(async (resolve) => {
				try {
					pipelineData.pipeline = await device.createRenderPipelineAsync(pipelineDescriptor);
				} catch (err) {}
				const errorScope = await device.popErrorScope();
				if (errorScope !== null) {
					pipelineData.error = true;
					error(errorScope.message);
				}
				resolve();
			});
			promises.push(p$1);
		}
	}
	/**
	* Creates GPU render bundle encoder for the given render context.
	*
	* @param {RenderContext} renderContext - The render context.
	* @param {?string} [label='renderBundleEncoder'] - The label.
	* @return {GPURenderBundleEncoder} The GPU render bundle encoder.
	*/
	createBundleEncoder(renderContext, label$2 = "renderBundleEncoder") {
		const { utils, device } = this.backend;
		const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderContext);
		const colorFormats = utils.getCurrentColorFormats(renderContext);
		const sampleCount = this._getSampleCount(renderContext);
		const descriptor = {
			label: label$2,
			colorFormats,
			depthStencilFormat,
			sampleCount
		};
		return device.createRenderBundleEncoder(descriptor);
	}
	/**
	* Creates a compute pipeline for the given compute node.
	*
	* @param {ComputePipeline} pipeline - The compute pipeline.
	* @param {Array<BindGroup>} bindings - The bindings.
	*/
	createComputePipeline(pipeline, bindings) {
		const backend = this.backend;
		const device = backend.device;
		const computeProgram = backend.get(pipeline.computeProgram).module;
		const pipelineGPU = backend.get(pipeline);
		const bindGroupLayouts = [];
		for (const bindingsGroup of bindings) {
			const bindingsData = backend.get(bindingsGroup);
			bindGroupLayouts.push(bindingsData.layout);
		}
		pipelineGPU.pipeline = device.createComputePipeline({
			compute: computeProgram,
			layout: device.createPipelineLayout({ bindGroupLayouts })
		});
	}
	/**
	* Returns the blending state as a descriptor object required
	* for the pipeline creation.
	*
	* @private
	* @param {Material} material - The material.
	* @return {Object} The blending state.
	*/
	_getBlending(material) {
		let color$2, alpha;
		const blending = material.blending;
		const blendSrc = material.blendSrc;
		const blendDst = material.blendDst;
		const blendEquation = material.blendEquation;
		if (blending === CustomBlending) {
			const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
			const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
			const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;
			color$2 = {
				srcFactor: this._getBlendFactor(blendSrc),
				dstFactor: this._getBlendFactor(blendDst),
				operation: this._getBlendOperation(blendEquation)
			};
			alpha = {
				srcFactor: this._getBlendFactor(blendSrcAlpha),
				dstFactor: this._getBlendFactor(blendDstAlpha),
				operation: this._getBlendOperation(blendEquationAlpha)
			};
		} else {
			const premultipliedAlpha = material.premultipliedAlpha;
			const setBlend = (srcRGB, dstRGB, srcAlpha, dstAlpha) => {
				color$2 = {
					srcFactor: srcRGB,
					dstFactor: dstRGB,
					operation: GPUBlendOperation.Add
				};
				alpha = {
					srcFactor: srcAlpha,
					dstFactor: dstAlpha,
					operation: GPUBlendOperation.Add
				};
			};
			if (premultipliedAlpha) switch (blending) {
				case NormalBlending:
					setBlend(GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
					break;
				case AdditiveBlending:
					setBlend(GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
					break;
				case SubtractiveBlending:
					setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);
					break;
				case MultiplyBlending:
					setBlend(GPUBlendFactor.Dst, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.Zero, GPUBlendFactor.One);
					break;
			}
			else switch (blending) {
				case NormalBlending:
					setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
					break;
				case AdditiveBlending:
					setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
					break;
				case SubtractiveBlending:
					error("WebGPURenderer: SubtractiveBlending requires material.premultipliedAlpha = true");
					break;
				case MultiplyBlending:
					error("WebGPURenderer: MultiplyBlending requires material.premultipliedAlpha = true");
					break;
			}
		}
		if (color$2 !== void 0 && alpha !== void 0) return {
			color: color$2,
			alpha
		};
		else error("WebGPURenderer: Invalid blending: ", blending);
	}
	/**
	* Returns the GPU blend factor which is required for the pipeline creation.
	*
	* @private
	* @param {number} blend - The blend factor as a three.js constant.
	* @return {string} The GPU blend factor.
	*/
	_getBlendFactor(blend) {
		let blendFactor;
		switch (blend) {
			case ZeroFactor:
				blendFactor = GPUBlendFactor.Zero;
				break;
			case OneFactor:
				blendFactor = GPUBlendFactor.One;
				break;
			case SrcColorFactor:
				blendFactor = GPUBlendFactor.Src;
				break;
			case OneMinusSrcColorFactor:
				blendFactor = GPUBlendFactor.OneMinusSrc;
				break;
			case SrcAlphaFactor:
				blendFactor = GPUBlendFactor.SrcAlpha;
				break;
			case OneMinusSrcAlphaFactor:
				blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
				break;
			case DstColorFactor:
				blendFactor = GPUBlendFactor.Dst;
				break;
			case OneMinusDstColorFactor:
				blendFactor = GPUBlendFactor.OneMinusDst;
				break;
			case DstAlphaFactor:
				blendFactor = GPUBlendFactor.DstAlpha;
				break;
			case OneMinusDstAlphaFactor:
				blendFactor = GPUBlendFactor.OneMinusDstAlpha;
				break;
			case SrcAlphaSaturateFactor:
				blendFactor = GPUBlendFactor.SrcAlphaSaturated;
				break;
			case BlendColorFactor:
				blendFactor = GPUBlendFactor.Constant;
				break;
			case OneMinusBlendColorFactor:
				blendFactor = GPUBlendFactor.OneMinusConstant;
				break;
			default: error("WebGPURenderer: Blend factor not supported.", blend);
		}
		return blendFactor;
	}
	/**
	* Returns the GPU stencil compare function which is required for the pipeline creation.
	*
	* @private
	* @param {Material} material - The material.
	* @return {string} The GPU stencil compare function.
	*/
	_getStencilCompare(material) {
		let stencilCompare;
		const stencilFunc = material.stencilFunc;
		switch (stencilFunc) {
			case NeverStencilFunc:
				stencilCompare = GPUCompareFunction.Never;
				break;
			case AlwaysStencilFunc:
				stencilCompare = GPUCompareFunction.Always;
				break;
			case LessStencilFunc:
				stencilCompare = GPUCompareFunction.Less;
				break;
			case LessEqualStencilFunc:
				stencilCompare = GPUCompareFunction.LessEqual;
				break;
			case EqualStencilFunc:
				stencilCompare = GPUCompareFunction.Equal;
				break;
			case GreaterEqualStencilFunc:
				stencilCompare = GPUCompareFunction.GreaterEqual;
				break;
			case GreaterStencilFunc:
				stencilCompare = GPUCompareFunction.Greater;
				break;
			case NotEqualStencilFunc:
				stencilCompare = GPUCompareFunction.NotEqual;
				break;
			default: error("WebGPURenderer: Invalid stencil function.", stencilFunc);
		}
		return stencilCompare;
	}
	/**
	* Returns the GPU stencil operation which is required for the pipeline creation.
	*
	* @private
	* @param {number} op - A three.js constant defining the stencil operation.
	* @return {string} The GPU stencil operation.
	*/
	_getStencilOperation(op) {
		let stencilOperation;
		switch (op) {
			case KeepStencilOp:
				stencilOperation = GPUStencilOperation.Keep;
				break;
			case ZeroStencilOp:
				stencilOperation = GPUStencilOperation.Zero;
				break;
			case ReplaceStencilOp:
				stencilOperation = GPUStencilOperation.Replace;
				break;
			case InvertStencilOp:
				stencilOperation = GPUStencilOperation.Invert;
				break;
			case IncrementStencilOp:
				stencilOperation = GPUStencilOperation.IncrementClamp;
				break;
			case DecrementStencilOp:
				stencilOperation = GPUStencilOperation.DecrementClamp;
				break;
			case IncrementWrapStencilOp:
				stencilOperation = GPUStencilOperation.IncrementWrap;
				break;
			case DecrementWrapStencilOp:
				stencilOperation = GPUStencilOperation.DecrementWrap;
				break;
			default: error("WebGPURenderer: Invalid stencil operation.", stencilOperation);
		}
		return stencilOperation;
	}
	/**
	* Returns the GPU blend operation which is required for the pipeline creation.
	*
	* @private
	* @param {number} blendEquation - A three.js constant defining the blend equation.
	* @return {string} The GPU blend operation.
	*/
	_getBlendOperation(blendEquation) {
		let blendOperation;
		switch (blendEquation) {
			case AddEquation:
				blendOperation = GPUBlendOperation.Add;
				break;
			case SubtractEquation:
				blendOperation = GPUBlendOperation.Subtract;
				break;
			case ReverseSubtractEquation:
				blendOperation = GPUBlendOperation.ReverseSubtract;
				break;
			case MinEquation:
				blendOperation = GPUBlendOperation.Min;
				break;
			case MaxEquation:
				blendOperation = GPUBlendOperation.Max;
				break;
			default: error("WebGPUPipelineUtils: Blend equation not supported.", blendEquation);
		}
		return blendOperation;
	}
	/**
	* Returns the primitive state as a descriptor object required
	* for the pipeline creation.
	*
	* @private
	* @param {Object3D} object - The 3D object.
	* @param {BufferGeometry} geometry - The geometry.
	* @param {Material} material - The material.
	* @return {Object} The primitive state.
	*/
	_getPrimitiveState(object, geometry, material) {
		const descriptor = {};
		descriptor.topology = this.backend.utils.getPrimitiveTopology(object, material);
		if (geometry.index !== null && object.isLine === true && object.isLineSegments !== true) descriptor.stripIndexFormat = geometry.index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
		let flipSided = material.side === BackSide;
		if (object.isMesh && object.matrixWorld.determinant() < 0) flipSided = !flipSided;
		descriptor.frontFace = flipSided === true ? GPUFrontFace.CW : GPUFrontFace.CCW;
		descriptor.cullMode = material.side === DoubleSide ? GPUCullMode.None : GPUCullMode.Back;
		return descriptor;
	}
	/**
	* Returns the GPU color write mask which is required for the pipeline creation.
	*
	* @private
	* @param {Material} material - The material.
	* @return {number} The GPU color write mask.
	*/
	_getColorWriteMask(material) {
		return material.colorWrite === true ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;
	}
	/**
	* Returns the GPU depth compare function which is required for the pipeline creation.
	*
	* @private
	* @param {Material} material - The material.
	* @return {string} The GPU depth compare function.
	*/
	_getDepthCompare(material) {
		let depthCompare;
		if (material.depthTest === false) depthCompare = GPUCompareFunction.Always;
		else {
			const depthFunc = material.depthFunc;
			switch (depthFunc) {
				case NeverDepth:
					depthCompare = GPUCompareFunction.Never;
					break;
				case AlwaysDepth:
					depthCompare = GPUCompareFunction.Always;
					break;
				case LessDepth:
					depthCompare = GPUCompareFunction.Less;
					break;
				case LessEqualDepth:
					depthCompare = GPUCompareFunction.LessEqual;
					break;
				case EqualDepth:
					depthCompare = GPUCompareFunction.Equal;
					break;
				case GreaterEqualDepth:
					depthCompare = GPUCompareFunction.GreaterEqual;
					break;
				case GreaterDepth:
					depthCompare = GPUCompareFunction.Greater;
					break;
				case NotEqualDepth:
					depthCompare = GPUCompareFunction.NotEqual;
					break;
				default: error("WebGPUPipelineUtils: Invalid depth function.", depthFunc);
			}
		}
		return depthCompare;
	}
};
/**
* Manages a pool of WebGPU timestamp queries for performance measurement.
* Extends the base TimestampQueryPool to provide WebGPU-specific implementation.
*
* @augments TimestampQueryPool
*/
var WebGPUTimestampQueryPool = class extends TimestampQueryPool {
	/**
	* Creates a new WebGPU timestamp query pool.
	*
	* @param {GPUDevice} device - The WebGPU device to create queries on.
	* @param {string} type - The type identifier for this query pool.
	* @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
	*/
	constructor(device, type$1, maxQueries = 2048) {
		super(maxQueries);
		this.device = device;
		this.type = type$1;
		this.querySet = this.device.createQuerySet({
			type: "timestamp",
			count: this.maxQueries,
			label: `queryset_global_timestamp_${type$1}`
		});
		const bufferSize = this.maxQueries * 8;
		this.resolveBuffer = this.device.createBuffer({
			label: `buffer_timestamp_resolve_${type$1}`,
			size: bufferSize,
			usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
		});
		this.resultBuffer = this.device.createBuffer({
			label: `buffer_timestamp_result_${type$1}`,
			size: bufferSize,
			usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
		});
	}
	/**
	* Allocates a pair of queries for a given render context.
	*
	* @param {string} uid - A unique identifier for the render context.
	* @returns {?number} The base offset for the allocated queries, or null if allocation failed.
	*/
	allocateQueriesForContext(uid) {
		if (!this.trackTimestamp || this.isDisposed) return null;
		if (this.currentQueryIndex + 2 > this.maxQueries) {
			warnOnce(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`);
			return null;
		}
		const baseOffset = this.currentQueryIndex;
		this.currentQueryIndex += 2;
		this.queryOffsets.set(uid, baseOffset);
		return baseOffset;
	}
	/**
	* Asynchronously resolves all pending queries and returns the total duration.
	* If there's already a pending resolve operation, returns that promise instead.
	*
	* @async
	* @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
	*/
	async resolveQueriesAsync() {
		if (!this.trackTimestamp || this.currentQueryIndex === 0 || this.isDisposed) return this.lastValue;
		if (this.pendingResolve) return this.pendingResolve;
		this.pendingResolve = this._resolveQueries();
		try {
			return await this.pendingResolve;
		} finally {
			this.pendingResolve = null;
		}
	}
	/**
	* Internal method to resolve queries and calculate total duration.
	*
	* @async
	* @private
	* @returns {Promise<number>} The total duration in milliseconds.
	*/
	async _resolveQueries() {
		if (this.isDisposed) return this.lastValue;
		try {
			if (this.resultBuffer.mapState !== "unmapped") return this.lastValue;
			const currentOffsets = new Map(this.queryOffsets);
			const queryCount = this.currentQueryIndex;
			const bytesUsed = queryCount * 8;
			this.currentQueryIndex = 0;
			this.queryOffsets.clear();
			const commandEncoder = this.device.createCommandEncoder();
			commandEncoder.resolveQuerySet(this.querySet, 0, queryCount, this.resolveBuffer, 0);
			commandEncoder.copyBufferToBuffer(this.resolveBuffer, 0, this.resultBuffer, 0, bytesUsed);
			const commandBuffer = commandEncoder.finish();
			this.device.queue.submit([commandBuffer]);
			if (this.resultBuffer.mapState !== "unmapped") return this.lastValue;
			await this.resultBuffer.mapAsync(GPUMapMode.READ, 0, bytesUsed);
			if (this.isDisposed) {
				if (this.resultBuffer.mapState === "mapped") this.resultBuffer.unmap();
				return this.lastValue;
			}
			const times = new BigUint64Array(this.resultBuffer.getMappedRange(0, bytesUsed));
			const framesDuration = {};
			const frames = [];
			for (const [uid, baseOffset] of currentOffsets) {
				const match = uid.match(/^(.*):f(\d+)$/);
				const frame = parseInt(match[2]);
				if (frames.includes(frame) === false) frames.push(frame);
				if (framesDuration[frame] === void 0) framesDuration[frame] = 0;
				const startTime = times[baseOffset];
				const endTime = times[baseOffset + 1];
				const duration = Number(endTime - startTime) / 1e6;
				this.timestamps.set(uid, duration);
				framesDuration[frame] += duration;
			}
			const totalDuration = framesDuration[frames[frames.length - 1]];
			this.resultBuffer.unmap();
			this.lastValue = totalDuration;
			this.frames = frames;
			return totalDuration;
		} catch (error$1) {
			error$1("Error resolving queries:", error$1);
			if (this.resultBuffer.mapState === "mapped") this.resultBuffer.unmap();
			return this.lastValue;
		}
	}
	/**
	* Dispose of the query pool.
	*
	* @async
	* @returns {Promise} A Promise that resolves when the dispose has been executed.
	*/
	async dispose() {
		if (this.isDisposed) return;
		this.isDisposed = true;
		if (this.pendingResolve) try {
			await this.pendingResolve;
		} catch (error$1) {
			error$1("Error waiting for pending resolve:", error$1);
		}
		if (this.resultBuffer && this.resultBuffer.mapState === "mapped") try {
			this.resultBuffer.unmap();
		} catch (error$1) {
			error$1("Error unmapping buffer:", error$1);
		}
		if (this.querySet) {
			this.querySet.destroy();
			this.querySet = null;
		}
		if (this.resolveBuffer) {
			this.resolveBuffer.destroy();
			this.resolveBuffer = null;
		}
		if (this.resultBuffer) {
			this.resultBuffer.destroy();
			this.resultBuffer = null;
		}
		this.queryOffsets.clear();
		this.pendingResolve = null;
	}
};
/**
* A backend implementation targeting WebGPU.
*
* @private
* @augments Backend
*/
var WebGPUBackend = class extends Backend {
	/**
	* WebGPUBackend options.
	*
	* @typedef {Object} WebGPUBackend~Options
	* @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
	* @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
	* @property {boolean} [compatibilityMode=false] - Whether the backend should be in compatibility mode or not.
	* @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
	* @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
	* @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
	* @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
	* @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
	* @property {boolean} [trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.
	* @property {string} [powerPreference=undefined] - The power preference.
	* @property {Object} [requiredLimits=undefined] - Specifies the limits that are required by the device request. The request will fail if the adapter cannot provide these limits.
	* @property {GPUDevice} [device=undefined] - If there is an existing GPU device on app level, it can be passed to the renderer as a parameter.
	* @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
	*/
	/**
	* Constructs a new WebGPU backend.
	*
	* @param {WebGPUBackend~Options} [parameters] - The configuration parameter.
	*/
	constructor(parameters = {}) {
		super(parameters);
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isWebGPUBackend = true;
		this.parameters.alpha = parameters.alpha === void 0 ? true : parameters.alpha;
		this.parameters.compatibilityMode = parameters.compatibilityMode === void 0 ? false : parameters.compatibilityMode;
		this.parameters.requiredLimits = parameters.requiredLimits === void 0 ? {} : parameters.requiredLimits;
		/**
		* Indicates whether the backend is in compatibility mode or not.
		* @type {boolean}
		* @default false
		*/
		this.compatibilityMode = this.parameters.compatibilityMode;
		/**
		* A reference to the device.
		*
		* @type {?GPUDevice}
		* @default null
		*/
		this.device = null;
		/**
		* A reference to the default render pass descriptor.
		*
		* @type {?Object}
		* @default null
		*/
		this.defaultRenderPassdescriptor = null;
		/**
		* A reference to a backend module holding common utility functions.
		*
		* @type {WebGPUUtils}
		*/
		this.utils = new WebGPUUtils(this);
		/**
		* A reference to a backend module holding shader attribute-related
		* utility functions.
		*
		* @type {WebGPUAttributeUtils}
		*/
		this.attributeUtils = new WebGPUAttributeUtils(this);
		/**
		* A reference to a backend module holding shader binding-related
		* utility functions.
		*
		* @type {WebGPUBindingUtils}
		*/
		this.bindingUtils = new WebGPUBindingUtils(this);
		/**
		* A reference to a backend module holding shader pipeline-related
		* utility functions.
		*
		* @type {WebGPUPipelineUtils}
		*/
		this.pipelineUtils = new WebGPUPipelineUtils(this);
		/**
		* A reference to a backend module holding shader texture-related
		* utility functions.
		*
		* @type {WebGPUTextureUtils}
		*/
		this.textureUtils = new WebGPUTextureUtils(this);
		/**
		* A map that manages the resolve buffers for occlusion queries.
		*
		* @type {Map<number,GPUBuffer>}
		*/
		this.occludedResolveCache = /* @__PURE__ */ new Map();
	}
	/**
	* Initializes the backend so it is ready for usage.
	*
	* @async
	* @param {Renderer} renderer - The renderer.
	* @return {Promise} A Promise that resolves when the backend has been initialized.
	*/
	async init(renderer) {
		await super.init(renderer);
		const parameters = this.parameters;
		let device;
		if (parameters.device === void 0) {
			const adapterOptions = {
				powerPreference: parameters.powerPreference,
				featureLevel: parameters.compatibilityMode ? "compatibility" : void 0
			};
			const adapter = typeof navigator !== "undefined" ? await navigator.gpu.requestAdapter(adapterOptions) : null;
			if (adapter === null) throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
			const features = Object.values(GPUFeatureName);
			const supportedFeatures = [];
			for (const name of features) if (adapter.features.has(name)) supportedFeatures.push(name);
			const deviceDescriptor = {
				requiredFeatures: supportedFeatures,
				requiredLimits: parameters.requiredLimits
			};
			device = await adapter.requestDevice(deviceDescriptor);
		} else device = parameters.device;
		device.lost.then((info) => {
			const deviceLossInfo = {
				api: "WebGPU",
				message: info.message || "Unknown reason",
				reason: info.reason || null,
				originalEvent: info
			};
			renderer.onDeviceLost(deviceLossInfo);
		});
		this.device = device;
		this.trackTimestamp = this.trackTimestamp && this.hasFeature(GPUFeatureName.TimestampQuery);
		this.updateSize();
	}
	/**
	* A reference to the context.
	*
	* @type {?GPUCanvasContext}
	* @default null
	*/
	get context() {
		const canvasTarget = this.renderer.getCanvasTarget();
		const canvasData = this.get(canvasTarget);
		let context$2 = canvasData.context;
		if (context$2 === void 0) {
			const parameters = this.parameters;
			if (canvasTarget.isDefaultCanvasTarget === true && parameters.context !== void 0) context$2 = parameters.context;
			else context$2 = canvasTarget.domElement.getContext("webgpu");
			if ("setAttribute" in canvasTarget.domElement) canvasTarget.domElement.setAttribute("data-engine", `three.js r${REVISION} webgpu`);
			const alphaMode = parameters.alpha ? "premultiplied" : "opaque";
			const toneMappingMode = parameters.outputType === HalfFloatType ? "extended" : "standard";
			context$2.configure({
				device: this.device,
				format: this.utils.getPreferredCanvasFormat(),
				usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
				alphaMode,
				toneMapping: { mode: toneMappingMode }
			});
			canvasData.context = context$2;
		}
		return context$2;
	}
	/**
	* The coordinate system of the backend.
	*
	* @type {number}
	* @readonly
	*/
	get coordinateSystem() {
		return WebGPUCoordinateSystem;
	}
	/**
	* This method performs a readback operation by moving buffer data from
	* a storage buffer attribute from the GPU to the CPU.
	*
	* @async
	* @param {StorageBufferAttribute} attribute - The storage buffer attribute.
	* @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
	*/
	async getArrayBufferAsync(attribute$2) {
		return await this.attributeUtils.getArrayBufferAsync(attribute$2);
	}
	/**
	* Returns the backend's rendering context.
	*
	* @return {GPUCanvasContext} The rendering context.
	*/
	getContext() {
		return this.context;
	}
	/**
	* Returns the default render pass descriptor.
	*
	* In WebGPU, the default framebuffer must be configured
	* like custom framebuffers so the backend needs a render
	* pass descriptor even when rendering directly to screen.
	*
	* @private
	* @return {Object} The render pass descriptor.
	*/
	_getDefaultRenderPassDescriptor() {
		const renderer = this.renderer;
		const canvasTarget = renderer.getCanvasTarget();
		const canvasData = this.get(canvasTarget);
		const samples = renderer.currentSamples;
		let descriptor = canvasData.descriptor;
		if (descriptor === void 0 || canvasData.samples !== samples) {
			descriptor = { colorAttachments: [{ view: null }] };
			if (renderer.depth === true || renderer.stencil === true) descriptor.depthStencilAttachment = { view: this.textureUtils.getDepthBuffer(renderer.depth, renderer.stencil).createView() };
			const colorAttachment$1 = descriptor.colorAttachments[0];
			if (samples > 0) colorAttachment$1.view = this.textureUtils.getColorBuffer().createView();
			else colorAttachment$1.resolveTarget = void 0;
			canvasData.descriptor = descriptor;
			canvasData.samples = samples;
		}
		const colorAttachment = descriptor.colorAttachments[0];
		if (samples > 0) colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();
		else colorAttachment.view = this.context.getCurrentTexture().createView();
		return descriptor;
	}
	/**
	* Internal to determine if the current render target is a render target array with depth 2D array texture.
	*
	* @param {RenderContext} renderContext - The render context.
	* @return {boolean} Whether the render target is a render target array with depth 2D array texture.
	*
	* @private
	*/
	_isRenderCameraDepthArray(renderContext) {
		return renderContext.depthTexture && renderContext.depthTexture.image.depth > 1 && renderContext.camera.isArrayCamera;
	}
	/**
	* Returns the render pass descriptor for the given render context.
	*
	* @private
	* @param {RenderContext} renderContext - The render context.
	* @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.
	* @return {Object} The render pass descriptor.
	*/
	_getRenderPassDescriptor(renderContext, colorAttachmentsConfig = {}) {
		const renderTarget = renderContext.renderTarget;
		const renderTargetData = this.get(renderTarget);
		let descriptors = renderTargetData.descriptors;
		if (descriptors === void 0 || renderTargetData.width !== renderTarget.width || renderTargetData.height !== renderTarget.height || renderTargetData.samples !== renderTarget.samples) {
			descriptors = {};
			renderTargetData.descriptors = descriptors;
		}
		const cacheKey = renderContext.getCacheKey();
		let descriptorBase = descriptors[cacheKey];
		if (descriptorBase === void 0) {
			const textures = renderContext.textures;
			const textureViews = [];
			let sliceIndex;
			const isRenderCameraDepthArray = this._isRenderCameraDepthArray(renderContext);
			for (let i = 0; i < textures.length; i++) {
				const textureData = this.get(textures[i]);
				const viewDescriptor = {
					label: `colorAttachment_${i}`,
					baseMipLevel: renderContext.activeMipmapLevel,
					mipLevelCount: 1,
					baseArrayLayer: renderContext.activeCubeFace,
					arrayLayerCount: 1,
					dimension: GPUTextureViewDimension.TwoD
				};
				if (renderTarget.isRenderTarget3D) {
					sliceIndex = renderContext.activeCubeFace;
					viewDescriptor.baseArrayLayer = 0;
					viewDescriptor.dimension = GPUTextureViewDimension.ThreeD;
					viewDescriptor.depthOrArrayLayers = textures[i].image.depth;
				} else if (renderTarget.isRenderTarget && textures[i].image.depth > 1) if (isRenderCameraDepthArray === true) {
					const cameras = renderContext.camera.cameras;
					for (let layer = 0; layer < cameras.length; layer++) {
						const layerViewDescriptor = {
							...viewDescriptor,
							baseArrayLayer: layer,
							arrayLayerCount: 1,
							dimension: GPUTextureViewDimension.TwoD
						};
						const textureView = textureData.texture.createView(layerViewDescriptor);
						textureViews.push({
							view: textureView,
							resolveTarget: void 0,
							depthSlice: void 0
						});
					}
				} else {
					viewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;
					viewDescriptor.depthOrArrayLayers = textures[i].image.depth;
				}
				if (isRenderCameraDepthArray !== true) {
					const textureView = textureData.texture.createView(viewDescriptor);
					let view, resolveTarget;
					if (textureData.msaaTexture !== void 0) {
						view = textureData.msaaTexture.createView();
						resolveTarget = textureView;
					} else {
						view = textureView;
						resolveTarget = void 0;
					}
					textureViews.push({
						view,
						resolveTarget,
						depthSlice: sliceIndex
					});
				}
			}
			descriptorBase = { textureViews };
			if (renderContext.depth) {
				const depthTextureData = this.get(renderContext.depthTexture);
				const options = {};
				if (renderContext.depthTexture.isArrayTexture) {
					options.dimension = GPUTextureViewDimension.TwoD;
					options.arrayLayerCount = 1;
					options.baseArrayLayer = renderContext.activeCubeFace;
				}
				descriptorBase.depthStencilView = depthTextureData.texture.createView(options);
			}
			descriptors[cacheKey] = descriptorBase;
			renderTargetData.width = renderTarget.width;
			renderTargetData.height = renderTarget.height;
			renderTargetData.samples = renderTarget.samples;
			renderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;
			renderTargetData.activeCubeFace = renderContext.activeCubeFace;
		}
		const descriptor = { colorAttachments: [] };
		for (let i = 0; i < descriptorBase.textureViews.length; i++) {
			const viewInfo = descriptorBase.textureViews[i];
			let clearValue = {
				r: 0,
				g: 0,
				b: 0,
				a: 1
			};
			if (i === 0 && colorAttachmentsConfig.clearValue) clearValue = colorAttachmentsConfig.clearValue;
			descriptor.colorAttachments.push({
				view: viewInfo.view,
				depthSlice: viewInfo.depthSlice,
				resolveTarget: viewInfo.resolveTarget,
				loadOp: colorAttachmentsConfig.loadOp || GPULoadOp.Load,
				storeOp: colorAttachmentsConfig.storeOp || GPUStoreOp.Store,
				clearValue
			});
		}
		if (descriptorBase.depthStencilView) descriptor.depthStencilAttachment = { view: descriptorBase.depthStencilView };
		return descriptor;
	}
	/**
	* This method is executed at the beginning of a render call and prepares
	* the WebGPU state for upcoming render calls
	*
	* @param {RenderContext} renderContext - The render context.
	*/
	beginRender(renderContext) {
		const renderContextData = this.get(renderContext);
		const device = this.device;
		const occlusionQueryCount = renderContext.occlusionQueryCount;
		let occlusionQuerySet;
		if (occlusionQueryCount > 0) {
			if (renderContextData.currentOcclusionQuerySet) renderContextData.currentOcclusionQuerySet.destroy();
			if (renderContextData.currentOcclusionQueryBuffer) renderContextData.currentOcclusionQueryBuffer.destroy();
			renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
			renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
			occlusionQuerySet = device.createQuerySet({
				type: "occlusion",
				count: occlusionQueryCount,
				label: `occlusionQuerySet_${renderContext.id}`
			});
			renderContextData.occlusionQuerySet = occlusionQuerySet;
			renderContextData.occlusionQueryIndex = 0;
			renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
			renderContextData.lastOcclusionObject = null;
		}
		let descriptor;
		if (renderContext.textures === null) descriptor = this._getDefaultRenderPassDescriptor();
		else descriptor = this._getRenderPassDescriptor(renderContext, { loadOp: GPULoadOp.Load });
		this.initTimestampQuery(TimestampQuery.RENDER, this.getTimestampUID(renderContext), descriptor);
		descriptor.occlusionQuerySet = occlusionQuerySet;
		const depthStencilAttachment = descriptor.depthStencilAttachment;
		if (renderContext.textures !== null) {
			const colorAttachments = descriptor.colorAttachments;
			for (let i = 0; i < colorAttachments.length; i++) {
				const colorAttachment = colorAttachments[i];
				if (renderContext.clearColor) {
					colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : {
						r: 0,
						g: 0,
						b: 0,
						a: 1
					};
					colorAttachment.loadOp = GPULoadOp.Clear;
				} else colorAttachment.loadOp = GPULoadOp.Load;
				colorAttachment.storeOp = GPUStoreOp.Store;
			}
		} else {
			const colorAttachment = descriptor.colorAttachments[0];
			if (renderContext.clearColor) {
				colorAttachment.clearValue = renderContext.clearColorValue;
				colorAttachment.loadOp = GPULoadOp.Clear;
			} else colorAttachment.loadOp = GPULoadOp.Load;
			colorAttachment.storeOp = GPUStoreOp.Store;
		}
		if (renderContext.depth) {
			if (renderContext.clearDepth) {
				depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
			} else depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
			depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
		}
		if (renderContext.stencil) {
			if (renderContext.clearStencil) {
				depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
			} else depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
			depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
		}
		const encoder = device.createCommandEncoder({ label: "renderContext_" + renderContext.id });
		if (this._isRenderCameraDepthArray(renderContext) === true) {
			const cameras = renderContext.camera.cameras;
			if (!renderContextData.layerDescriptors || renderContextData.layerDescriptors.length !== cameras.length) this._createDepthLayerDescriptors(renderContext, renderContextData, descriptor, cameras);
			else this._updateDepthLayerDescriptors(renderContext, renderContextData, cameras);
			renderContextData.bundleEncoders = [];
			renderContextData.bundleSets = [];
			for (let i = 0; i < cameras.length; i++) {
				const bundleEncoder = this.pipelineUtils.createBundleEncoder(renderContext, "renderBundleArrayCamera_" + i);
				const bundleSets = {
					attributes: {},
					bindingGroups: [],
					pipeline: null,
					index: null
				};
				renderContextData.bundleEncoders.push(bundleEncoder);
				renderContextData.bundleSets.push(bundleSets);
			}
			renderContextData.currentPass = null;
		} else {
			renderContextData.currentPass = encoder.beginRenderPass(descriptor);
			if (renderContext.viewport) this.updateViewport(renderContext);
			if (renderContext.scissor) this.updateScissor(renderContext);
		}
		renderContextData.descriptor = descriptor;
		renderContextData.encoder = encoder;
		renderContextData.currentSets = {
			attributes: {},
			bindingGroups: [],
			pipeline: null,
			index: null
		};
		renderContextData.renderBundles = [];
	}
	/**
	* This method creates layer descriptors for each camera in an array camera
	* to prepare for rendering to a depth array texture.
	*
	* @param {RenderContext} renderContext - The render context.
	* @param {Object} renderContextData - The render context data.
	* @param {Object} descriptor  - The render pass descriptor.
	* @param {ArrayCamera} cameras - The array camera.
	*
	* @private
	*/
	_createDepthLayerDescriptors(renderContext, renderContextData, descriptor, cameras) {
		const depthStencilAttachment = descriptor.depthStencilAttachment;
		renderContextData.layerDescriptors = [];
		const depthTextureData = this.get(renderContext.depthTexture);
		if (!depthTextureData.viewCache) depthTextureData.viewCache = [];
		for (let i = 0; i < cameras.length; i++) {
			const layerDescriptor = {
				...descriptor,
				colorAttachments: [{
					...descriptor.colorAttachments[0],
					view: descriptor.colorAttachments[i].view
				}]
			};
			if (descriptor.depthStencilAttachment) {
				const layerIndex = i;
				if (!depthTextureData.viewCache[layerIndex]) depthTextureData.viewCache[layerIndex] = depthTextureData.texture.createView({
					dimension: GPUTextureViewDimension.TwoD,
					baseArrayLayer: i,
					arrayLayerCount: 1
				});
				layerDescriptor.depthStencilAttachment = {
					view: depthTextureData.viewCache[layerIndex],
					depthLoadOp: depthStencilAttachment.depthLoadOp || GPULoadOp.Clear,
					depthStoreOp: depthStencilAttachment.depthStoreOp || GPUStoreOp.Store,
					depthClearValue: depthStencilAttachment.depthClearValue || 1
				};
				if (renderContext.stencil) {
					layerDescriptor.depthStencilAttachment.stencilLoadOp = depthStencilAttachment.stencilLoadOp;
					layerDescriptor.depthStencilAttachment.stencilStoreOp = depthStencilAttachment.stencilStoreOp;
					layerDescriptor.depthStencilAttachment.stencilClearValue = depthStencilAttachment.stencilClearValue;
				}
			} else layerDescriptor.depthStencilAttachment = { ...depthStencilAttachment };
			renderContextData.layerDescriptors.push(layerDescriptor);
		}
	}
	/**
	* This method updates the layer descriptors for each camera in an array camera
	* to prepare for rendering to a depth array texture.
	*
	* @param {RenderContext} renderContext - The render context.
	* @param {Object} renderContextData - The render context data.
	* @param {ArrayCamera} cameras - The array camera.
	*
	*/
	_updateDepthLayerDescriptors(renderContext, renderContextData, cameras) {
		for (let i = 0; i < cameras.length; i++) {
			const layerDescriptor = renderContextData.layerDescriptors[i];
			if (layerDescriptor.depthStencilAttachment) {
				const depthAttachment = layerDescriptor.depthStencilAttachment;
				if (renderContext.depth) if (renderContext.clearDepth) {
					depthAttachment.depthClearValue = renderContext.clearDepthValue;
					depthAttachment.depthLoadOp = GPULoadOp.Clear;
				} else depthAttachment.depthLoadOp = GPULoadOp.Load;
				if (renderContext.stencil) if (renderContext.clearStencil) {
					depthAttachment.stencilClearValue = renderContext.clearStencilValue;
					depthAttachment.stencilLoadOp = GPULoadOp.Clear;
				} else depthAttachment.stencilLoadOp = GPULoadOp.Load;
			}
		}
	}
	/**
	* This method is executed at the end of a render call and finalizes work
	* after draw calls.
	*
	* @param {RenderContext} renderContext - The render context.
	*/
	finishRender(renderContext) {
		const renderContextData = this.get(renderContext);
		const occlusionQueryCount = renderContext.occlusionQueryCount;
		if (renderContextData.renderBundles.length > 0) renderContextData.currentPass.executeBundles(renderContextData.renderBundles);
		if (occlusionQueryCount > renderContextData.occlusionQueryIndex) renderContextData.currentPass.endOcclusionQuery();
		const encoder = renderContextData.encoder;
		if (this._isRenderCameraDepthArray(renderContext) === true) {
			const bundles = [];
			for (let i = 0; i < renderContextData.bundleEncoders.length; i++) {
				const bundleEncoder = renderContextData.bundleEncoders[i];
				bundles.push(bundleEncoder.finish());
			}
			for (let i = 0; i < renderContextData.layerDescriptors.length; i++) if (i < bundles.length) {
				const layerDescriptor = renderContextData.layerDescriptors[i];
				const renderPass = encoder.beginRenderPass(layerDescriptor);
				if (renderContext.viewport) {
					const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;
					renderPass.setViewport(x, y, width, height, minDepth, maxDepth);
				}
				if (renderContext.scissor) {
					const { x, y, width, height } = renderContext.scissorValue;
					renderPass.setScissorRect(x, y, width, height);
				}
				renderPass.executeBundles([bundles[i]]);
				renderPass.end();
			}
		} else if (renderContextData.currentPass) renderContextData.currentPass.end();
		if (occlusionQueryCount > 0) {
			const bufferSize = occlusionQueryCount * 8;
			let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);
			if (queryResolveBuffer === void 0) {
				queryResolveBuffer = this.device.createBuffer({
					size: bufferSize,
					usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
				});
				this.occludedResolveCache.set(bufferSize, queryResolveBuffer);
			}
			const readBuffer = this.device.createBuffer({
				size: bufferSize,
				usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
			});
			renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);
			renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);
			renderContextData.occlusionQueryBuffer = readBuffer;
			this.resolveOccludedAsync(renderContext);
		}
		this.device.queue.submit([renderContextData.encoder.finish()]);
		if (renderContext.textures !== null) {
			const textures = renderContext.textures;
			for (let i = 0; i < textures.length; i++) {
				const texture$2 = textures[i];
				if (texture$2.generateMipmaps === true) this.textureUtils.generateMipmaps(texture$2);
			}
		}
	}
	/**
	* Returns `true` if the given 3D object is fully occluded by other
	* 3D objects in the scene.
	*
	* @param {RenderContext} renderContext - The render context.
	* @param {Object3D} object - The 3D object to test.
	* @return {boolean} Whether the 3D object is fully occluded or not.
	*/
	isOccluded(renderContext, object) {
		const renderContextData = this.get(renderContext);
		return renderContextData.occluded && renderContextData.occluded.has(object);
	}
	/**
	* This method processes the result of occlusion queries and writes it
	* into render context data.
	*
	* @async
	* @param {RenderContext} renderContext - The render context.
	* @return {Promise} A Promise that resolves when the occlusion query results have been processed.
	*/
	async resolveOccludedAsync(renderContext) {
		const renderContextData = this.get(renderContext);
		const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;
		if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {
			const occluded = /* @__PURE__ */ new WeakSet();
			renderContextData.currentOcclusionQueryObjects = null;
			renderContextData.currentOcclusionQueryBuffer = null;
			await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);
			const buffer$2 = currentOcclusionQueryBuffer.getMappedRange();
			const results = new BigUint64Array(buffer$2);
			for (let i = 0; i < currentOcclusionQueryObjects.length; i++) if (results[i] === BigInt(0)) occluded.add(currentOcclusionQueryObjects[i]);
			currentOcclusionQueryBuffer.destroy();
			renderContextData.occluded = occluded;
		}
	}
	/**
	* Updates the viewport with the values from the given render context.
	*
	* @param {RenderContext} renderContext - The render context.
	*/
	updateViewport(renderContext) {
		const { currentPass } = this.get(renderContext);
		const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;
		currentPass.setViewport(x, y, width, height, minDepth, maxDepth);
	}
	/**
	* Updates the scissor with the values from the given render context.
	*
	* @param {RenderContext} renderContext - The render context.
	*/
	updateScissor(renderContext) {
		const { currentPass } = this.get(renderContext);
		const { x, y, width, height } = renderContext.scissorValue;
		currentPass.setScissorRect(x, y, width, height);
	}
	/**
	* Returns the clear color and alpha into a single
	* color object.
	*
	* @return {Color4} The clear color.
	*/
	getClearColor() {
		const clearColor = super.getClearColor();
		if (this.renderer.alpha === true) {
			clearColor.r *= clearColor.a;
			clearColor.g *= clearColor.a;
			clearColor.b *= clearColor.a;
		}
		return clearColor;
	}
	/**
	* Performs a clear operation.
	*
	* @param {boolean} color - Whether the color buffer should be cleared or not.
	* @param {boolean} depth - Whether the depth buffer should be cleared or not.
	* @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
	* @param {?RenderContext} [renderTargetContext=null] - The render context of the current set render target.
	*/
	clear(color$2, depth$2, stencil, renderTargetContext = null) {
		const device = this.device;
		const renderer = this.renderer;
		let colorAttachments = [];
		let depthStencilAttachment;
		let clearValue;
		let supportsDepth;
		let supportsStencil;
		if (color$2) {
			const clearColor = this.getClearColor();
			clearValue = {
				r: clearColor.r,
				g: clearColor.g,
				b: clearColor.b,
				a: clearColor.a
			};
		}
		if (renderTargetContext === null) {
			supportsDepth = renderer.depth;
			supportsStencil = renderer.stencil;
			const descriptor = this._getDefaultRenderPassDescriptor();
			if (color$2) {
				colorAttachments = descriptor.colorAttachments;
				const colorAttachment = colorAttachments[0];
				colorAttachment.clearValue = clearValue;
				colorAttachment.loadOp = GPULoadOp.Clear;
				colorAttachment.storeOp = GPUStoreOp.Store;
			}
			if (supportsDepth || supportsStencil) depthStencilAttachment = descriptor.depthStencilAttachment;
		} else {
			supportsDepth = renderTargetContext.depth;
			supportsStencil = renderTargetContext.stencil;
			const clearConfig = {
				loadOp: color$2 ? GPULoadOp.Clear : GPULoadOp.Load,
				clearValue: color$2 ? clearValue : void 0
			};
			if (supportsDepth) {
				clearConfig.depthLoadOp = depth$2 ? GPULoadOp.Clear : GPULoadOp.Load;
				clearConfig.depthClearValue = depth$2 ? renderer.getClearDepth() : void 0;
				clearConfig.depthStoreOp = GPUStoreOp.Store;
			}
			if (supportsStencil) {
				clearConfig.stencilLoadOp = stencil ? GPULoadOp.Clear : GPULoadOp.Load;
				clearConfig.stencilClearValue = stencil ? renderer.getClearStencil() : void 0;
				clearConfig.stencilStoreOp = GPUStoreOp.Store;
			}
			const descriptor = this._getRenderPassDescriptor(renderTargetContext, clearConfig);
			colorAttachments = descriptor.colorAttachments;
			depthStencilAttachment = descriptor.depthStencilAttachment;
		}
		if (supportsDepth && depthStencilAttachment) if (depth$2) {
			depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
			depthStencilAttachment.depthClearValue = renderer.getClearDepth();
			depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
		} else {
			depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
			depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
		}
		if (supportsStencil && depthStencilAttachment) if (stencil) {
			depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
			depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
			depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
		} else {
			depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
			depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
		}
		const encoder = device.createCommandEncoder({ label: "clear" });
		encoder.beginRenderPass({
			colorAttachments,
			depthStencilAttachment
		}).end();
		device.queue.submit([encoder.finish()]);
	}
	/**
	* This method is executed at the beginning of a compute call and
	* prepares the state for upcoming compute tasks.
	*
	* @param {Node|Array<Node>} computeGroup - The compute node(s).
	*/
	beginCompute(computeGroup) {
		const groupGPU = this.get(computeGroup);
		const descriptor = { label: "computeGroup_" + computeGroup.id };
		this.initTimestampQuery(TimestampQuery.COMPUTE, this.getTimestampUID(computeGroup), descriptor);
		groupGPU.cmdEncoderGPU = this.device.createCommandEncoder({ label: "computeGroup_" + computeGroup.id });
		groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass(descriptor);
	}
	/**
	* Executes a compute command for the given compute node.
	*
	* @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
	* @param {Node} computeNode - The compute node.
	* @param {Array<BindGroup>} bindings - The bindings.
	* @param {ComputePipeline} pipeline - The compute pipeline.
	* @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
	* - A single number representing count, or
	* - An array [x, y, z] representing dispatch size, or
	* - A IndirectStorageBufferAttribute for indirect dispatch size.
	*/
	compute(computeGroup, computeNode, bindings, pipeline, dispatchSize = null) {
		const computeNodeData = this.get(computeNode);
		const { passEncoderGPU } = this.get(computeGroup);
		const pipelineGPU = this.get(pipeline).pipeline;
		this.pipelineUtils.setPipeline(passEncoderGPU, pipelineGPU);
		for (let i = 0, l = bindings.length; i < l; i++) {
			const bindGroup = bindings[i];
			const bindingsData = this.get(bindGroup);
			passEncoderGPU.setBindGroup(i, bindingsData.group);
		}
		if (dispatchSize === null) dispatchSize = computeNode.count;
		if (dispatchSize && typeof dispatchSize === "object" && dispatchSize.isIndirectStorageBufferAttribute) {
			const dispatchBuffer = this.get(dispatchSize).buffer;
			passEncoderGPU.dispatchWorkgroupsIndirect(dispatchBuffer, 0);
			return;
		}
		if (typeof dispatchSize === "number") {
			const count = dispatchSize;
			if (computeNodeData.dispatchSize === void 0 || computeNodeData.count !== count) {
				computeNodeData.dispatchSize = [
					0,
					1,
					1
				];
				computeNodeData.count = count;
				const workgroupSize = computeNode.workgroupSize;
				let size = workgroupSize[0];
				for (let i = 1; i < workgroupSize.length; i++) size *= workgroupSize[i];
				const dispatchCount = Math.ceil(count / size);
				const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;
				dispatchSize = [
					dispatchCount,
					1,
					1
				];
				if (dispatchCount > maxComputeWorkgroupsPerDimension) {
					dispatchSize[0] = Math.min(dispatchCount, maxComputeWorkgroupsPerDimension);
					dispatchSize[1] = Math.ceil(dispatchCount / maxComputeWorkgroupsPerDimension);
				}
				computeNodeData.dispatchSize = dispatchSize;
			}
			dispatchSize = computeNodeData.dispatchSize;
		}
		passEncoderGPU.dispatchWorkgroups(dispatchSize[0], dispatchSize[1] || 1, dispatchSize[2] || 1);
	}
	/**
	* This method is executed at the end of a compute call and
	* finalizes work after compute tasks.
	*
	* @param {Node|Array<Node>} computeGroup - The compute node(s).
	*/
	finishCompute(computeGroup) {
		const groupData = this.get(computeGroup);
		groupData.passEncoderGPU.end();
		this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);
	}
	/**
	* Executes a draw command for the given render object.
	*
	* @param {RenderObject} renderObject - The render object to draw.
	* @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
	*/
	draw(renderObject, info) {
		const { object, material, context: context$2, pipeline } = renderObject;
		const bindings = renderObject.getBindings();
		const renderContextData = this.get(context$2);
		const pipelineData = this.get(pipeline);
		const pipelineGPU = pipelineData.pipeline;
		if (pipelineData.error === true) return;
		const index = renderObject.getIndex();
		const hasIndex = index !== null;
		const drawParams = renderObject.getDrawParameters();
		if (drawParams === null) return;
		const setPipelineAndBindings = (passEncoderGPU, currentSets) => {
			this.pipelineUtils.setPipeline(passEncoderGPU, pipelineGPU);
			currentSets.pipeline = pipelineGPU;
			const currentBindingGroups = currentSets.bindingGroups;
			for (let i = 0, l = bindings.length; i < l; i++) {
				const bindGroup = bindings[i];
				const bindingsData = this.get(bindGroup);
				if (currentBindingGroups[bindGroup.index] !== bindGroup.id) {
					passEncoderGPU.setBindGroup(bindGroup.index, bindingsData.group);
					currentBindingGroups[bindGroup.index] = bindGroup.id;
				}
			}
			if (hasIndex === true) {
				if (currentSets.index !== index) {
					const buffer$2 = this.get(index).buffer;
					const indexFormat = index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
					passEncoderGPU.setIndexBuffer(buffer$2, indexFormat);
					currentSets.index = index;
				}
			}
			const vertexBuffers = renderObject.getVertexBuffers();
			for (let i = 0, l = vertexBuffers.length; i < l; i++) {
				const vertexBuffer = vertexBuffers[i];
				if (currentSets.attributes[i] !== vertexBuffer) {
					const buffer$2 = this.get(vertexBuffer).buffer;
					passEncoderGPU.setVertexBuffer(i, buffer$2);
					currentSets.attributes[i] = vertexBuffer;
				}
			}
			if (context$2.stencil === true && material.stencilWrite === true && renderContextData.currentStencilRef !== material.stencilRef) {
				passEncoderGPU.setStencilReference(material.stencilRef);
				renderContextData.currentStencilRef = material.stencilRef;
			}
		};
		const draw = (passEncoderGPU, currentSets) => {
			setPipelineAndBindings(passEncoderGPU, currentSets);
			if (object.isBatchedMesh === true) {
				const starts = object._multiDrawStarts;
				const counts = object._multiDrawCounts;
				const drawCount = object._multiDrawCount;
				const drawInstances = object._multiDrawInstances;
				if (drawInstances !== null) warnOnce("WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");
				for (let i = 0; i < drawCount; i++) {
					const count = drawInstances ? drawInstances[i] : 1;
					const firstInstance = count > 1 ? 0 : i;
					if (hasIndex === true) passEncoderGPU.drawIndexed(counts[i], count, starts[i] / index.array.BYTES_PER_ELEMENT, 0, firstInstance);
					else passEncoderGPU.draw(counts[i], count, starts[i], firstInstance);
					info.update(object, counts[i], count);
				}
			} else if (hasIndex === true) {
				const { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;
				const indirect = renderObject.getIndirect();
				if (indirect !== null) {
					const buffer$2 = this.get(indirect).buffer;
					passEncoderGPU.drawIndexedIndirect(buffer$2, 0);
				} else passEncoderGPU.drawIndexed(indexCount, instanceCount, firstIndex, 0, 0);
				info.update(object, indexCount, instanceCount);
			} else {
				const { vertexCount, instanceCount, firstVertex } = drawParams;
				const indirect = renderObject.getIndirect();
				if (indirect !== null) {
					const buffer$2 = this.get(indirect).buffer;
					passEncoderGPU.drawIndirect(buffer$2, 0);
				} else passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);
				info.update(object, vertexCount, instanceCount);
			}
		};
		if (renderObject.camera.isArrayCamera && renderObject.camera.cameras.length > 0) {
			const cameraData = this.get(renderObject.camera);
			const cameras = renderObject.camera.cameras;
			const cameraIndex$2 = renderObject.getBindingGroup("cameraIndex");
			if (cameraData.indexesGPU === void 0 || cameraData.indexesGPU.length !== cameras.length) {
				const bindingsData = this.get(cameraIndex$2);
				const indexesGPU = [];
				const data = new Uint32Array([
					0,
					0,
					0,
					0
				]);
				for (let i = 0, len = cameras.length; i < len; i++) {
					data[0] = i;
					const bindGroupIndex = this.bindingUtils.createBindGroupIndex(data, bindingsData.layout);
					indexesGPU.push(bindGroupIndex);
				}
				cameraData.indexesGPU = indexesGPU;
			}
			const pixelRatio = this.renderer.getPixelRatio();
			for (let i = 0, len = cameras.length; i < len; i++) {
				const subCamera = cameras[i];
				if (object.layers.test(subCamera.layers)) {
					const vp = subCamera.viewport;
					let pass$2 = renderContextData.currentPass;
					let sets = renderContextData.currentSets;
					if (renderContextData.bundleEncoders) {
						const bundleEncoder = renderContextData.bundleEncoders[i];
						const bundleSets = renderContextData.bundleSets[i];
						pass$2 = bundleEncoder;
						sets = bundleSets;
					}
					if (vp) pass$2.setViewport(Math.floor(vp.x * pixelRatio), Math.floor(vp.y * pixelRatio), Math.floor(vp.width * pixelRatio), Math.floor(vp.height * pixelRatio), context$2.viewportValue.minDepth, context$2.viewportValue.maxDepth);
					if (cameraIndex$2 && cameraData.indexesGPU) {
						pass$2.setBindGroup(cameraIndex$2.index, cameraData.indexesGPU[i]);
						sets.bindingGroups[cameraIndex$2.index] = cameraIndex$2.id;
					}
					draw(pass$2, sets);
				}
			}
		} else if (renderContextData.currentPass) {
			if (renderContextData.occlusionQuerySet !== void 0) {
				const lastObject = renderContextData.lastOcclusionObject;
				if (lastObject !== object) {
					if (lastObject !== null && lastObject.occlusionTest === true) {
						renderContextData.currentPass.endOcclusionQuery();
						renderContextData.occlusionQueryIndex++;
					}
					if (object.occlusionTest === true) {
						renderContextData.currentPass.beginOcclusionQuery(renderContextData.occlusionQueryIndex);
						renderContextData.occlusionQueryObjects[renderContextData.occlusionQueryIndex] = object;
					}
					renderContextData.lastOcclusionObject = object;
				}
			}
			draw(renderContextData.currentPass, renderContextData.currentSets);
		}
	}
	/**
	* Returns `true` if the render pipeline requires an update.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {boolean} Whether the render pipeline requires an update or not.
	*/
	needsRenderUpdate(renderObject) {
		const data = this.get(renderObject);
		const { object, material } = renderObject;
		const utils = this.utils;
		const sampleCount = utils.getSampleCountRenderContext(renderObject.context);
		const colorSpace = utils.getCurrentColorSpace(renderObject.context);
		const colorFormat = utils.getCurrentColorFormat(renderObject.context);
		const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
		const primitiveTopology = utils.getPrimitiveTopology(object, material);
		let needsUpdate = false;
		if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage || data.sampleCount !== sampleCount || data.colorSpace !== colorSpace || data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat || data.primitiveTopology !== primitiveTopology || data.clippingContextCacheKey !== renderObject.clippingContextCacheKey) {
			data.material = material;
			data.materialVersion = material.version;
			data.transparent = material.transparent;
			data.blending = material.blending;
			data.premultipliedAlpha = material.premultipliedAlpha;
			data.blendSrc = material.blendSrc;
			data.blendDst = material.blendDst;
			data.blendEquation = material.blendEquation;
			data.blendSrcAlpha = material.blendSrcAlpha;
			data.blendDstAlpha = material.blendDstAlpha;
			data.blendEquationAlpha = material.blendEquationAlpha;
			data.colorWrite = material.colorWrite;
			data.depthWrite = material.depthWrite;
			data.depthTest = material.depthTest;
			data.depthFunc = material.depthFunc;
			data.stencilWrite = material.stencilWrite;
			data.stencilFunc = material.stencilFunc;
			data.stencilFail = material.stencilFail;
			data.stencilZFail = material.stencilZFail;
			data.stencilZPass = material.stencilZPass;
			data.stencilFuncMask = material.stencilFuncMask;
			data.stencilWriteMask = material.stencilWriteMask;
			data.side = material.side;
			data.alphaToCoverage = material.alphaToCoverage;
			data.sampleCount = sampleCount;
			data.colorSpace = colorSpace;
			data.colorFormat = colorFormat;
			data.depthStencilFormat = depthStencilFormat;
			data.primitiveTopology = primitiveTopology;
			data.clippingContextCacheKey = renderObject.clippingContextCacheKey;
			needsUpdate = true;
		}
		return needsUpdate;
	}
	/**
	* Returns a cache key that is used to identify render pipelines.
	*
	* @param {RenderObject} renderObject - The render object.
	* @return {string} The cache key.
	*/
	getRenderCacheKey(renderObject) {
		const { object, material } = renderObject;
		const utils = this.utils;
		const renderContext = renderObject.context;
		const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
		return [
			material.transparent,
			material.blending,
			material.premultipliedAlpha,
			material.blendSrc,
			material.blendDst,
			material.blendEquation,
			material.blendSrcAlpha,
			material.blendDstAlpha,
			material.blendEquationAlpha,
			material.colorWrite,
			material.depthWrite,
			material.depthTest,
			material.depthFunc,
			material.stencilWrite,
			material.stencilFunc,
			material.stencilFail,
			material.stencilZFail,
			material.stencilZPass,
			material.stencilFuncMask,
			material.stencilWriteMask,
			material.side,
			frontFaceCW,
			utils.getSampleCountRenderContext(renderContext),
			utils.getCurrentColorSpace(renderContext),
			utils.getCurrentColorFormat(renderContext),
			utils.getCurrentDepthStencilFormat(renderContext),
			utils.getPrimitiveTopology(object, material),
			renderObject.getGeometryCacheKey(),
			renderObject.clippingContextCacheKey
		].join();
	}
	/**
	* Updates a GPU sampler for the given texture.
	*
	* @param {Texture} texture - The texture to update the sampler for.
	* @return {string} The current sampler key.
	*/
	updateSampler(texture$2) {
		return this.textureUtils.updateSampler(texture$2);
	}
	/**
	* Creates a default texture for the given texture that can be used
	* as a placeholder until the actual texture is ready for usage.
	*
	* @param {Texture} texture - The texture to create a default texture for.
	* @return {boolean} Whether the sampler has been updated or not.
	*/
	createDefaultTexture(texture$2) {
		return this.textureUtils.createDefaultTexture(texture$2);
	}
	/**
	* Defines a texture on the GPU for the given texture object.
	*
	* @param {Texture} texture - The texture.
	* @param {Object} [options={}] - Optional configuration parameter.
	*/
	createTexture(texture$2, options) {
		this.textureUtils.createTexture(texture$2, options);
	}
	/**
	* Uploads the updated texture data to the GPU.
	*
	* @param {Texture} texture - The texture.
	* @param {Object} [options={}] - Optional configuration parameter.
	*/
	updateTexture(texture$2, options) {
		this.textureUtils.updateTexture(texture$2, options);
	}
	/**
	* Generates mipmaps for the given texture.
	*
	* @param {Texture} texture - The texture.
	*/
	generateMipmaps(texture$2) {
		this.textureUtils.generateMipmaps(texture$2);
	}
	/**
	* Destroys the GPU data for the given texture object.
	*
	* @param {Texture} texture - The texture.
	* @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
	*/
	destroyTexture(texture$2, isDefaultTexture = false) {
		this.textureUtils.destroyTexture(texture$2, isDefaultTexture);
	}
	/**
	* Returns texture data as a typed array.
	*
	* @async
	* @param {Texture} texture - The texture to copy.
	* @param {number} x - The x coordinate of the copy origin.
	* @param {number} y - The y coordinate of the copy origin.
	* @param {number} width - The width of the copy.
	* @param {number} height - The height of the copy.
	* @param {number} faceIndex - The face index.
	* @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
	*/
	async copyTextureToBuffer(texture$2, x, y, width, height, faceIndex) {
		return this.textureUtils.copyTextureToBuffer(texture$2, x, y, width, height, faceIndex);
	}
	/**
	* Inits a time stamp query for the given render context.
	*
	* @param {string} type - The type of the timestamp query (e.g. 'render', 'compute').
	* @param {number} uid - Unique id for the context (e.g. render context id).
	* @param {Object} descriptor - The query descriptor.
	*/
	initTimestampQuery(type$1, uid, descriptor) {
		if (!this.trackTimestamp) return;
		if (!this.timestampQueryPool[type$1]) this.timestampQueryPool[type$1] = new WebGPUTimestampQueryPool(this.device, type$1, 2048);
		const timestampQueryPool = this.timestampQueryPool[type$1];
		const baseOffset = timestampQueryPool.allocateQueriesForContext(uid);
		descriptor.timestampWrites = {
			querySet: timestampQueryPool.querySet,
			beginningOfPassWriteIndex: baseOffset,
			endOfPassWriteIndex: baseOffset + 1
		};
	}
	/**
	* Returns a node builder for the given render object.
	*
	* @param {RenderObject} object - The render object.
	* @param {Renderer} renderer - The renderer.
	* @return {WGSLNodeBuilder} The node builder.
	*/
	createNodeBuilder(object, renderer) {
		return new WGSLNodeBuilder(object, renderer);
	}
	/**
	* Creates a shader program from the given programmable stage.
	*
	* @param {ProgrammableStage} program - The programmable stage.
	*/
	createProgram(program) {
		const programGPU = this.get(program);
		programGPU.module = {
			module: this.device.createShaderModule({
				code: program.code,
				label: program.stage + (program.name !== "" ? `_${program.name}` : "")
			}),
			entryPoint: "main"
		};
	}
	/**
	* Destroys the shader program of the given programmable stage.
	*
	* @param {ProgrammableStage} program - The programmable stage.
	*/
	destroyProgram(program) {
		this.delete(program);
	}
	/**
	* Creates a render pipeline for the given render object.
	*
	* @param {RenderObject} renderObject - The render object.
	* @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
	*/
	createRenderPipeline(renderObject, promises) {
		this.pipelineUtils.createRenderPipeline(renderObject, promises);
	}
	/**
	* Creates a compute pipeline for the given compute node.
	*
	* @param {ComputePipeline} computePipeline - The compute pipeline.
	* @param {Array<BindGroup>} bindings - The bindings.
	*/
	createComputePipeline(computePipeline, bindings) {
		this.pipelineUtils.createComputePipeline(computePipeline, bindings);
	}
	/**
	* Prepares the state for encoding render bundles.
	*
	* @param {RenderContext} renderContext - The render context.
	*/
	beginBundle(renderContext) {
		const renderContextData = this.get(renderContext);
		renderContextData._currentPass = renderContextData.currentPass;
		renderContextData._currentSets = renderContextData.currentSets;
		renderContextData.currentSets = {
			attributes: {},
			bindingGroups: [],
			pipeline: null,
			index: null
		};
		renderContextData.currentPass = this.pipelineUtils.createBundleEncoder(renderContext);
	}
	/**
	* After processing render bundles this method finalizes related work.
	*
	* @param {RenderContext} renderContext - The render context.
	* @param {RenderBundle} bundle - The render bundle.
	*/
	finishBundle(renderContext, bundle) {
		const renderContextData = this.get(renderContext);
		const bundleGPU = renderContextData.currentPass.finish();
		this.get(bundle).bundleGPU = bundleGPU;
		renderContextData.currentSets = renderContextData._currentSets;
		renderContextData.currentPass = renderContextData._currentPass;
	}
	/**
	* Adds a render bundle to the render context data.
	*
	* @param {RenderContext} renderContext - The render context.
	* @param {RenderBundle} bundle - The render bundle to add.
	*/
	addBundle(renderContext, bundle) {
		this.get(renderContext).renderBundles.push(this.get(bundle).bundleGPU);
	}
	/**
	* Creates bindings from the given bind group definition.
	*
	* @param {BindGroup} bindGroup - The bind group.
	* @param {Array<BindGroup>} bindings - Array of bind groups.
	* @param {number} cacheIndex - The cache index.
	* @param {number} version - The version.
	*/
	createBindings(bindGroup, bindings, cacheIndex, version) {
		this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
	}
	/**
	* Updates the given bind group definition.
	*
	* @param {BindGroup} bindGroup - The bind group.
	* @param {Array<BindGroup>} bindings - Array of bind groups.
	* @param {number} cacheIndex - The cache index.
	* @param {number} version - The version.
	*/
	updateBindings(bindGroup, bindings, cacheIndex, version) {
		this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
	}
	/**
	* Updates a buffer binding.
	*
	*  @param {Buffer} binding - The buffer binding to update.
	*/
	updateBinding(binding) {
		this.bindingUtils.updateBinding(binding);
	}
	/**
	* Creates the buffer of an indexed shader attribute.
	*
	* @param {BufferAttribute} attribute - The indexed buffer attribute.
	*/
	createIndexAttribute(attribute$2) {
		let usage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
		if (attribute$2.isStorageBufferAttribute || attribute$2.isStorageInstancedBufferAttribute) usage |= GPUBufferUsage.STORAGE;
		this.attributeUtils.createAttribute(attribute$2, usage);
	}
	/**
	* Creates the GPU buffer of a shader attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	createAttribute(attribute$2) {
		this.attributeUtils.createAttribute(attribute$2, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
	}
	/**
	* Creates the GPU buffer of a storage attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	createStorageAttribute(attribute$2) {
		this.attributeUtils.createAttribute(attribute$2, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
	}
	/**
	* Creates the GPU buffer of an indirect storage attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute.
	*/
	createIndirectStorageAttribute(attribute$2) {
		this.attributeUtils.createAttribute(attribute$2, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
	}
	/**
	* Updates the GPU buffer of a shader attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute to update.
	*/
	updateAttribute(attribute$2) {
		this.attributeUtils.updateAttribute(attribute$2);
	}
	/**
	* Destroys the GPU buffer of a shader attribute.
	*
	* @param {BufferAttribute} attribute - The buffer attribute to destroy.
	*/
	destroyAttribute(attribute$2) {
		this.attributeUtils.destroyAttribute(attribute$2);
	}
	/**
	* Triggers an update of the default render pass descriptor.
	*/
	updateSize() {
		this.delete(this.renderer.getCanvasTarget());
	}
	/**
	* Returns the maximum anisotropy texture filtering value.
	*
	* @return {number} The maximum anisotropy texture filtering value.
	*/
	getMaxAnisotropy() {
		return 16;
	}
	/**
	* Checks if the given feature is supported by the backend.
	*
	* @param {string} name - The feature's name.
	* @return {boolean} Whether the feature is supported or not.
	*/
	hasFeature(name) {
		if (GPUFeatureMap[name] !== void 0) name = GPUFeatureMap[name];
		return this.device.features.has(name);
	}
	/**
	* Copies data of the given source texture to the given destination texture.
	*
	* @param {Texture} srcTexture - The source texture.
	* @param {Texture} dstTexture - The destination texture.
	* @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
	* @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
	* @param {number} [srcLevel=0] - The mipmap level to copy.
	* @param {number} [dstLevel=0] - The destination mip level to copy to.
	*/
	copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
		let dstX = 0;
		let dstY = 0;
		let dstZ = 0;
		let srcX = 0;
		let srcY = 0;
		let srcZ = 0;
		let srcWidth = srcTexture.image.width;
		let srcHeight = srcTexture.image.height;
		let srcDepth = 1;
		if (srcRegion !== null) if (srcRegion.isBox3 === true) {
			srcX = srcRegion.min.x;
			srcY = srcRegion.min.y;
			srcZ = srcRegion.min.z;
			srcWidth = srcRegion.max.x - srcRegion.min.x;
			srcHeight = srcRegion.max.y - srcRegion.min.y;
			srcDepth = srcRegion.max.z - srcRegion.min.z;
		} else {
			srcX = srcRegion.min.x;
			srcY = srcRegion.min.y;
			srcWidth = srcRegion.max.x - srcRegion.min.x;
			srcHeight = srcRegion.max.y - srcRegion.min.y;
			srcDepth = 1;
		}
		if (dstPosition !== null) {
			dstX = dstPosition.x;
			dstY = dstPosition.y;
			dstZ = dstPosition.z || 0;
		}
		const encoder = this.device.createCommandEncoder({ label: "copyTextureToTexture_" + srcTexture.id + "_" + dstTexture.id });
		const sourceGPU = this.get(srcTexture).texture;
		const destinationGPU = this.get(dstTexture).texture;
		encoder.copyTextureToTexture({
			texture: sourceGPU,
			mipLevel: srcLevel,
			origin: {
				x: srcX,
				y: srcY,
				z: srcZ
			}
		}, {
			texture: destinationGPU,
			mipLevel: dstLevel,
			origin: {
				x: dstX,
				y: dstY,
				z: dstZ
			}
		}, [
			srcWidth,
			srcHeight,
			srcDepth
		]);
		this.device.queue.submit([encoder.finish()]);
		if (dstLevel === 0 && dstTexture.generateMipmaps) this.textureUtils.generateMipmaps(dstTexture);
	}
	/**
	* Copies the current bound framebuffer to the given texture.
	*
	* @param {Texture} texture - The destination texture.
	* @param {RenderContext} renderContext - The render context.
	* @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
	*/
	copyFramebufferToTexture(texture$2, renderContext, rectangle) {
		const renderContextData = this.get(renderContext);
		let sourceGPU = null;
		if (renderContext.renderTarget) if (texture$2.isDepthTexture) sourceGPU = this.get(renderContext.depthTexture).texture;
		else sourceGPU = this.get(renderContext.textures[0]).texture;
		else if (texture$2.isDepthTexture) sourceGPU = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil);
		else sourceGPU = this.context.getCurrentTexture();
		const destinationGPU = this.get(texture$2).texture;
		if (sourceGPU.format !== destinationGPU.format) {
			error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", sourceGPU.format, destinationGPU.format);
			return;
		}
		let encoder;
		if (renderContextData.currentPass) {
			renderContextData.currentPass.end();
			encoder = renderContextData.encoder;
		} else encoder = this.device.createCommandEncoder({ label: "copyFramebufferToTexture_" + texture$2.id });
		encoder.copyTextureToTexture({
			texture: sourceGPU,
			origin: [
				rectangle.x,
				rectangle.y,
				0
			]
		}, { texture: destinationGPU }, [rectangle.z, rectangle.w]);
		if (texture$2.generateMipmaps) this.textureUtils.generateMipmaps(texture$2, encoder);
		if (renderContextData.currentPass) {
			const { descriptor } = renderContextData;
			for (let i = 0; i < descriptor.colorAttachments.length; i++) descriptor.colorAttachments[i].loadOp = GPULoadOp.Load;
			if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
			if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
			renderContextData.currentPass = encoder.beginRenderPass(descriptor);
			renderContextData.currentSets = {
				attributes: {},
				bindingGroups: [],
				pipeline: null,
				index: null
			};
			if (renderContext.viewport) this.updateViewport(renderContext);
			if (renderContext.scissor) this.updateScissor(renderContext);
		} else this.device.queue.submit([encoder.finish()]);
	}
	dispose() {
		this.textureUtils.dispose();
	}
};
/**
* A IES version of {@link SpotLight}. Can only be used with {@link WebGPURenderer}.
*
* @augments SpotLight
*/
var IESSpotLight = class extends SpotLight {
	/**
	* Constructs a new IES spot light.
	*
	* @param {(number|Color|string)} [color=0xffffff] - The light's color.
	* @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
	* @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
	* @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
	* @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
	* @param {number} [decay=2] - The amount the light dims along the distance of the light.
	*/
	constructor(color$2, intensity, distance$3, angle, penumbra, decay) {
		super(color$2, intensity, distance$3, angle, penumbra, decay);
		/**
		* TODO
		*
		* @type {?Texture}
		* @default null
		*/
		this.iesMap = null;
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.iesMap = source.iesMap;
		return this;
	}
};
/**
* A projector light version of {@link SpotLight}. Can only be used with {@link WebGPURenderer}.
*
* @augments SpotLight
*/
var ProjectorLight = class extends SpotLight {
	/**
	* Constructs a new projector light.
	*
	* @param {(number|Color|string)} [color=0xffffff] - The light's color.
	* @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
	* @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
	* @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
	* @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
	* @param {number} [decay=2] - The amount the light dims along the distance of the light.
	*/
	constructor(color$2, intensity, distance$3, angle, penumbra, decay) {
		super(color$2, intensity, distance$3, angle, penumbra, decay);
		/**
		* Aspect ratio of the light. Set to `null` to use the texture aspect ratio.
		*
		* @type {?number}
		* @default null
		*/
		this.aspect = null;
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.aspect = source.aspect;
		return this;
	}
};
/**
* This version of a node library represents the standard version
* used in {@link WebGPURenderer}. It maps lights, tone mapping
* techniques and materials to node-based implementations.
*
* @private
* @augments NodeLibrary
*/
var StandardNodeLibrary = class extends NodeLibrary {
	/**
	* Constructs a new standard node library.
	*/
	constructor() {
		super();
		this.addMaterial(MeshPhongNodeMaterial, "MeshPhongMaterial");
		this.addMaterial(MeshStandardNodeMaterial, "MeshStandardMaterial");
		this.addMaterial(MeshPhysicalNodeMaterial, "MeshPhysicalMaterial");
		this.addMaterial(MeshToonNodeMaterial, "MeshToonMaterial");
		this.addMaterial(MeshBasicNodeMaterial, "MeshBasicMaterial");
		this.addMaterial(MeshLambertNodeMaterial, "MeshLambertMaterial");
		this.addMaterial(MeshNormalNodeMaterial, "MeshNormalMaterial");
		this.addMaterial(MeshMatcapNodeMaterial, "MeshMatcapMaterial");
		this.addMaterial(LineBasicNodeMaterial, "LineBasicMaterial");
		this.addMaterial(LineDashedNodeMaterial, "LineDashedMaterial");
		this.addMaterial(PointsNodeMaterial, "PointsMaterial");
		this.addMaterial(SpriteNodeMaterial, "SpriteMaterial");
		this.addMaterial(ShadowNodeMaterial, "ShadowMaterial");
		this.addLight(PointLightNode, PointLight);
		this.addLight(DirectionalLightNode, DirectionalLight);
		this.addLight(RectAreaLightNode, RectAreaLight);
		this.addLight(SpotLightNode, SpotLight);
		this.addLight(AmbientLightNode, AmbientLight);
		this.addLight(HemisphereLightNode, HemisphereLight);
		this.addLight(LightProbeNode, LightProbe);
		this.addLight(IESSpotLightNode, IESSpotLight);
		this.addLight(ProjectorLightNode, ProjectorLight);
		this.addToneMapping(linearToneMapping$1, LinearToneMapping);
		this.addToneMapping(reinhardToneMapping$1, ReinhardToneMapping);
		this.addToneMapping(cineonToneMapping$1, CineonToneMapping);
		this.addToneMapping(acesFilmicToneMapping$1, ACESFilmicToneMapping);
		this.addToneMapping(agxToneMapping$1, AgXToneMapping);
		this.addToneMapping(neutralToneMapping$1, NeutralToneMapping);
	}
};
/**
* This renderer is the new alternative of `WebGLRenderer`. `WebGPURenderer` has the ability
* to target different backends. By default, the renderer tries to use a WebGPU backend if the
* browser supports WebGPU. If not, `WebGPURenderer` falls backs to a WebGL 2 backend.
*
* @augments Renderer
*/
var WebGPURenderer = class extends Renderer {
	/**
	* WebGPURenderer options.
	*
	* @typedef {Object} WebGPURenderer~Options
	* @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
	* @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
	* @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
	* @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
	* @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
	* @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
	* @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
	* @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
	* @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
	* @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best
	* quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
	*/
	/**
	* Constructs a new WebGPU renderer.
	*
	* @param {WebGPURenderer~Options} [parameters] - The configuration parameter.
	*/
	constructor(parameters = {}) {
		let BackendClass;
		if (parameters.forceWebGL) BackendClass = WebGLBackend;
		else {
			BackendClass = WebGPUBackend;
			parameters.getFallback = () => {
				warn("WebGPURenderer: WebGPU is not available, running under WebGL2 backend.");
				return new WebGLBackend(parameters);
			};
		}
		const backend = new BackendClass(parameters);
		super(backend, parameters);
		/**
		* The generic default value is overwritten with the
		* standard node library for type mapping.
		*
		* @type {StandardNodeLibrary}
		*/
		this.library = new StandardNodeLibrary();
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isWebGPURenderer = true;
		if (typeof __THREE_DEVTOOLS__ !== "undefined") __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
	}
};

//#endregion
//#region node_modules/three/build/three.tsl.js
var BRDF_GGX = TSL.BRDF_GGX;
var BRDF_Lambert = TSL.BRDF_Lambert;
var BasicPointShadowFilter = TSL.BasicPointShadowFilter;
var BasicShadowFilter = TSL.BasicShadowFilter;
var Break = TSL.Break;
var Const = TSL.Const;
var Continue = TSL.Continue;
var DFGApprox = TSL.DFGApprox;
var D_GGX = TSL.D_GGX;
var Discard = TSL.Discard;
var EPSILON = TSL.EPSILON;
var F_Schlick = TSL.F_Schlick;
var Fn = TSL.Fn;
var INFINITY = TSL.INFINITY;
var If = TSL.If;
var Loop = TSL.Loop;
var NodeAccess = TSL.NodeAccess;
var NodeShaderStage = TSL.NodeShaderStage;
var NodeType = TSL.NodeType;
var NodeUpdateType = TSL.NodeUpdateType;
var PCFShadowFilter = TSL.PCFShadowFilter;
var PCFSoftShadowFilter = TSL.PCFSoftShadowFilter;
var PI = TSL.PI;
var PI2 = TSL.PI2;
var TWO_PI = TSL.TWO_PI;
var HALF_PI = TSL.HALF_PI;
var PointShadowFilter = TSL.PointShadowFilter;
var Return = TSL.Return;
var Schlick_to_F0 = TSL.Schlick_to_F0;
var ScriptableNodeResources = TSL.ScriptableNodeResources;
var ShaderNode = TSL.ShaderNode;
var Stack = TSL.Stack;
var Switch = TSL.Switch;
var TBNViewMatrix = TSL.TBNViewMatrix;
var VSMShadowFilter = TSL.VSMShadowFilter;
var V_GGX_SmithCorrelated = TSL.V_GGX_SmithCorrelated;
var Var = TSL.Var;
var VarIntent = TSL.VarIntent;
var abs = TSL.abs;
var acesFilmicToneMapping = TSL.acesFilmicToneMapping;
var acos = TSL.acos;
var add = TSL.add;
var addMethodChaining = TSL.addMethodChaining;
var addNodeElement = TSL.addNodeElement;
var agxToneMapping = TSL.agxToneMapping;
var all = TSL.all;
var alphaT = TSL.alphaT;
var and = TSL.and;
var anisotropy = TSL.anisotropy;
var anisotropyB = TSL.anisotropyB;
var anisotropyT = TSL.anisotropyT;
var any = TSL.any;
var append = TSL.append;
var array = TSL.array;
var arrayBuffer = TSL.arrayBuffer;
var asin = TSL.asin;
var assign = TSL.assign;
var atan = TSL.atan;
var atan2 = TSL.atan2;
var atomicAdd = TSL.atomicAdd;
var atomicAnd = TSL.atomicAnd;
var atomicFunc = TSL.atomicFunc;
var atomicLoad = TSL.atomicLoad;
var atomicMax = TSL.atomicMax;
var atomicMin = TSL.atomicMin;
var atomicOr = TSL.atomicOr;
var atomicStore = TSL.atomicStore;
var atomicSub = TSL.atomicSub;
var atomicXor = TSL.atomicXor;
var attenuationColor = TSL.attenuationColor;
var attenuationDistance = TSL.attenuationDistance;
var attribute = TSL.attribute;
var attributeArray = TSL.attributeArray;
var backgroundBlurriness = TSL.backgroundBlurriness;
var backgroundIntensity = TSL.backgroundIntensity;
var backgroundRotation = TSL.backgroundRotation;
var batch = TSL.batch;
var bentNormalView = TSL.bentNormalView;
var billboarding = TSL.billboarding;
var bitAnd = TSL.bitAnd;
var bitNot = TSL.bitNot;
var bitOr = TSL.bitOr;
var bitXor = TSL.bitXor;
var bitangentGeometry = TSL.bitangentGeometry;
var bitangentLocal = TSL.bitangentLocal;
var bitangentView = TSL.bitangentView;
var bitangentWorld = TSL.bitangentWorld;
var bitcast = TSL.bitcast;
var blendBurn = TSL.blendBurn;
var blendColor = TSL.blendColor;
var blendDodge = TSL.blendDodge;
var blendOverlay = TSL.blendOverlay;
var blendScreen = TSL.blendScreen;
var blur = TSL.blur;
var bool = TSL.bool;
var buffer = TSL.buffer;
var bufferAttribute = TSL.bufferAttribute;
var bumpMap = TSL.bumpMap;
var burn = TSL.burn;
var builtin = TSL.builtin;
var bvec2 = TSL.bvec2;
var bvec3 = TSL.bvec3;
var bvec4 = TSL.bvec4;
var bypass = TSL.bypass;
var cache = TSL.cache;
var call = TSL.call;
var cameraFar = TSL.cameraFar;
var cameraIndex = TSL.cameraIndex;
var cameraNear = TSL.cameraNear;
var cameraNormalMatrix = TSL.cameraNormalMatrix;
var cameraPosition = TSL.cameraPosition;
var cameraProjectionMatrix = TSL.cameraProjectionMatrix;
var cameraProjectionMatrixInverse = TSL.cameraProjectionMatrixInverse;
var cameraViewMatrix = TSL.cameraViewMatrix;
var cameraViewport = TSL.cameraViewport;
var cameraWorldMatrix = TSL.cameraWorldMatrix;
var cbrt = TSL.cbrt;
var cdl = TSL.cdl;
var ceil = TSL.ceil;
var checker = TSL.checker;
var cineonToneMapping = TSL.cineonToneMapping;
var clamp = TSL.clamp;
var clearcoat = TSL.clearcoat;
var clearcoatNormalView = TSL.clearcoatNormalView;
var clearcoatRoughness = TSL.clearcoatRoughness;
var code = TSL.code;
var color = TSL.color;
var colorSpaceToWorking = TSL.colorSpaceToWorking;
var colorToDirection = TSL.colorToDirection;
var compute = TSL.compute;
var computeKernel = TSL.computeKernel;
var computeSkinning = TSL.computeSkinning;
var context = TSL.context;
var convert = TSL.convert;
var convertColorSpace = TSL.convertColorSpace;
var convertToTexture = TSL.convertToTexture;
var cos = TSL.cos;
var cross = TSL.cross;
var cubeTexture = TSL.cubeTexture;
var cubeTextureBase = TSL.cubeTextureBase;
var cubeToUV = TSL.cubeToUV;
var dFdx = TSL.dFdx;
var dFdy = TSL.dFdy;
var dashSize = TSL.dashSize;
var debug = TSL.debug;
var decrement = TSL.decrement;
var decrementBefore = TSL.decrementBefore;
var defaultBuildStages = TSL.defaultBuildStages;
var defaultShaderStages = TSL.defaultShaderStages;
var defined = TSL.defined;
var degrees = TSL.degrees;
var deltaTime = TSL.deltaTime;
var densityFog = TSL.densityFog;
var densityFogFactor = TSL.densityFogFactor;
var depth = TSL.depth;
var depthPass = TSL.depthPass;
var determinant = TSL.determinant;
var difference = TSL.difference;
var diffuseColor = TSL.diffuseColor;
var directPointLight = TSL.directPointLight;
var directionToColor = TSL.directionToColor;
var directionToFaceDirection = TSL.directionToFaceDirection;
var dispersion = TSL.dispersion;
var distance = TSL.distance;
var div = TSL.div;
var dodge = TSL.dodge;
var dot = TSL.dot;
var drawIndex = TSL.drawIndex;
var dynamicBufferAttribute = TSL.dynamicBufferAttribute;
var element = TSL.element;
var emissive = TSL.emissive;
var equal = TSL.equal;
var equals$1 = TSL.equals;
var equirectUV = TSL.equirectUV;
var exp = TSL.exp;
var exp2 = TSL.exp2;
var expression = TSL.expression;
var faceDirection = TSL.faceDirection;
var faceForward = TSL.faceForward;
var faceforward = TSL.faceforward;
var float = TSL.float;
var floatBitsToInt = TSL.floatBitsToInt;
var floatBitsToUint = TSL.floatBitsToUint;
var floor = TSL.floor;
var fog = TSL.fog;
var fract = TSL.fract;
var frameGroup = TSL.frameGroup;
var frameId = TSL.frameId;
var frontFacing = TSL.frontFacing;
var fwidth = TSL.fwidth;
var gain = TSL.gain;
var gapSize = TSL.gapSize;
var getConstNodeType = TSL.getConstNodeType;
var getCurrentStack = TSL.getCurrentStack;
var getDirection = TSL.getDirection;
var getDistanceAttenuation = TSL.getDistanceAttenuation;
var getGeometryRoughness = TSL.getGeometryRoughness;
var getNormalFromDepth = TSL.getNormalFromDepth;
var interleavedGradientNoise = TSL.interleavedGradientNoise;
var getParallaxCorrectNormal = TSL.getParallaxCorrectNormal;
var getRoughness = TSL.getRoughness;
var getScreenPosition = TSL.getScreenPosition;
var getShIrradianceAt = TSL.getShIrradianceAt;
var getShadowMaterial = TSL.getShadowMaterial;
var getShadowRenderObjectFunction = TSL.getShadowRenderObjectFunction;
var getTextureIndex = TSL.getTextureIndex;
var getViewPosition = TSL.getViewPosition;
var globalId = TSL.globalId;
var glsl = TSL.glsl;
var glslFn = TSL.glslFn;
var grayscale = TSL.grayscale;
var greaterThan = TSL.greaterThan;
var greaterThanEqual = TSL.greaterThanEqual;
var hash = TSL.hash;
var highpModelNormalViewMatrix = TSL.highpModelNormalViewMatrix;
var highpModelViewMatrix = TSL.highpModelViewMatrix;
var hue = TSL.hue;
var increment = TSL.increment;
var incrementBefore = TSL.incrementBefore;
var instance = TSL.instance;
var instanceIndex = TSL.instanceIndex;
var instancedArray = TSL.instancedArray;
var instancedBufferAttribute = TSL.instancedBufferAttribute;
var instancedDynamicBufferAttribute = TSL.instancedDynamicBufferAttribute;
var instancedMesh = TSL.instancedMesh;
var int = TSL.int;
var intBitsToFloat = TSL.intBitsToFloat;
var inverse = TSL.inverse;
var inverseSqrt = TSL.inverseSqrt;
var inversesqrt = TSL.inversesqrt;
var invocationLocalIndex = TSL.invocationLocalIndex;
var invocationSubgroupIndex = TSL.invocationSubgroupIndex;
var ior = TSL.ior;
var iridescence = TSL.iridescence;
var iridescenceIOR = TSL.iridescenceIOR;
var iridescenceThickness = TSL.iridescenceThickness;
var ivec2 = TSL.ivec2;
var ivec3 = TSL.ivec3;
var ivec4 = TSL.ivec4;
var js = TSL.js;
var label = TSL.label;
var length = TSL.length;
var lengthSq = TSL.lengthSq;
var lessThan = TSL.lessThan;
var lessThanEqual = TSL.lessThanEqual;
var lightPosition = TSL.lightPosition;
var lightProjectionUV = TSL.lightProjectionUV;
var lightShadowMatrix = TSL.lightShadowMatrix;
var lightTargetDirection = TSL.lightTargetDirection;
var lightTargetPosition = TSL.lightTargetPosition;
var lightViewPosition = TSL.lightViewPosition;
var lightingContext = TSL.lightingContext;
var lights = TSL.lights;
var linearDepth = TSL.linearDepth;
var linearToneMapping = TSL.linearToneMapping;
var localId = TSL.localId;
var log$1 = TSL.log;
var log2 = TSL.log2;
var logarithmicDepthToViewZ = TSL.logarithmicDepthToViewZ;
var luminance$1 = TSL.luminance;
var mat2 = TSL.mat2;
var mat3 = TSL.mat3;
var mat4 = TSL.mat4;
var matcapUV = TSL.matcapUV;
var materialAO = TSL.materialAO;
var materialAlphaTest = TSL.materialAlphaTest;
var materialAnisotropy = TSL.materialAnisotropy;
var materialAnisotropyVector = TSL.materialAnisotropyVector;
var materialAttenuationColor = TSL.materialAttenuationColor;
var materialAttenuationDistance = TSL.materialAttenuationDistance;
var materialClearcoat = TSL.materialClearcoat;
var materialClearcoatNormal = TSL.materialClearcoatNormal;
var materialClearcoatRoughness = TSL.materialClearcoatRoughness;
var materialColor = TSL.materialColor;
var materialDispersion = TSL.materialDispersion;
var materialEmissive = TSL.materialEmissive;
var materialEnvIntensity = TSL.materialEnvIntensity;
var materialEnvRotation = TSL.materialEnvRotation;
var materialIOR = TSL.materialIOR;
var materialIridescence = TSL.materialIridescence;
var materialIridescenceIOR = TSL.materialIridescenceIOR;
var materialIridescenceThickness = TSL.materialIridescenceThickness;
var materialLightMap = TSL.materialLightMap;
var materialLineDashOffset = TSL.materialLineDashOffset;
var materialLineDashSize = TSL.materialLineDashSize;
var materialLineGapSize = TSL.materialLineGapSize;
var materialLineScale = TSL.materialLineScale;
var materialLineWidth = TSL.materialLineWidth;
var materialMetalness = TSL.materialMetalness;
var materialNormal = TSL.materialNormal;
var materialOpacity = TSL.materialOpacity;
var materialPointSize = TSL.materialPointSize;
var materialReference = TSL.materialReference;
var materialReflectivity = TSL.materialReflectivity;
var materialRefractionRatio = TSL.materialRefractionRatio;
var materialRotation = TSL.materialRotation;
var materialRoughness = TSL.materialRoughness;
var materialSheen = TSL.materialSheen;
var materialSheenRoughness = TSL.materialSheenRoughness;
var materialShininess = TSL.materialShininess;
var materialSpecular = TSL.materialSpecular;
var materialSpecularColor = TSL.materialSpecularColor;
var materialSpecularIntensity = TSL.materialSpecularIntensity;
var materialSpecularStrength = TSL.materialSpecularStrength;
var materialThickness = TSL.materialThickness;
var materialTransmission = TSL.materialTransmission;
var max = TSL.max;
var maxMipLevel = TSL.maxMipLevel;
var mediumpModelViewMatrix = TSL.mediumpModelViewMatrix;
var metalness = TSL.metalness;
var min = TSL.min;
var mix = TSL.mix;
var mixElement = TSL.mixElement;
var mod = TSL.mod;
var modInt = TSL.modInt;
var modelDirection = TSL.modelDirection;
var modelNormalMatrix = TSL.modelNormalMatrix;
var modelPosition = TSL.modelPosition;
var modelRadius = TSL.modelRadius;
var modelScale = TSL.modelScale;
var modelViewMatrix = TSL.modelViewMatrix;
var modelViewPosition = TSL.modelViewPosition;
var modelViewProjection = TSL.modelViewProjection;
var modelWorldMatrix = TSL.modelWorldMatrix;
var modelWorldMatrixInverse = TSL.modelWorldMatrixInverse;
var morphReference = TSL.morphReference;
var mrt = TSL.mrt;
var mul = TSL.mul;
var mx_aastep = TSL.mx_aastep;
var mx_add = TSL.mx_add;
var mx_atan2 = TSL.mx_atan2;
var mx_cell_noise_float = TSL.mx_cell_noise_float;
var mx_contrast = TSL.mx_contrast;
var mx_divide = TSL.mx_divide;
var mx_fractal_noise_float = TSL.mx_fractal_noise_float;
var mx_fractal_noise_vec2 = TSL.mx_fractal_noise_vec2;
var mx_fractal_noise_vec3 = TSL.mx_fractal_noise_vec3;
var mx_fractal_noise_vec4 = TSL.mx_fractal_noise_vec4;
var mx_frame = TSL.mx_frame;
var mx_heighttonormal = TSL.mx_heighttonormal;
var mx_hsvtorgb = TSL.mx_hsvtorgb;
var mx_ifequal = TSL.mx_ifequal;
var mx_ifgreater = TSL.mx_ifgreater;
var mx_ifgreatereq = TSL.mx_ifgreatereq;
var mx_invert = TSL.mx_invert;
var mx_modulo = TSL.mx_modulo;
var mx_multiply = TSL.mx_multiply;
var mx_noise_float = TSL.mx_noise_float;
var mx_noise_vec3 = TSL.mx_noise_vec3;
var mx_noise_vec4 = TSL.mx_noise_vec4;
var mx_place2d = TSL.mx_place2d;
var mx_power = TSL.mx_power;
var mx_ramp4 = TSL.mx_ramp4;
var mx_ramplr = TSL.mx_ramplr;
var mx_ramptb = TSL.mx_ramptb;
var mx_rgbtohsv = TSL.mx_rgbtohsv;
var mx_rotate2d = TSL.mx_rotate2d;
var mx_rotate3d = TSL.mx_rotate3d;
var mx_safepower = TSL.mx_safepower;
var mx_separate = TSL.mx_separate;
var mx_splitlr = TSL.mx_splitlr;
var mx_splittb = TSL.mx_splittb;
var mx_srgb_texture_to_lin_rec709 = TSL.mx_srgb_texture_to_lin_rec709;
var mx_subtract = TSL.mx_subtract;
var mx_timer = TSL.mx_timer;
var mx_transform_uv = TSL.mx_transform_uv;
var mx_unifiednoise2d = TSL.mx_unifiednoise2d;
var mx_unifiednoise3d = TSL.mx_unifiednoise3d;
var mx_worley_noise_float = TSL.mx_worley_noise_float;
var mx_worley_noise_vec2 = TSL.mx_worley_noise_vec2;
var mx_worley_noise_vec3 = TSL.mx_worley_noise_vec3;
var negate = TSL.negate;
var neutralToneMapping = TSL.neutralToneMapping;
var nodeArray = TSL.nodeArray;
var nodeImmutable = TSL.nodeImmutable;
var nodeObject = TSL.nodeObject;
var nodeObjectIntent = TSL.nodeObjectIntent;
var nodeObjects = TSL.nodeObjects;
var nodeProxy = TSL.nodeProxy;
var nodeProxyIntent = TSL.nodeProxyIntent;
var normalFlat = TSL.normalFlat;
var normalGeometry = TSL.normalGeometry;
var normalLocal = TSL.normalLocal;
var normalMap = TSL.normalMap;
var normalView = TSL.normalView;
var normalViewGeometry = TSL.normalViewGeometry;
var normalWorld = TSL.normalWorld;
var normalWorldGeometry = TSL.normalWorldGeometry;
var normalize = TSL.normalize;
var not = TSL.not;
var notEqual = TSL.notEqual;
var numWorkgroups = TSL.numWorkgroups;
var objectDirection = TSL.objectDirection;
var objectGroup = TSL.objectGroup;
var objectPosition = TSL.objectPosition;
var objectRadius = TSL.objectRadius;
var objectScale = TSL.objectScale;
var objectViewPosition = TSL.objectViewPosition;
var objectWorldMatrix = TSL.objectWorldMatrix;
var OnBeforeObjectUpdate = TSL.OnBeforeObjectUpdate;
var OnBeforeMaterialUpdate = TSL.OnBeforeMaterialUpdate;
var OnObjectUpdate = TSL.OnObjectUpdate;
var OnMaterialUpdate = TSL.OnMaterialUpdate;
var oneMinus = TSL.oneMinus;
var or = TSL.or;
var orthographicDepthToViewZ = TSL.orthographicDepthToViewZ;
var oscSawtooth = TSL.oscSawtooth;
var oscSine = TSL.oscSine;
var oscSquare = TSL.oscSquare;
var oscTriangle = TSL.oscTriangle;
var output = TSL.output;
var outputStruct = TSL.outputStruct;
var overlay = TSL.overlay;
var overloadingFn = TSL.overloadingFn;
var parabola = TSL.parabola;
var parallaxDirection = TSL.parallaxDirection;
var parallaxUV = TSL.parallaxUV;
var parameter = TSL.parameter;
var pass = TSL.pass;
var passTexture = TSL.passTexture;
var pcurve = TSL.pcurve;
var perspectiveDepthToViewZ = TSL.perspectiveDepthToViewZ;
var pmremTexture = TSL.pmremTexture;
var pointShadow = TSL.pointShadow;
var pointUV = TSL.pointUV;
var pointWidth = TSL.pointWidth;
var positionGeometry = TSL.positionGeometry;
var positionLocal = TSL.positionLocal;
var positionPrevious = TSL.positionPrevious;
var positionView = TSL.positionView;
var positionViewDirection = TSL.positionViewDirection;
var positionWorld = TSL.positionWorld;
var positionWorldDirection = TSL.positionWorldDirection;
var posterize = TSL.posterize;
var pow = TSL.pow;
var pow2 = TSL.pow2;
var pow3 = TSL.pow3;
var pow4 = TSL.pow4;
var premultiplyAlpha = TSL.premultiplyAlpha;
var property = TSL.property;
var radians = TSL.radians;
var rand = TSL.rand;
var range$1 = TSL.range;
var rangeFog = TSL.rangeFog;
var rangeFogFactor = TSL.rangeFogFactor;
var reciprocal = TSL.reciprocal;
var reference = TSL.reference;
var referenceBuffer = TSL.referenceBuffer;
var reflect = TSL.reflect;
var reflectVector = TSL.reflectVector;
var reflectView = TSL.reflectView;
var reflector = TSL.reflector;
var refract = TSL.refract;
var refractVector = TSL.refractVector;
var refractView = TSL.refractView;
var reinhardToneMapping = TSL.reinhardToneMapping;
var remap = TSL.remap;
var remapClamp = TSL.remapClamp;
var renderGroup = TSL.renderGroup;
var renderOutput = TSL.renderOutput;
var rendererReference = TSL.rendererReference;
var rotate = TSL.rotate;
var rotateUV = TSL.rotateUV;
var roughness = TSL.roughness;
var round = TSL.round;
var rtt = TSL.rtt;
var sRGBTransferEOTF = TSL.sRGBTransferEOTF;
var sRGBTransferOETF = TSL.sRGBTransferOETF;
var sample = TSL.sample;
var sampler = TSL.sampler;
var samplerComparison = TSL.samplerComparison;
var saturate = TSL.saturate;
var saturation = TSL.saturation;
var screen = TSL.screen;
var screenCoordinate = TSL.screenCoordinate;
var screenDPR = TSL.screenDPR;
var screenSize = TSL.screenSize;
var screenUV = TSL.screenUV;
var scriptable = TSL.scriptable;
var scriptableValue = TSL.scriptableValue;
var select = TSL.select;
var setCurrentStack = TSL.setCurrentStack;
var setName = TSL.setName;
var shaderStages = TSL.shaderStages;
var shadow = TSL.shadow;
var shadowPositionWorld = TSL.shadowPositionWorld;
var shapeCircle = TSL.shapeCircle;
var sharedUniformGroup = TSL.sharedUniformGroup;
var sheen = TSL.sheen;
var sheenRoughness = TSL.sheenRoughness;
var shiftLeft = TSL.shiftLeft;
var shiftRight = TSL.shiftRight;
var shininess = TSL.shininess;
var sign = TSL.sign;
var sin = TSL.sin;
var sinc = TSL.sinc;
var skinning = TSL.skinning;
var smoothstep = TSL.smoothstep;
var smoothstepElement = TSL.smoothstepElement;
var specularColor = TSL.specularColor;
var specularF90 = TSL.specularF90;
var spherizeUV = TSL.spherizeUV;
var split = TSL.split;
var spritesheetUV = TSL.spritesheetUV;
var sqrt = TSL.sqrt;
var stack = TSL.stack;
var step = TSL.step;
var stepElement = TSL.stepElement;
var storage = TSL.storage;
var storageBarrier = TSL.storageBarrier;
var storageObject = TSL.storageObject;
var storageTexture = TSL.storageTexture;
var string = TSL.string;
var struct = TSL.struct;
var sub = TSL.sub;
var subgroupAdd = TSL.subgroupAdd;
var subgroupAll = TSL.subgroupAll;
var subgroupAnd = TSL.subgroupAnd;
var subgroupAny = TSL.subgroupAny;
var subgroupBallot = TSL.subgroupBallot;
var subgroupBroadcast = TSL.subgroupBroadcast;
var subgroupBroadcastFirst = TSL.subgroupBroadcastFirst;
var subBuild = TSL.subBuild;
var subgroupElect = TSL.subgroupElect;
var subgroupExclusiveAdd = TSL.subgroupExclusiveAdd;
var subgroupExclusiveMul = TSL.subgroupExclusiveMul;
var subgroupInclusiveAdd = TSL.subgroupInclusiveAdd;
var subgroupInclusiveMul = TSL.subgroupInclusiveMul;
var subgroupIndex = TSL.subgroupIndex;
var subgroupMax = TSL.subgroupMax;
var subgroupMin = TSL.subgroupMin;
var subgroupMul = TSL.subgroupMul;
var subgroupOr = TSL.subgroupOr;
var subgroupShuffle = TSL.subgroupShuffle;
var subgroupShuffleDown = TSL.subgroupShuffleDown;
var subgroupShuffleUp = TSL.subgroupShuffleUp;
var subgroupShuffleXor = TSL.subgroupShuffleXor;
var subgroupSize = TSL.subgroupSize;
var subgroupXor = TSL.subgroupXor;
var tan = TSL.tan;
var tangentGeometry = TSL.tangentGeometry;
var tangentLocal = TSL.tangentLocal;
var tangentView = TSL.tangentView;
var tangentWorld = TSL.tangentWorld;
var texture = TSL.texture;
var texture3D = TSL.texture3D;
var textureBarrier = TSL.textureBarrier;
var textureBicubic = TSL.textureBicubic;
var textureBicubicLevel = TSL.textureBicubicLevel;
var textureCubeUV = TSL.textureCubeUV;
var textureLoad = TSL.textureLoad;
var textureSize = TSL.textureSize;
var textureLevel = TSL.textureLevel;
var textureStore = TSL.textureStore;
var thickness = TSL.thickness;
var time = TSL.time;
var toneMapping = TSL.toneMapping;
var toneMappingExposure = TSL.toneMappingExposure;
var toonOutlinePass = TSL.toonOutlinePass;
var transformDirection = TSL.transformDirection;
var transformNormal = TSL.transformNormal;
var transformNormalToView = TSL.transformNormalToView;
var transformedClearcoatNormalView = TSL.transformedClearcoatNormalView;
var transformedNormalView = TSL.transformedNormalView;
var transformedNormalWorld = TSL.transformedNormalWorld;
var transmission = TSL.transmission;
var transpose = TSL.transpose;
var triNoise3D = TSL.triNoise3D;
var triplanarTexture = TSL.triplanarTexture;
var triplanarTextures = TSL.triplanarTextures;
var trunc = TSL.trunc;
var uint = TSL.uint;
var uintBitsToFloat = TSL.uintBitsToFloat;
var uniform = TSL.uniform;
var uniformArray = TSL.uniformArray;
var uniformCubeTexture = TSL.uniformCubeTexture;
var uniformGroup = TSL.uniformGroup;
var uniformFlow = TSL.uniformFlow;
var uniformTexture = TSL.uniformTexture;
var unpremultiplyAlpha = TSL.unpremultiplyAlpha;
var userData = TSL.userData;
var uv = TSL.uv;
var uvec2 = TSL.uvec2;
var uvec3 = TSL.uvec3;
var uvec4 = TSL.uvec4;
var varying = TSL.varying;
var varyingProperty = TSL.varyingProperty;
var vec2 = TSL.vec2;
var vec3 = TSL.vec3;
var vec4 = TSL.vec4;
var vectorComponents = TSL.vectorComponents;
var velocity = TSL.velocity;
var vertexColor = TSL.vertexColor;
var vertexIndex = TSL.vertexIndex;
var vertexStage = TSL.vertexStage;
var vibrance = TSL.vibrance;
var viewZToLogarithmicDepth = TSL.viewZToLogarithmicDepth;
var viewZToOrthographicDepth = TSL.viewZToOrthographicDepth;
var viewZToPerspectiveDepth = TSL.viewZToPerspectiveDepth;
var viewport = TSL.viewport;
var viewportCoordinate = TSL.viewportCoordinate;
var viewportDepthTexture = TSL.viewportDepthTexture;
var viewportLinearDepth = TSL.viewportLinearDepth;
var viewportMipTexture = TSL.viewportMipTexture;
var viewportResolution = TSL.viewportResolution;
var viewportSafeUV = TSL.viewportSafeUV;
var viewportSharedTexture = TSL.viewportSharedTexture;
var viewportSize = TSL.viewportSize;
var viewportTexture = TSL.viewportTexture;
var viewportUV = TSL.viewportUV;
var wgsl = TSL.wgsl;
var wgslFn = TSL.wgslFn;
var workgroupArray = TSL.workgroupArray;
var workgroupBarrier = TSL.workgroupBarrier;
var workgroupId = TSL.workgroupId;
var workingToColorSpace = TSL.workingToColorSpace;
var xor = TSL.xor;

//#endregion
//#region node_modules/shaders/dist/core/edges-Bd7GP4s2.js
var applyEdgeHandling = (distortedUV, sampledColor, childTexture, edgeModeUniform) => {
	const inBoundsX = step(float(0), distortedUV.x).mul(step(distortedUV.x, float(1)));
	const inBoundsY = step(float(0), distortedUV.y).mul(step(distortedUV.y, float(1)));
	const inBounds = inBoundsX.mul(inBoundsY);
	const transparentColor = vec4(sampledColor.rgb, sampledColor.a.mul(inBounds));
	if (!childTexture) return select(step(float(.5), edgeModeUniform), transparentColor, sampledColor);
	const mirrorX = mod(abs(distortedUV.x), float(2));
	const mirrorY = mod(abs(distortedUV.y), float(2));
	const mirroredUV = vec2(select(step(float(1), mirrorX), float(2).sub(mirrorX), mirrorX), select(step(float(1), mirrorY), float(2).sub(mirrorY), mirrorY));
	const mirrorColor = childTexture.sample(mirroredUV);
	const wrappedUV = vec2(fract(distortedUV.x), fract(distortedUV.y));
	const wrapColor = childTexture.sample(wrappedUV);
	return select(step(float(.5), edgeModeUniform), select(step(float(1.5), edgeModeUniform), select(step(float(2.5), edgeModeUniform), wrapColor, mirrorColor), transparentColor), sampledColor);
};

//#endregion
//#region node_modules/three/build/three.module.js
function WebGLAnimation() {
	let context$2 = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;
	function onAnimationFrame$1(time$2, frame) {
		animationLoop(time$2, frame);
		requestId = context$2.requestAnimationFrame(onAnimationFrame$1);
	}
	return {
		start: function() {
			if (isAnimating === true) return;
			if (animationLoop === null) return;
			requestId = context$2.requestAnimationFrame(onAnimationFrame$1);
			isAnimating = true;
		},
		stop: function() {
			context$2.cancelAnimationFrame(requestId);
			isAnimating = false;
		},
		setAnimationLoop: function(callback) {
			animationLoop = callback;
		},
		setContext: function(value) {
			context$2 = value;
		}
	};
}
function WebGLAttributes(gl) {
	const buffers = /* @__PURE__ */ new WeakMap();
	function createBuffer(attribute$2, bufferType) {
		const array$2 = attribute$2.array;
		const usage = attribute$2.usage;
		const size = array$2.byteLength;
		const buffer$2 = gl.createBuffer();
		gl.bindBuffer(bufferType, buffer$2);
		gl.bufferData(bufferType, array$2, usage);
		attribute$2.onUploadCallback();
		let type$1;
		if (array$2 instanceof Float32Array) type$1 = gl.FLOAT;
		else if (typeof Float16Array !== "undefined" && array$2 instanceof Float16Array) type$1 = gl.HALF_FLOAT;
		else if (array$2 instanceof Uint16Array) if (attribute$2.isFloat16BufferAttribute) type$1 = gl.HALF_FLOAT;
		else type$1 = gl.UNSIGNED_SHORT;
		else if (array$2 instanceof Int16Array) type$1 = gl.SHORT;
		else if (array$2 instanceof Uint32Array) type$1 = gl.UNSIGNED_INT;
		else if (array$2 instanceof Int32Array) type$1 = gl.INT;
		else if (array$2 instanceof Int8Array) type$1 = gl.BYTE;
		else if (array$2 instanceof Uint8Array) type$1 = gl.UNSIGNED_BYTE;
		else if (array$2 instanceof Uint8ClampedArray) type$1 = gl.UNSIGNED_BYTE;
		else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array$2);
		return {
			buffer: buffer$2,
			type: type$1,
			bytesPerElement: array$2.BYTES_PER_ELEMENT,
			version: attribute$2.version,
			size
		};
	}
	function updateBuffer(buffer$2, attribute$2, bufferType) {
		const array$2 = attribute$2.array;
		const updateRanges = attribute$2.updateRanges;
		gl.bindBuffer(bufferType, buffer$2);
		if (updateRanges.length === 0) gl.bufferSubData(bufferType, 0, array$2);
		else {
			updateRanges.sort((a$1, b$2) => a$1.start - b$2.start);
			let mergeIndex = 0;
			for (let i = 1; i < updateRanges.length; i++) {
				const previousRange = updateRanges[mergeIndex];
				const range$3 = updateRanges[i];
				if (range$3.start <= previousRange.start + previousRange.count + 1) previousRange.count = Math.max(previousRange.count, range$3.start + range$3.count - previousRange.start);
				else {
					++mergeIndex;
					updateRanges[mergeIndex] = range$3;
				}
			}
			updateRanges.length = mergeIndex + 1;
			for (let i = 0, l = updateRanges.length; i < l; i++) {
				const range$3 = updateRanges[i];
				gl.bufferSubData(bufferType, range$3.start * array$2.BYTES_PER_ELEMENT, array$2, range$3.start, range$3.count);
			}
			attribute$2.clearUpdateRanges();
		}
		attribute$2.onUploadCallback();
	}
	function get$1(attribute$2) {
		if (attribute$2.isInterleavedBufferAttribute) attribute$2 = attribute$2.data;
		return buffers.get(attribute$2);
	}
	function remove(attribute$2) {
		if (attribute$2.isInterleavedBufferAttribute) attribute$2 = attribute$2.data;
		const data = buffers.get(attribute$2);
		if (data) {
			gl.deleteBuffer(data.buffer);
			buffers.delete(attribute$2);
		}
	}
	function update(attribute$2, bufferType) {
		if (attribute$2.isInterleavedBufferAttribute) attribute$2 = attribute$2.data;
		if (attribute$2.isGLBufferAttribute) {
			const cached = buffers.get(attribute$2);
			if (!cached || cached.version < attribute$2.version) buffers.set(attribute$2, {
				buffer: attribute$2.buffer,
				type: attribute$2.type,
				bytesPerElement: attribute$2.elementSize,
				version: attribute$2.version
			});
			return;
		}
		const data = buffers.get(attribute$2);
		if (data === void 0) buffers.set(attribute$2, createBuffer(attribute$2, bufferType));
		else if (data.version < attribute$2.version) {
			if (data.size !== attribute$2.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
			updateBuffer(data.buffer, attribute$2, bufferType);
			data.version = attribute$2.version;
		}
	}
	return {
		get: get$1,
		remove,
		update
	};
}
var ShaderChunk = {
	alphahash_fragment: "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
	alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif",
	alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
	alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
	alphatest_fragment: "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif",
	alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif",
	aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif",
	aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
	batching_pars_vertex: "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif",
	batching_vertex: "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
	begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif",
	beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",
	bsdfs: "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated",
	iridescence_fragment: "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif",
	bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",
	clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif",
	clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
	clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",
	clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",
	color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",
	color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",
	color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif",
	color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif",
	common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
	cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",
	defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",
	displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",
	displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
	emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n		emissiveColor = sRGBTransferEOTF( emissiveColor );\n	#endif\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
	emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",
	colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
	colorspace_pars_fragment: "vec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
	envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",
	envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n#endif",
	envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",
	envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",
	envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif",
	envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",
	fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif",
	fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif",
	fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
	fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
	gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}",
	lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
	lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
	lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert",
	lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif",
	lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
	lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon",
	lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
	lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong",
	lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
	lights_physical_pars_fragment: "uniform sampler2D dfgLUT;\nstruct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 uv = vec2( roughness, dotNV );\n	return texture2D( dfgLUT, uv ).rg;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nvec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 dfgV = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNV * dotNV), 0.0, dotNV), material.roughness );\n	vec2 dfgL = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNL * dotNL), 0.0, dotNL), material.roughness );\n	vec3 FssEss_V = material.specularColor * dfgV.x + material.specularF90 * dfgV.y;\n	vec3 FssEss_L = material.specularColor * dfgL.x + material.specularF90 * dfgL.y;\n	float Ess_V = dfgV.x + dfgV.y;\n	float Ess_L = dfgL.x + dfgL.y;\n	float Ems_V = 1.0 - Ess_V;\n	float Ems_L = 1.0 - Ess_L;\n	vec3 Favg = material.specularColor + ( 1.0 - material.specularColor ) * 0.047619;\n	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg * Favg + EPSILON );\n	float compensationFactor = Ems_V * Ems_L;\n	vec3 multiScatter = Fms * compensationFactor;\n	return singleScatter + multiScatter;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
	lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
	lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif",
	lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
	logdepthbuf_fragment: "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
	logdepthbuf_pars_fragment: "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
	logdepthbuf_pars_vertex: "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
	logdepthbuf_vertex: "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
	map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif",
	map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",
	map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
	map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
	metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",
	metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
	morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif",
	morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif",
	morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif",
	morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif",
	morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif",
	normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
	normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
	normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
	normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
	normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif",
	normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif",
	clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
	clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
	clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif",
	iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif",
	opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}",
	premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",
	project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
	dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
	dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",
	roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",
	roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
	shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );\n		#ifdef USE_REVERSED_DEPTH_BUFFER\n			return step( depth, compare );\n		#else\n			return step( compare, depth );\n		#endif\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		#ifdef USE_REVERSED_DEPTH_BUFFER\n			float hard_shadow = step( distribution.x, compare );\n		#else\n			float hard_shadow = step( compare, distribution.x );\n		#endif\n		if ( hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif",
	shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",
	shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif",
	shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",
	skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
	skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif",
	skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
	skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",
	specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
	specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
	tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
	tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
	transmission_fragment: "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
	transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		#else\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif",
	uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif",
	uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif",
	uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
	worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",
	background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
	background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
	backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
	backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
	cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
	cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
	depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",
	depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	#ifdef USE_REVERSED_DEPTH_BUFFER\n		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];\n	#else\n		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;\n	#endif\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}",
	distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",
	distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",
	equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
	equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
	linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
	linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
	meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",
	meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
	meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
	meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
	meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",
	meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
	meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",
	meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}",
	meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
	meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
	meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",
	meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
	meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
	meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
	points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",
	points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
	shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
	shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}",
	sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
	sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}"
};
var UniformsLib = {
	common: {
		diffuse: { value: /* @__PURE__ */ new Color$1(16777215) },
		opacity: { value: 1 },
		map: { value: null },
		mapTransform: { value: /* @__PURE__ */ new Matrix3() },
		alphaMap: { value: null },
		alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		alphaTest: { value: 0 }
	},
	specularmap: {
		specularMap: { value: null },
		specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }
	},
	envmap: {
		envMap: { value: null },
		envMapRotation: { value: /* @__PURE__ */ new Matrix3() },
		flipEnvMap: { value: -1 },
		reflectivity: { value: 1 },
		ior: { value: 1.5 },
		refractionRatio: { value: .98 },
		dfgLUT: { value: null }
	},
	aomap: {
		aoMap: { value: null },
		aoMapIntensity: { value: 1 },
		aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }
	},
	lightmap: {
		lightMap: { value: null },
		lightMapIntensity: { value: 1 },
		lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }
	},
	bumpmap: {
		bumpMap: { value: null },
		bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		bumpScale: { value: 1 }
	},
	normalmap: {
		normalMap: { value: null },
		normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
	},
	displacementmap: {
		displacementMap: { value: null },
		displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }
	},
	emissivemap: {
		emissiveMap: { value: null },
		emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }
	},
	metalnessmap: {
		metalnessMap: { value: null },
		metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
	},
	roughnessmap: {
		roughnessMap: { value: null },
		roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
	},
	gradientmap: { gradientMap: { value: null } },
	fog: {
		fogDensity: { value: 25e-5 },
		fogNear: { value: 1 },
		fogFar: { value: 2e3 },
		fogColor: { value: /* @__PURE__ */ new Color$1(16777215) }
	},
	lights: {
		ambientLightColor: { value: [] },
		lightProbe: { value: [] },
		directionalLights: {
			value: [],
			properties: {
				direction: {},
				color: {}
			}
		},
		directionalLightShadows: {
			value: [],
			properties: {
				shadowIntensity: 1,
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			}
		},
		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },
		spotLights: {
			value: [],
			properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			}
		},
		spotLightShadows: {
			value: [],
			properties: {
				shadowIntensity: 1,
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			}
		},
		spotLightMap: { value: [] },
		spotShadowMap: { value: [] },
		spotLightMatrix: { value: [] },
		pointLights: {
			value: [],
			properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			}
		},
		pointLightShadows: {
			value: [],
			properties: {
				shadowIntensity: 1,
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			}
		},
		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },
		hemisphereLights: {
			value: [],
			properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			}
		},
		rectAreaLights: {
			value: [],
			properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			}
		},
		ltc_1: { value: null },
		ltc_2: { value: null }
	},
	points: {
		diffuse: { value: /* @__PURE__ */ new Color$1(16777215) },
		opacity: { value: 1 },
		size: { value: 1 },
		scale: { value: 1 },
		map: { value: null },
		alphaMap: { value: null },
		alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		alphaTest: { value: 0 },
		uvTransform: { value: /* @__PURE__ */ new Matrix3() }
	},
	sprite: {
		diffuse: { value: /* @__PURE__ */ new Color$1(16777215) },
		opacity: { value: 1 },
		center: { value: /* @__PURE__ */ new Vector2(.5, .5) },
		rotation: { value: 0 },
		map: { value: null },
		mapTransform: { value: /* @__PURE__ */ new Matrix3() },
		alphaMap: { value: null },
		alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		alphaTest: { value: 0 }
	}
};
var ShaderLib = {
	basic: {
		uniforms: /* @__PURE__ */ mergeUniforms([
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		]),
		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag
	},
	lambert: {
		uniforms: /* @__PURE__ */ mergeUniforms([
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{ emissive: { value: /* @__PURE__ */ new Color$1(0) } }
		]),
		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag
	},
	phong: {
		uniforms: /* @__PURE__ */ mergeUniforms([
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /* @__PURE__ */ new Color$1(0) },
				specular: { value: /* @__PURE__ */ new Color$1(1118481) },
				shininess: { value: 30 }
			}
		]),
		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag
	},
	standard: {
		uniforms: /* @__PURE__ */ mergeUniforms([
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /* @__PURE__ */ new Color$1(0) },
				roughness: { value: 1 },
				metalness: { value: 0 },
				envMapIntensity: { value: 1 }
			}
		]),
		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	},
	toon: {
		uniforms: /* @__PURE__ */ mergeUniforms([
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{ emissive: { value: /* @__PURE__ */ new Color$1(0) } }
		]),
		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag
	},
	matcap: {
		uniforms: /* @__PURE__ */ mergeUniforms([
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{ matcap: { value: null } }
		]),
		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag
	},
	points: {
		uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.points, UniformsLib.fog]),
		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag
	},
	dashed: {
		uniforms: /* @__PURE__ */ mergeUniforms([
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		]),
		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag
	},
	depth: {
		uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag
	},
	normal: {
		uniforms: /* @__PURE__ */ mergeUniforms([
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{ opacity: { value: 1 } }
		]),
		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag
	},
	sprite: {
		uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag
	},
	background: {
		uniforms: {
			uvTransform: { value: /* @__PURE__ */ new Matrix3() },
			t2D: { value: null },
			backgroundIntensity: { value: 1 }
		},
		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag
	},
	backgroundCube: {
		uniforms: {
			envMap: { value: null },
			flipEnvMap: { value: -1 },
			backgroundBlurriness: { value: 0 },
			backgroundIntensity: { value: 1 },
			backgroundRotation: { value: /* @__PURE__ */ new Matrix3() }
		},
		vertexShader: ShaderChunk.backgroundCube_vert,
		fragmentShader: ShaderChunk.backgroundCube_frag
	},
	cube: {
		uniforms: {
			tCube: { value: null },
			tFlip: { value: -1 },
			opacity: { value: 1 }
		},
		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag
	},
	equirect: {
		uniforms: { tEquirect: { value: null } },
		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag
	},
	distanceRGBA: {
		uniforms: /* @__PURE__ */ mergeUniforms([
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: /* @__PURE__ */ new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1e3 }
			}
		]),
		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag
	},
	shadow: {
		uniforms: /* @__PURE__ */ mergeUniforms([
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: /* @__PURE__ */ new Color$1(0) },
				opacity: { value: 1 }
			}
		]),
		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag
	}
};
ShaderLib.physical = {
	uniforms: /* @__PURE__ */ mergeUniforms([ShaderLib.standard.uniforms, {
		clearcoat: { value: 0 },
		clearcoatMap: { value: null },
		clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		clearcoatNormalMap: { value: null },
		clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
		clearcoatRoughness: { value: 0 },
		clearcoatRoughnessMap: { value: null },
		clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		dispersion: { value: 0 },
		iridescence: { value: 0 },
		iridescenceMap: { value: null },
		iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		iridescenceIOR: { value: 1.3 },
		iridescenceThicknessMinimum: { value: 100 },
		iridescenceThicknessMaximum: { value: 400 },
		iridescenceThicknessMap: { value: null },
		iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		sheen: { value: 0 },
		sheenColor: { value: /* @__PURE__ */ new Color$1(0) },
		sheenColorMap: { value: null },
		sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		sheenRoughness: { value: 1 },
		sheenRoughnessMap: { value: null },
		sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		transmission: { value: 0 },
		transmissionMap: { value: null },
		transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
		transmissionSamplerMap: { value: null },
		thickness: { value: 0 },
		thicknessMap: { value: null },
		thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		attenuationDistance: { value: 0 },
		attenuationColor: { value: /* @__PURE__ */ new Color$1(0) },
		specularColor: { value: /* @__PURE__ */ new Color$1(1, 1, 1) },
		specularColorMap: { value: null },
		specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		specularIntensity: { value: 1 },
		specularIntensityMap: { value: null },
		specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
		anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
		anisotropyMap: { value: null },
		anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }
	}]),
	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag
};
var _rgb = {
	r: 0,
	b: 0,
	g: 0
};
var _e1$1 = /* @__PURE__ */ new Euler();
var _m1$1 = /* @__PURE__ */ new Matrix4();
function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
	const clearColor = new Color$1(0);
	let clearAlpha = alpha === true ? 0 : 1;
	let planeMesh;
	let boxMesh;
	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;
	function getBackground(scene) {
		let background = scene.isScene === true ? scene.background : null;
		if (background && background.isTexture) background = (scene.backgroundBlurriness > 0 ? cubeuvmaps : cubemaps).get(background);
		return background;
	}
	function render(scene) {
		let forceClear = false;
		const background = getBackground(scene);
		if (background === null) setClear(clearColor, clearAlpha);
		else if (background && background.isColor) {
			setClear(background, 1);
			forceClear = true;
		}
		const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
		if (environmentBlendMode === "additive") state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
		else if (environmentBlendMode === "alpha-blend") state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
		if (renderer.autoClear || forceClear) {
			state.buffers.depth.setTest(true);
			state.buffers.depth.setMask(true);
			state.buffers.color.setMask(true);
			renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
		}
	}
	function addToRenderList(renderList, scene) {
		const background = getBackground(scene);
		if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
			if (boxMesh === void 0) {
				boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
					name: "BackgroundCubeMaterial",
					uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
					vertexShader: ShaderLib.backgroundCube.vertexShader,
					fragmentShader: ShaderLib.backgroundCube.fragmentShader,
					side: BackSide,
					depthTest: false,
					depthWrite: false,
					fog: false,
					allowOverride: false
				}));
				boxMesh.geometry.deleteAttribute("normal");
				boxMesh.geometry.deleteAttribute("uv");
				boxMesh.onBeforeRender = function(renderer$1, scene$1, camera) {
					this.matrixWorld.copyPosition(camera.matrixWorld);
				};
				Object.defineProperty(boxMesh.material, "envMap", { get: function() {
					return this.uniforms.envMap.value;
				} });
				objects.update(boxMesh);
			}
			_e1$1.copy(scene.backgroundRotation);
			_e1$1.x *= -1;
			_e1$1.y *= -1;
			_e1$1.z *= -1;
			if (background.isCubeTexture && background.isRenderTargetTexture === false) {
				_e1$1.y *= -1;
				_e1$1.z *= -1;
			}
			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
			boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
			boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
			boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));
			boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
			if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
				boxMesh.material.needsUpdate = true;
				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;
			}
			boxMesh.layers.enableAll();
			renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
		} else if (background && background.isTexture) {
			if (planeMesh === void 0) {
				planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
					name: "BackgroundMaterial",
					uniforms: cloneUniforms(ShaderLib.background.uniforms),
					vertexShader: ShaderLib.background.vertexShader,
					fragmentShader: ShaderLib.background.fragmentShader,
					side: FrontSide,
					depthTest: false,
					depthWrite: false,
					fog: false,
					allowOverride: false
				}));
				planeMesh.geometry.deleteAttribute("normal");
				Object.defineProperty(planeMesh.material, "map", { get: function() {
					return this.uniforms.t2D.value;
				} });
				objects.update(planeMesh);
			}
			planeMesh.material.uniforms.t2D.value = background;
			planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
			planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
			if (background.matrixAutoUpdate === true) background.updateMatrix();
			planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
			if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
				planeMesh.material.needsUpdate = true;
				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;
			}
			planeMesh.layers.enableAll();
			renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
		}
	}
	function setClear(color$2, alpha$1) {
		color$2.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
		state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha$1, premultipliedAlpha);
	}
	function dispose() {
		if (boxMesh !== void 0) {
			boxMesh.geometry.dispose();
			boxMesh.material.dispose();
			boxMesh = void 0;
		}
		if (planeMesh !== void 0) {
			planeMesh.geometry.dispose();
			planeMesh.material.dispose();
			planeMesh = void 0;
		}
	}
	return {
		getClearColor: function() {
			return clearColor;
		},
		setClearColor: function(color$2, alpha$1 = 1) {
			clearColor.set(color$2);
			clearAlpha = alpha$1;
			setClear(clearColor, clearAlpha);
		},
		getClearAlpha: function() {
			return clearAlpha;
		},
		setClearAlpha: function(alpha$1) {
			clearAlpha = alpha$1;
			setClear(clearColor, clearAlpha);
		},
		render,
		addToRenderList,
		dispose
	};
}
function WebGLBindingStates(gl, attributes) {
	const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	const bindingStates = {};
	const defaultState = createBindingState(null);
	let currentState = defaultState;
	let forceUpdate = false;
	function setup(object, material, program, geometry, index) {
		let updateBuffers = false;
		const state = getBindingState(geometry, program, material);
		if (currentState !== state) {
			currentState = state;
			bindVertexArrayObject(currentState.object);
		}
		updateBuffers = needsUpdate(object, geometry, program, index);
		if (updateBuffers) saveCache(object, geometry, program, index);
		if (index !== null) attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
		if (updateBuffers || forceUpdate) {
			forceUpdate = false;
			setupVertexAttributes(object, material, program, geometry);
			if (index !== null) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
		}
	}
	function createVertexArrayObject() {
		return gl.createVertexArray();
	}
	function bindVertexArrayObject(vao) {
		return gl.bindVertexArray(vao);
	}
	function deleteVertexArrayObject(vao) {
		return gl.deleteVertexArray(vao);
	}
	function getBindingState(geometry, program, material) {
		const wireframe = material.wireframe === true;
		let programMap = bindingStates[geometry.id];
		if (programMap === void 0) {
			programMap = {};
			bindingStates[geometry.id] = programMap;
		}
		let stateMap = programMap[program.id];
		if (stateMap === void 0) {
			stateMap = {};
			programMap[program.id] = stateMap;
		}
		let state = stateMap[wireframe];
		if (state === void 0) {
			state = createBindingState(createVertexArrayObject());
			stateMap[wireframe] = state;
		}
		return state;
	}
	function createBindingState(vao) {
		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];
		for (let i = 0; i < maxVertexAttributes; i++) {
			newAttributes[i] = 0;
			enabledAttributes[i] = 0;
			attributeDivisors[i] = 0;
		}
		return {
			geometry: null,
			program: null,
			wireframe: false,
			newAttributes,
			enabledAttributes,
			attributeDivisors,
			object: vao,
			attributes: {},
			index: null
		};
	}
	function needsUpdate(object, geometry, program, index) {
		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;
		let attributesNum = 0;
		const programAttributes = program.getAttributes();
		for (const name in programAttributes) if (programAttributes[name].location >= 0) {
			const cachedAttribute = cachedAttributes[name];
			let geometryAttribute = geometryAttributes[name];
			if (geometryAttribute === void 0) {
				if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
				if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
			}
			if (cachedAttribute === void 0) return true;
			if (cachedAttribute.attribute !== geometryAttribute) return true;
			if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
			attributesNum++;
		}
		if (currentState.attributesNum !== attributesNum) return true;
		if (currentState.index !== index) return true;
		return false;
	}
	function saveCache(object, geometry, program, index) {
		const cache$2 = {};
		const attributes$1 = geometry.attributes;
		let attributesNum = 0;
		const programAttributes = program.getAttributes();
		for (const name in programAttributes) if (programAttributes[name].location >= 0) {
			let attribute$2 = attributes$1[name];
			if (attribute$2 === void 0) {
				if (name === "instanceMatrix" && object.instanceMatrix) attribute$2 = object.instanceMatrix;
				if (name === "instanceColor" && object.instanceColor) attribute$2 = object.instanceColor;
			}
			const data = {};
			data.attribute = attribute$2;
			if (attribute$2 && attribute$2.data) data.data = attribute$2.data;
			cache$2[name] = data;
			attributesNum++;
		}
		currentState.attributes = cache$2;
		currentState.attributesNum = attributesNum;
		currentState.index = index;
	}
	function initAttributes() {
		const newAttributes = currentState.newAttributes;
		for (let i = 0, il = newAttributes.length; i < il; i++) newAttributes[i] = 0;
	}
	function enableAttribute(attribute$2) {
		enableAttributeAndDivisor(attribute$2, 0);
	}
	function enableAttributeAndDivisor(attribute$2, meshPerAttribute) {
		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;
		newAttributes[attribute$2] = 1;
		if (enabledAttributes[attribute$2] === 0) {
			gl.enableVertexAttribArray(attribute$2);
			enabledAttributes[attribute$2] = 1;
		}
		if (attributeDivisors[attribute$2] !== meshPerAttribute) {
			gl.vertexAttribDivisor(attribute$2, meshPerAttribute);
			attributeDivisors[attribute$2] = meshPerAttribute;
		}
	}
	function disableUnusedAttributes() {
		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		for (let i = 0, il = enabledAttributes.length; i < il; i++) if (enabledAttributes[i] !== newAttributes[i]) {
			gl.disableVertexAttribArray(i);
			enabledAttributes[i] = 0;
		}
	}
	function vertexAttribPointer(index, size, type$1, normalized, stride, offset, integer) {
		if (integer === true) gl.vertexAttribIPointer(index, size, type$1, stride, offset);
		else gl.vertexAttribPointer(index, size, type$1, normalized, stride, offset);
	}
	function setupVertexAttributes(object, material, program, geometry) {
		initAttributes();
		const geometryAttributes = geometry.attributes;
		const programAttributes = program.getAttributes();
		const materialDefaultAttributeValues = material.defaultAttributeValues;
		for (const name in programAttributes) {
			const programAttribute = programAttributes[name];
			if (programAttribute.location >= 0) {
				let geometryAttribute = geometryAttributes[name];
				if (geometryAttribute === void 0) {
					if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
					if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
				}
				if (geometryAttribute !== void 0) {
					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;
					const attribute$2 = attributes.get(geometryAttribute);
					if (attribute$2 === void 0) continue;
					const buffer$2 = attribute$2.buffer;
					const type$1 = attribute$2.type;
					const bytesPerElement = attribute$2.bytesPerElement;
					const integer = type$1 === gl.INT || type$1 === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
					if (geometryAttribute.isInterleavedBufferAttribute) {
						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;
						if (data.isInstancedInterleavedBuffer) {
							for (let i = 0; i < programAttribute.locationSize; i++) enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
							if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) geometry._maxInstanceCount = data.meshPerAttribute * data.count;
						} else for (let i = 0; i < programAttribute.locationSize; i++) enableAttribute(programAttribute.location + i);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer$2);
						for (let i = 0; i < programAttribute.locationSize; i++) vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type$1, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i) * bytesPerElement, integer);
					} else {
						if (geometryAttribute.isInstancedBufferAttribute) {
							for (let i = 0; i < programAttribute.locationSize; i++) enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
							if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
						} else for (let i = 0; i < programAttribute.locationSize; i++) enableAttribute(programAttribute.location + i);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer$2);
						for (let i = 0; i < programAttribute.locationSize; i++) vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type$1, normalized, size * bytesPerElement, size / programAttribute.locationSize * i * bytesPerElement, integer);
					}
				} else if (materialDefaultAttributeValues !== void 0) {
					const value = materialDefaultAttributeValues[name];
					if (value !== void 0) switch (value.length) {
						case 2:
							gl.vertexAttrib2fv(programAttribute.location, value);
							break;
						case 3:
							gl.vertexAttrib3fv(programAttribute.location, value);
							break;
						case 4:
							gl.vertexAttrib4fv(programAttribute.location, value);
							break;
						default: gl.vertexAttrib1fv(programAttribute.location, value);
					}
				}
			}
		}
		disableUnusedAttributes();
	}
	function dispose() {
		reset();
		for (const geometryId in bindingStates) {
			const programMap = bindingStates[geometryId];
			for (const programId in programMap) {
				const stateMap = programMap[programId];
				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}
				delete programMap[programId];
			}
			delete bindingStates[geometryId];
		}
	}
	function releaseStatesOfGeometry(geometry) {
		if (bindingStates[geometry.id] === void 0) return;
		const programMap = bindingStates[geometry.id];
		for (const programId in programMap) {
			const stateMap = programMap[programId];
			for (const wireframe in stateMap) {
				deleteVertexArrayObject(stateMap[wireframe].object);
				delete stateMap[wireframe];
			}
			delete programMap[programId];
		}
		delete bindingStates[geometry.id];
	}
	function releaseStatesOfProgram(program) {
		for (const geometryId in bindingStates) {
			const programMap = bindingStates[geometryId];
			if (programMap[program.id] === void 0) continue;
			const stateMap = programMap[program.id];
			for (const wireframe in stateMap) {
				deleteVertexArrayObject(stateMap[wireframe].object);
				delete stateMap[wireframe];
			}
			delete programMap[program.id];
		}
	}
	function reset() {
		resetDefaultState();
		forceUpdate = true;
		if (currentState === defaultState) return;
		currentState = defaultState;
		bindVertexArrayObject(currentState.object);
	}
	function resetDefaultState() {
		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;
	}
	return {
		setup,
		reset,
		resetDefaultState,
		dispose,
		releaseStatesOfGeometry,
		releaseStatesOfProgram,
		initAttributes,
		enableAttribute,
		disableUnusedAttributes
	};
}
function WebGLBufferRenderer(gl, extensions, info) {
	let mode;
	function setMode(value) {
		mode = value;
	}
	function render(start, count) {
		gl.drawArrays(mode, start, count);
		info.update(count, mode, 1);
	}
	function renderInstances(start, count, primcount) {
		if (primcount === 0) return;
		gl.drawArraysInstanced(mode, start, count, primcount);
		info.update(count, mode, primcount);
	}
	function renderMultiDraw(starts, counts, drawCount) {
		if (drawCount === 0) return;
		extensions.get("WEBGL_multi_draw").multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
		let elementCount = 0;
		for (let i = 0; i < drawCount; i++) elementCount += counts[i];
		info.update(elementCount, mode, 1);
	}
	function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
		if (drawCount === 0) return;
		const extension = extensions.get("WEBGL_multi_draw");
		if (extension === null) for (let i = 0; i < starts.length; i++) renderInstances(starts[i], counts[i], primcount[i]);
		else {
			extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
			let elementCount = 0;
			for (let i = 0; i < drawCount; i++) elementCount += counts[i] * primcount[i];
			info.update(elementCount, mode, 1);
		}
	}
	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;
	this.renderMultiDraw = renderMultiDraw;
	this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLCapabilities(gl, extensions, parameters, utils) {
	let maxAnisotropy;
	function getMaxAnisotropy() {
		if (maxAnisotropy !== void 0) return maxAnisotropy;
		if (extensions.has("EXT_texture_filter_anisotropic") === true) {
			const extension = extensions.get("EXT_texture_filter_anisotropic");
			maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
		} else maxAnisotropy = 0;
		return maxAnisotropy;
	}
	function textureFormatReadable(textureFormat) {
		if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) return false;
		return true;
	}
	function textureTypeReadable(textureType) {
		const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float"));
		if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && textureType !== FloatType && !halfFloatSupportedByExt) return false;
		return true;
	}
	function getMaxPrecision(precision$1) {
		if (precision$1 === "highp") {
			if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) return "highp";
			precision$1 = "mediump";
		}
		if (precision$1 === "mediump") {
			if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) return "mediump";
		}
		return "lowp";
	}
	let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
	const maxPrecision = getMaxPrecision(precision);
	if (maxPrecision !== precision) {
		warn("WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
		precision = maxPrecision;
	}
	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
	const reversedDepthBuffer = parameters.reversedDepthBuffer === true && extensions.has("EXT_clip_control");
	const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
	const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
	const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
	const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
	const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
	const vertexTextures = maxVertexTextures > 0;
	const maxSamples = gl.getParameter(gl.MAX_SAMPLES);
	return {
		isWebGL2: true,
		getMaxAnisotropy,
		getMaxPrecision,
		textureFormatReadable,
		textureTypeReadable,
		precision,
		logarithmicDepthBuffer,
		reversedDepthBuffer,
		maxTextures,
		maxVertexTextures,
		maxTextureSize,
		maxCubemapSize,
		maxAttributes,
		maxVertexUniforms,
		maxVaryings,
		maxFragmentUniforms,
		vertexTextures,
		maxSamples
	};
}
function WebGLClipping(properties) {
	const scope = this;
	let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
	const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform$2 = {
		value: null,
		needsUpdate: false
	};
	this.uniform = uniform$2;
	this.numPlanes = 0;
	this.numIntersection = 0;
	this.init = function(planes, enableLocalClipping) {
		const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
		localClippingEnabled = enableLocalClipping;
		numGlobalPlanes = planes.length;
		return enabled;
	};
	this.beginShadows = function() {
		renderingShadows = true;
		projectPlanes(null);
	};
	this.endShadows = function() {
		renderingShadows = false;
	};
	this.setGlobalState = function(planes, camera) {
		globalState = projectPlanes(planes, camera, 0);
	};
	this.setState = function(material, camera, useCache) {
		const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
		const materialProperties = properties.get(material);
		if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) if (renderingShadows) projectPlanes(null);
		else resetGlobalState();
		else {
			const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
			let dstArray = materialProperties.clippingState || null;
			uniform$2.value = dstArray;
			dstArray = projectPlanes(planes, camera, lGlobal, useCache);
			for (let i = 0; i !== lGlobal; ++i) dstArray[i] = globalState[i];
			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;
		}
	};
	function resetGlobalState() {
		if (uniform$2.value !== globalState) {
			uniform$2.value = globalState;
			uniform$2.needsUpdate = numGlobalPlanes > 0;
		}
		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;
	}
	function projectPlanes(planes, camera, dstOffset, skipTransform) {
		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;
		if (nPlanes !== 0) {
			dstArray = uniform$2.value;
			if (skipTransform !== true || dstArray === null) {
				const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
				viewNormalMatrix.getNormalMatrix(viewMatrix);
				if (dstArray === null || dstArray.length < flatSize) dstArray = new Float32Array(flatSize);
				for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
					plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
					plane.normal.toArray(dstArray, i4);
					dstArray[i4 + 3] = plane.constant;
				}
			}
			uniform$2.value = dstArray;
			uniform$2.needsUpdate = true;
		}
		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;
		return dstArray;
	}
}
function WebGLCubeMaps(renderer) {
	let cubemaps = /* @__PURE__ */ new WeakMap();
	function mapTextureMapping$1(texture$2, mapping) {
		if (mapping === EquirectangularReflectionMapping) texture$2.mapping = CubeReflectionMapping;
		else if (mapping === EquirectangularRefractionMapping) texture$2.mapping = CubeRefractionMapping;
		return texture$2;
	}
	function get$1(texture$2) {
		if (texture$2 && texture$2.isTexture) {
			const mapping = texture$2.mapping;
			if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) if (cubemaps.has(texture$2)) {
				const cubemap = cubemaps.get(texture$2).texture;
				return mapTextureMapping$1(cubemap, texture$2.mapping);
			} else {
				const image = texture$2.image;
				if (image && image.height > 0) {
					const renderTarget = new WebGLCubeRenderTarget(image.height);
					renderTarget.fromEquirectangularTexture(renderer, texture$2);
					cubemaps.set(texture$2, renderTarget);
					texture$2.addEventListener("dispose", onTextureDispose$1);
					return mapTextureMapping$1(renderTarget.texture, texture$2.mapping);
				} else return null;
			}
		}
		return texture$2;
	}
	function onTextureDispose$1(event) {
		const texture$2 = event.target;
		texture$2.removeEventListener("dispose", onTextureDispose$1);
		const cubemap = cubemaps.get(texture$2);
		if (cubemap !== void 0) {
			cubemaps.delete(texture$2);
			cubemap.dispose();
		}
	}
	function dispose() {
		cubemaps = /* @__PURE__ */ new WeakMap();
	}
	return {
		get: get$1,
		dispose
	};
}
var LOD_MIN = 4;
var EXTRA_LOD_SIGMA = [
	.125,
	.215,
	.35,
	.446,
	.526,
	.582
];
var MAX_SAMPLES = 20;
var GGX_SAMPLES = 256;
var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
var _clearColor = /* @__PURE__ */ new Color$1();
var _oldTarget = null;
var _oldActiveCubeFace = 0;
var _oldActiveMipmapLevel = 0;
var _oldXrEnabled = false;
var _origin = /* @__PURE__ */ new Vector3();
/**
* This class generates a Prefiltered, Mipmapped Radiance Environment Map
* (PMREM) from a cubeMap environment texture. This allows different levels of
* blur to be quickly accessed based on material roughness. It is packed into a
* special CubeUV format that allows us to perform custom interpolation so that
* we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
* chain, it only goes down to the LOD_MIN level (above), and then creates extra
* even more filtered 'mips' at the same LOD_MIN resolution, associated with
* higher roughness levels. In this way we maintain resolution to smoothly
* interpolate diffuse lighting while limiting sampling computation.
*
* The prefiltering uses GGX VNDF (Visible Normal Distribution Function)
* importance sampling based on "Sampling the GGX Distribution of Visible Normals"
* (Heitz, 2018) to generate environment maps that accurately match the GGX BRDF
* used in material rendering for physically-based image-based lighting.
*/
var PMREMGenerator = class {
	/**
	* Constructs a new PMREM generator.
	*
	* @param {WebGLRenderer} renderer - The renderer.
	*/
	constructor(renderer) {
		this._renderer = renderer;
		this._pingPongRenderTarget = null;
		this._lodMax = 0;
		this._cubeSize = 0;
		this._sizeLods = [];
		this._sigmas = [];
		this._lodMeshes = [];
		this._backgroundBox = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;
		this._blurMaterial = null;
		this._ggxMaterial = null;
	}
	/**
	* Generates a PMREM from a supplied Scene, which can be faster than using an
	* image if networking bandwidth is low. Optional sigma specifies a blur radius
	* in radians to be applied to the scene before PMREM generation. Optional near
	* and far planes ensure the scene is rendered in its entirety.
	*
	* @param {Scene} scene - The scene to be captured.
	* @param {number} [sigma=0] - The blur radius in radians.
	* @param {number} [near=0.1] - The near plane distance.
	* @param {number} [far=100] - The far plane distance.
	* @param {Object} [options={}] - The configuration options.
	* @param {number} [options.size=256] - The texture size of the PMREM.
	* @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
	* @return {WebGLRenderTarget} The resulting PMREM.
	*/
	fromScene(scene, sigma = 0, near = .1, far = 100, options = {}) {
		const { size = 256, position = _origin } = options;
		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
		_oldXrEnabled = this._renderer.xr.enabled;
		this._renderer.xr.enabled = false;
		this._setSize(size);
		const cubeUVRenderTarget = this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;
		this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position);
		if (sigma > 0) this._blur(cubeUVRenderTarget, 0, 0, sigma);
		this._applyPMREM(cubeUVRenderTarget);
		this._cleanup(cubeUVRenderTarget);
		return cubeUVRenderTarget;
	}
	/**
	* Generates a PMREM from an equirectangular texture, which can be either LDR
	* or HDR. The ideal input image size is 1k (1024 x 512),
	* as this matches best with the 256 x 256 cubemap output.
	*
	* @param {Texture} equirectangular - The equirectangular texture to be converted.
	* @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
	* @return {WebGLRenderTarget} The resulting PMREM.
	*/
	fromEquirectangular(equirectangular, renderTarget = null) {
		return this._fromTexture(equirectangular, renderTarget);
	}
	/**
	* Generates a PMREM from an cubemap texture, which can be either LDR
	* or HDR. The ideal input cube size is 256 x 256,
	* as this matches best with the 256 x 256 cubemap output.
	*
	* @param {Texture} cubemap - The cubemap texture to be converted.
	* @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
	* @return {WebGLRenderTarget} The resulting PMREM.
	*/
	fromCubemap(cubemap, renderTarget = null) {
		return this._fromTexture(cubemap, renderTarget);
	}
	/**
	* Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	* your texture's network fetch for increased concurrency.
	*/
	compileCubemapShader() {
		if (this._cubemapMaterial === null) {
			this._cubemapMaterial = _getCubemapMaterial();
			this._compileMaterial(this._cubemapMaterial);
		}
	}
	/**
	* Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	* your texture's network fetch for increased concurrency.
	*/
	compileEquirectangularShader() {
		if (this._equirectMaterial === null) {
			this._equirectMaterial = _getEquirectMaterial();
			this._compileMaterial(this._equirectMaterial);
		}
	}
	/**
	* Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	* so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	* one of them will cause any others to also become unusable.
	*/
	dispose() {
		this._dispose();
		if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
		if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
		if (this._backgroundBox !== null) {
			this._backgroundBox.geometry.dispose();
			this._backgroundBox.material.dispose();
		}
	}
	_setSize(cubeSize) {
		this._lodMax = Math.floor(Math.log2(cubeSize));
		this._cubeSize = Math.pow(2, this._lodMax);
	}
	_dispose() {
		if (this._blurMaterial !== null) this._blurMaterial.dispose();
		if (this._ggxMaterial !== null) this._ggxMaterial.dispose();
		if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
		for (let i = 0; i < this._lodMeshes.length; i++) this._lodMeshes[i].geometry.dispose();
	}
	_cleanup(outputTarget) {
		this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
		this._renderer.xr.enabled = _oldXrEnabled;
		outputTarget.scissorTest = false;
		_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
	}
	_fromTexture(texture$2, renderTarget) {
		if (texture$2.mapping === CubeReflectionMapping || texture$2.mapping === CubeRefractionMapping) this._setSize(texture$2.image.length === 0 ? 16 : texture$2.image[0].width || texture$2.image[0].image.width);
		else this._setSize(texture$2.image.width / 4);
		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
		_oldXrEnabled = this._renderer.xr.enabled;
		this._renderer.xr.enabled = false;
		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV(texture$2, cubeUVRenderTarget);
		this._applyPMREM(cubeUVRenderTarget);
		this._cleanup(cubeUVRenderTarget);
		return cubeUVRenderTarget;
	}
	_allocateTargets() {
		const width = 3 * Math.max(this._cubeSize, 112);
		const height = 4 * this._cubeSize;
		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			colorSpace: LinearSRGBColorSpace,
			depthBuffer: false
		};
		const cubeUVRenderTarget = _createRenderTarget(width, height, params);
		if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
			if (this._pingPongRenderTarget !== null) this._dispose();
			this._pingPongRenderTarget = _createRenderTarget(width, height, params);
			const { _lodMax } = this;
			({lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas} = _createPlanes(_lodMax));
			this._blurMaterial = _getBlurShader(_lodMax, width, height);
			this._ggxMaterial = _getGGXShader(_lodMax, width, height);
		}
		return cubeUVRenderTarget;
	}
	_compileMaterial(material) {
		const mesh = new Mesh(new BufferGeometry(), material);
		this._renderer.compile(mesh, _flatCamera);
	}
	_sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position) {
		const cubeCamera = new PerspectiveCamera(90, 1, near, far);
		const upSign = [
			1,
			-1,
			1,
			1,
			1,
			1
		];
		const forwardSign = [
			1,
			1,
			1,
			-1,
			-1,
			-1
		];
		const renderer = this._renderer;
		const originalAutoClear = renderer.autoClear;
		const toneMapping$2 = renderer.toneMapping;
		renderer.getClearColor(_clearColor);
		renderer.toneMapping = NoToneMapping;
		renderer.autoClear = false;
		if (renderer.state.buffers.depth.getReversed()) {
			renderer.setRenderTarget(cubeUVRenderTarget);
			renderer.clearDepth();
			renderer.setRenderTarget(null);
		}
		if (this._backgroundBox === null) this._backgroundBox = new Mesh(new BoxGeometry(), new MeshBasicMaterial({
			name: "PMREM.Background",
			side: BackSide,
			depthWrite: false,
			depthTest: false
		}));
		const backgroundBox = this._backgroundBox;
		const backgroundMaterial = backgroundBox.material;
		let useSolidColor = false;
		const background = scene.background;
		if (background) {
			if (background.isColor) {
				backgroundMaterial.color.copy(background);
				scene.background = null;
				useSolidColor = true;
			}
		} else {
			backgroundMaterial.color.copy(_clearColor);
			useSolidColor = true;
		}
		for (let i = 0; i < 6; i++) {
			const col = i % 3;
			if (col === 0) {
				cubeCamera.up.set(0, upSign[i], 0);
				cubeCamera.position.set(position.x, position.y, position.z);
				cubeCamera.lookAt(position.x + forwardSign[i], position.y, position.z);
			} else if (col === 1) {
				cubeCamera.up.set(0, 0, upSign[i]);
				cubeCamera.position.set(position.x, position.y, position.z);
				cubeCamera.lookAt(position.x, position.y + forwardSign[i], position.z);
			} else {
				cubeCamera.up.set(0, upSign[i], 0);
				cubeCamera.position.set(position.x, position.y, position.z);
				cubeCamera.lookAt(position.x, position.y, position.z + forwardSign[i]);
			}
			const size = this._cubeSize;
			_setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
			renderer.setRenderTarget(cubeUVRenderTarget);
			if (useSolidColor) renderer.render(backgroundBox, cubeCamera);
			renderer.render(scene, cubeCamera);
		}
		renderer.toneMapping = toneMapping$2;
		renderer.autoClear = originalAutoClear;
		scene.background = background;
	}
	_textureToCubeUV(texture$2, cubeUVRenderTarget) {
		const renderer = this._renderer;
		const isCubeTexture = texture$2.mapping === CubeReflectionMapping || texture$2.mapping === CubeRefractionMapping;
		if (isCubeTexture) {
			if (this._cubemapMaterial === null) this._cubemapMaterial = _getCubemapMaterial();
			this._cubemapMaterial.uniforms.flipEnvMap.value = texture$2.isRenderTargetTexture === false ? -1 : 1;
		} else if (this._equirectMaterial === null) this._equirectMaterial = _getEquirectMaterial();
		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		const mesh = this._lodMeshes[0];
		mesh.material = material;
		const uniforms = material.uniforms;
		uniforms["envMap"].value = texture$2;
		const size = this._cubeSize;
		_setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
		renderer.setRenderTarget(cubeUVRenderTarget);
		renderer.render(mesh, _flatCamera);
	}
	_applyPMREM(cubeUVRenderTarget) {
		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;
		const n$2 = this._lodMeshes.length;
		for (let i = 1; i < n$2; i++) this._applyGGXFilter(cubeUVRenderTarget, i - 1, i);
		renderer.autoClear = autoClear;
	}
	/**
	* Applies GGX VNDF importance sampling filter to generate a prefiltered environment map.
	* Uses Monte Carlo integration with VNDF importance sampling to accurately represent the
	* GGX BRDF for physically-based rendering. Reads from the previous LOD level and
	* applies incremental roughness filtering to avoid over-blurring.
	*
	* @private
	* @param {WebGLRenderTarget} cubeUVRenderTarget
	* @param {number} lodIn - Source LOD level to read from
	* @param {number} lodOut - Target LOD level to write to
	*/
	_applyGGXFilter(cubeUVRenderTarget, lodIn, lodOut) {
		const renderer = this._renderer;
		const pingPongRenderTarget = this._pingPongRenderTarget;
		const ggxMaterial = this._ggxMaterial;
		const ggxMesh = this._lodMeshes[lodOut];
		ggxMesh.material = ggxMaterial;
		const ggxUniforms = ggxMaterial.uniforms;
		const targetRoughness = lodOut / (this._lodMeshes.length - 1);
		const sourceRoughness = lodIn / (this._lodMeshes.length - 1);
		const incrementalRoughness = Math.sqrt(targetRoughness * targetRoughness - sourceRoughness * sourceRoughness);
		const blurStrength = .05 + targetRoughness * .95;
		const adjustedRoughness = incrementalRoughness * blurStrength;
		const { _lodMax } = this;
		const outputSize = this._sizeLods[lodOut];
		const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
		const y = 4 * (this._cubeSize - outputSize);
		ggxUniforms["envMap"].value = cubeUVRenderTarget.texture;
		ggxUniforms["roughness"].value = adjustedRoughness;
		ggxUniforms["mipInt"].value = _lodMax - lodIn;
		_setViewport(pingPongRenderTarget, x, y, 3 * outputSize, 2 * outputSize);
		renderer.setRenderTarget(pingPongRenderTarget);
		renderer.render(ggxMesh, _flatCamera);
		ggxUniforms["envMap"].value = pingPongRenderTarget.texture;
		ggxUniforms["roughness"].value = 0;
		ggxUniforms["mipInt"].value = _lodMax - lodOut;
		_setViewport(cubeUVRenderTarget, x, y, 3 * outputSize, 2 * outputSize);
		renderer.setRenderTarget(cubeUVRenderTarget);
		renderer.render(ggxMesh, _flatCamera);
	}
	/**
	* This is a two-pass Gaussian blur for a cubemap. Normally this is done
	* vertically and horizontally, but this breaks down on a cube. Here we apply
	* the blur latitudinally (around the poles), and then longitudinally (towards
	* the poles) to approximate the orthogonally-separable blur. It is least
	* accurate at the poles, but still does a decent job.
	*
	* Used for initial scene blur in fromScene() method when sigma > 0.
	*
	* @private
	* @param {WebGLRenderTarget} cubeUVRenderTarget
	* @param {number} lodIn
	* @param {number} lodOut
	* @param {number} sigma
	* @param {Vector3} [poleAxis]
	*/
	_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
		const pingPongRenderTarget = this._pingPongRenderTarget;
		this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
		this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
	}
	_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;
		if (direction !== "latitudinal" && direction !== "longitudinal") error("blur direction must be either latitudinal or longitudinal!");
		const STANDARD_DEVIATIONS = 3;
		const blurMesh = this._lodMeshes[lodOut];
		blurMesh.material = blurMaterial;
		const blurUniforms = blurMaterial.uniforms;
		const pixels = this._sizeLods[lodIn] - 1;
		const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
		if (samples > MAX_SAMPLES) warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
		const weights = [];
		let sum = 0;
		for (let i = 0; i < MAX_SAMPLES; ++i) {
			const x$1 = i / sigmaPixels;
			const weight = Math.exp(-x$1 * x$1 / 2);
			weights.push(weight);
			if (i === 0) sum += weight;
			else if (i < samples) sum += 2 * weight;
		}
		for (let i = 0; i < weights.length; i++) weights[i] = weights[i] / sum;
		blurUniforms["envMap"].value = targetIn.texture;
		blurUniforms["samples"].value = samples;
		blurUniforms["weights"].value = weights;
		blurUniforms["latitudinal"].value = direction === "latitudinal";
		if (poleAxis) blurUniforms["poleAxis"].value = poleAxis;
		const { _lodMax } = this;
		blurUniforms["dTheta"].value = radiansPerPixel;
		blurUniforms["mipInt"].value = _lodMax - lodIn;
		const outputSize = this._sizeLods[lodOut];
		const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
		const y = 4 * (this._cubeSize - outputSize);
		_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
		renderer.setRenderTarget(targetOut);
		renderer.render(blurMesh, _flatCamera);
	}
};
function _createPlanes(lodMax) {
	const sizeLods = [];
	const sigmas = [];
	const lodMeshes = [];
	let lod = lodMax;
	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
	for (let i = 0; i < totalLods; i++) {
		const sizeLod = Math.pow(2, lod);
		sizeLods.push(sizeLod);
		let sigma = 1 / sizeLod;
		if (i > lodMax - LOD_MIN) sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
		else if (i === 0) sigma = 0;
		sigmas.push(sigma);
		const texelSize = 1 / (sizeLod - 2);
		const min$3 = -texelSize;
		const max$3 = 1 + texelSize;
		const uv1 = [
			min$3,
			min$3,
			max$3,
			min$3,
			max$3,
			max$3,
			min$3,
			min$3,
			max$3,
			max$3,
			min$3,
			max$3
		];
		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;
		const position = new Float32Array(positionSize * vertices * cubeFaces);
		const uv$3 = new Float32Array(uvSize * vertices * cubeFaces);
		const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
		for (let face = 0; face < cubeFaces; face++) {
			const x = face % 3 * 2 / 3 - 1;
			const y = face > 2 ? 0 : -1;
			const coordinates = [
				x,
				y,
				0,
				x + 2 / 3,
				y,
				0,
				x + 2 / 3,
				y + 1,
				0,
				x,
				y,
				0,
				x + 2 / 3,
				y + 1,
				0,
				x,
				y + 1,
				0
			];
			position.set(coordinates, positionSize * vertices * face);
			uv$3.set(uv1, uvSize * vertices * face);
			const fill = [
				face,
				face,
				face,
				face,
				face,
				face
			];
			faceIndex.set(fill, faceIndexSize * vertices * face);
		}
		const planes = new BufferGeometry();
		planes.setAttribute("position", new BufferAttribute(position, positionSize));
		planes.setAttribute("uv", new BufferAttribute(uv$3, uvSize));
		planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
		lodMeshes.push(new Mesh(planes, null));
		if (lod > LOD_MIN) lod--;
	}
	return {
		lodMeshes,
		sizeLods,
		sigmas
	};
}
function _createRenderTarget(width, height, params) {
	const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
	target.viewport.set(x, y, width, height);
	target.scissor.set(x, y, width, height);
}
function _getGGXShader(lodMax, width, height) {
	return new ShaderMaterial({
		name: "PMREMGGXConvolution",
		defines: {
			"GGX_SAMPLES": GGX_SAMPLES,
			"CUBEUV_TEXEL_WIDTH": 1 / width,
			"CUBEUV_TEXEL_HEIGHT": 1 / height,
			"CUBEUV_MAX_MIP": `${lodMax}.0`
		},
		uniforms: {
			"envMap": { value: null },
			"roughness": { value: 0 },
			"mipInt": { value: 0 }
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: `

			precision highp float;
			precision highp int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,
		blending: NoBlending,
		depthTest: false,
		depthWrite: false
	});
}
function _getBlurShader(lodMax, width, height) {
	const weights = new Float32Array(MAX_SAMPLES);
	const poleAxis = new Vector3(0, 1, 0);
	return new ShaderMaterial({
		name: "SphericalGaussianBlur",
		defines: {
			"n": MAX_SAMPLES,
			"CUBEUV_TEXEL_WIDTH": 1 / width,
			"CUBEUV_TEXEL_HEIGHT": 1 / height,
			"CUBEUV_MAX_MIP": `${lodMax}.0`
		},
		uniforms: {
			"envMap": { value: null },
			"samples": { value: 1 },
			"weights": { value: weights },
			"latitudinal": { value: false },
			"dTheta": { value: 0 },
			"mipInt": { value: 0 },
			"poleAxis": { value: poleAxis }
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
		blending: NoBlending,
		depthTest: false,
		depthWrite: false
	});
}
function _getEquirectMaterial() {
	return new ShaderMaterial({
		name: "EquirectangularToCubeUV",
		uniforms: { "envMap": { value: null } },
		vertexShader: _getCommonVertexShader(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
		blending: NoBlending,
		depthTest: false,
		depthWrite: false
	});
}
function _getCubemapMaterial() {
	return new ShaderMaterial({
		name: "CubemapToCubeUV",
		uniforms: {
			"envMap": { value: null },
			"flipEnvMap": { value: -1 }
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
		blending: NoBlending,
		depthTest: false,
		depthWrite: false
	});
}
function _getCommonVertexShader() {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function WebGLCubeUVMaps(renderer) {
	let cubeUVmaps = /* @__PURE__ */ new WeakMap();
	let pmremGenerator = null;
	function get$1(texture$2) {
		if (texture$2 && texture$2.isTexture) {
			const mapping = texture$2.mapping;
			const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
			const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
			if (isEquirectMap || isCubeMap) {
				let renderTarget = cubeUVmaps.get(texture$2);
				const currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;
				if (texture$2.isRenderTargetTexture && texture$2.pmremVersion !== currentPMREMVersion) {
					if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture$2, renderTarget) : pmremGenerator.fromCubemap(texture$2, renderTarget);
					renderTarget.texture.pmremVersion = texture$2.pmremVersion;
					cubeUVmaps.set(texture$2, renderTarget);
					return renderTarget.texture;
				} else if (renderTarget !== void 0) return renderTarget.texture;
				else {
					const image = texture$2.image;
					if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
						if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
						renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture$2) : pmremGenerator.fromCubemap(texture$2);
						renderTarget.texture.pmremVersion = texture$2.pmremVersion;
						cubeUVmaps.set(texture$2, renderTarget);
						texture$2.addEventListener("dispose", onTextureDispose$1);
						return renderTarget.texture;
					} else return null;
				}
			}
		}
		return texture$2;
	}
	function isCubeTextureComplete(image) {
		let count = 0;
		const length$2 = 6;
		for (let i = 0; i < length$2; i++) if (image[i] !== void 0) count++;
		return count === length$2;
	}
	function onTextureDispose$1(event) {
		const texture$2 = event.target;
		texture$2.removeEventListener("dispose", onTextureDispose$1);
		const cubemapUV = cubeUVmaps.get(texture$2);
		if (cubemapUV !== void 0) {
			cubeUVmaps.delete(texture$2);
			cubemapUV.dispose();
		}
	}
	function dispose() {
		cubeUVmaps = /* @__PURE__ */ new WeakMap();
		if (pmremGenerator !== null) {
			pmremGenerator.dispose();
			pmremGenerator = null;
		}
	}
	return {
		get: get$1,
		dispose
	};
}
function WebGLExtensions(gl) {
	const extensions = {};
	function getExtension(name) {
		if (extensions[name] !== void 0) return extensions[name];
		const extension = gl.getExtension(name);
		extensions[name] = extension;
		return extension;
	}
	return {
		has: function(name) {
			return getExtension(name) !== null;
		},
		init: function() {
			getExtension("EXT_color_buffer_float");
			getExtension("WEBGL_clip_cull_distance");
			getExtension("OES_texture_float_linear");
			getExtension("EXT_color_buffer_half_float");
			getExtension("WEBGL_multisampled_render_to_texture");
			getExtension("WEBGL_render_shared_exponent");
		},
		get: function(name) {
			const extension = getExtension(name);
			if (extension === null) warnOnce("WebGLRenderer: " + name + " extension not supported.");
			return extension;
		}
	};
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
	const geometries = {};
	const wireframeAttributes = /* @__PURE__ */ new WeakMap();
	function onGeometryDispose(event) {
		const geometry = event.target;
		if (geometry.index !== null) attributes.remove(geometry.index);
		for (const name in geometry.attributes) attributes.remove(geometry.attributes[name]);
		geometry.removeEventListener("dispose", onGeometryDispose);
		delete geometries[geometry.id];
		const attribute$2 = wireframeAttributes.get(geometry);
		if (attribute$2) {
			attributes.remove(attribute$2);
			wireframeAttributes.delete(geometry);
		}
		bindingStates.releaseStatesOfGeometry(geometry);
		if (geometry.isInstancedBufferGeometry === true) delete geometry._maxInstanceCount;
		info.memory.geometries--;
	}
	function get$1(object, geometry) {
		if (geometries[geometry.id] === true) return geometry;
		geometry.addEventListener("dispose", onGeometryDispose);
		geometries[geometry.id] = true;
		info.memory.geometries++;
		return geometry;
	}
	function update(geometry) {
		const geometryAttributes = geometry.attributes;
		for (const name in geometryAttributes) attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
	}
	function updateWireframeAttribute(geometry) {
		const indices = [];
		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;
		if (geometryIndex !== null) {
			const array$2 = geometryIndex.array;
			version = geometryIndex.version;
			for (let i = 0, l = array$2.length; i < l; i += 3) {
				const a$1 = array$2[i + 0];
				const b$2 = array$2[i + 1];
				const c$1 = array$2[i + 2];
				indices.push(a$1, b$2, b$2, c$1, c$1, a$1);
			}
		} else if (geometryPosition !== void 0) {
			const array$2 = geometryPosition.array;
			version = geometryPosition.version;
			for (let i = 0, l = array$2.length / 3 - 1; i < l; i += 3) {
				const a$1 = i + 0;
				const b$2 = i + 1;
				const c$1 = i + 2;
				indices.push(a$1, b$2, b$2, c$1, c$1, a$1);
			}
		} else return;
		const attribute$2 = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
		attribute$2.version = version;
		const previousAttribute = wireframeAttributes.get(geometry);
		if (previousAttribute) attributes.remove(previousAttribute);
		wireframeAttributes.set(geometry, attribute$2);
	}
	function getWireframeAttribute(geometry) {
		const currentAttribute = wireframeAttributes.get(geometry);
		if (currentAttribute) {
			const geometryIndex = geometry.index;
			if (geometryIndex !== null) {
				if (currentAttribute.version < geometryIndex.version) updateWireframeAttribute(geometry);
			}
		} else updateWireframeAttribute(geometry);
		return wireframeAttributes.get(geometry);
	}
	return {
		get: get$1,
		update,
		getWireframeAttribute
	};
}
function WebGLIndexedBufferRenderer(gl, extensions, info) {
	let mode;
	function setMode(value) {
		mode = value;
	}
	let type$1, bytesPerElement;
	function setIndex(value) {
		type$1 = value.type;
		bytesPerElement = value.bytesPerElement;
	}
	function render(start, count) {
		gl.drawElements(mode, count, type$1, start * bytesPerElement);
		info.update(count, mode, 1);
	}
	function renderInstances(start, count, primcount) {
		if (primcount === 0) return;
		gl.drawElementsInstanced(mode, count, type$1, start * bytesPerElement, primcount);
		info.update(count, mode, primcount);
	}
	function renderMultiDraw(starts, counts, drawCount) {
		if (drawCount === 0) return;
		extensions.get("WEBGL_multi_draw").multiDrawElementsWEBGL(mode, counts, 0, type$1, starts, 0, drawCount);
		let elementCount = 0;
		for (let i = 0; i < drawCount; i++) elementCount += counts[i];
		info.update(elementCount, mode, 1);
	}
	function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
		if (drawCount === 0) return;
		const extension = extensions.get("WEBGL_multi_draw");
		if (extension === null) for (let i = 0; i < starts.length; i++) renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i]);
		else {
			extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type$1, starts, 0, primcount, 0, drawCount);
			let elementCount = 0;
			for (let i = 0; i < drawCount; i++) elementCount += counts[i] * primcount[i];
			info.update(elementCount, mode, 1);
		}
	}
	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;
	this.renderMultiDraw = renderMultiDraw;
	this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLInfo(gl) {
	const memory = {
		geometries: 0,
		textures: 0
	};
	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};
	function update(count, mode, instanceCount) {
		render.calls++;
		switch (mode) {
			case gl.TRIANGLES:
				render.triangles += instanceCount * (count / 3);
				break;
			case gl.LINES:
				render.lines += instanceCount * (count / 2);
				break;
			case gl.LINE_STRIP:
				render.lines += instanceCount * (count - 1);
				break;
			case gl.LINE_LOOP:
				render.lines += instanceCount * count;
				break;
			case gl.POINTS:
				render.points += instanceCount * count;
				break;
			default:
				error("WebGLInfo: Unknown draw mode:", mode);
				break;
		}
	}
	function reset() {
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;
	}
	return {
		memory,
		render,
		programs: null,
		autoReset: true,
		reset,
		update
	};
}
function WebGLMorphtargets(gl, capabilities, textures) {
	const morphTextures = /* @__PURE__ */ new WeakMap();
	const morph = new Vector4();
	function update(object, geometry, program) {
		const objectInfluences = object.morphTargetInfluences;
		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
		let entry = morphTextures.get(geometry);
		if (entry === void 0 || entry.count !== morphTargetsCount) {
			if (entry !== void 0) entry.texture.dispose();
			const hasMorphPosition = geometry.morphAttributes.position !== void 0;
			const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
			const hasMorphColors = geometry.morphAttributes.color !== void 0;
			const morphTargets = geometry.morphAttributes.position || [];
			const morphNormals = geometry.morphAttributes.normal || [];
			const morphColors = geometry.morphAttributes.color || [];
			let vertexDataCount = 0;
			if (hasMorphPosition === true) vertexDataCount = 1;
			if (hasMorphNormals === true) vertexDataCount = 2;
			if (hasMorphColors === true) vertexDataCount = 3;
			let width = geometry.attributes.position.count * vertexDataCount;
			let height = 1;
			if (width > capabilities.maxTextureSize) {
				height = Math.ceil(width / capabilities.maxTextureSize);
				width = capabilities.maxTextureSize;
			}
			const buffer$2 = new Float32Array(width * height * 4 * morphTargetsCount);
			const texture$2 = new DataArrayTexture(buffer$2, width, height, morphTargetsCount);
			texture$2.type = FloatType;
			texture$2.needsUpdate = true;
			const vertexDataStride = vertexDataCount * 4;
			for (let i = 0; i < morphTargetsCount; i++) {
				const morphTarget = morphTargets[i];
				const morphNormal = morphNormals[i];
				const morphColor = morphColors[i];
				const offset = width * height * 4 * i;
				for (let j = 0; j < morphTarget.count; j++) {
					const stride = j * vertexDataStride;
					if (hasMorphPosition === true) {
						morph.fromBufferAttribute(morphTarget, j);
						buffer$2[offset + stride + 0] = morph.x;
						buffer$2[offset + stride + 1] = morph.y;
						buffer$2[offset + stride + 2] = morph.z;
						buffer$2[offset + stride + 3] = 0;
					}
					if (hasMorphNormals === true) {
						morph.fromBufferAttribute(morphNormal, j);
						buffer$2[offset + stride + 4] = morph.x;
						buffer$2[offset + stride + 5] = morph.y;
						buffer$2[offset + stride + 6] = morph.z;
						buffer$2[offset + stride + 7] = 0;
					}
					if (hasMorphColors === true) {
						morph.fromBufferAttribute(morphColor, j);
						buffer$2[offset + stride + 8] = morph.x;
						buffer$2[offset + stride + 9] = morph.y;
						buffer$2[offset + stride + 10] = morph.z;
						buffer$2[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
					}
				}
			}
			entry = {
				count: morphTargetsCount,
				texture: texture$2,
				size: new Vector2(width, height)
			};
			morphTextures.set(geometry, entry);
			function disposeTexture() {
				texture$2.dispose();
				morphTextures.delete(geometry);
				geometry.removeEventListener("dispose", disposeTexture);
			}
			geometry.addEventListener("dispose", disposeTexture);
		}
		if (object.isInstancedMesh === true && object.morphTexture !== null) program.getUniforms().setValue(gl, "morphTexture", object.morphTexture, textures);
		else {
			let morphInfluencesSum = 0;
			for (let i = 0; i < objectInfluences.length; i++) morphInfluencesSum += objectInfluences[i];
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
			program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
			program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
		}
		program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
		program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
	}
	return { update };
}
function WebGLObjects(gl, geometries, attributes, info) {
	let updateMap = /* @__PURE__ */ new WeakMap();
	function update(object) {
		const frame = info.render.frame;
		const geometry = object.geometry;
		const buffergeometry = geometries.get(object, geometry);
		if (updateMap.get(buffergeometry) !== frame) {
			geometries.update(buffergeometry);
			updateMap.set(buffergeometry, frame);
		}
		if (object.isInstancedMesh) {
			if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) object.addEventListener("dispose", onInstancedMeshDispose);
			if (updateMap.get(object) !== frame) {
				attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
				if (object.instanceColor !== null) attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
				updateMap.set(object, frame);
			}
		}
		if (object.isSkinnedMesh) {
			const skeleton = object.skeleton;
			if (updateMap.get(skeleton) !== frame) {
				skeleton.update();
				updateMap.set(skeleton, frame);
			}
		}
		return buffergeometry;
	}
	function dispose() {
		updateMap = /* @__PURE__ */ new WeakMap();
	}
	function onInstancedMeshDispose(event) {
		const instancedMesh$2 = event.target;
		instancedMesh$2.removeEventListener("dispose", onInstancedMeshDispose);
		attributes.remove(instancedMesh$2.instanceMatrix);
		if (instancedMesh$2.instanceColor !== null) attributes.remove(instancedMesh$2.instanceColor);
	}
	return {
		update,
		dispose
	};
}
/**
* Uniforms of a program.
* Those form a tree structure with a special top-level container for the root,
* which you get by calling 'new WebGLUniforms( gl, program )'.
*
*
* Properties of inner nodes including the top-level container:
*
* .seq - array of nested uniforms
* .map - nested uniforms by name
*
*
* Methods of all nodes except the top-level container:
*
* .setValue( gl, value, [textures] )
*
* 		uploads a uniform value(s)
*  	the 'textures' parameter is needed for sampler uniforms
*
*
* Static methods of the top-level container (textures factorizations):
*
* .upload( gl, seq, values, textures )
*
* 		sets uniforms in 'seq' to 'values[id].value'
*
* .seqWithValue( seq, values ) : filteredSeq
*
* 		filters 'seq' entries with corresponding entry in values
*
*
* Methods of the top-level container (textures factorizations):
*
* .setValue( gl, name, value, textures )
*
* 		sets uniform with  name 'name' to 'value'
*
* .setOptional( gl, obj, prop )
*
* 		like .set for an optional property of the object
*
*/
var emptyTexture = /* @__PURE__ */ new Texture();
var emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
var emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
var empty3dTexture = /* @__PURE__ */ new Data3DTexture();
var emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array$2, nBlocks, blockSize) {
	const firstElem = array$2[0];
	if (firstElem <= 0 || firstElem > 0) return array$2;
	const n$2 = nBlocks * blockSize;
	let r = arrayCacheF32[n$2];
	if (r === void 0) {
		r = new Float32Array(n$2);
		arrayCacheF32[n$2] = r;
	}
	if (nBlocks !== 0) {
		firstElem.toArray(r, 0);
		for (let i = 1, offset = 0; i !== nBlocks; ++i) {
			offset += blockSize;
			array$2[i].toArray(r, offset);
		}
	}
	return r;
}
function arraysEqual(a$1, b$2) {
	if (a$1.length !== b$2.length) return false;
	for (let i = 0, l = a$1.length; i < l; i++) if (a$1[i] !== b$2[i]) return false;
	return true;
}
function copyArray(a$1, b$2) {
	for (let i = 0, l = b$2.length; i < l; i++) a$1[i] = b$2[i];
}
function allocTexUnits(textures, n$2) {
	let r = arrayCacheI32[n$2];
	if (r === void 0) {
		r = new Int32Array(n$2);
		arrayCacheI32[n$2] = r;
	}
	for (let i = 0; i !== n$2; ++i) r[i] = textures.allocateTextureUnit();
	return r;
}
function setValueV1f(gl, v) {
	const cache$2 = this.cache;
	if (cache$2[0] === v) return;
	gl.uniform1f(this.addr, v);
	cache$2[0] = v;
}
function setValueV2f(gl, v) {
	const cache$2 = this.cache;
	if (v.x !== void 0) {
		if (cache$2[0] !== v.x || cache$2[1] !== v.y) {
			gl.uniform2f(this.addr, v.x, v.y);
			cache$2[0] = v.x;
			cache$2[1] = v.y;
		}
	} else {
		if (arraysEqual(cache$2, v)) return;
		gl.uniform2fv(this.addr, v);
		copyArray(cache$2, v);
	}
}
function setValueV3f(gl, v) {
	const cache$2 = this.cache;
	if (v.x !== void 0) {
		if (cache$2[0] !== v.x || cache$2[1] !== v.y || cache$2[2] !== v.z) {
			gl.uniform3f(this.addr, v.x, v.y, v.z);
			cache$2[0] = v.x;
			cache$2[1] = v.y;
			cache$2[2] = v.z;
		}
	} else if (v.r !== void 0) {
		if (cache$2[0] !== v.r || cache$2[1] !== v.g || cache$2[2] !== v.b) {
			gl.uniform3f(this.addr, v.r, v.g, v.b);
			cache$2[0] = v.r;
			cache$2[1] = v.g;
			cache$2[2] = v.b;
		}
	} else {
		if (arraysEqual(cache$2, v)) return;
		gl.uniform3fv(this.addr, v);
		copyArray(cache$2, v);
	}
}
function setValueV4f(gl, v) {
	const cache$2 = this.cache;
	if (v.x !== void 0) {
		if (cache$2[0] !== v.x || cache$2[1] !== v.y || cache$2[2] !== v.z || cache$2[3] !== v.w) {
			gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
			cache$2[0] = v.x;
			cache$2[1] = v.y;
			cache$2[2] = v.z;
			cache$2[3] = v.w;
		}
	} else {
		if (arraysEqual(cache$2, v)) return;
		gl.uniform4fv(this.addr, v);
		copyArray(cache$2, v);
	}
}
function setValueM2(gl, v) {
	const cache$2 = this.cache;
	const elements = v.elements;
	if (elements === void 0) {
		if (arraysEqual(cache$2, v)) return;
		gl.uniformMatrix2fv(this.addr, false, v);
		copyArray(cache$2, v);
	} else {
		if (arraysEqual(cache$2, elements)) return;
		mat2array.set(elements);
		gl.uniformMatrix2fv(this.addr, false, mat2array);
		copyArray(cache$2, elements);
	}
}
function setValueM3(gl, v) {
	const cache$2 = this.cache;
	const elements = v.elements;
	if (elements === void 0) {
		if (arraysEqual(cache$2, v)) return;
		gl.uniformMatrix3fv(this.addr, false, v);
		copyArray(cache$2, v);
	} else {
		if (arraysEqual(cache$2, elements)) return;
		mat3array.set(elements);
		gl.uniformMatrix3fv(this.addr, false, mat3array);
		copyArray(cache$2, elements);
	}
}
function setValueM4(gl, v) {
	const cache$2 = this.cache;
	const elements = v.elements;
	if (elements === void 0) {
		if (arraysEqual(cache$2, v)) return;
		gl.uniformMatrix4fv(this.addr, false, v);
		copyArray(cache$2, v);
	} else {
		if (arraysEqual(cache$2, elements)) return;
		mat4array.set(elements);
		gl.uniformMatrix4fv(this.addr, false, mat4array);
		copyArray(cache$2, elements);
	}
}
function setValueV1i(gl, v) {
	const cache$2 = this.cache;
	if (cache$2[0] === v) return;
	gl.uniform1i(this.addr, v);
	cache$2[0] = v;
}
function setValueV2i(gl, v) {
	const cache$2 = this.cache;
	if (v.x !== void 0) {
		if (cache$2[0] !== v.x || cache$2[1] !== v.y) {
			gl.uniform2i(this.addr, v.x, v.y);
			cache$2[0] = v.x;
			cache$2[1] = v.y;
		}
	} else {
		if (arraysEqual(cache$2, v)) return;
		gl.uniform2iv(this.addr, v);
		copyArray(cache$2, v);
	}
}
function setValueV3i(gl, v) {
	const cache$2 = this.cache;
	if (v.x !== void 0) {
		if (cache$2[0] !== v.x || cache$2[1] !== v.y || cache$2[2] !== v.z) {
			gl.uniform3i(this.addr, v.x, v.y, v.z);
			cache$2[0] = v.x;
			cache$2[1] = v.y;
			cache$2[2] = v.z;
		}
	} else {
		if (arraysEqual(cache$2, v)) return;
		gl.uniform3iv(this.addr, v);
		copyArray(cache$2, v);
	}
}
function setValueV4i(gl, v) {
	const cache$2 = this.cache;
	if (v.x !== void 0) {
		if (cache$2[0] !== v.x || cache$2[1] !== v.y || cache$2[2] !== v.z || cache$2[3] !== v.w) {
			gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
			cache$2[0] = v.x;
			cache$2[1] = v.y;
			cache$2[2] = v.z;
			cache$2[3] = v.w;
		}
	} else {
		if (arraysEqual(cache$2, v)) return;
		gl.uniform4iv(this.addr, v);
		copyArray(cache$2, v);
	}
}
function setValueV1ui(gl, v) {
	const cache$2 = this.cache;
	if (cache$2[0] === v) return;
	gl.uniform1ui(this.addr, v);
	cache$2[0] = v;
}
function setValueV2ui(gl, v) {
	const cache$2 = this.cache;
	if (v.x !== void 0) {
		if (cache$2[0] !== v.x || cache$2[1] !== v.y) {
			gl.uniform2ui(this.addr, v.x, v.y);
			cache$2[0] = v.x;
			cache$2[1] = v.y;
		}
	} else {
		if (arraysEqual(cache$2, v)) return;
		gl.uniform2uiv(this.addr, v);
		copyArray(cache$2, v);
	}
}
function setValueV3ui(gl, v) {
	const cache$2 = this.cache;
	if (v.x !== void 0) {
		if (cache$2[0] !== v.x || cache$2[1] !== v.y || cache$2[2] !== v.z) {
			gl.uniform3ui(this.addr, v.x, v.y, v.z);
			cache$2[0] = v.x;
			cache$2[1] = v.y;
			cache$2[2] = v.z;
		}
	} else {
		if (arraysEqual(cache$2, v)) return;
		gl.uniform3uiv(this.addr, v);
		copyArray(cache$2, v);
	}
}
function setValueV4ui(gl, v) {
	const cache$2 = this.cache;
	if (v.x !== void 0) {
		if (cache$2[0] !== v.x || cache$2[1] !== v.y || cache$2[2] !== v.z || cache$2[3] !== v.w) {
			gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
			cache$2[0] = v.x;
			cache$2[1] = v.y;
			cache$2[2] = v.z;
			cache$2[3] = v.w;
		}
	} else {
		if (arraysEqual(cache$2, v)) return;
		gl.uniform4uiv(this.addr, v);
		copyArray(cache$2, v);
	}
}
function setValueT1(gl, v, textures) {
	const cache$2 = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache$2[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache$2[0] = unit;
	}
	let emptyTexture2D;
	if (this.type === gl.SAMPLER_2D_SHADOW) {
		emptyShadowTexture.compareFunction = LessEqualCompare;
		emptyTexture2D = emptyShadowTexture;
	} else emptyTexture2D = emptyTexture;
	textures.setTexture2D(v || emptyTexture2D, unit);
}
function setValueT3D1(gl, v, textures) {
	const cache$2 = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache$2[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache$2[0] = unit;
	}
	textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
	const cache$2 = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache$2[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache$2[0] = unit;
	}
	textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
	const cache$2 = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache$2[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache$2[0] = unit;
	}
	textures.setTexture2DArray(v || emptyArrayTexture, unit);
}
function getSingularSetter(type$1) {
	switch (type$1) {
		case 5126: return setValueV1f;
		case 35664: return setValueV2f;
		case 35665: return setValueV3f;
		case 35666: return setValueV4f;
		case 35674: return setValueM2;
		case 35675: return setValueM3;
		case 35676: return setValueM4;
		case 5124:
		case 35670: return setValueV1i;
		case 35667:
		case 35671: return setValueV2i;
		case 35668:
		case 35672: return setValueV3i;
		case 35669:
		case 35673: return setValueV4i;
		case 5125: return setValueV1ui;
		case 36294: return setValueV2ui;
		case 36295: return setValueV3ui;
		case 36296: return setValueV4ui;
		case 35678:
		case 36198:
		case 36298:
		case 36306:
		case 35682: return setValueT1;
		case 35679:
		case 36299:
		case 36307: return setValueT3D1;
		case 35680:
		case 36300:
		case 36308:
		case 36293: return setValueT6;
		case 36289:
		case 36303:
		case 36311:
		case 36292: return setValueT2DArray1;
	}
}
function setValueV1fArray(gl, v) {
	gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
	const data = flatten(v, this.size, 2);
	gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
	const data = flatten(v, this.size, 3);
	gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
	const data = flatten(v, this.size, 4);
	gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
	const data = flatten(v, this.size, 4);
	gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
	const data = flatten(v, this.size, 9);
	gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
	const data = flatten(v, this.size, 16);
	gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
	gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
	gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
	gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
	gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
	gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
	gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
	gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
	gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
	const cache$2 = this.cache;
	const n$2 = v.length;
	const units = allocTexUnits(textures, n$2);
	if (!arraysEqual(cache$2, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache$2, units);
	}
	for (let i = 0; i !== n$2; ++i) textures.setTexture2D(v[i] || emptyTexture, units[i]);
}
function setValueT3DArray(gl, v, textures) {
	const cache$2 = this.cache;
	const n$2 = v.length;
	const units = allocTexUnits(textures, n$2);
	if (!arraysEqual(cache$2, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache$2, units);
	}
	for (let i = 0; i !== n$2; ++i) textures.setTexture3D(v[i] || empty3dTexture, units[i]);
}
function setValueT6Array(gl, v, textures) {
	const cache$2 = this.cache;
	const n$2 = v.length;
	const units = allocTexUnits(textures, n$2);
	if (!arraysEqual(cache$2, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache$2, units);
	}
	for (let i = 0; i !== n$2; ++i) textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
}
function setValueT2DArrayArray(gl, v, textures) {
	const cache$2 = this.cache;
	const n$2 = v.length;
	const units = allocTexUnits(textures, n$2);
	if (!arraysEqual(cache$2, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache$2, units);
	}
	for (let i = 0; i !== n$2; ++i) textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
}
function getPureArraySetter(type$1) {
	switch (type$1) {
		case 5126: return setValueV1fArray;
		case 35664: return setValueV2fArray;
		case 35665: return setValueV3fArray;
		case 35666: return setValueV4fArray;
		case 35674: return setValueM2Array;
		case 35675: return setValueM3Array;
		case 35676: return setValueM4Array;
		case 5124:
		case 35670: return setValueV1iArray;
		case 35667:
		case 35671: return setValueV2iArray;
		case 35668:
		case 35672: return setValueV3iArray;
		case 35669:
		case 35673: return setValueV4iArray;
		case 5125: return setValueV1uiArray;
		case 36294: return setValueV2uiArray;
		case 36295: return setValueV3uiArray;
		case 36296: return setValueV4uiArray;
		case 35678:
		case 36198:
		case 36298:
		case 36306:
		case 35682: return setValueT1Array;
		case 35679:
		case 36299:
		case 36307: return setValueT3DArray;
		case 35680:
		case 36300:
		case 36308:
		case 36293: return setValueT6Array;
		case 36289:
		case 36303:
		case 36311:
		case 36292: return setValueT2DArrayArray;
	}
}
var SingleUniform = class {
	constructor(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.type = activeInfo.type;
		this.setValue = getSingularSetter(activeInfo.type);
	}
};
var PureArrayUniform = class {
	constructor(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.type = activeInfo.type;
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter(activeInfo.type);
	}
};
var StructuredUniform = class {
	constructor(id) {
		this.id = id;
		this.seq = [];
		this.map = {};
	}
	setValue(gl, value, textures) {
		const seq = this.seq;
		for (let i = 0, n$2 = seq.length; i !== n$2; ++i) {
			const u = seq[i];
			u.setValue(gl, value[u.id], textures);
		}
	}
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
	container.seq.push(uniformObject);
	container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
	const path = activeInfo.name, pathLength = path.length;
	RePathPart.lastIndex = 0;
	while (true) {
		const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
		let id = match[1];
		const idIsIndex = match[2] === "]", subscript = match[3];
		if (idIsIndex) id = id | 0;
		if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
			addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
			break;
		} else {
			let next = container.map[id];
			if (next === void 0) {
				next = new StructuredUniform(id);
				addUniform(container, next);
			}
			container = next;
		}
	}
}
var WebGLUniforms = class {
	constructor(gl, program) {
		this.seq = [];
		this.map = {};
		const n$2 = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
		for (let i = 0; i < n$2; ++i) {
			const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
			parseUniform(info, addr, this);
		}
	}
	setValue(gl, name, value, textures) {
		const u = this.map[name];
		if (u !== void 0) u.setValue(gl, value, textures);
	}
	setOptional(gl, object, name) {
		const v = object[name];
		if (v !== void 0) this.setValue(gl, name, v);
	}
	static upload(gl, seq, values, textures) {
		for (let i = 0, n$2 = seq.length; i !== n$2; ++i) {
			const u = seq[i], v = values[u.id];
			if (v.needsUpdate !== false) u.setValue(gl, v.value, textures);
		}
	}
	static seqWithValue(seq, values) {
		const r = [];
		for (let i = 0, n$2 = seq.length; i !== n$2; ++i) {
			const u = seq[i];
			if (u.id in values) r.push(u);
		}
		return r;
	}
};
function WebGLShader(gl, type$1, string$2) {
	const shader = gl.createShader(type$1);
	gl.shaderSource(shader, string$2);
	gl.compileShader(shader);
	return shader;
}
var COMPLETION_STATUS_KHR = 37297;
var programIdCount = 0;
function handleSource(string$2, errorLine) {
	const lines = string$2.split("\n");
	const lines2 = [];
	const from = Math.max(errorLine - 6, 0);
	const to$1 = Math.min(errorLine + 6, lines.length);
	for (let i = from; i < to$1; i++) {
		const line = i + 1;
		lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
	}
	return lines2.join("\n");
}
var _m0 = /* @__PURE__ */ new Matrix3();
function getEncodingComponents(colorSpace) {
	ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, colorSpace);
	const encodingMatrix = `mat3( ${_m0.elements.map((v) => v.toFixed(4))} )`;
	switch (ColorManagement.getTransfer(colorSpace)) {
		case LinearTransfer: return [encodingMatrix, "LinearTransferOETF"];
		case SRGBTransfer: return [encodingMatrix, "sRGBTransferOETF"];
		default:
			warn("WebGLProgram: Unsupported color space: ", colorSpace);
			return [encodingMatrix, "LinearTransferOETF"];
	}
}
function getShaderErrors(gl, shader, type$1) {
	const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	const errors = (gl.getShaderInfoLog(shader) || "").trim();
	if (status && errors === "") return "";
	const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
	if (errorMatches) {
		const errorLine = parseInt(errorMatches[1]);
		return type$1.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
	} else return errors;
}
function getTexelEncodingFunction(functionName, colorSpace) {
	const components = getEncodingComponents(colorSpace);
	return [
		`vec4 ${functionName}( vec4 value ) {`,
		`	return ${components[1]}( vec4( value.rgb * ${components[0]}, value.a ) );`,
		"}"
	].join("\n");
}
function getToneMappingFunction(functionName, toneMapping$2) {
	let toneMappingName;
	switch (toneMapping$2) {
		case LinearToneMapping:
			toneMappingName = "Linear";
			break;
		case ReinhardToneMapping:
			toneMappingName = "Reinhard";
			break;
		case CineonToneMapping:
			toneMappingName = "Cineon";
			break;
		case ACESFilmicToneMapping:
			toneMappingName = "ACESFilmic";
			break;
		case AgXToneMapping:
			toneMappingName = "AgX";
			break;
		case NeutralToneMapping:
			toneMappingName = "Neutral";
			break;
		case CustomToneMapping:
			toneMappingName = "Custom";
			break;
		default:
			warn("WebGLProgram: Unsupported toneMapping:", toneMapping$2);
			toneMappingName = "Linear";
	}
	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
var _v0 = /* @__PURE__ */ new Vector3();
function getLuminanceFunction() {
	ColorManagement.getLuminanceCoefficients(_v0);
	const r = _v0.x.toFixed(4);
	const g$1 = _v0.y.toFixed(4);
	const b$2 = _v0.z.toFixed(4);
	return [
		"float luminance( const in vec3 rgb ) {",
		`	const vec3 weights = vec3( ${r}, ${g$1}, ${b$2} );`,
		"	return dot( weights, rgb );",
		"}"
	].join("\n");
}
function generateVertexExtensions(parameters) {
	return [parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", parameters.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
	const chunks = [];
	for (const name in defines) {
		const value = defines[name];
		if (value === false) continue;
		chunks.push("#define " + name + " " + value);
	}
	return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
	const attributes = {};
	const n$2 = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
	for (let i = 0; i < n$2; i++) {
		const info = gl.getActiveAttrib(program, i);
		const name = info.name;
		let locationSize = 1;
		if (info.type === gl.FLOAT_MAT2) locationSize = 2;
		if (info.type === gl.FLOAT_MAT3) locationSize = 3;
		if (info.type === gl.FLOAT_MAT4) locationSize = 4;
		attributes[name] = {
			type: info.type,
			location: gl.getAttribLocation(program, name),
			locationSize
		};
	}
	return attributes;
}
function filterEmptyLine(string$2) {
	return string$2 !== "";
}
function replaceLightNums(string$2, parameters) {
	const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
	return string$2.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string$2, parameters) {
	return string$2.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string$2) {
	return string$2.replace(includePattern, includeReplacer);
}
var shaderChunkMap = /* @__PURE__ */ new Map();
function includeReplacer(match, include) {
	let string$2 = ShaderChunk[include];
	if (string$2 === void 0) {
		const newInclude = shaderChunkMap.get(include);
		if (newInclude !== void 0) {
			string$2 = ShaderChunk[newInclude];
			warn("WebGLRenderer: Shader chunk \"%s\" has been deprecated. Use \"%s\" instead.", include, newInclude);
		} else throw new Error("Can not resolve #include <" + include + ">");
	}
	return resolveIncludes(string$2);
}
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string$2) {
	return string$2.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
	let string$2 = "";
	for (let i = parseInt(start); i < parseInt(end); i++) string$2 += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
	return string$2;
}
function generatePrecision(parameters) {
	let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
	if (parameters.precision === "highp") precisionstring += "\n#define HIGH_PRECISION";
	else if (parameters.precision === "mediump") precisionstring += "\n#define MEDIUM_PRECISION";
	else if (parameters.precision === "lowp") precisionstring += "\n#define LOW_PRECISION";
	return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
	let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
	if (parameters.shadowMapType === PCFShadowMap) shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
	else if (parameters.shadowMapType === PCFSoftShadowMap) shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
	else if (parameters.shadowMapType === VSMShadowMap) shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
	return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
	let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
	if (parameters.envMap) switch (parameters.envMapMode) {
		case CubeReflectionMapping:
		case CubeRefractionMapping:
			envMapTypeDefine = "ENVMAP_TYPE_CUBE";
			break;
		case CubeUVReflectionMapping:
			envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
			break;
	}
	return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
	let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
	if (parameters.envMap) switch (parameters.envMapMode) {
		case CubeRefractionMapping:
			envMapModeDefine = "ENVMAP_MODE_REFRACTION";
			break;
	}
	return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
	let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
	if (parameters.envMap) switch (parameters.combine) {
		case MultiplyOperation:
			envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
			break;
		case MixOperation:
			envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
			break;
		case AddOperation:
			envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
			break;
	}
	return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
	const imageHeight = parameters.envMapCubeUVHeight;
	if (imageHeight === null) return null;
	const maxMip = Math.log2(imageHeight) - 2;
	const texelHeight = 1 / imageHeight;
	return {
		texelWidth: 1 / (3 * Math.max(Math.pow(2, maxMip), 112)),
		texelHeight,
		maxMip
	};
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
	const gl = renderer.getContext();
	const defines = parameters.defines;
	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;
	const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
	const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
	const envMapModeDefine = generateEnvMapModeDefine(parameters);
	const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
	const envMapCubeUVSize = generateCubeUVSize(parameters);
	const customVertexExtensions = generateVertexExtensions(parameters);
	const customDefines = generateDefines(defines);
	const program = gl.createProgram();
	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
	if (parameters.isRawShaderMaterial) {
		prefixVertex = [
			"#define SHADER_TYPE " + parameters.shaderType,
			"#define SHADER_NAME " + parameters.shaderName,
			customDefines
		].filter(filterEmptyLine).join("\n");
		if (prefixVertex.length > 0) prefixVertex += "\n";
		prefixFragment = [
			"#define SHADER_TYPE " + parameters.shaderType,
			"#define SHADER_NAME " + parameters.shaderName,
			customDefines
		].filter(filterEmptyLine).join("\n");
		if (prefixFragment.length > 0) prefixFragment += "\n";
	} else {
		prefixVertex = [
			generatePrecision(parameters),
			"#define SHADER_TYPE " + parameters.shaderType,
			"#define SHADER_NAME " + parameters.shaderName,
			customDefines,
			parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
			parameters.batching ? "#define USE_BATCHING" : "",
			parameters.batchingColor ? "#define USE_BATCHING_COLOR" : "",
			parameters.instancing ? "#define USE_INSTANCING" : "",
			parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
			parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
			parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
			parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.envMap ? "#define " + envMapModeDefine : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.aoMap ? "#define USE_AOMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
			parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
			parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
			parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
			parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
			parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
			parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
			parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
			parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
			parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
			parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
			parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
			parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
			parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
			parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
			parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
			parameters.transmission ? "#define USE_TRANSMISSION" : "",
			parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
			parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
			parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
			parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
			parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
			parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
			parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
			parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
			parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
			parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
			parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
			parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
			parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
			parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
			parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
			parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
			parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
			parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
			parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
			parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
			parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
			parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
			parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
			parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
			parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
			parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
			parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
			parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",
			parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
			parameters.vertexUv1s ? "#define USE_UV1" : "",
			parameters.vertexUv2s ? "#define USE_UV2" : "",
			parameters.vertexUv3s ? "#define USE_UV3" : "",
			parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
			parameters.flatShading ? "#define FLAT_SHADED" : "",
			parameters.skinning ? "#define USE_SKINNING" : "",
			parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
			parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
			parameters.morphColors ? "#define USE_MORPHCOLORS" : "",
			parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
			parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",
			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
			parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
			parameters.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "",
			parameters.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "",
			"uniform mat4 modelMatrix;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;",
			"uniform vec3 cameraPosition;",
			"uniform bool isOrthographic;",
			"#ifdef USE_INSTANCING",
			"	attribute mat4 instanceMatrix;",
			"#endif",
			"#ifdef USE_INSTANCING_COLOR",
			"	attribute vec3 instanceColor;",
			"#endif",
			"#ifdef USE_INSTANCING_MORPH",
			"	uniform sampler2D morphTexture;",
			"#endif",
			"attribute vec3 position;",
			"attribute vec3 normal;",
			"attribute vec2 uv;",
			"#ifdef USE_UV1",
			"	attribute vec2 uv1;",
			"#endif",
			"#ifdef USE_UV2",
			"	attribute vec2 uv2;",
			"#endif",
			"#ifdef USE_UV3",
			"	attribute vec2 uv3;",
			"#endif",
			"#ifdef USE_TANGENT",
			"	attribute vec4 tangent;",
			"#endif",
			"#if defined( USE_COLOR_ALPHA )",
			"	attribute vec4 color;",
			"#elif defined( USE_COLOR )",
			"	attribute vec3 color;",
			"#endif",
			"#ifdef USE_SKINNING",
			"	attribute vec4 skinIndex;",
			"	attribute vec4 skinWeight;",
			"#endif",
			"\n"
		].filter(filterEmptyLine).join("\n");
		prefixFragment = [
			generatePrecision(parameters),
			"#define SHADER_TYPE " + parameters.shaderType,
			"#define SHADER_NAME " + parameters.shaderName,
			customDefines,
			parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
			parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
			parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
			parameters.map ? "#define USE_MAP" : "",
			parameters.matcap ? "#define USE_MATCAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.envMap ? "#define " + envMapTypeDefine : "",
			parameters.envMap ? "#define " + envMapModeDefine : "",
			parameters.envMap ? "#define " + envMapBlendingDefine : "",
			envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
			envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
			envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.aoMap ? "#define USE_AOMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
			parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
			parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
			parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
			parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
			parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
			parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
			parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
			parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
			parameters.dispersion ? "#define USE_DISPERSION" : "",
			parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
			parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
			parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
			parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
			parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
			parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
			parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
			parameters.alphaTest ? "#define USE_ALPHATEST" : "",
			parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
			parameters.sheen ? "#define USE_SHEEN" : "",
			parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
			parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
			parameters.transmission ? "#define USE_TRANSMISSION" : "",
			parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
			parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
			parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
			parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? "#define USE_COLOR" : "",
			parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
			parameters.vertexUv1s ? "#define USE_UV1" : "",
			parameters.vertexUv2s ? "#define USE_UV2" : "",
			parameters.vertexUv3s ? "#define USE_UV3" : "",
			parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
			parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
			parameters.flatShading ? "#define FLAT_SHADED" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",
			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
			parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
			parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
			parameters.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
			parameters.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "",
			parameters.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "",
			"uniform mat4 viewMatrix;",
			"uniform vec3 cameraPosition;",
			"uniform bool isOrthographic;",
			parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
			parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
			parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
			parameters.dithering ? "#define DITHERING" : "",
			parameters.opaque ? "#define OPAQUE" : "",
			ShaderChunk["colorspace_pars_fragment"],
			getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
			getLuminanceFunction(),
			parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
			"\n"
		].filter(filterEmptyLine).join("\n");
	}
	vertexShader = resolveIncludes(vertexShader);
	vertexShader = replaceLightNums(vertexShader, parameters);
	vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
	fragmentShader = resolveIncludes(fragmentShader);
	fragmentShader = replaceLightNums(fragmentShader, parameters);
	fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
	vertexShader = unrollLoops(vertexShader);
	fragmentShader = unrollLoops(fragmentShader);
	if (parameters.isRawShaderMaterial !== true) {
		versionString = "#version 300 es\n";
		prefixVertex = [
			customVertexExtensions,
			"#define attribute in",
			"#define varying out",
			"#define texture2D texture"
		].join("\n") + "\n" + prefixVertex;
		prefixFragment = [
			"#define varying in",
			parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
			parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
			"#define gl_FragDepthEXT gl_FragDepth",
			"#define texture2D texture",
			"#define textureCube texture",
			"#define texture2DProj textureProj",
			"#define texture2DLodEXT textureLod",
			"#define texture2DProjLodEXT textureProjLod",
			"#define textureCubeLodEXT textureLod",
			"#define texture2DGradEXT textureGrad",
			"#define texture2DProjGradEXT textureProjGrad",
			"#define textureCubeGradEXT textureGrad"
		].join("\n") + "\n" + prefixFragment;
	}
	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;
	const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
	const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
	gl.attachShader(program, glVertexShader);
	gl.attachShader(program, glFragmentShader);
	if (parameters.index0AttributeName !== void 0) gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
	else if (parameters.morphTargets === true) gl.bindAttribLocation(program, 0, "position");
	gl.linkProgram(program);
	function onFirstUse(self$1) {
		if (renderer.debug.checkShaderErrors) {
			const programInfoLog = gl.getProgramInfoLog(program) || "";
			const vertexShaderInfoLog = gl.getShaderInfoLog(glVertexShader) || "";
			const fragmentShaderInfoLog = gl.getShaderInfoLog(glFragmentShader) || "";
			const programLog = programInfoLog.trim();
			const vertexLog = vertexShaderInfoLog.trim();
			const fragmentLog = fragmentShaderInfoLog.trim();
			let runnable = true;
			let haveDiagnostics = true;
			if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
				runnable = false;
				if (typeof renderer.debug.onShaderError === "function") renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
				else {
					const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
					const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
					error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nMaterial Name: " + self$1.name + "\nMaterial Type: " + self$1.type + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
				}
			} else if (programLog !== "") warn("WebGLProgram: Program Info Log:", programLog);
			else if (vertexLog === "" || fragmentLog === "") haveDiagnostics = false;
			if (haveDiagnostics) self$1.diagnostics = {
				runnable,
				programLog,
				vertexShader: {
					log: vertexLog,
					prefix: prefixVertex
				},
				fragmentShader: {
					log: fragmentLog,
					prefix: prefixFragment
				}
			};
		}
		gl.deleteShader(glVertexShader);
		gl.deleteShader(glFragmentShader);
		cachedUniforms = new WebGLUniforms(gl, program);
		cachedAttributes = fetchAttributeLocations(gl, program);
	}
	let cachedUniforms;
	this.getUniforms = function() {
		if (cachedUniforms === void 0) onFirstUse(this);
		return cachedUniforms;
	};
	let cachedAttributes;
	this.getAttributes = function() {
		if (cachedAttributes === void 0) onFirstUse(this);
		return cachedAttributes;
	};
	let programReady = parameters.rendererExtensionParallelShaderCompile === false;
	this.isReady = function() {
		if (programReady === false) programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
		return programReady;
	};
	this.destroy = function() {
		bindingStates.releaseStatesOfProgram(this);
		gl.deleteProgram(program);
		this.program = void 0;
	};
	this.type = parameters.shaderType;
	this.name = parameters.shaderName;
	this.id = programIdCount++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;
	return this;
}
var _id = 0;
var WebGLShaderCache = class {
	constructor() {
		this.shaderCache = /* @__PURE__ */ new Map();
		this.materialCache = /* @__PURE__ */ new Map();
	}
	update(material) {
		const vertexShader = material.vertexShader;
		const fragmentShader = material.fragmentShader;
		const vertexShaderStage = this._getShaderStage(vertexShader);
		const fragmentShaderStage = this._getShaderStage(fragmentShader);
		const materialShaders = this._getShaderCacheForMaterial(material);
		if (materialShaders.has(vertexShaderStage) === false) {
			materialShaders.add(vertexShaderStage);
			vertexShaderStage.usedTimes++;
		}
		if (materialShaders.has(fragmentShaderStage) === false) {
			materialShaders.add(fragmentShaderStage);
			fragmentShaderStage.usedTimes++;
		}
		return this;
	}
	remove(material) {
		const materialShaders = this.materialCache.get(material);
		for (const shaderStage of materialShaders) {
			shaderStage.usedTimes--;
			if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
		}
		this.materialCache.delete(material);
		return this;
	}
	getVertexShaderID(material) {
		return this._getShaderStage(material.vertexShader).id;
	}
	getFragmentShaderID(material) {
		return this._getShaderStage(material.fragmentShader).id;
	}
	dispose() {
		this.shaderCache.clear();
		this.materialCache.clear();
	}
	_getShaderCacheForMaterial(material) {
		const cache$2 = this.materialCache;
		let set$1 = cache$2.get(material);
		if (set$1 === void 0) {
			set$1 = /* @__PURE__ */ new Set();
			cache$2.set(material, set$1);
		}
		return set$1;
	}
	_getShaderStage(code$2) {
		const cache$2 = this.shaderCache;
		let stage = cache$2.get(code$2);
		if (stage === void 0) {
			stage = new WebGLShaderStage(code$2);
			cache$2.set(code$2, stage);
		}
		return stage;
	}
};
var WebGLShaderStage = class {
	constructor(code$2) {
		this.id = _id++;
		this.code = code$2;
		this.usedTimes = 0;
	}
};
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping$1) {
	const _programLayers = new Layers();
	const _customShaders = new WebGLShaderCache();
	const _activeChannels = /* @__PURE__ */ new Set();
	const programs = [];
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
	let precision = capabilities.precision;
	const shaderIDs = {
		MeshDepthMaterial: "depth",
		MeshDistanceMaterial: "distanceRGBA",
		MeshNormalMaterial: "normal",
		MeshBasicMaterial: "basic",
		MeshLambertMaterial: "lambert",
		MeshPhongMaterial: "phong",
		MeshToonMaterial: "toon",
		MeshStandardMaterial: "physical",
		MeshPhysicalMaterial: "physical",
		MeshMatcapMaterial: "matcap",
		LineBasicMaterial: "basic",
		LineDashedMaterial: "dashed",
		PointsMaterial: "points",
		ShadowMaterial: "shadow",
		SpriteMaterial: "sprite"
	};
	function getChannel(value) {
		_activeChannels.add(value);
		if (value === 0) return "uv";
		return `uv${value}`;
	}
	function getParameters(material, lights$2, shadows, scene, object) {
		const fog$2 = scene.fog;
		const geometry = object.geometry;
		const environment$1 = material.isMeshStandardMaterial ? scene.environment : null;
		const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment$1);
		const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
		const shaderID = shaderIDs[material.type];
		if (material.precision !== null) {
			precision = capabilities.getMaxPrecision(material.precision);
			if (precision !== material.precision) warn("WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
		}
		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
		let morphTextureStride = 0;
		if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;
		if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;
		if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;
		let vertexShader, fragmentShader;
		let customVertexShaderID, customFragmentShaderID;
		if (shaderID) {
			const shader = ShaderLib[shaderID];
			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;
		} else {
			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;
			_customShaders.update(material);
			customVertexShaderID = _customShaders.getVertexShaderID(material);
			customFragmentShaderID = _customShaders.getFragmentShaderID(material);
		}
		const currentRenderTarget = renderer.getRenderTarget();
		const reversedDepthBuffer = renderer.state.buffers.depth.getReversed();
		const IS_INSTANCEDMESH = object.isInstancedMesh === true;
		const IS_BATCHEDMESH = object.isBatchedMesh === true;
		const HAS_MAP = !!material.map;
		const HAS_MATCAP = !!material.matcap;
		const HAS_ENVMAP = !!envMap;
		const HAS_AOMAP = !!material.aoMap;
		const HAS_LIGHTMAP = !!material.lightMap;
		const HAS_BUMPMAP = !!material.bumpMap;
		const HAS_NORMALMAP = !!material.normalMap;
		const HAS_DISPLACEMENTMAP = !!material.displacementMap;
		const HAS_EMISSIVEMAP = !!material.emissiveMap;
		const HAS_METALNESSMAP = !!material.metalnessMap;
		const HAS_ROUGHNESSMAP = !!material.roughnessMap;
		const HAS_ANISOTROPY = material.anisotropy > 0;
		const HAS_CLEARCOAT = material.clearcoat > 0;
		const HAS_DISPERSION = material.dispersion > 0;
		const HAS_IRIDESCENCE = material.iridescence > 0;
		const HAS_SHEEN = material.sheen > 0;
		const HAS_TRANSMISSION = material.transmission > 0;
		const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
		const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
		const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
		const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
		const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
		const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
		const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
		const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
		const HAS_SPECULARMAP = !!material.specularMap;
		const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
		const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
		const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
		const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
		const HAS_GRADIENTMAP = !!material.gradientMap;
		const HAS_ALPHAMAP = !!material.alphaMap;
		const HAS_ALPHATEST = material.alphaTest > 0;
		const HAS_ALPHAHASH = !!material.alphaHash;
		const HAS_EXTENSIONS = !!material.extensions;
		let toneMapping$2 = NoToneMapping;
		if (material.toneMapped) {
			if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) toneMapping$2 = renderer.toneMapping;
		}
		const parameters = {
			shaderID,
			shaderType: material.type,
			shaderName: material.name,
			vertexShader,
			fragmentShader,
			defines: material.defines,
			customVertexShaderID,
			customFragmentShaderID,
			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,
			precision,
			batching: IS_BATCHEDMESH,
			batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
			instancing: IS_INSTANCEDMESH,
			instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
			instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
			supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
			outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
			alphaToCoverage: !!material.alphaToCoverage,
			map: HAS_MAP,
			matcap: HAS_MATCAP,
			envMap: HAS_ENVMAP,
			envMapMode: HAS_ENVMAP && envMap.mapping,
			envMapCubeUVHeight,
			aoMap: HAS_AOMAP,
			lightMap: HAS_LIGHTMAP,
			bumpMap: HAS_BUMPMAP,
			normalMap: HAS_NORMALMAP,
			displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
			emissiveMap: HAS_EMISSIVEMAP,
			normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
			normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
			metalnessMap: HAS_METALNESSMAP,
			roughnessMap: HAS_ROUGHNESSMAP,
			anisotropy: HAS_ANISOTROPY,
			anisotropyMap: HAS_ANISOTROPYMAP,
			clearcoat: HAS_CLEARCOAT,
			clearcoatMap: HAS_CLEARCOATMAP,
			clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
			clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
			dispersion: HAS_DISPERSION,
			iridescence: HAS_IRIDESCENCE,
			iridescenceMap: HAS_IRIDESCENCEMAP,
			iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
			sheen: HAS_SHEEN,
			sheenColorMap: HAS_SHEEN_COLORMAP,
			sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
			specularMap: HAS_SPECULARMAP,
			specularColorMap: HAS_SPECULAR_COLORMAP,
			specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
			transmission: HAS_TRANSMISSION,
			transmissionMap: HAS_TRANSMISSIONMAP,
			thicknessMap: HAS_THICKNESSMAP,
			gradientMap: HAS_GRADIENTMAP,
			opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
			alphaMap: HAS_ALPHAMAP,
			alphaTest: HAS_ALPHATEST,
			alphaHash: HAS_ALPHAHASH,
			combine: material.combine,
			mapUv: HAS_MAP && getChannel(material.map.channel),
			aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
			lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
			bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
			normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
			displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
			emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
			metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
			roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
			anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
			clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
			clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
			clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
			iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
			iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
			sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
			sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
			specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
			specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
			specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
			transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
			thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
			alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
			vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
			pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
			fog: !!fog$2,
			useFog: material.fog === true,
			fogExp2: !!fog$2 && fog$2.isFogExp2,
			flatShading: material.flatShading === true && material.wireframe === false,
			sizeAttenuation: material.sizeAttenuation === true,
			logarithmicDepthBuffer,
			reversedDepthBuffer,
			skinning: object.isSkinnedMesh === true,
			morphTargets: geometry.morphAttributes.position !== void 0,
			morphNormals: geometry.morphAttributes.normal !== void 0,
			morphColors: geometry.morphAttributes.color !== void 0,
			morphTargetsCount,
			morphTextureStride,
			numDirLights: lights$2.directional.length,
			numPointLights: lights$2.point.length,
			numSpotLights: lights$2.spot.length,
			numSpotLightMaps: lights$2.spotLightMap.length,
			numRectAreaLights: lights$2.rectArea.length,
			numHemiLights: lights$2.hemi.length,
			numDirLightShadows: lights$2.directionalShadowMap.length,
			numPointLightShadows: lights$2.pointShadowMap.length,
			numSpotLightShadows: lights$2.spotShadowMap.length,
			numSpotLightShadowsWithMaps: lights$2.numSpotLightShadowsWithMaps,
			numLightProbes: lights$2.numLightProbes,
			numClippingPlanes: clipping$1.numPlanes,
			numClipIntersection: clipping$1.numIntersection,
			dithering: material.dithering,
			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,
			toneMapping: toneMapping$2,
			decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
			decodeVideoTextureEmissive: HAS_EMISSIVEMAP && material.emissiveMap.isVideoTexture === true && ColorManagement.getTransfer(material.emissiveMap.colorSpace) === SRGBTransfer,
			premultipliedAlpha: material.premultipliedAlpha,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,
			useDepthPacking: material.depthPacking >= 0,
			depthPacking: material.depthPacking || 0,
			index0AttributeName: material.index0AttributeName,
			extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has("WEBGL_clip_cull_distance"),
			extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has("WEBGL_multi_draw"),
			rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
			customProgramCacheKey: material.customProgramCacheKey()
		};
		parameters.vertexUv1s = _activeChannels.has(1);
		parameters.vertexUv2s = _activeChannels.has(2);
		parameters.vertexUv3s = _activeChannels.has(3);
		_activeChannels.clear();
		return parameters;
	}
	function getProgramCacheKey(parameters) {
		const array$2 = [];
		if (parameters.shaderID) array$2.push(parameters.shaderID);
		else {
			array$2.push(parameters.customVertexShaderID);
			array$2.push(parameters.customFragmentShaderID);
		}
		if (parameters.defines !== void 0) for (const name in parameters.defines) {
			array$2.push(name);
			array$2.push(parameters.defines[name]);
		}
		if (parameters.isRawShaderMaterial === false) {
			getProgramCacheKeyParameters(array$2, parameters);
			getProgramCacheKeyBooleans(array$2, parameters);
			array$2.push(renderer.outputColorSpace);
		}
		array$2.push(parameters.customProgramCacheKey);
		return array$2.join();
	}
	function getProgramCacheKeyParameters(array$2, parameters) {
		array$2.push(parameters.precision);
		array$2.push(parameters.outputColorSpace);
		array$2.push(parameters.envMapMode);
		array$2.push(parameters.envMapCubeUVHeight);
		array$2.push(parameters.mapUv);
		array$2.push(parameters.alphaMapUv);
		array$2.push(parameters.lightMapUv);
		array$2.push(parameters.aoMapUv);
		array$2.push(parameters.bumpMapUv);
		array$2.push(parameters.normalMapUv);
		array$2.push(parameters.displacementMapUv);
		array$2.push(parameters.emissiveMapUv);
		array$2.push(parameters.metalnessMapUv);
		array$2.push(parameters.roughnessMapUv);
		array$2.push(parameters.anisotropyMapUv);
		array$2.push(parameters.clearcoatMapUv);
		array$2.push(parameters.clearcoatNormalMapUv);
		array$2.push(parameters.clearcoatRoughnessMapUv);
		array$2.push(parameters.iridescenceMapUv);
		array$2.push(parameters.iridescenceThicknessMapUv);
		array$2.push(parameters.sheenColorMapUv);
		array$2.push(parameters.sheenRoughnessMapUv);
		array$2.push(parameters.specularMapUv);
		array$2.push(parameters.specularColorMapUv);
		array$2.push(parameters.specularIntensityMapUv);
		array$2.push(parameters.transmissionMapUv);
		array$2.push(parameters.thicknessMapUv);
		array$2.push(parameters.combine);
		array$2.push(parameters.fogExp2);
		array$2.push(parameters.sizeAttenuation);
		array$2.push(parameters.morphTargetsCount);
		array$2.push(parameters.morphAttributeCount);
		array$2.push(parameters.numDirLights);
		array$2.push(parameters.numPointLights);
		array$2.push(parameters.numSpotLights);
		array$2.push(parameters.numSpotLightMaps);
		array$2.push(parameters.numHemiLights);
		array$2.push(parameters.numRectAreaLights);
		array$2.push(parameters.numDirLightShadows);
		array$2.push(parameters.numPointLightShadows);
		array$2.push(parameters.numSpotLightShadows);
		array$2.push(parameters.numSpotLightShadowsWithMaps);
		array$2.push(parameters.numLightProbes);
		array$2.push(parameters.shadowMapType);
		array$2.push(parameters.toneMapping);
		array$2.push(parameters.numClippingPlanes);
		array$2.push(parameters.numClipIntersection);
		array$2.push(parameters.depthPacking);
	}
	function getProgramCacheKeyBooleans(array$2, parameters) {
		_programLayers.disableAll();
		if (parameters.supportsVertexTextures) _programLayers.enable(0);
		if (parameters.instancing) _programLayers.enable(1);
		if (parameters.instancingColor) _programLayers.enable(2);
		if (parameters.instancingMorph) _programLayers.enable(3);
		if (parameters.matcap) _programLayers.enable(4);
		if (parameters.envMap) _programLayers.enable(5);
		if (parameters.normalMapObjectSpace) _programLayers.enable(6);
		if (parameters.normalMapTangentSpace) _programLayers.enable(7);
		if (parameters.clearcoat) _programLayers.enable(8);
		if (parameters.iridescence) _programLayers.enable(9);
		if (parameters.alphaTest) _programLayers.enable(10);
		if (parameters.vertexColors) _programLayers.enable(11);
		if (parameters.vertexAlphas) _programLayers.enable(12);
		if (parameters.vertexUv1s) _programLayers.enable(13);
		if (parameters.vertexUv2s) _programLayers.enable(14);
		if (parameters.vertexUv3s) _programLayers.enable(15);
		if (parameters.vertexTangents) _programLayers.enable(16);
		if (parameters.anisotropy) _programLayers.enable(17);
		if (parameters.alphaHash) _programLayers.enable(18);
		if (parameters.batching) _programLayers.enable(19);
		if (parameters.dispersion) _programLayers.enable(20);
		if (parameters.batchingColor) _programLayers.enable(21);
		if (parameters.gradientMap) _programLayers.enable(22);
		array$2.push(_programLayers.mask);
		_programLayers.disableAll();
		if (parameters.fog) _programLayers.enable(0);
		if (parameters.useFog) _programLayers.enable(1);
		if (parameters.flatShading) _programLayers.enable(2);
		if (parameters.logarithmicDepthBuffer) _programLayers.enable(3);
		if (parameters.reversedDepthBuffer) _programLayers.enable(4);
		if (parameters.skinning) _programLayers.enable(5);
		if (parameters.morphTargets) _programLayers.enable(6);
		if (parameters.morphNormals) _programLayers.enable(7);
		if (parameters.morphColors) _programLayers.enable(8);
		if (parameters.premultipliedAlpha) _programLayers.enable(9);
		if (parameters.shadowMapEnabled) _programLayers.enable(10);
		if (parameters.doubleSided) _programLayers.enable(11);
		if (parameters.flipSided) _programLayers.enable(12);
		if (parameters.useDepthPacking) _programLayers.enable(13);
		if (parameters.dithering) _programLayers.enable(14);
		if (parameters.transmission) _programLayers.enable(15);
		if (parameters.sheen) _programLayers.enable(16);
		if (parameters.opaque) _programLayers.enable(17);
		if (parameters.pointsUvs) _programLayers.enable(18);
		if (parameters.decodeVideoTexture) _programLayers.enable(19);
		if (parameters.decodeVideoTextureEmissive) _programLayers.enable(20);
		if (parameters.alphaToCoverage) _programLayers.enable(21);
		array$2.push(_programLayers.mask);
	}
	function getUniforms(material) {
		const shaderID = shaderIDs[material.type];
		let uniforms;
		if (shaderID) {
			const shader = ShaderLib[shaderID];
			uniforms = UniformsUtils.clone(shader.uniforms);
		} else uniforms = material.uniforms;
		return uniforms;
	}
	function acquireProgram(parameters, cacheKey) {
		let program;
		for (let p$1 = 0, pl = programs.length; p$1 < pl; p$1++) {
			const preexistingProgram = programs[p$1];
			if (preexistingProgram.cacheKey === cacheKey) {
				program = preexistingProgram;
				++program.usedTimes;
				break;
			}
		}
		if (program === void 0) {
			program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
			programs.push(program);
		}
		return program;
	}
	function releaseProgram(program) {
		if (--program.usedTimes === 0) {
			const i = programs.indexOf(program);
			programs[i] = programs[programs.length - 1];
			programs.pop();
			program.destroy();
		}
	}
	function releaseShaderCache(material) {
		_customShaders.remove(material);
	}
	function dispose() {
		_customShaders.dispose();
	}
	return {
		getParameters,
		getProgramCacheKey,
		getUniforms,
		acquireProgram,
		releaseProgram,
		releaseShaderCache,
		programs,
		dispose
	};
}
function WebGLProperties() {
	let properties = /* @__PURE__ */ new WeakMap();
	function has(object) {
		return properties.has(object);
	}
	function get$1(object) {
		let map = properties.get(object);
		if (map === void 0) {
			map = {};
			properties.set(object, map);
		}
		return map;
	}
	function remove(object) {
		properties.delete(object);
	}
	function update(object, key, value) {
		properties.get(object)[key] = value;
	}
	function dispose() {
		properties = /* @__PURE__ */ new WeakMap();
	}
	return {
		has,
		get: get$1,
		remove,
		update,
		dispose
	};
}
function painterSortStable(a$1, b$2) {
	if (a$1.groupOrder !== b$2.groupOrder) return a$1.groupOrder - b$2.groupOrder;
	else if (a$1.renderOrder !== b$2.renderOrder) return a$1.renderOrder - b$2.renderOrder;
	else if (a$1.material.id !== b$2.material.id) return a$1.material.id - b$2.material.id;
	else if (a$1.z !== b$2.z) return a$1.z - b$2.z;
	else return a$1.id - b$2.id;
}
function reversePainterSortStable(a$1, b$2) {
	if (a$1.groupOrder !== b$2.groupOrder) return a$1.groupOrder - b$2.groupOrder;
	else if (a$1.renderOrder !== b$2.renderOrder) return a$1.renderOrder - b$2.renderOrder;
	else if (a$1.z !== b$2.z) return b$2.z - a$1.z;
	else return a$1.id - b$2.id;
}
function WebGLRenderList() {
	const renderItems = [];
	let renderItemsIndex = 0;
	const opaque = [];
	const transmissive = [];
	const transparent = [];
	function init() {
		renderItemsIndex = 0;
		opaque.length = 0;
		transmissive.length = 0;
		transparent.length = 0;
	}
	function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
		let renderItem = renderItems[renderItemsIndex];
		if (renderItem === void 0) {
			renderItem = {
				id: object.id,
				object,
				geometry,
				material,
				groupOrder,
				renderOrder: object.renderOrder,
				z,
				group
			};
			renderItems[renderItemsIndex] = renderItem;
		} else {
			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;
		}
		renderItemsIndex++;
		return renderItem;
	}
	function push(object, geometry, material, groupOrder, z, group) {
		const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
		if (material.transmission > 0) transmissive.push(renderItem);
		else if (material.transparent === true) transparent.push(renderItem);
		else opaque.push(renderItem);
	}
	function unshift(object, geometry, material, groupOrder, z, group) {
		const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
		if (material.transmission > 0) transmissive.unshift(renderItem);
		else if (material.transparent === true) transparent.unshift(renderItem);
		else opaque.unshift(renderItem);
	}
	function sort(customOpaqueSort, customTransparentSort) {
		if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
		if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
		if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
	}
	function finish() {
		for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
			const renderItem = renderItems[i];
			if (renderItem.id === null) break;
			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.group = null;
		}
	}
	return {
		opaque,
		transmissive,
		transparent,
		init,
		push,
		unshift,
		finish,
		sort
	};
}
function WebGLRenderLists() {
	let lists = /* @__PURE__ */ new WeakMap();
	function get$1(scene, renderCallDepth) {
		const listArray = lists.get(scene);
		let list;
		if (listArray === void 0) {
			list = new WebGLRenderList();
			lists.set(scene, [list]);
		} else if (renderCallDepth >= listArray.length) {
			list = new WebGLRenderList();
			listArray.push(list);
		} else list = listArray[renderCallDepth];
		return list;
	}
	function dispose() {
		lists = /* @__PURE__ */ new WeakMap();
	}
	return {
		get: get$1,
		dispose
	};
}
function UniformsCache() {
	const lights$2 = {};
	return { get: function(light) {
		if (lights$2[light.id] !== void 0) return lights$2[light.id];
		let uniforms;
		switch (light.type) {
			case "DirectionalLight":
				uniforms = {
					direction: new Vector3(),
					color: new Color$1()
				};
				break;
			case "SpotLight":
				uniforms = {
					position: new Vector3(),
					direction: new Vector3(),
					color: new Color$1(),
					distance: 0,
					coneCos: 0,
					penumbraCos: 0,
					decay: 0
				};
				break;
			case "PointLight":
				uniforms = {
					position: new Vector3(),
					color: new Color$1(),
					distance: 0,
					decay: 0
				};
				break;
			case "HemisphereLight":
				uniforms = {
					direction: new Vector3(),
					skyColor: new Color$1(),
					groundColor: new Color$1()
				};
				break;
			case "RectAreaLight":
				uniforms = {
					color: new Color$1(),
					position: new Vector3(),
					halfWidth: new Vector3(),
					halfHeight: new Vector3()
				};
				break;
		}
		lights$2[light.id] = uniforms;
		return uniforms;
	} };
}
function ShadowUniformsCache() {
	const lights$2 = {};
	return { get: function(light) {
		if (lights$2[light.id] !== void 0) return lights$2[light.id];
		let uniforms;
		switch (light.type) {
			case "DirectionalLight":
				uniforms = {
					shadowIntensity: 1,
					shadowBias: 0,
					shadowNormalBias: 0,
					shadowRadius: 1,
					shadowMapSize: new Vector2()
				};
				break;
			case "SpotLight":
				uniforms = {
					shadowIntensity: 1,
					shadowBias: 0,
					shadowNormalBias: 0,
					shadowRadius: 1,
					shadowMapSize: new Vector2()
				};
				break;
			case "PointLight":
				uniforms = {
					shadowIntensity: 1,
					shadowBias: 0,
					shadowNormalBias: 0,
					shadowRadius: 1,
					shadowMapSize: new Vector2(),
					shadowCameraNear: 1,
					shadowCameraFar: 1e3
				};
				break;
		}
		lights$2[light.id] = uniforms;
		return uniforms;
	} };
}
var nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
	return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions) {
	const cache$2 = new UniformsCache();
	const shadowCache = ShadowUniformsCache();
	const state = {
		version: 0,
		hash: {
			directionalLength: -1,
			pointLength: -1,
			spotLength: -1,
			rectAreaLength: -1,
			hemiLength: -1,
			numDirectionalShadows: -1,
			numPointShadows: -1,
			numSpotShadows: -1,
			numSpotMaps: -1,
			numLightProbes: -1
		},
		ambient: [
			0,
			0,
			0
		],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotLightMap: [],
		spotShadow: [],
		spotShadowMap: [],
		spotLightMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],
		numSpotLightShadowsWithMaps: 0,
		numLightProbes: 0
	};
	for (let i = 0; i < 9; i++) state.probe.push(new Vector3());
	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();
	function setup(lights$2) {
		let r = 0, g$1 = 0, b$2 = 0;
		for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;
		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;
		let numSpotMaps = 0;
		let numSpotShadowsWithMaps = 0;
		let numLightProbes = 0;
		lights$2.sort(shadowCastingAndTexturingLightsFirst);
		for (let i = 0, l = lights$2.length; i < l; i++) {
			const light = lights$2[i];
			const color$2 = light.color;
			const intensity = light.intensity;
			const distance$3 = light.distance;
			const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
			if (light.isAmbientLight) {
				r += color$2.r * intensity;
				g$1 += color$2.g * intensity;
				b$2 += color$2.b * intensity;
			} else if (light.isLightProbe) {
				for (let j = 0; j < 9; j++) state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
				numLightProbes++;
			} else if (light.isDirectionalLight) {
				const uniforms = cache$2.get(light);
				uniforms.color.copy(light.color).multiplyScalar(light.intensity);
				if (light.castShadow) {
					const shadow$2 = light.shadow;
					const shadowUniforms = shadowCache.get(light);
					shadowUniforms.shadowIntensity = shadow$2.intensity;
					shadowUniforms.shadowBias = shadow$2.bias;
					shadowUniforms.shadowNormalBias = shadow$2.normalBias;
					shadowUniforms.shadowRadius = shadow$2.radius;
					shadowUniforms.shadowMapSize = shadow$2.mapSize;
					state.directionalShadow[directionalLength] = shadowUniforms;
					state.directionalShadowMap[directionalLength] = shadowMap;
					state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
					numDirectionalShadows++;
				}
				state.directional[directionalLength] = uniforms;
				directionalLength++;
			} else if (light.isSpotLight) {
				const uniforms = cache$2.get(light);
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.color.copy(color$2).multiplyScalar(intensity);
				uniforms.distance = distance$3;
				uniforms.coneCos = Math.cos(light.angle);
				uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
				uniforms.decay = light.decay;
				state.spot[spotLength] = uniforms;
				const shadow$2 = light.shadow;
				if (light.map) {
					state.spotLightMap[numSpotMaps] = light.map;
					numSpotMaps++;
					shadow$2.updateMatrices(light);
					if (light.castShadow) numSpotShadowsWithMaps++;
				}
				state.spotLightMatrix[spotLength] = shadow$2.matrix;
				if (light.castShadow) {
					const shadowUniforms = shadowCache.get(light);
					shadowUniforms.shadowIntensity = shadow$2.intensity;
					shadowUniforms.shadowBias = shadow$2.bias;
					shadowUniforms.shadowNormalBias = shadow$2.normalBias;
					shadowUniforms.shadowRadius = shadow$2.radius;
					shadowUniforms.shadowMapSize = shadow$2.mapSize;
					state.spotShadow[spotLength] = shadowUniforms;
					state.spotShadowMap[spotLength] = shadowMap;
					numSpotShadows++;
				}
				spotLength++;
			} else if (light.isRectAreaLight) {
				const uniforms = cache$2.get(light);
				uniforms.color.copy(color$2).multiplyScalar(intensity);
				uniforms.halfWidth.set(light.width * .5, 0, 0);
				uniforms.halfHeight.set(0, light.height * .5, 0);
				state.rectArea[rectAreaLength] = uniforms;
				rectAreaLength++;
			} else if (light.isPointLight) {
				const uniforms = cache$2.get(light);
				uniforms.color.copy(light.color).multiplyScalar(light.intensity);
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;
				if (light.castShadow) {
					const shadow$2 = light.shadow;
					const shadowUniforms = shadowCache.get(light);
					shadowUniforms.shadowIntensity = shadow$2.intensity;
					shadowUniforms.shadowBias = shadow$2.bias;
					shadowUniforms.shadowNormalBias = shadow$2.normalBias;
					shadowUniforms.shadowRadius = shadow$2.radius;
					shadowUniforms.shadowMapSize = shadow$2.mapSize;
					shadowUniforms.shadowCameraNear = shadow$2.camera.near;
					shadowUniforms.shadowCameraFar = shadow$2.camera.far;
					state.pointShadow[pointLength] = shadowUniforms;
					state.pointShadowMap[pointLength] = shadowMap;
					state.pointShadowMatrix[pointLength] = light.shadow.matrix;
					numPointShadows++;
				}
				state.point[pointLength] = uniforms;
				pointLength++;
			} else if (light.isHemisphereLight) {
				const uniforms = cache$2.get(light);
				uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
				uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
				state.hemi[hemiLength] = uniforms;
				hemiLength++;
			}
		}
		if (rectAreaLength > 0) if (extensions.has("OES_texture_float_linear") === true) {
			state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
			state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
		} else {
			state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
			state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
		}
		state.ambient[0] = r;
		state.ambient[1] = g$1;
		state.ambient[2] = b$2;
		const hash$3 = state.hash;
		if (hash$3.directionalLength !== directionalLength || hash$3.pointLength !== pointLength || hash$3.spotLength !== spotLength || hash$3.rectAreaLength !== rectAreaLength || hash$3.hemiLength !== hemiLength || hash$3.numDirectionalShadows !== numDirectionalShadows || hash$3.numPointShadows !== numPointShadows || hash$3.numSpotShadows !== numSpotShadows || hash$3.numSpotMaps !== numSpotMaps || hash$3.numLightProbes !== numLightProbes) {
			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;
			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
			state.spotLightMap.length = numSpotMaps;
			state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
			state.numLightProbes = numLightProbes;
			hash$3.directionalLength = directionalLength;
			hash$3.pointLength = pointLength;
			hash$3.spotLength = spotLength;
			hash$3.rectAreaLength = rectAreaLength;
			hash$3.hemiLength = hemiLength;
			hash$3.numDirectionalShadows = numDirectionalShadows;
			hash$3.numPointShadows = numPointShadows;
			hash$3.numSpotShadows = numSpotShadows;
			hash$3.numSpotMaps = numSpotMaps;
			hash$3.numLightProbes = numLightProbes;
			state.version = nextVersion++;
		}
	}
	function setupView(lights$2, camera) {
		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;
		const viewMatrix = camera.matrixWorldInverse;
		for (let i = 0, l = lights$2.length; i < l; i++) {
			const light = lights$2[i];
			if (light.isDirectionalLight) {
				const uniforms = state.directional[directionalLength];
				uniforms.direction.setFromMatrixPosition(light.matrixWorld);
				vector3.setFromMatrixPosition(light.target.matrixWorld);
				uniforms.direction.sub(vector3);
				uniforms.direction.transformDirection(viewMatrix);
				directionalLength++;
			} else if (light.isSpotLight) {
				const uniforms = state.spot[spotLength];
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.position.applyMatrix4(viewMatrix);
				uniforms.direction.setFromMatrixPosition(light.matrixWorld);
				vector3.setFromMatrixPosition(light.target.matrixWorld);
				uniforms.direction.sub(vector3);
				uniforms.direction.transformDirection(viewMatrix);
				spotLength++;
			} else if (light.isRectAreaLight) {
				const uniforms = state.rectArea[rectAreaLength];
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.position.applyMatrix4(viewMatrix);
				matrix42.identity();
				matrix4.copy(light.matrixWorld);
				matrix4.premultiply(viewMatrix);
				matrix42.extractRotation(matrix4);
				uniforms.halfWidth.set(light.width * .5, 0, 0);
				uniforms.halfHeight.set(0, light.height * .5, 0);
				uniforms.halfWidth.applyMatrix4(matrix42);
				uniforms.halfHeight.applyMatrix4(matrix42);
				rectAreaLength++;
			} else if (light.isPointLight) {
				const uniforms = state.point[pointLength];
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.position.applyMatrix4(viewMatrix);
				pointLength++;
			} else if (light.isHemisphereLight) {
				const uniforms = state.hemi[hemiLength];
				uniforms.direction.setFromMatrixPosition(light.matrixWorld);
				uniforms.direction.transformDirection(viewMatrix);
				hemiLength++;
			}
		}
	}
	return {
		setup,
		setupView,
		state
	};
}
function WebGLRenderState(extensions) {
	const lights$2 = new WebGLLights(extensions);
	const lightsArray = [];
	const shadowsArray = [];
	function init(camera) {
		state.camera = camera;
		lightsArray.length = 0;
		shadowsArray.length = 0;
	}
	function pushLight(light) {
		lightsArray.push(light);
	}
	function pushShadow(shadowLight) {
		shadowsArray.push(shadowLight);
	}
	function setupLights() {
		lights$2.setup(lightsArray);
	}
	function setupLightsView(camera) {
		lights$2.setupView(lightsArray, camera);
	}
	const state = {
		lightsArray,
		shadowsArray,
		camera: null,
		lights: lights$2,
		transmissionRenderTarget: {}
	};
	return {
		init,
		state,
		setupLights,
		setupLightsView,
		pushLight,
		pushShadow
	};
}
function WebGLRenderStates(extensions) {
	let renderStates = /* @__PURE__ */ new WeakMap();
	function get$1(scene, renderCallDepth = 0) {
		const renderStateArray = renderStates.get(scene);
		let renderState;
		if (renderStateArray === void 0) {
			renderState = new WebGLRenderState(extensions);
			renderStates.set(scene, [renderState]);
		} else if (renderCallDepth >= renderStateArray.length) {
			renderState = new WebGLRenderState(extensions);
			renderStateArray.push(renderState);
		} else renderState = renderStateArray[renderCallDepth];
		return renderState;
	}
	function dispose() {
		renderStates = /* @__PURE__ */ new WeakMap();
	}
	return {
		get: get$1,
		dispose
	};
}
var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(renderer, objects, capabilities) {
	let _frustum$2 = new Frustum();
	const _shadowMapSize$1 = new Vector2(), _viewportSize$1 = new Vector2(), _viewport$1 = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize;
	const shadowSide = {
		[FrontSide]: BackSide,
		[BackSide]: FrontSide,
		[DoubleSide]: DoubleSide
	};
	const shadowMaterialVertical = new ShaderMaterial({
		defines: { VSM_SAMPLES: 8 },
		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4 }
		},
		vertexShader: vertex,
		fragmentShader: fragment
	});
	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([
		-1,
		-1,
		.5,
		3,
		-1,
		.5,
		-1,
		3,
		.5
	]), 3));
	const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
	const scope = this;
	this.enabled = false;
	this.autoUpdate = true;
	this.needsUpdate = false;
	this.type = PCFShadowMap;
	let _previousType = this.type;
	this.render = function(lights$2, scene, camera) {
		if (scope.enabled === false) return;
		if (scope.autoUpdate === false && scope.needsUpdate === false) return;
		if (lights$2.length === 0) return;
		const currentRenderTarget = renderer.getRenderTarget();
		const activeCubeFace = renderer.getActiveCubeFace();
		const activeMipmapLevel = renderer.getActiveMipmapLevel();
		const _state = renderer.state;
		_state.setBlending(NoBlending);
		if (_state.buffers.depth.getReversed() === true) _state.buffers.color.setClear(0, 0, 0, 0);
		else _state.buffers.color.setClear(1, 1, 1, 1);
		_state.buffers.depth.setTest(true);
		_state.setScissorTest(false);
		const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
		const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
		for (let i = 0, il = lights$2.length; i < il; i++) {
			const light = lights$2[i];
			const shadow$2 = light.shadow;
			if (shadow$2 === void 0) {
				warn("WebGLShadowMap:", light, "has no shadow.");
				continue;
			}
			if (shadow$2.autoUpdate === false && shadow$2.needsUpdate === false) continue;
			_shadowMapSize$1.copy(shadow$2.mapSize);
			const shadowFrameExtents = shadow$2.getFrameExtents();
			_shadowMapSize$1.multiply(shadowFrameExtents);
			_viewportSize$1.copy(shadow$2.mapSize);
			if (_shadowMapSize$1.x > _maxTextureSize || _shadowMapSize$1.y > _maxTextureSize) {
				if (_shadowMapSize$1.x > _maxTextureSize) {
					_viewportSize$1.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
					_shadowMapSize$1.x = _viewportSize$1.x * shadowFrameExtents.x;
					shadow$2.mapSize.x = _viewportSize$1.x;
				}
				if (_shadowMapSize$1.y > _maxTextureSize) {
					_viewportSize$1.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
					_shadowMapSize$1.y = _viewportSize$1.y * shadowFrameExtents.y;
					shadow$2.mapSize.y = _viewportSize$1.y;
				}
			}
			if (shadow$2.map === null || toVSM === true || fromVSM === true) {
				const pars = this.type !== VSMShadowMap ? {
					minFilter: NearestFilter,
					magFilter: NearestFilter
				} : {};
				if (shadow$2.map !== null) shadow$2.map.dispose();
				shadow$2.map = new WebGLRenderTarget(_shadowMapSize$1.x, _shadowMapSize$1.y, pars);
				shadow$2.map.texture.name = light.name + ".shadowMap";
				shadow$2.camera.updateProjectionMatrix();
			}
			renderer.setRenderTarget(shadow$2.map);
			renderer.clear();
			const viewportCount = shadow$2.getViewportCount();
			for (let vp = 0; vp < viewportCount; vp++) {
				const viewport$2 = shadow$2.getViewport(vp);
				_viewport$1.set(_viewportSize$1.x * viewport$2.x, _viewportSize$1.y * viewport$2.y, _viewportSize$1.x * viewport$2.z, _viewportSize$1.y * viewport$2.w);
				_state.viewport(_viewport$1);
				shadow$2.updateMatrices(light, vp);
				_frustum$2 = shadow$2.getFrustum();
				renderObject(scene, camera, shadow$2.camera, light, this.type);
			}
			if (shadow$2.isPointLightShadow !== true && this.type === VSMShadowMap) VSMPass(shadow$2, camera);
			shadow$2.needsUpdate = false;
		}
		_previousType = this.type;
		scope.needsUpdate = false;
		renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
	};
	function VSMPass(shadow$2, camera) {
		const geometry = objects.update(fullScreenMesh);
		if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow$2.blurSamples) {
			shadowMaterialVertical.defines.VSM_SAMPLES = shadow$2.blurSamples;
			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow$2.blurSamples;
			shadowMaterialVertical.needsUpdate = true;
			shadowMaterialHorizontal.needsUpdate = true;
		}
		if (shadow$2.mapPass === null) shadow$2.mapPass = new WebGLRenderTarget(_shadowMapSize$1.x, _shadowMapSize$1.y);
		shadowMaterialVertical.uniforms.shadow_pass.value = shadow$2.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow$2.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow$2.radius;
		renderer.setRenderTarget(shadow$2.mapPass);
		renderer.clear();
		renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow$2.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow$2.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow$2.radius;
		renderer.setRenderTarget(shadow$2.map);
		renderer.clear();
		renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
	}
	function getDepthMaterial(object, material, light, type$1) {
		let result = null;
		const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
		if (customMaterial !== void 0) result = customMaterial;
		else {
			result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
			if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0 || material.alphaToCoverage === true) {
				const keyA = result.uuid, keyB = material.uuid;
				let materialsForVariant = _materialCache[keyA];
				if (materialsForVariant === void 0) {
					materialsForVariant = {};
					_materialCache[keyA] = materialsForVariant;
				}
				let cachedMaterial = materialsForVariant[keyB];
				if (cachedMaterial === void 0) {
					cachedMaterial = result.clone();
					materialsForVariant[keyB] = cachedMaterial;
					material.addEventListener("dispose", onMaterialDispose);
				}
				result = cachedMaterial;
			}
		}
		result.visible = material.visible;
		result.wireframe = material.wireframe;
		if (type$1 === VSMShadowMap) result.side = material.shadowSide !== null ? material.shadowSide : material.side;
		else result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
		result.alphaMap = material.alphaMap;
		result.alphaTest = material.alphaToCoverage === true ? .5 : material.alphaTest;
		result.map = material.map;
		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;
		result.displacementMap = material.displacementMap;
		result.displacementScale = material.displacementScale;
		result.displacementBias = material.displacementBias;
		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;
		if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
			const materialProperties = renderer.properties.get(result);
			materialProperties.light = light;
		}
		return result;
	}
	function renderObject(object, camera, shadowCamera, light, type$1) {
		if (object.visible === false) return;
		if (object.layers.test(camera.layers) && (object.isMesh || object.isLine || object.isPoints)) {
			if ((object.castShadow || object.receiveShadow && type$1 === VSMShadowMap) && (!object.frustumCulled || _frustum$2.intersectsObject(object))) {
				object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
				const geometry = objects.update(object);
				const material = object.material;
				if (Array.isArray(material)) {
					const groups = geometry.groups;
					for (let k = 0, kl = groups.length; k < kl; k++) {
						const group = groups[k];
						const groupMaterial = material[group.materialIndex];
						if (groupMaterial && groupMaterial.visible) {
							const depthMaterial = getDepthMaterial(object, groupMaterial, light, type$1);
							object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
							renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
							object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
						}
					}
				} else if (material.visible) {
					const depthMaterial = getDepthMaterial(object, material, light, type$1);
					object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
					renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
					object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
				}
			}
		}
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) renderObject(children[i], camera, shadowCamera, light, type$1);
	}
	function onMaterialDispose(event) {
		event.target.removeEventListener("dispose", onMaterialDispose);
		for (const id in _materialCache) {
			const cache$2 = _materialCache[id];
			const uuid = event.target.uuid;
			if (uuid in cache$2) {
				cache$2[uuid].dispose();
				delete cache$2[uuid];
			}
		}
	}
}
var reversedFuncs = {
	[NeverDepth]: AlwaysDepth,
	[LessDepth]: GreaterDepth,
	[EqualDepth]: NotEqualDepth,
	[LessEqualDepth]: GreaterEqualDepth,
	[AlwaysDepth]: NeverDepth,
	[GreaterDepth]: LessDepth,
	[NotEqualDepth]: EqualDepth,
	[GreaterEqualDepth]: LessEqualDepth
};
function WebGLState(gl, extensions) {
	function ColorBuffer() {
		let locked = false;
		const color$2 = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4(0, 0, 0, 0);
		return {
			setMask: function(colorMask) {
				if (currentColorMask !== colorMask && !locked) {
					gl.colorMask(colorMask, colorMask, colorMask, colorMask);
					currentColorMask = colorMask;
				}
			},
			setLocked: function(lock) {
				locked = lock;
			},
			setClear: function(r, g$1, b$2, a$1, premultipliedAlpha) {
				if (premultipliedAlpha === true) {
					r *= a$1;
					g$1 *= a$1;
					b$2 *= a$1;
				}
				color$2.set(r, g$1, b$2, a$1);
				if (currentColorClear.equals(color$2) === false) {
					gl.clearColor(r, g$1, b$2, a$1);
					currentColorClear.copy(color$2);
				}
			},
			reset: function() {
				locked = false;
				currentColorMask = null;
				currentColorClear.set(-1, 0, 0, 0);
			}
		};
	}
	function DepthBuffer() {
		let locked = false;
		let currentReversed = false;
		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;
		return {
			setReversed: function(reversed) {
				if (currentReversed !== reversed) {
					const ext = extensions.get("EXT_clip_control");
					if (reversed) ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT);
					else ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.NEGATIVE_ONE_TO_ONE_EXT);
					currentReversed = reversed;
					const oldDepth = currentDepthClear;
					currentDepthClear = null;
					this.setClear(oldDepth);
				}
			},
			getReversed: function() {
				return currentReversed;
			},
			setTest: function(depthTest) {
				if (depthTest) enable(gl.DEPTH_TEST);
				else disable(gl.DEPTH_TEST);
			},
			setMask: function(depthMask) {
				if (currentDepthMask !== depthMask && !locked) {
					gl.depthMask(depthMask);
					currentDepthMask = depthMask;
				}
			},
			setFunc: function(depthFunc) {
				if (currentReversed) depthFunc = reversedFuncs[depthFunc];
				if (currentDepthFunc !== depthFunc) {
					switch (depthFunc) {
						case NeverDepth:
							gl.depthFunc(gl.NEVER);
							break;
						case AlwaysDepth:
							gl.depthFunc(gl.ALWAYS);
							break;
						case LessDepth:
							gl.depthFunc(gl.LESS);
							break;
						case LessEqualDepth:
							gl.depthFunc(gl.LEQUAL);
							break;
						case EqualDepth:
							gl.depthFunc(gl.EQUAL);
							break;
						case GreaterEqualDepth:
							gl.depthFunc(gl.GEQUAL);
							break;
						case GreaterDepth:
							gl.depthFunc(gl.GREATER);
							break;
						case NotEqualDepth:
							gl.depthFunc(gl.NOTEQUAL);
							break;
						default: gl.depthFunc(gl.LEQUAL);
					}
					currentDepthFunc = depthFunc;
				}
			},
			setLocked: function(lock) {
				locked = lock;
			},
			setClear: function(depth$2) {
				if (currentDepthClear !== depth$2) {
					if (currentReversed) depth$2 = 1 - depth$2;
					gl.clearDepth(depth$2);
					currentDepthClear = depth$2;
				}
			},
			reset: function() {
				locked = false;
				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;
				currentReversed = false;
			}
		};
	}
	function StencilBuffer() {
		let locked = false;
		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;
		return {
			setTest: function(stencilTest) {
				if (!locked) if (stencilTest) enable(gl.STENCIL_TEST);
				else disable(gl.STENCIL_TEST);
			},
			setMask: function(stencilMask) {
				if (currentStencilMask !== stencilMask && !locked) {
					gl.stencilMask(stencilMask);
					currentStencilMask = stencilMask;
				}
			},
			setFunc: function(stencilFunc, stencilRef, stencilMask) {
				if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
					gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;
				}
			},
			setOp: function(stencilFail, stencilZFail, stencilZPass) {
				if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
					gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;
				}
			},
			setLocked: function(lock) {
				locked = lock;
			},
			setClear: function(stencil) {
				if (currentStencilClear !== stencil) {
					gl.clearStencil(stencil);
					currentStencilClear = stencil;
				}
			},
			reset: function() {
				locked = false;
				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;
			}
		};
	}
	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();
	const uboBindings = /* @__PURE__ */ new WeakMap();
	const uboProgramMap = /* @__PURE__ */ new WeakMap();
	let enabledCapabilities = {};
	let currentBoundFramebuffers = {};
	let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
	let defaultDrawbuffers = [];
	let currentProgram = null;
	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentBlendColor = new Color$1(0, 0, 0);
	let currentBlendAlpha = 0;
	let currentPremultipledAlpha = false;
	let currentFlipSided = null;
	let currentCullFace = null;
	let currentLineWidth = null;
	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;
	const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter(gl.VERSION);
	if (glVersion.indexOf("WebGL") !== -1) {
		version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
		lineWidthAvailable = version >= 1;
	} else if (glVersion.indexOf("OpenGL ES") !== -1) {
		version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
		lineWidthAvailable = version >= 2;
	}
	let currentTextureSlot = null;
	let currentBoundTextures = {};
	const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
	const viewportParam = gl.getParameter(gl.VIEWPORT);
	const currentScissor = new Vector4().fromArray(scissorParam);
	const currentViewport = new Vector4().fromArray(viewportParam);
	function createTexture(type$1, target, count, dimensions) {
		const data = new Uint8Array(4);
		const texture$2 = gl.createTexture();
		gl.bindTexture(type$1, texture$2);
		gl.texParameteri(type$1, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(type$1, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		for (let i = 0; i < count; i++) if (type$1 === gl.TEXTURE_3D || type$1 === gl.TEXTURE_2D_ARRAY) gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
		else gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
		return texture$2;
	}
	const emptyTextures = {};
	emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
	emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
	emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
	emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
	colorBuffer.setClear(0, 0, 0, 1);
	depthBuffer.setClear(1);
	stencilBuffer.setClear(0);
	enable(gl.DEPTH_TEST);
	depthBuffer.setFunc(LessEqualDepth);
	setFlipSided(false);
	setCullFace(CullFaceBack);
	enable(gl.CULL_FACE);
	setBlending(NoBlending);
	function enable(id) {
		if (enabledCapabilities[id] !== true) {
			gl.enable(id);
			enabledCapabilities[id] = true;
		}
	}
	function disable(id) {
		if (enabledCapabilities[id] !== false) {
			gl.disable(id);
			enabledCapabilities[id] = false;
		}
	}
	function bindFramebuffer(target, framebuffer) {
		if (currentBoundFramebuffers[target] !== framebuffer) {
			gl.bindFramebuffer(target, framebuffer);
			currentBoundFramebuffers[target] = framebuffer;
			if (target === gl.DRAW_FRAMEBUFFER) currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
			if (target === gl.FRAMEBUFFER) currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
			return true;
		}
		return false;
	}
	function drawBuffers(renderTarget, framebuffer) {
		let drawBuffers$1 = defaultDrawbuffers;
		let needsUpdate = false;
		if (renderTarget) {
			drawBuffers$1 = currentDrawbuffers.get(framebuffer);
			if (drawBuffers$1 === void 0) {
				drawBuffers$1 = [];
				currentDrawbuffers.set(framebuffer, drawBuffers$1);
			}
			const textures = renderTarget.textures;
			if (drawBuffers$1.length !== textures.length || drawBuffers$1[0] !== gl.COLOR_ATTACHMENT0) {
				for (let i = 0, il = textures.length; i < il; i++) drawBuffers$1[i] = gl.COLOR_ATTACHMENT0 + i;
				drawBuffers$1.length = textures.length;
				needsUpdate = true;
			}
		} else if (drawBuffers$1[0] !== gl.BACK) {
			drawBuffers$1[0] = gl.BACK;
			needsUpdate = true;
		}
		if (needsUpdate) gl.drawBuffers(drawBuffers$1);
	}
	function useProgram(program) {
		if (currentProgram !== program) {
			gl.useProgram(program);
			currentProgram = program;
			return true;
		}
		return false;
	}
	const equationToGL$1 = {
		[AddEquation]: gl.FUNC_ADD,
		[SubtractEquation]: gl.FUNC_SUBTRACT,
		[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
	};
	equationToGL$1[MinEquation] = gl.MIN;
	equationToGL$1[MaxEquation] = gl.MAX;
	const factorToGL$1 = {
		[ZeroFactor]: gl.ZERO,
		[OneFactor]: gl.ONE,
		[SrcColorFactor]: gl.SRC_COLOR,
		[SrcAlphaFactor]: gl.SRC_ALPHA,
		[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
		[DstColorFactor]: gl.DST_COLOR,
		[DstAlphaFactor]: gl.DST_ALPHA,
		[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
		[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
		[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
		[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
		[ConstantColorFactor]: gl.CONSTANT_COLOR,
		[OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,
		[ConstantAlphaFactor]: gl.CONSTANT_ALPHA,
		[OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA
	};
	function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor$2, blendAlpha, premultipliedAlpha) {
		if (blending === NoBlending) {
			if (currentBlendingEnabled === true) {
				disable(gl.BLEND);
				currentBlendingEnabled = false;
			}
			return;
		}
		if (currentBlendingEnabled === false) {
			enable(gl.BLEND);
			currentBlendingEnabled = true;
		}
		if (blending !== CustomBlending) {
			if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
				if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
					gl.blendEquation(gl.FUNC_ADD);
					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;
				}
				if (premultipliedAlpha) switch (blending) {
					case NormalBlending:
						gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
						break;
					case AdditiveBlending:
						gl.blendFunc(gl.ONE, gl.ONE);
						break;
					case SubtractiveBlending:
						gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
						break;
					case MultiplyBlending:
						gl.blendFuncSeparate(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
						break;
					default:
						error("WebGLState: Invalid blending: ", blending);
						break;
				}
				else switch (blending) {
					case NormalBlending:
						gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
						break;
					case AdditiveBlending:
						gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);
						break;
					case SubtractiveBlending:
						error("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
						break;
					case MultiplyBlending:
						error("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
						break;
					default:
						error("WebGLState: Invalid blending: ", blending);
						break;
				}
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
				currentBlendColor.set(0, 0, 0);
				currentBlendAlpha = 0;
				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;
			}
			return;
		}
		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;
		if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
			gl.blendEquationSeparate(equationToGL$1[blendEquation], equationToGL$1[blendEquationAlpha]);
			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;
		}
		if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
			gl.blendFuncSeparate(factorToGL$1[blendSrc], factorToGL$1[blendDst], factorToGL$1[blendSrcAlpha], factorToGL$1[blendDstAlpha]);
			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;
		}
		if (blendColor$2.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
			gl.blendColor(blendColor$2.r, blendColor$2.g, blendColor$2.b, blendAlpha);
			currentBlendColor.copy(blendColor$2);
			currentBlendAlpha = blendAlpha;
		}
		currentBlending = blending;
		currentPremultipledAlpha = false;
	}
	function setMaterial(material, frontFaceCW) {
		material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
		let flipSided = material.side === BackSide;
		if (frontFaceCW) flipSided = !flipSided;
		setFlipSided(flipSided);
		material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
		depthBuffer.setFunc(material.depthFunc);
		depthBuffer.setTest(material.depthTest);
		depthBuffer.setMask(material.depthWrite);
		colorBuffer.setMask(material.colorWrite);
		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest(stencilWrite);
		if (stencilWrite) {
			stencilBuffer.setMask(material.stencilWriteMask);
			stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
			stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
		}
		setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
		material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
	}
	function setFlipSided(flipSided) {
		if (currentFlipSided !== flipSided) {
			if (flipSided) gl.frontFace(gl.CW);
			else gl.frontFace(gl.CCW);
			currentFlipSided = flipSided;
		}
	}
	function setCullFace(cullFace) {
		if (cullFace !== CullFaceNone) {
			enable(gl.CULL_FACE);
			if (cullFace !== currentCullFace) if (cullFace === CullFaceBack) gl.cullFace(gl.BACK);
			else if (cullFace === CullFaceFront) gl.cullFace(gl.FRONT);
			else gl.cullFace(gl.FRONT_AND_BACK);
		} else disable(gl.CULL_FACE);
		currentCullFace = cullFace;
	}
	function setLineWidth(width) {
		if (width !== currentLineWidth) {
			if (lineWidthAvailable) gl.lineWidth(width);
			currentLineWidth = width;
		}
	}
	function setPolygonOffset(polygonOffset, factor, units) {
		if (polygonOffset) {
			enable(gl.POLYGON_OFFSET_FILL);
			if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
				gl.polygonOffset(factor, units);
				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;
			}
		} else disable(gl.POLYGON_OFFSET_FILL);
	}
	function setScissorTest(scissorTest) {
		if (scissorTest) enable(gl.SCISSOR_TEST);
		else disable(gl.SCISSOR_TEST);
	}
	function activeTexture(webglSlot) {
		if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
		if (currentTextureSlot !== webglSlot) {
			gl.activeTexture(webglSlot);
			currentTextureSlot = webglSlot;
		}
	}
	function bindTexture(webglType, webglTexture, webglSlot) {
		if (webglSlot === void 0) if (currentTextureSlot === null) webglSlot = gl.TEXTURE0 + maxTextures - 1;
		else webglSlot = currentTextureSlot;
		let boundTexture = currentBoundTextures[webglSlot];
		if (boundTexture === void 0) {
			boundTexture = {
				type: void 0,
				texture: void 0
			};
			currentBoundTextures[webglSlot] = boundTexture;
		}
		if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
			gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;
		}
	}
	function unbindTexture() {
		const boundTexture = currentBoundTextures[currentTextureSlot];
		if (boundTexture !== void 0 && boundTexture.type !== void 0) {
			gl.bindTexture(boundTexture.type, null);
			boundTexture.type = void 0;
			boundTexture.texture = void 0;
		}
	}
	function compressedTexImage2D() {
		try {
			gl.compressedTexImage2D(...arguments);
		} catch (error$1) {
			error$1("WebGLState:", error$1);
		}
	}
	function compressedTexImage3D() {
		try {
			gl.compressedTexImage3D(...arguments);
		} catch (error$1) {
			error$1("WebGLState:", error$1);
		}
	}
	function texSubImage2D() {
		try {
			gl.texSubImage2D(...arguments);
		} catch (error$1) {
			error$1("WebGLState:", error$1);
		}
	}
	function texSubImage3D() {
		try {
			gl.texSubImage3D(...arguments);
		} catch (error$1) {
			error$1("WebGLState:", error$1);
		}
	}
	function compressedTexSubImage2D() {
		try {
			gl.compressedTexSubImage2D(...arguments);
		} catch (error$1) {
			error$1("WebGLState:", error$1);
		}
	}
	function compressedTexSubImage3D() {
		try {
			gl.compressedTexSubImage3D(...arguments);
		} catch (error$1) {
			error$1("WebGLState:", error$1);
		}
	}
	function texStorage2D() {
		try {
			gl.texStorage2D(...arguments);
		} catch (error$1) {
			error$1("WebGLState:", error$1);
		}
	}
	function texStorage3D() {
		try {
			gl.texStorage3D(...arguments);
		} catch (error$1) {
			error$1("WebGLState:", error$1);
		}
	}
	function texImage2D() {
		try {
			gl.texImage2D(...arguments);
		} catch (error$1) {
			error$1("WebGLState:", error$1);
		}
	}
	function texImage3D() {
		try {
			gl.texImage3D(...arguments);
		} catch (error$1) {
			error$1("WebGLState:", error$1);
		}
	}
	function scissor(scissor$1) {
		if (currentScissor.equals(scissor$1) === false) {
			gl.scissor(scissor$1.x, scissor$1.y, scissor$1.z, scissor$1.w);
			currentScissor.copy(scissor$1);
		}
	}
	function viewport$2(viewport$3) {
		if (currentViewport.equals(viewport$3) === false) {
			gl.viewport(viewport$3.x, viewport$3.y, viewport$3.z, viewport$3.w);
			currentViewport.copy(viewport$3);
		}
	}
	function updateUBOMapping(uniformsGroup, program) {
		let mapping = uboProgramMap.get(program);
		if (mapping === void 0) {
			mapping = /* @__PURE__ */ new WeakMap();
			uboProgramMap.set(program, mapping);
		}
		let blockIndex = mapping.get(uniformsGroup);
		if (blockIndex === void 0) {
			blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
			mapping.set(uniformsGroup, blockIndex);
		}
	}
	function uniformBlockBinding(uniformsGroup, program) {
		const blockIndex = uboProgramMap.get(program).get(uniformsGroup);
		if (uboBindings.get(program) !== blockIndex) {
			gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
			uboBindings.set(program, blockIndex);
		}
	}
	function reset() {
		gl.disable(gl.BLEND);
		gl.disable(gl.CULL_FACE);
		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.POLYGON_OFFSET_FILL);
		gl.disable(gl.SCISSOR_TEST);
		gl.disable(gl.STENCIL_TEST);
		gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
		gl.blendEquation(gl.FUNC_ADD);
		gl.blendFunc(gl.ONE, gl.ZERO);
		gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
		gl.blendColor(0, 0, 0, 0);
		gl.colorMask(true, true, true, true);
		gl.clearColor(0, 0, 0, 0);
		gl.depthMask(true);
		gl.depthFunc(gl.LESS);
		depthBuffer.setReversed(false);
		gl.clearDepth(1);
		gl.stencilMask(4294967295);
		gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
		gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
		gl.clearStencil(0);
		gl.cullFace(gl.BACK);
		gl.frontFace(gl.CCW);
		gl.polygonOffset(0, 0);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
		gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
		gl.useProgram(null);
		gl.lineWidth(1);
		gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
		enabledCapabilities = {};
		currentTextureSlot = null;
		currentBoundTextures = {};
		currentBoundFramebuffers = {};
		currentDrawbuffers = /* @__PURE__ */ new WeakMap();
		defaultDrawbuffers = [];
		currentProgram = null;
		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentBlendColor = new Color$1(0, 0, 0);
		currentBlendAlpha = 0;
		currentPremultipledAlpha = false;
		currentFlipSided = null;
		currentCullFace = null;
		currentLineWidth = null;
		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;
		currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
		currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();
	}
	return {
		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},
		enable,
		disable,
		bindFramebuffer,
		drawBuffers,
		useProgram,
		setBlending,
		setMaterial,
		setFlipSided,
		setCullFace,
		setLineWidth,
		setPolygonOffset,
		setScissorTest,
		activeTexture,
		bindTexture,
		unbindTexture,
		compressedTexImage2D,
		compressedTexImage3D,
		texImage2D,
		texImage3D,
		updateUBOMapping,
		uniformBlockBinding,
		texStorage2D,
		texStorage3D,
		texSubImage2D,
		texSubImage3D,
		compressedTexSubImage2D,
		compressedTexSubImage3D,
		scissor,
		viewport: viewport$2,
		reset
	};
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
	const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
	const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
	const _imageDimensions = new Vector2();
	const _videoTextures = /* @__PURE__ */ new WeakMap();
	let _canvas$1;
	const _sources = /* @__PURE__ */ new WeakMap();
	let useOffscreenCanvas = false;
	try {
		useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
	} catch (err) {}
	function createCanvas(width, height) {
		return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
	}
	function resizeImage(image, needsNewCanvas, maxSize) {
		let scale$3 = 1;
		const dimensions = getDimensions(image);
		if (dimensions.width > maxSize || dimensions.height > maxSize) scale$3 = maxSize / Math.max(dimensions.width, dimensions.height);
		if (scale$3 < 1) if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap || typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
			const width = Math.floor(scale$3 * dimensions.width);
			const height = Math.floor(scale$3 * dimensions.height);
			if (_canvas$1 === void 0) _canvas$1 = createCanvas(width, height);
			const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas$1;
			canvas.width = width;
			canvas.height = height;
			canvas.getContext("2d").drawImage(image, 0, 0, width, height);
			warn("WebGLRenderer: Texture has been resized from (" + dimensions.width + "x" + dimensions.height + ") to (" + width + "x" + height + ").");
			return canvas;
		} else {
			if ("data" in image) warn("WebGLRenderer: Image in DataTexture is too big (" + dimensions.width + "x" + dimensions.height + ").");
			return image;
		}
		return image;
	}
	function textureNeedsGenerateMipmaps(texture$2) {
		return texture$2.generateMipmaps;
	}
	function generateMipmap(target) {
		_gl.generateMipmap(target);
	}
	function getTargetType(texture$2) {
		if (texture$2.isWebGLCubeRenderTarget) return _gl.TEXTURE_CUBE_MAP;
		if (texture$2.isWebGL3DRenderTarget) return _gl.TEXTURE_3D;
		if (texture$2.isWebGLArrayRenderTarget || texture$2.isCompressedArrayTexture) return _gl.TEXTURE_2D_ARRAY;
		return _gl.TEXTURE_2D;
	}
	function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
		if (internalFormatName !== null) {
			if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
			warn("WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
		}
		let internalFormat = glFormat;
		if (glFormat === _gl.RED) {
			if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
		}
		if (glFormat === _gl.RED_INTEGER) {
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
			if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
			if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
			if (glType === _gl.BYTE) internalFormat = _gl.R8I;
			if (glType === _gl.SHORT) internalFormat = _gl.R16I;
			if (glType === _gl.INT) internalFormat = _gl.R32I;
		}
		if (glFormat === _gl.RG) {
			if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
		}
		if (glFormat === _gl.RG_INTEGER) {
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
			if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
			if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
			if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
			if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
			if (glType === _gl.INT) internalFormat = _gl.RG32I;
		}
		if (glFormat === _gl.RGB_INTEGER) {
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8UI;
			if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGB16UI;
			if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGB32UI;
			if (glType === _gl.BYTE) internalFormat = _gl.RGB8I;
			if (glType === _gl.SHORT) internalFormat = _gl.RGB16I;
			if (glType === _gl.INT) internalFormat = _gl.RGB32I;
		}
		if (glFormat === _gl.RGBA_INTEGER) {
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8UI;
			if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGBA16UI;
			if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGBA32UI;
			if (glType === _gl.BYTE) internalFormat = _gl.RGBA8I;
			if (glType === _gl.SHORT) internalFormat = _gl.RGBA16I;
			if (glType === _gl.INT) internalFormat = _gl.RGBA32I;
		}
		if (glFormat === _gl.RGB) {
			if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;
			if (glType === _gl.UNSIGNED_INT_10F_11F_11F_REV) internalFormat = _gl.R11F_G11F_B10F;
		}
		if (glFormat === _gl.RGBA) {
			const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
			if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
			if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
			if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
		}
		if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) extensions.get("EXT_color_buffer_float");
		return internalFormat;
	}
	function getInternalDepthFormat(useStencil, depthType) {
		let glInternalFormat;
		if (useStencil) {
			if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) glInternalFormat = _gl.DEPTH24_STENCIL8;
			else if (depthType === FloatType) glInternalFormat = _gl.DEPTH32F_STENCIL8;
			else if (depthType === UnsignedShortType) {
				glInternalFormat = _gl.DEPTH24_STENCIL8;
				warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.");
			}
		} else if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) glInternalFormat = _gl.DEPTH_COMPONENT24;
		else if (depthType === FloatType) glInternalFormat = _gl.DEPTH_COMPONENT32F;
		else if (depthType === UnsignedShortType) glInternalFormat = _gl.DEPTH_COMPONENT16;
		return glInternalFormat;
	}
	function getMipLevels(texture$2, image) {
		if (textureNeedsGenerateMipmaps(texture$2) === true || texture$2.isFramebufferTexture && texture$2.minFilter !== NearestFilter && texture$2.minFilter !== LinearFilter) return Math.log2(Math.max(image.width, image.height)) + 1;
		else if (texture$2.mipmaps !== void 0 && texture$2.mipmaps.length > 0) return texture$2.mipmaps.length;
		else if (texture$2.isCompressedTexture && Array.isArray(texture$2.image)) return image.mipmaps.length;
		else return 1;
	}
	function onTextureDispose$1(event) {
		const texture$2 = event.target;
		texture$2.removeEventListener("dispose", onTextureDispose$1);
		deallocateTexture(texture$2);
		if (texture$2.isVideoTexture) _videoTextures.delete(texture$2);
	}
	function onRenderTargetDispose(event) {
		const renderTarget = event.target;
		renderTarget.removeEventListener("dispose", onRenderTargetDispose);
		deallocateRenderTarget(renderTarget);
	}
	function deallocateTexture(texture$2) {
		const textureProperties = properties.get(texture$2);
		if (textureProperties.__webglInit === void 0) return;
		const source = texture$2.source;
		const webglTextures = _sources.get(source);
		if (webglTextures) {
			const webglTexture = webglTextures[textureProperties.__cacheKey];
			webglTexture.usedTimes--;
			if (webglTexture.usedTimes === 0) deleteTexture(texture$2);
			if (Object.keys(webglTextures).length === 0) _sources.delete(source);
		}
		properties.remove(texture$2);
	}
	function deleteTexture(texture$2) {
		const textureProperties = properties.get(texture$2);
		_gl.deleteTexture(textureProperties.__webglTexture);
		const source = texture$2.source;
		const webglTextures = _sources.get(source);
		delete webglTextures[textureProperties.__cacheKey];
		info.memory.textures--;
	}
	function deallocateRenderTarget(renderTarget) {
		const renderTargetProperties = properties.get(renderTarget);
		if (renderTarget.depthTexture) {
			renderTarget.depthTexture.dispose();
			properties.remove(renderTarget.depthTexture);
		}
		if (renderTarget.isWebGLCubeRenderTarget) for (let i = 0; i < 6; i++) {
			if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
			else _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
			if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
		}
		else {
			if (Array.isArray(renderTargetProperties.__webglFramebuffer)) for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
			else _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
			if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
			if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
			if (renderTargetProperties.__webglColorRenderbuffer) {
				for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) if (renderTargetProperties.__webglColorRenderbuffer[i]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
			}
			if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
		}
		const textures = renderTarget.textures;
		for (let i = 0, il = textures.length; i < il; i++) {
			const attachmentProperties = properties.get(textures[i]);
			if (attachmentProperties.__webglTexture) {
				_gl.deleteTexture(attachmentProperties.__webglTexture);
				info.memory.textures--;
			}
			properties.remove(textures[i]);
		}
		properties.remove(renderTarget);
	}
	let textureUnits = 0;
	function resetTextureUnits() {
		textureUnits = 0;
	}
	function allocateTextureUnit() {
		const textureUnit = textureUnits;
		if (textureUnit >= capabilities.maxTextures) warn("WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
		textureUnits += 1;
		return textureUnit;
	}
	function getTextureCacheKey(texture$2) {
		const array$2 = [];
		array$2.push(texture$2.wrapS);
		array$2.push(texture$2.wrapT);
		array$2.push(texture$2.wrapR || 0);
		array$2.push(texture$2.magFilter);
		array$2.push(texture$2.minFilter);
		array$2.push(texture$2.anisotropy);
		array$2.push(texture$2.internalFormat);
		array$2.push(texture$2.format);
		array$2.push(texture$2.type);
		array$2.push(texture$2.generateMipmaps);
		array$2.push(texture$2.premultiplyAlpha);
		array$2.push(texture$2.flipY);
		array$2.push(texture$2.unpackAlignment);
		array$2.push(texture$2.colorSpace);
		return array$2.join();
	}
	function setTexture2D(texture$2, slot) {
		const textureProperties = properties.get(texture$2);
		if (texture$2.isVideoTexture) updateVideoTexture(texture$2);
		if (texture$2.isRenderTargetTexture === false && texture$2.isExternalTexture !== true && texture$2.version > 0 && textureProperties.__version !== texture$2.version) {
			const image = texture$2.image;
			if (image === null) warn("WebGLRenderer: Texture marked for update but no image data found.");
			else if (image.complete === false) warn("WebGLRenderer: Texture marked for update but image is incomplete");
			else {
				uploadTexture(textureProperties, texture$2, slot);
				return;
			}
		} else if (texture$2.isExternalTexture) textureProperties.__webglTexture = texture$2.sourceTexture ? texture$2.sourceTexture : null;
		state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	function setTexture2DArray(texture$2, slot) {
		const textureProperties = properties.get(texture$2);
		if (texture$2.isRenderTargetTexture === false && texture$2.version > 0 && textureProperties.__version !== texture$2.version) {
			uploadTexture(textureProperties, texture$2, slot);
			return;
		} else if (texture$2.isExternalTexture) textureProperties.__webglTexture = texture$2.sourceTexture ? texture$2.sourceTexture : null;
		state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	function setTexture3D(texture$2, slot) {
		const textureProperties = properties.get(texture$2);
		if (texture$2.isRenderTargetTexture === false && texture$2.version > 0 && textureProperties.__version !== texture$2.version) {
			uploadTexture(textureProperties, texture$2, slot);
			return;
		}
		state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	function setTextureCube(texture$2, slot) {
		const textureProperties = properties.get(texture$2);
		if (texture$2.version > 0 && textureProperties.__version !== texture$2.version) {
			uploadCubeTexture(textureProperties, texture$2, slot);
			return;
		}
		state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	const wrappingToGL$1 = {
		[RepeatWrapping]: _gl.REPEAT,
		[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
		[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
	};
	const filterToGL$1 = {
		[NearestFilter]: _gl.NEAREST,
		[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
		[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
		[LinearFilter]: _gl.LINEAR,
		[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
		[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
	};
	const compareToGL$1 = {
		[NeverCompare]: _gl.NEVER,
		[AlwaysCompare]: _gl.ALWAYS,
		[LessCompare]: _gl.LESS,
		[LessEqualCompare]: _gl.LEQUAL,
		[EqualCompare]: _gl.EQUAL,
		[GreaterEqualCompare]: _gl.GEQUAL,
		[GreaterCompare]: _gl.GREATER,
		[NotEqualCompare]: _gl.NOTEQUAL
	};
	function setTextureParameters(textureType, texture$2) {
		if (texture$2.type === FloatType && extensions.has("OES_texture_float_linear") === false && (texture$2.magFilter === LinearFilter || texture$2.magFilter === LinearMipmapNearestFilter || texture$2.magFilter === NearestMipmapLinearFilter || texture$2.magFilter === LinearMipmapLinearFilter || texture$2.minFilter === LinearFilter || texture$2.minFilter === LinearMipmapNearestFilter || texture$2.minFilter === NearestMipmapLinearFilter || texture$2.minFilter === LinearMipmapLinearFilter)) warn("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.");
		_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL$1[texture$2.wrapS]);
		_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL$1[texture$2.wrapT]);
		if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL$1[texture$2.wrapR]);
		_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL$1[texture$2.magFilter]);
		_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL$1[texture$2.minFilter]);
		if (texture$2.compareFunction) {
			_gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
			_gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL$1[texture$2.compareFunction]);
		}
		if (extensions.has("EXT_texture_filter_anisotropic") === true) {
			if (texture$2.magFilter === NearestFilter) return;
			if (texture$2.minFilter !== NearestMipmapLinearFilter && texture$2.minFilter !== LinearMipmapLinearFilter) return;
			if (texture$2.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
			if (texture$2.anisotropy > 1 || properties.get(texture$2).__currentAnisotropy) {
				const extension = extensions.get("EXT_texture_filter_anisotropic");
				_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture$2.anisotropy, capabilities.getMaxAnisotropy()));
				properties.get(texture$2).__currentAnisotropy = texture$2.anisotropy;
			}
		}
	}
	function initTexture(textureProperties, texture$2) {
		let forceUpload = false;
		if (textureProperties.__webglInit === void 0) {
			textureProperties.__webglInit = true;
			texture$2.addEventListener("dispose", onTextureDispose$1);
		}
		const source = texture$2.source;
		let webglTextures = _sources.get(source);
		if (webglTextures === void 0) {
			webglTextures = {};
			_sources.set(source, webglTextures);
		}
		const textureCacheKey = getTextureCacheKey(texture$2);
		if (textureCacheKey !== textureProperties.__cacheKey) {
			if (webglTextures[textureCacheKey] === void 0) {
				webglTextures[textureCacheKey] = {
					texture: _gl.createTexture(),
					usedTimes: 0
				};
				info.memory.textures++;
				forceUpload = true;
			}
			webglTextures[textureCacheKey].usedTimes++;
			const webglTexture = webglTextures[textureProperties.__cacheKey];
			if (webglTexture !== void 0) {
				webglTextures[textureProperties.__cacheKey].usedTimes--;
				if (webglTexture.usedTimes === 0) deleteTexture(texture$2);
			}
			textureProperties.__cacheKey = textureCacheKey;
			textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
		}
		return forceUpload;
	}
	function getRow(index, rowLength, componentStride) {
		return Math.floor(Math.floor(index / componentStride) / rowLength);
	}
	function updateTexture(texture$2, image, glFormat, glType) {
		const componentStride = 4;
		const updateRanges = texture$2.updateRanges;
		if (updateRanges.length === 0) state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
		else {
			updateRanges.sort((a$1, b$2) => a$1.start - b$2.start);
			let mergeIndex = 0;
			for (let i = 1; i < updateRanges.length; i++) {
				const previousRange = updateRanges[mergeIndex];
				const range$3 = updateRanges[i];
				const previousEnd = previousRange.start + previousRange.count;
				const currentRow = getRow(range$3.start, image.width, componentStride);
				const previousRow = getRow(previousRange.start, image.width, componentStride);
				if (range$3.start <= previousEnd + 1 && currentRow === previousRow && getRow(range$3.start + range$3.count - 1, image.width, componentStride) === currentRow) previousRange.count = Math.max(previousRange.count, range$3.start + range$3.count - previousRange.start);
				else {
					++mergeIndex;
					updateRanges[mergeIndex] = range$3;
				}
			}
			updateRanges.length = mergeIndex + 1;
			const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
			const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
			const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
			for (let i = 0, l = updateRanges.length; i < l; i++) {
				const range$3 = updateRanges[i];
				const pixelStart = Math.floor(range$3.start / componentStride);
				const pixelCount = Math.ceil(range$3.count / componentStride);
				const x = pixelStart % image.width;
				const y = Math.floor(pixelStart / image.width);
				const width = pixelCount;
				const height = 1;
				_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, x);
				_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, y);
				state.texSubImage2D(_gl.TEXTURE_2D, 0, x, y, width, height, glFormat, glType, image.data);
			}
			texture$2.clearUpdateRanges();
			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
		}
	}
	function uploadTexture(textureProperties, texture$2, slot) {
		let textureType = _gl.TEXTURE_2D;
		if (texture$2.isDataArrayTexture || texture$2.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
		if (texture$2.isData3DTexture) textureType = _gl.TEXTURE_3D;
		const forceUpload = initTexture(textureProperties, texture$2);
		const source = texture$2.source;
		state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		const sourceProperties = properties.get(source);
		if (source.version !== sourceProperties.__version || forceUpload === true) {
			state.activeTexture(_gl.TEXTURE0 + slot);
			const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
			const texturePrimaries = texture$2.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture$2.colorSpace);
			const unpackConversion = texture$2.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture$2.flipY);
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture$2.premultiplyAlpha);
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture$2.unpackAlignment);
			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
			let image = resizeImage(texture$2.image, false, capabilities.maxTextureSize);
			image = verifyColorSpace(texture$2, image);
			const glFormat = utils.convert(texture$2.format, texture$2.colorSpace);
			const glType = utils.convert(texture$2.type);
			let glInternalFormat = getInternalFormat(texture$2.internalFormat, glFormat, glType, texture$2.colorSpace, texture$2.isVideoTexture);
			setTextureParameters(textureType, texture$2);
			let mipmap;
			const mipmaps = texture$2.mipmaps;
			const useTexStorage = texture$2.isVideoTexture !== true;
			const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
			const dataReady = source.dataReady;
			const levels = getMipLevels(texture$2, image);
			if (texture$2.isDepthTexture) {
				glInternalFormat = getInternalDepthFormat(texture$2.format === DepthStencilFormat, texture$2.type);
				if (allocateMemory) if (useTexStorage) state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
				else state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
			} else if (texture$2.isDataTexture) if (mipmaps.length > 0) {
				if (useTexStorage && allocateMemory) state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
				for (let i = 0, il = mipmaps.length; i < il; i++) {
					mipmap = mipmaps[i];
					if (useTexStorage) {
						if (dataReady) state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
					} else state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
				}
				texture$2.generateMipmaps = false;
			} else if (useTexStorage) {
				if (allocateMemory) state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
				if (dataReady) updateTexture(texture$2, image, glFormat, glType);
			} else state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
			else if (texture$2.isCompressedTexture) if (texture$2.isCompressedArrayTexture) {
				if (useTexStorage && allocateMemory) state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
				for (let i = 0, il = mipmaps.length; i < il; i++) {
					mipmap = mipmaps[i];
					if (texture$2.format !== RGBAFormat) if (glFormat !== null) if (useTexStorage) {
						if (dataReady) if (texture$2.layerUpdates.size > 0) {
							const layerByteLength = getByteLength(mipmap.width, mipmap.height, texture$2.format, texture$2.type);
							for (const layerIndex of texture$2.layerUpdates) {
								const layerData = mipmap.data.subarray(layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT, (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT);
								state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData);
							}
							texture$2.clearLayerUpdates();
						} else state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
					} else state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
					else warn("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
					else if (useTexStorage) {
						if (dataReady) state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
					} else state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
				}
			} else {
				if (useTexStorage && allocateMemory) state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
				for (let i = 0, il = mipmaps.length; i < il; i++) {
					mipmap = mipmaps[i];
					if (texture$2.format !== RGBAFormat) if (glFormat !== null) if (useTexStorage) {
						if (dataReady) state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
					} else state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
					else warn("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
					else if (useTexStorage) {
						if (dataReady) state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
					} else state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
				}
			}
			else if (texture$2.isDataArrayTexture) if (useTexStorage) {
				if (allocateMemory) state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
				if (dataReady) if (texture$2.layerUpdates.size > 0) {
					const layerByteLength = getByteLength(image.width, image.height, texture$2.format, texture$2.type);
					for (const layerIndex of texture$2.layerUpdates) {
						const layerData = image.data.subarray(layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT, (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT);
						state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);
					}
					texture$2.clearLayerUpdates();
				} else state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
			} else state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
			else if (texture$2.isData3DTexture) if (useTexStorage) {
				if (allocateMemory) state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
				if (dataReady) state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
			} else state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
			else if (texture$2.isFramebufferTexture) {
				if (allocateMemory) if (useTexStorage) state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
				else {
					let width = image.width, height = image.height;
					for (let i = 0; i < levels; i++) {
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
						width >>= 1;
						height >>= 1;
					}
				}
			} else if (mipmaps.length > 0) {
				if (useTexStorage && allocateMemory) {
					const dimensions = getDimensions(mipmaps[0]);
					state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
				}
				for (let i = 0, il = mipmaps.length; i < il; i++) {
					mipmap = mipmaps[i];
					if (useTexStorage) {
						if (dataReady) state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
					} else state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
				}
				texture$2.generateMipmaps = false;
			} else if (useTexStorage) {
				if (allocateMemory) {
					const dimensions = getDimensions(image);
					state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
				}
				if (dataReady) state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
			} else state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
			if (textureNeedsGenerateMipmaps(texture$2)) generateMipmap(textureType);
			sourceProperties.__version = source.version;
			if (texture$2.onUpdate) texture$2.onUpdate(texture$2);
		}
		textureProperties.__version = texture$2.version;
	}
	function uploadCubeTexture(textureProperties, texture$2, slot) {
		if (texture$2.image.length !== 6) return;
		const forceUpload = initTexture(textureProperties, texture$2);
		const source = texture$2.source;
		state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		const sourceProperties = properties.get(source);
		if (source.version !== sourceProperties.__version || forceUpload === true) {
			state.activeTexture(_gl.TEXTURE0 + slot);
			const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
			const texturePrimaries = texture$2.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture$2.colorSpace);
			const unpackConversion = texture$2.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture$2.flipY);
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture$2.premultiplyAlpha);
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture$2.unpackAlignment);
			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
			const isCompressed = texture$2.isCompressedTexture || texture$2.image[0].isCompressedTexture;
			const isDataTexture = texture$2.image[0] && texture$2.image[0].isDataTexture;
			const cubeImage = [];
			for (let i = 0; i < 6; i++) {
				if (!isCompressed && !isDataTexture) cubeImage[i] = resizeImage(texture$2.image[i], true, capabilities.maxCubemapSize);
				else cubeImage[i] = isDataTexture ? texture$2.image[i].image : texture$2.image[i];
				cubeImage[i] = verifyColorSpace(texture$2, cubeImage[i]);
			}
			const image = cubeImage[0], glFormat = utils.convert(texture$2.format, texture$2.colorSpace), glType = utils.convert(texture$2.type), glInternalFormat = getInternalFormat(texture$2.internalFormat, glFormat, glType, texture$2.colorSpace);
			const useTexStorage = texture$2.isVideoTexture !== true;
			const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
			const dataReady = source.dataReady;
			let levels = getMipLevels(texture$2, image);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture$2);
			let mipmaps;
			if (isCompressed) {
				if (useTexStorage && allocateMemory) state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
				for (let i = 0; i < 6; i++) {
					mipmaps = cubeImage[i].mipmaps;
					for (let j = 0; j < mipmaps.length; j++) {
						const mipmap = mipmaps[j];
						if (texture$2.format !== RGBAFormat) if (glFormat !== null) if (useTexStorage) {
							if (dataReady) state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
						} else state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
						else warn("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
						else if (useTexStorage) {
							if (dataReady) state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
						} else state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}
				}
			} else {
				mipmaps = texture$2.mipmaps;
				if (useTexStorage && allocateMemory) {
					if (mipmaps.length > 0) levels++;
					const dimensions = getDimensions(cubeImage[0]);
					state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
				}
				for (let i = 0; i < 6; i++) if (isDataTexture) {
					if (useTexStorage) {
						if (dataReady) state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
					} else state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
					for (let j = 0; j < mipmaps.length; j++) {
						const mipmapImage = mipmaps[j].image[i].image;
						if (useTexStorage) {
							if (dataReady) state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
						} else state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
					}
				} else {
					if (useTexStorage) {
						if (dataReady) state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
					} else state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
					for (let j = 0; j < mipmaps.length; j++) {
						const mipmap = mipmaps[j];
						if (useTexStorage) {
							if (dataReady) state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
						} else state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
					}
				}
			}
			if (textureNeedsGenerateMipmaps(texture$2)) generateMipmap(_gl.TEXTURE_CUBE_MAP);
			sourceProperties.__version = source.version;
			if (texture$2.onUpdate) texture$2.onUpdate(texture$2);
		}
		textureProperties.__version = texture$2.version;
	}
	function setupFrameBufferTexture(framebuffer, renderTarget, texture$2, attachment, textureTarget, level) {
		const glFormat = utils.convert(texture$2.format, texture$2.colorSpace);
		const glType = utils.convert(texture$2.type);
		const glInternalFormat = getInternalFormat(texture$2.internalFormat, glFormat, glType, texture$2.colorSpace);
		const renderTargetProperties = properties.get(renderTarget);
		const textureProperties = properties.get(texture$2);
		textureProperties.__renderTarget = renderTarget;
		if (!renderTargetProperties.__hasExternalTextures) {
			const width = Math.max(1, renderTarget.width >> level);
			const height = Math.max(1, renderTarget.height >> level);
			if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
			else state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
		}
		state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
		if (useMultisampledRTT(renderTarget)) multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples(renderTarget));
		else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level);
		state.bindFramebuffer(_gl.FRAMEBUFFER, null);
	}
	function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
		_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
		if (renderTarget.depthBuffer) {
			const depthTexture = renderTarget.depthTexture;
			const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
			const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
			const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
			const samples = getRenderTargetSamples(renderTarget);
			if (useMultisampledRTT(renderTarget)) multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
			else if (isMultisample) _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
			else _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
			_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
		} else {
			const textures = renderTarget.textures;
			for (let i = 0; i < textures.length; i++) {
				const texture$2 = textures[i];
				const glFormat = utils.convert(texture$2.format, texture$2.colorSpace);
				const glType = utils.convert(texture$2.type);
				const glInternalFormat = getInternalFormat(texture$2.internalFormat, glFormat, glType, texture$2.colorSpace);
				const samples = getRenderTargetSamples(renderTarget);
				if (isMultisample && useMultisampledRTT(renderTarget) === false) _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				else if (useMultisampledRTT(renderTarget)) multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				else _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
			}
		}
		_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
	}
	function setupDepthTexture(framebuffer, renderTarget) {
		if (renderTarget && renderTarget.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
		state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
		if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
		const textureProperties = properties.get(renderTarget.depthTexture);
		textureProperties.__renderTarget = renderTarget;
		if (!textureProperties.__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;
		}
		setTexture2D(renderTarget.depthTexture, 0);
		const webglDepthTexture = textureProperties.__webglTexture;
		const samples = getRenderTargetSamples(renderTarget);
		if (renderTarget.depthTexture.format === DepthFormat) if (useMultisampledRTT(renderTarget)) multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
		else _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
		else if (renderTarget.depthTexture.format === DepthStencilFormat) if (useMultisampledRTT(renderTarget)) multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
		else _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
		else throw new Error("Unknown depthTexture format");
	}
	function setupDepthRenderbuffer(renderTarget) {
		const renderTargetProperties = properties.get(renderTarget);
		const isCube = renderTarget.isWebGLCubeRenderTarget === true;
		if (renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture) {
			const depthTexture = renderTarget.depthTexture;
			if (renderTargetProperties.__depthDisposeCallback) renderTargetProperties.__depthDisposeCallback();
			if (depthTexture) {
				const disposeEvent = () => {
					delete renderTargetProperties.__boundDepthTexture;
					delete renderTargetProperties.__depthDisposeCallback;
					depthTexture.removeEventListener("dispose", disposeEvent);
				};
				depthTexture.addEventListener("dispose", disposeEvent);
				renderTargetProperties.__depthDisposeCallback = disposeEvent;
			}
			renderTargetProperties.__boundDepthTexture = depthTexture;
		}
		if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
			if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
			const mipmaps = renderTarget.texture.mipmaps;
			if (mipmaps && mipmaps.length > 0) setupDepthTexture(renderTargetProperties.__webglFramebuffer[0], renderTarget);
			else setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
		} else if (isCube) {
			renderTargetProperties.__webglDepthbuffer = [];
			for (let i = 0; i < 6; i++) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
				if (renderTargetProperties.__webglDepthbuffer[i] === void 0) {
					renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
				} else {
					const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
					const renderbuffer = renderTargetProperties.__webglDepthbuffer[i];
					_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
				}
			}
		} else {
			const mipmaps = renderTarget.texture.mipmaps;
			if (mipmaps && mipmaps.length > 0) state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[0]);
			else state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
			if (renderTargetProperties.__webglDepthbuffer === void 0) {
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
			} else {
				const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
				const renderbuffer = renderTargetProperties.__webglDepthbuffer;
				_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
			}
		}
		state.bindFramebuffer(_gl.FRAMEBUFFER, null);
	}
	function rebindTextures(renderTarget, colorTexture, depthTexture) {
		const renderTargetProperties = properties.get(renderTarget);
		if (colorTexture !== void 0) setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
		if (depthTexture !== void 0) setupDepthRenderbuffer(renderTarget);
	}
	function setupRenderTarget(renderTarget) {
		const texture$2 = renderTarget.texture;
		const renderTargetProperties = properties.get(renderTarget);
		const textureProperties = properties.get(texture$2);
		renderTarget.addEventListener("dispose", onRenderTargetDispose);
		const textures = renderTarget.textures;
		const isCube = renderTarget.isWebGLCubeRenderTarget === true;
		const isMultipleRenderTargets = textures.length > 1;
		if (!isMultipleRenderTargets) {
			if (textureProperties.__webglTexture === void 0) textureProperties.__webglTexture = _gl.createTexture();
			textureProperties.__version = texture$2.version;
			info.memory.textures++;
		}
		if (isCube) {
			renderTargetProperties.__webglFramebuffer = [];
			for (let i = 0; i < 6; i++) if (texture$2.mipmaps && texture$2.mipmaps.length > 0) {
				renderTargetProperties.__webglFramebuffer[i] = [];
				for (let level = 0; level < texture$2.mipmaps.length; level++) renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();
			} else renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
		} else {
			if (texture$2.mipmaps && texture$2.mipmaps.length > 0) {
				renderTargetProperties.__webglFramebuffer = [];
				for (let level = 0; level < texture$2.mipmaps.length; level++) renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
			} else renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
			if (isMultipleRenderTargets) for (let i = 0, il = textures.length; i < il; i++) {
				const attachmentProperties = properties.get(textures[i]);
				if (attachmentProperties.__webglTexture === void 0) {
					attachmentProperties.__webglTexture = _gl.createTexture();
					info.memory.textures++;
				}
			}
			if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
				renderTargetProperties.__webglColorRenderbuffer = [];
				state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				for (let i = 0; i < textures.length; i++) {
					const texture$3 = textures[i];
					renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
					_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
					const glFormat = utils.convert(texture$3.format, texture$3.colorSpace);
					const glType = utils.convert(texture$3.type);
					const glInternalFormat = getInternalFormat(texture$3.internalFormat, glFormat, glType, texture$3.colorSpace, renderTarget.isXRRenderTarget === true);
					const samples = getRenderTargetSamples(renderTarget);
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
				}
				_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
				if (renderTarget.depthBuffer) {
					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
				}
				state.bindFramebuffer(_gl.FRAMEBUFFER, null);
			}
		}
		if (isCube) {
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture$2);
			for (let i = 0; i < 6; i++) if (texture$2.mipmaps && texture$2.mipmaps.length > 0) for (let level = 0; level < texture$2.mipmaps.length; level++) setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture$2, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);
			else setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture$2, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
			if (textureNeedsGenerateMipmaps(texture$2)) generateMipmap(_gl.TEXTURE_CUBE_MAP);
			state.unbindTexture();
		} else if (isMultipleRenderTargets) {
			for (let i = 0, il = textures.length; i < il; i++) {
				const attachment = textures[i];
				const attachmentProperties = properties.get(attachment);
				let glTextureType = _gl.TEXTURE_2D;
				if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
				state.bindTexture(glTextureType, attachmentProperties.__webglTexture);
				setTextureParameters(glTextureType, attachment);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, glTextureType, 0);
				if (textureNeedsGenerateMipmaps(attachment)) generateMipmap(glTextureType);
			}
			state.unbindTexture();
		} else {
			let glTextureType = _gl.TEXTURE_2D;
			if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
			state.bindTexture(glTextureType, textureProperties.__webglTexture);
			setTextureParameters(glTextureType, texture$2);
			if (texture$2.mipmaps && texture$2.mipmaps.length > 0) for (let level = 0; level < texture$2.mipmaps.length; level++) setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture$2, _gl.COLOR_ATTACHMENT0, glTextureType, level);
			else setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture$2, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
			if (textureNeedsGenerateMipmaps(texture$2)) generateMipmap(glTextureType);
			state.unbindTexture();
		}
		if (renderTarget.depthBuffer) setupDepthRenderbuffer(renderTarget);
	}
	function updateRenderTargetMipmap(renderTarget) {
		const textures = renderTarget.textures;
		for (let i = 0, il = textures.length; i < il; i++) {
			const texture$2 = textures[i];
			if (textureNeedsGenerateMipmaps(texture$2)) {
				const targetType = getTargetType(renderTarget);
				const webglTexture = properties.get(texture$2).__webglTexture;
				state.bindTexture(targetType, webglTexture);
				generateMipmap(targetType);
				state.unbindTexture();
			}
		}
	}
	const invalidationArrayRead = [];
	const invalidationArrayDraw = [];
	function updateMultisampleRenderTarget(renderTarget) {
		if (renderTarget.samples > 0) {
			if (useMultisampledRTT(renderTarget) === false) {
				const textures = renderTarget.textures;
				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = _gl.COLOR_BUFFER_BIT;
				const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
				const renderTargetProperties = properties.get(renderTarget);
				const isMultipleRenderTargets = textures.length > 1;
				if (isMultipleRenderTargets) for (let i = 0; i < textures.length; i++) {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
				}
				state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				const mipmaps = renderTarget.texture.mipmaps;
				if (mipmaps && mipmaps.length > 0) state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[0]);
				else state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
				for (let i = 0; i < textures.length; i++) {
					if (renderTarget.resolveDepthBuffer) {
						if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
						if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
					}
					if (isMultipleRenderTargets) {
						_gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
						const webglTexture = properties.get(textures[i]).__webglTexture;
						_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
					}
					_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
					if (supportsInvalidateFramebuffer === true) {
						invalidationArrayRead.length = 0;
						invalidationArrayDraw.length = 0;
						invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i);
						if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
							invalidationArrayRead.push(depthStyle);
							invalidationArrayDraw.push(depthStyle);
							_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
						}
						_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
					}
				}
				state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
				state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
				if (isMultipleRenderTargets) for (let i = 0; i < textures.length; i++) {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
					const webglTexture = properties.get(textures[i]).__webglTexture;
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
				}
				state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
			} else if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
				const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
				_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
			}
		}
	}
	function getRenderTargetSamples(renderTarget) {
		return Math.min(capabilities.maxSamples, renderTarget.samples);
	}
	function useMultisampledRTT(renderTarget) {
		const renderTargetProperties = properties.get(renderTarget);
		return renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
	}
	function updateVideoTexture(texture$2) {
		const frame = info.render.frame;
		if (_videoTextures.get(texture$2) !== frame) {
			_videoTextures.set(texture$2, frame);
			texture$2.update();
		}
	}
	function verifyColorSpace(texture$2, image) {
		const colorSpace = texture$2.colorSpace;
		const format = texture$2.format;
		const type$1 = texture$2.type;
		if (texture$2.isCompressedTexture === true || texture$2.isVideoTexture === true) return image;
		if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
			if (format !== RGBAFormat || type$1 !== UnsignedByteType) warn("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
		} else error("WebGLTextures: Unsupported texture color space:", colorSpace);
		return image;
	}
	function getDimensions(image) {
		if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement) {
			_imageDimensions.width = image.naturalWidth || image.width;
			_imageDimensions.height = image.naturalHeight || image.height;
		} else if (typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
			_imageDimensions.width = image.displayWidth;
			_imageDimensions.height = image.displayHeight;
		} else {
			_imageDimensions.width = image.width;
			_imageDimensions.height = image.height;
		}
		return _imageDimensions;
	}
	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;
	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.rebindTextures = rebindTextures;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
	this.setupFrameBufferTexture = setupFrameBufferTexture;
	this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions) {
	function convert$2(p$1, colorSpace = NoColorSpace) {
		let extension;
		const transfer = ColorManagement.getTransfer(colorSpace);
		if (p$1 === UnsignedByteType) return gl.UNSIGNED_BYTE;
		if (p$1 === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
		if (p$1 === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
		if (p$1 === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
		if (p$1 === UnsignedInt101111Type) return gl.UNSIGNED_INT_10F_11F_11F_REV;
		if (p$1 === ByteType) return gl.BYTE;
		if (p$1 === ShortType) return gl.SHORT;
		if (p$1 === UnsignedShortType) return gl.UNSIGNED_SHORT;
		if (p$1 === IntType) return gl.INT;
		if (p$1 === UnsignedIntType) return gl.UNSIGNED_INT;
		if (p$1 === FloatType) return gl.FLOAT;
		if (p$1 === HalfFloatType) return gl.HALF_FLOAT;
		if (p$1 === AlphaFormat) return gl.ALPHA;
		if (p$1 === RGBFormat) return gl.RGB;
		if (p$1 === RGBAFormat) return gl.RGBA;
		if (p$1 === DepthFormat) return gl.DEPTH_COMPONENT;
		if (p$1 === DepthStencilFormat) return gl.DEPTH_STENCIL;
		if (p$1 === RedFormat) return gl.RED;
		if (p$1 === RedIntegerFormat) return gl.RED_INTEGER;
		if (p$1 === RGFormat) return gl.RG;
		if (p$1 === RGIntegerFormat) return gl.RG_INTEGER;
		if (p$1 === RGBAIntegerFormat) return gl.RGBA_INTEGER;
		if (p$1 === RGB_S3TC_DXT1_Format || p$1 === RGBA_S3TC_DXT1_Format || p$1 === RGBA_S3TC_DXT3_Format || p$1 === RGBA_S3TC_DXT5_Format) if (transfer === SRGBTransfer) {
			extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
			if (extension !== null) {
				if (p$1 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
				if (p$1 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
				if (p$1 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
				if (p$1 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
			} else return null;
		} else {
			extension = extensions.get("WEBGL_compressed_texture_s3tc");
			if (extension !== null) {
				if (p$1 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if (p$1 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if (p$1 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if (p$1 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
			} else return null;
		}
		if (p$1 === RGB_PVRTC_4BPPV1_Format || p$1 === RGB_PVRTC_2BPPV1_Format || p$1 === RGBA_PVRTC_4BPPV1_Format || p$1 === RGBA_PVRTC_2BPPV1_Format) {
			extension = extensions.get("WEBGL_compressed_texture_pvrtc");
			if (extension !== null) {
				if (p$1 === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (p$1 === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (p$1 === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (p$1 === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
			} else return null;
		}
		if (p$1 === RGB_ETC1_Format || p$1 === RGB_ETC2_Format || p$1 === RGBA_ETC2_EAC_Format) {
			extension = extensions.get("WEBGL_compressed_texture_etc");
			if (extension !== null) {
				if (p$1 === RGB_ETC1_Format || p$1 === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if (p$1 === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
			} else return null;
		}
		if (p$1 === RGBA_ASTC_4x4_Format || p$1 === RGBA_ASTC_5x4_Format || p$1 === RGBA_ASTC_5x5_Format || p$1 === RGBA_ASTC_6x5_Format || p$1 === RGBA_ASTC_6x6_Format || p$1 === RGBA_ASTC_8x5_Format || p$1 === RGBA_ASTC_8x6_Format || p$1 === RGBA_ASTC_8x8_Format || p$1 === RGBA_ASTC_10x5_Format || p$1 === RGBA_ASTC_10x6_Format || p$1 === RGBA_ASTC_10x8_Format || p$1 === RGBA_ASTC_10x10_Format || p$1 === RGBA_ASTC_12x10_Format || p$1 === RGBA_ASTC_12x12_Format) {
			extension = extensions.get("WEBGL_compressed_texture_astc");
			if (extension !== null) {
				if (p$1 === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if (p$1 === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if (p$1 === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if (p$1 === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if (p$1 === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if (p$1 === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if (p$1 === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if (p$1 === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if (p$1 === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if (p$1 === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if (p$1 === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if (p$1 === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if (p$1 === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if (p$1 === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
			} else return null;
		}
		if (p$1 === RGBA_BPTC_Format || p$1 === RGB_BPTC_SIGNED_Format || p$1 === RGB_BPTC_UNSIGNED_Format) {
			extension = extensions.get("EXT_texture_compression_bptc");
			if (extension !== null) {
				if (p$1 === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
				if (p$1 === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
				if (p$1 === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
			} else return null;
		}
		if (p$1 === RED_RGTC1_Format || p$1 === SIGNED_RED_RGTC1_Format || p$1 === RED_GREEN_RGTC2_Format || p$1 === SIGNED_RED_GREEN_RGTC2_Format) {
			extension = extensions.get("EXT_texture_compression_rgtc");
			if (extension !== null) {
				if (p$1 === RED_RGTC1_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
				if (p$1 === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if (p$1 === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if (p$1 === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
			} else return null;
		}
		if (p$1 === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;
		return gl[p$1] !== void 0 ? gl[p$1] : null;
	}
	return { convert: convert$2 };
}
var _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
var _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
/**
* A XR module that manages the access to the Depth Sensing API.
*/
var WebXRDepthSensing = class {
	/**
	* Constructs a new depth sensing module.
	*/
	constructor() {
		/**
		* An opaque texture representing the depth of the user's environment.
		*
		* @type {?ExternalTexture}
		*/
		this.texture = null;
		/**
		* A plane mesh for visualizing the depth texture.
		*
		* @type {?Mesh}
		*/
		this.mesh = null;
		/**
		* The depth near value.
		*
		* @type {number}
		*/
		this.depthNear = 0;
		/**
		* The depth near far.
		*
		* @type {number}
		*/
		this.depthFar = 0;
	}
	/**
	* Inits the depth sensing module
	*
	* @param {XRWebGLDepthInformation} depthData - The XR depth data.
	* @param {XRRenderState} renderState - The XR render state.
	*/
	init(depthData, renderState) {
		if (this.texture === null) {
			const texture$2 = new ExternalTexture(depthData.texture);
			if (depthData.depthNear !== renderState.depthNear || depthData.depthFar !== renderState.depthFar) {
				this.depthNear = depthData.depthNear;
				this.depthFar = depthData.depthFar;
			}
			this.texture = texture$2;
		}
	}
	/**
	* Returns a plane mesh that visualizes the depth texture.
	*
	* @param {ArrayCamera} cameraXR - The XR camera.
	* @return {?Mesh} The plane mesh.
	*/
	getMesh(cameraXR) {
		if (this.texture !== null) {
			if (this.mesh === null) {
				const viewport$2 = cameraXR.cameras[0].viewport;
				const material = new ShaderMaterial({
					vertexShader: _occlusion_vertex,
					fragmentShader: _occlusion_fragment,
					uniforms: {
						depthColor: { value: this.texture },
						depthWidth: { value: viewport$2.z },
						depthHeight: { value: viewport$2.w }
					}
				});
				this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
			}
		}
		return this.mesh;
	}
	/**
	* Resets the module
	*/
	reset() {
		this.texture = null;
		this.mesh = null;
	}
	/**
	* Returns a texture representing the depth of the user's environment.
	*
	* @return {?ExternalTexture} The depth texture.
	*/
	getDepthTexture() {
		return this.texture;
	}
};
/**
* This class represents an abstraction of the WebXR Device API and is
* internally used by {@link WebGLRenderer}. `WebXRManager` also provides a public
* interface that allows users to enable/disable XR and perform XR related
* tasks like for instance retrieving controllers.
*
* @augments EventDispatcher
* @hideconstructor
*/
var WebXRManager = class extends EventDispatcher {
	/**
	* Constructs a new WebGL renderer.
	*
	* @param {WebGLRenderer} renderer - The renderer.
	* @param {WebGL2RenderingContext} gl - The rendering context.
	*/
	constructor(renderer, gl) {
		super();
		const scope = this;
		let session = null;
		let framebufferScaleFactor = 1;
		let referenceSpace = null;
		let referenceSpaceType = "local-floor";
		let foveation = 1;
		let customReferenceSpace = null;
		let pose = null;
		let glBinding = null;
		let glProjLayer = null;
		let glBaseLayer = null;
		let xrFrame = null;
		const supportsGlBinding = typeof XRWebGLBinding !== "undefined";
		const depthSensing = new WebXRDepthSensing();
		const cameraAccessTextures = {};
		const attributes = gl.getContextAttributes();
		let initialRenderTarget = null;
		let newRenderTarget = null;
		const controllers = [];
		const controllerInputSources = [];
		const currentSize = new Vector2();
		let currentPixelRatio = null;
		const cameraL = new PerspectiveCamera();
		cameraL.viewport = new Vector4();
		const cameraR = new PerspectiveCamera();
		cameraR.viewport = new Vector4();
		const cameras = [cameraL, cameraR];
		const cameraXR = new ArrayCamera();
		let _currentDepthNear = null;
		let _currentDepthFar = null;
		/**
		* Whether the manager's XR camera should be automatically updated or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.cameraAutoUpdate = true;
		/**
		* This flag notifies the renderer to be ready for XR rendering. Set it to `true`
		* if you are going to use XR in your app.
		*
		* @type {boolean}
		* @default false
		*/
		this.enabled = false;
		/**
		* Whether XR presentation is active or not.
		*
		* @type {boolean}
		* @readonly
		* @default false
		*/
		this.isPresenting = false;
		/**
		* Returns a group representing the `target ray` space of the XR controller.
		* Use this space for visualizing 3D objects that support the user in pointing
		* tasks like UI interaction.
		*
		* @param {number} index - The index of the controller.
		* @return {Group} A group representing the `target ray` space.
		*/
		this.getController = function(index) {
			let controller = controllers[index];
			if (controller === void 0) {
				controller = new WebXRController();
				controllers[index] = controller;
			}
			return controller.getTargetRaySpace();
		};
		/**
		* Returns a group representing the `grip` space of the XR controller.
		* Use this space for visualizing 3D objects that support the user in pointing
		* tasks like UI interaction.
		*
		* Note: If you want to show something in the user's hand AND offer a
		* pointing ray at the same time, you'll want to attached the handheld object
		* to the group returned by `getControllerGrip()` and the ray to the
		* group returned by `getController()`. The idea is to have two
		* different groups in two different coordinate spaces for the same WebXR
		* controller.
		*
		* @param {number} index - The index of the controller.
		* @return {Group} A group representing the `grip` space.
		*/
		this.getControllerGrip = function(index) {
			let controller = controllers[index];
			if (controller === void 0) {
				controller = new WebXRController();
				controllers[index] = controller;
			}
			return controller.getGripSpace();
		};
		/**
		* Returns a group representing the `hand` space of the XR controller.
		* Use this space for visualizing 3D objects that support the user in pointing
		* tasks like UI interaction.
		*
		* @param {number} index - The index of the controller.
		* @return {Group} A group representing the `hand` space.
		*/
		this.getHand = function(index) {
			let controller = controllers[index];
			if (controller === void 0) {
				controller = new WebXRController();
				controllers[index] = controller;
			}
			return controller.getHandSpace();
		};
		function onSessionEvent$1(event) {
			const controllerIndex = controllerInputSources.indexOf(event.inputSource);
			if (controllerIndex === -1) return;
			const controller = controllers[controllerIndex];
			if (controller !== void 0) {
				controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
				controller.dispatchEvent({
					type: event.type,
					data: event.inputSource
				});
			}
		}
		function onSessionEnd$1() {
			session.removeEventListener("select", onSessionEvent$1);
			session.removeEventListener("selectstart", onSessionEvent$1);
			session.removeEventListener("selectend", onSessionEvent$1);
			session.removeEventListener("squeeze", onSessionEvent$1);
			session.removeEventListener("squeezestart", onSessionEvent$1);
			session.removeEventListener("squeezeend", onSessionEvent$1);
			session.removeEventListener("end", onSessionEnd$1);
			session.removeEventListener("inputsourceschange", onInputSourcesChange$1);
			for (let i = 0; i < controllers.length; i++) {
				const inputSource = controllerInputSources[i];
				if (inputSource === null) continue;
				controllerInputSources[i] = null;
				controllers[i].disconnect(inputSource);
			}
			_currentDepthNear = null;
			_currentDepthFar = null;
			depthSensing.reset();
			for (const key in cameraAccessTextures) delete cameraAccessTextures[key];
			renderer.setRenderTarget(initialRenderTarget);
			glBaseLayer = null;
			glProjLayer = null;
			glBinding = null;
			session = null;
			newRenderTarget = null;
			animation.stop();
			scope.isPresenting = false;
			renderer.setPixelRatio(currentPixelRatio);
			renderer.setSize(currentSize.width, currentSize.height, false);
			scope.dispatchEvent({ type: "sessionend" });
		}
		/**
		* Sets the framebuffer scale factor.
		*
		* This method can not be used during a XR session.
		*
		* @param {number} value - The framebuffer scale factor.
		*/
		this.setFramebufferScaleFactor = function(value) {
			framebufferScaleFactor = value;
			if (scope.isPresenting === true) warn("WebXRManager: Cannot change framebuffer scale while presenting.");
		};
		/**
		* Sets the reference space type. Can be used to configure a spatial relationship with the user's physical
		* environment. Depending on how the user moves in 3D space, setting an appropriate reference space can
		* improve tracking. Default is `local-floor`. Valid values can be found here
		* https://developer.mozilla.org/en-US/docs/Web/API/XRReferenceSpace#reference_space_types.
		*
		* This method can not be used during a XR session.
		*
		* @param {string} value - The reference space type.
		*/
		this.setReferenceSpaceType = function(value) {
			referenceSpaceType = value;
			if (scope.isPresenting === true) warn("WebXRManager: Cannot change reference space type while presenting.");
		};
		/**
		* Returns the XR reference space.
		*
		* @return {XRReferenceSpace} The XR reference space.
		*/
		this.getReferenceSpace = function() {
			return customReferenceSpace || referenceSpace;
		};
		/**
		* Sets a custom XR reference space.
		*
		* @param {XRReferenceSpace} space - The XR reference space.
		*/
		this.setReferenceSpace = function(space) {
			customReferenceSpace = space;
		};
		/**
		* Returns the current base layer.
		*
		* This is an `XRProjectionLayer` when the targeted XR device supports the
		* WebXR Layers API, or an `XRWebGLLayer` otherwise.
		*
		* @return {?(XRWebGLLayer|XRProjectionLayer)} The XR base layer.
		*/
		this.getBaseLayer = function() {
			return glProjLayer !== null ? glProjLayer : glBaseLayer;
		};
		/**
		* Returns the current XR binding.
		*
		* Creates a new binding if needed and the browser is
		* capable of doing so.
		*
		* @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.
		*/
		this.getBinding = function() {
			if (glBinding === null && supportsGlBinding) glBinding = new XRWebGLBinding(session, gl);
			return glBinding;
		};
		/**
		* Returns the current XR frame.
		*
		* @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
		*/
		this.getFrame = function() {
			return xrFrame;
		};
		/**
		* Returns the current XR session.
		*
		* @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
		*/
		this.getSession = function() {
			return session;
		};
		/**
		* After a XR session has been requested usually with one of the `*Button` modules, it
		* is injected into the renderer with this method. This method triggers the start of
		* the actual XR rendering.
		*
		* @async
		* @param {XRSession} value - The XR session to set.
		* @return {Promise} A Promise that resolves when the session has been set.
		*/
		this.setSession = async function(value) {
			session = value;
			if (session !== null) {
				initialRenderTarget = renderer.getRenderTarget();
				session.addEventListener("select", onSessionEvent$1);
				session.addEventListener("selectstart", onSessionEvent$1);
				session.addEventListener("selectend", onSessionEvent$1);
				session.addEventListener("squeeze", onSessionEvent$1);
				session.addEventListener("squeezestart", onSessionEvent$1);
				session.addEventListener("squeezeend", onSessionEvent$1);
				session.addEventListener("end", onSessionEnd$1);
				session.addEventListener("inputsourceschange", onInputSourcesChange$1);
				if (attributes.xrCompatible !== true) await gl.makeXRCompatible();
				currentPixelRatio = renderer.getPixelRatio();
				renderer.getSize(currentSize);
				if (!(supportsGlBinding && "createProjectionLayer" in XRWebGLBinding.prototype)) {
					const layerInit = {
						antialias: attributes.antialias,
						alpha: true,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor
					};
					glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
					session.updateRenderState({ baseLayer: glBaseLayer });
					renderer.setPixelRatio(1);
					renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
					newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
						format: RGBAFormat,
						type: UnsignedByteType,
						colorSpace: renderer.outputColorSpace,
						stencilBuffer: attributes.stencil,
						resolveDepthBuffer: glBaseLayer.ignoreDepthValues === false,
						resolveStencilBuffer: glBaseLayer.ignoreDepthValues === false
					});
				} else {
					let depthFormat = null;
					let depthType = null;
					let glDepthFormat = null;
					if (attributes.depth) {
						glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
					}
					const projectionlayerInit = {
						colorFormat: gl.RGBA8,
						depthFormat: glDepthFormat,
						scaleFactor: framebufferScaleFactor
					};
					glBinding = this.getBinding();
					glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
					session.updateRenderState({ layers: [glProjLayer] });
					renderer.setPixelRatio(1);
					renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
					newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
						format: RGBAFormat,
						type: UnsignedByteType,
						depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
						stencilBuffer: attributes.stencil,
						colorSpace: renderer.outputColorSpace,
						samples: attributes.antialias ? 4 : 0,
						resolveDepthBuffer: glProjLayer.ignoreDepthValues === false,
						resolveStencilBuffer: glProjLayer.ignoreDepthValues === false
					});
				}
				newRenderTarget.isXRRenderTarget = true;
				this.setFoveation(foveation);
				customReferenceSpace = null;
				referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
				animation.setContext(session);
				animation.start();
				scope.isPresenting = true;
				scope.dispatchEvent({ type: "sessionstart" });
			}
		};
		/**
		* Returns the environment blend mode from the current XR session.
		*
		* @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
		*/
		this.getEnvironmentBlendMode = function() {
			if (session !== null) return session.environmentBlendMode;
		};
		/**
		* Returns the current depth texture computed via depth sensing.
		*
		* See {@link WebXRDepthSensing#getDepthTexture}.
		*
		* @return {?Texture} The depth texture.
		*/
		this.getDepthTexture = function() {
			return depthSensing.getDepthTexture();
		};
		function onInputSourcesChange$1(event) {
			for (let i = 0; i < event.removed.length; i++) {
				const inputSource = event.removed[i];
				const index = controllerInputSources.indexOf(inputSource);
				if (index >= 0) {
					controllerInputSources[index] = null;
					controllers[index].disconnect(inputSource);
				}
			}
			for (let i = 0; i < event.added.length; i++) {
				const inputSource = event.added[i];
				let controllerIndex = controllerInputSources.indexOf(inputSource);
				if (controllerIndex === -1) {
					for (let i$1 = 0; i$1 < controllers.length; i$1++) if (i$1 >= controllerInputSources.length) {
						controllerInputSources.push(inputSource);
						controllerIndex = i$1;
						break;
					} else if (controllerInputSources[i$1] === null) {
						controllerInputSources[i$1] = inputSource;
						controllerIndex = i$1;
						break;
					}
					if (controllerIndex === -1) break;
				}
				const controller = controllers[controllerIndex];
				if (controller) controller.connect(inputSource);
			}
		}
		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();
		/**
		* Assumes 2 cameras that are parallel and share an X-axis, and that
		* the cameras' projection and world matrices have already been set.
		* And that near and far planes are identical for both cameras.
		* Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		*
		* @param {ArrayCamera} camera - The camera to update.
		* @param {PerspectiveCamera} cameraL - The left camera.
		* @param {PerspectiveCamera} cameraR - The right camera.
		*/
		function setProjectionFromUnion$1(camera, cameraL$1, cameraR$1) {
			cameraLPos.setFromMatrixPosition(cameraL$1.matrixWorld);
			cameraRPos.setFromMatrixPosition(cameraR$1.matrixWorld);
			const ipd = cameraLPos.distanceTo(cameraRPos);
			const projL = cameraL$1.projectionMatrix.elements;
			const projR = cameraR$1.projectionMatrix.elements;
			const near = projL[14] / (projL[10] - 1);
			const far = projL[14] / (projL[10] + 1);
			const topFov = (projL[9] + 1) / projL[5];
			const bottomFov = (projL[9] - 1) / projL[5];
			const leftFov = (projL[8] - 1) / projL[0];
			const rightFov = (projR[8] + 1) / projR[0];
			const left = near * leftFov;
			const right = near * rightFov;
			const zOffset = ipd / (-leftFov + rightFov);
			const xOffset = zOffset * -leftFov;
			cameraL$1.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
			camera.translateX(xOffset);
			camera.translateZ(zOffset);
			camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
			camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
			if (projL[10] === -1) {
				camera.projectionMatrix.copy(cameraL$1.projectionMatrix);
				camera.projectionMatrixInverse.copy(cameraL$1.projectionMatrixInverse);
			} else {
				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + (ipd - xOffset);
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;
				camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
				camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
			}
		}
		function updateCamera$1(camera, parent) {
			if (parent === null) camera.matrixWorld.copy(camera.matrix);
			else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
			camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
		}
		/**
		* Updates the state of the XR camera. Use this method on app level if you
		* set `cameraAutoUpdate` to `false`. The method requires the non-XR
		* camera of the scene as a parameter. The passed in camera's transformation
		* is automatically adjusted to the position of the XR camera when calling
		* this method.
		*
		* @param {Camera} camera - The camera.
		*/
		this.updateCamera = function(camera) {
			if (session === null) return;
			let depthNear = camera.near;
			let depthFar = camera.far;
			if (depthSensing.texture !== null) {
				if (depthSensing.depthNear > 0) depthNear = depthSensing.depthNear;
				if (depthSensing.depthFar > 0) depthFar = depthSensing.depthFar;
			}
			cameraXR.near = cameraR.near = cameraL.near = depthNear;
			cameraXR.far = cameraR.far = cameraL.far = depthFar;
			if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
				session.updateRenderState({
					depthNear: cameraXR.near,
					depthFar: cameraXR.far
				});
				_currentDepthNear = cameraXR.near;
				_currentDepthFar = cameraXR.far;
			}
			cameraXR.layers.mask = camera.layers.mask | 6;
			cameraL.layers.mask = cameraXR.layers.mask & 3;
			cameraR.layers.mask = cameraXR.layers.mask & 5;
			const parent = camera.parent;
			const cameras$1 = cameraXR.cameras;
			updateCamera$1(cameraXR, parent);
			for (let i = 0; i < cameras$1.length; i++) updateCamera$1(cameras$1[i], parent);
			if (cameras$1.length === 2) setProjectionFromUnion$1(cameraXR, cameraL, cameraR);
			else cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
			updateUserCamera$1(camera, cameraXR, parent);
		};
		function updateUserCamera$1(camera, cameraXR$1, parent) {
			if (parent === null) camera.matrix.copy(cameraXR$1.matrixWorld);
			else {
				camera.matrix.copy(parent.matrixWorld);
				camera.matrix.invert();
				camera.matrix.multiply(cameraXR$1.matrixWorld);
			}
			camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
			camera.updateMatrixWorld(true);
			camera.projectionMatrix.copy(cameraXR$1.projectionMatrix);
			camera.projectionMatrixInverse.copy(cameraXR$1.projectionMatrixInverse);
			if (camera.isPerspectiveCamera) {
				camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
				camera.zoom = 1;
			}
		}
		/**
		* Returns an instance of {@link ArrayCamera} which represents the XR camera
		* of the active XR session. For each view it holds a separate camera object.
		*
		* The camera's `fov` is currently not used and does not reflect the fov of
		* the XR camera. If you need the fov on app level, you have to compute in
		* manually from the XR camera's projection matrices.
		*
		* @return {ArrayCamera} The XR camera.
		*/
		this.getCamera = function() {
			return cameraXR;
		};
		/**
		* Returns the amount of foveation used by the XR compositor for the projection layer.
		*
		* @return {number|undefined} The amount of foveation.
		*/
		this.getFoveation = function() {
			if (glProjLayer === null && glBaseLayer === null) return;
			return foveation;
		};
		/**
		* Sets the foveation value.
		*
		* @param {number} value - A number in the range `[0,1]` where `0` means no foveation (full resolution)
		* and `1` means maximum foveation (the edges render at lower resolution).
		*/
		this.setFoveation = function(value) {
			foveation = value;
			if (glProjLayer !== null) glProjLayer.fixedFoveation = value;
			if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) glBaseLayer.fixedFoveation = value;
		};
		/**
		* Returns `true` if depth sensing is supported.
		*
		* @return {boolean} Whether depth sensing is supported or not.
		*/
		this.hasDepthSensing = function() {
			return depthSensing.texture !== null;
		};
		/**
		* Returns the depth sensing mesh.
		*
		* See {@link WebXRDepthSensing#getMesh}.
		*
		* @return {Mesh} The depth sensing mesh.
		*/
		this.getDepthSensingMesh = function() {
			return depthSensing.getMesh(cameraXR);
		};
		/**
		* Retrieves an opaque texture from the view-aligned {@link XRCamera}.
		* Only available during the current animation loop.
		*
		* @param {XRCamera} xrCamera - The camera to query.
		* @return {?Texture} An opaque texture representing the current raw camera frame.
		*/
		this.getCameraTexture = function(xrCamera) {
			return cameraAccessTextures[xrCamera];
		};
		let onAnimationFrameCallback = null;
		function onAnimationFrame$1(time$2, frame) {
			pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
			xrFrame = frame;
			if (pose !== null) {
				const views = pose.views;
				if (glBaseLayer !== null) {
					renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
					renderer.setRenderTarget(newRenderTarget);
				}
				let cameraXRNeedsUpdate = false;
				if (views.length !== cameraXR.cameras.length) {
					cameraXR.cameras.length = 0;
					cameraXRNeedsUpdate = true;
				}
				for (let i = 0; i < views.length; i++) {
					const view = views[i];
					let viewport$2 = null;
					if (glBaseLayer !== null) viewport$2 = glBaseLayer.getViewport(view);
					else {
						const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
						viewport$2 = glSubImage.viewport;
						if (i === 0) {
							renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glSubImage.depthStencilTexture);
							renderer.setRenderTarget(newRenderTarget);
						}
					}
					let camera = cameras[i];
					if (camera === void 0) {
						camera = new PerspectiveCamera();
						camera.layers.enable(i);
						camera.viewport = new Vector4();
						cameras[i] = camera;
					}
					camera.matrix.fromArray(view.transform.matrix);
					camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
					camera.projectionMatrix.fromArray(view.projectionMatrix);
					camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
					camera.viewport.set(viewport$2.x, viewport$2.y, viewport$2.width, viewport$2.height);
					if (i === 0) {
						cameraXR.matrix.copy(camera.matrix);
						cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
					}
					if (cameraXRNeedsUpdate === true) cameraXR.cameras.push(camera);
				}
				const enabledFeatures = session.enabledFeatures;
				if (enabledFeatures && enabledFeatures.includes("depth-sensing") && session.depthUsage == "gpu-optimized" && supportsGlBinding) {
					glBinding = scope.getBinding();
					const depthData = glBinding.getDepthInformation(views[0]);
					if (depthData && depthData.isValid && depthData.texture) depthSensing.init(depthData, session.renderState);
				}
				if (enabledFeatures && enabledFeatures.includes("camera-access") && supportsGlBinding) {
					renderer.state.unbindTexture();
					glBinding = scope.getBinding();
					for (let i = 0; i < views.length; i++) {
						const camera = views[i].camera;
						if (camera) {
							let cameraTex = cameraAccessTextures[camera];
							if (!cameraTex) {
								cameraTex = new ExternalTexture();
								cameraAccessTextures[camera] = cameraTex;
							}
							cameraTex.sourceTexture = glBinding.getCameraImage(camera);
						}
					}
				}
			}
			for (let i = 0; i < controllers.length; i++) {
				const inputSource = controllerInputSources[i];
				const controller = controllers[i];
				if (inputSource !== null && controller !== void 0) controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
			}
			if (onAnimationFrameCallback) onAnimationFrameCallback(time$2, frame);
			if (frame.detectedPlanes) scope.dispatchEvent({
				type: "planesdetected",
				data: frame
			});
			xrFrame = null;
		}
		const animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame$1);
		this.setAnimationLoop = function(callback) {
			onAnimationFrameCallback = callback;
		};
		this.dispose = function() {};
	}
};
var _e1 = /* @__PURE__ */ new Euler();
var _m1 = /* @__PURE__ */ new Matrix4();
function WebGLMaterials(renderer, properties) {
	function refreshTransformUniform(map, uniform$2) {
		if (map.matrixAutoUpdate === true) map.updateMatrix();
		uniform$2.value.copy(map.matrix);
	}
	function refreshFogUniforms(uniforms, fog$2) {
		fog$2.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
		if (fog$2.isFog) {
			uniforms.fogNear.value = fog$2.near;
			uniforms.fogFar.value = fog$2.far;
		} else if (fog$2.isFogExp2) uniforms.fogDensity.value = fog$2.density;
	}
	function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
		if (material.isMeshBasicMaterial) refreshUniformsCommon(uniforms, material);
		else if (material.isMeshLambertMaterial) refreshUniformsCommon(uniforms, material);
		else if (material.isMeshToonMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsToon(uniforms, material);
		} else if (material.isMeshPhongMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsPhong(uniforms, material);
		} else if (material.isMeshStandardMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsStandard(uniforms, material);
			if (material.isMeshPhysicalMaterial) refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
		} else if (material.isMeshMatcapMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsMatcap(uniforms, material);
		} else if (material.isMeshDepthMaterial) refreshUniformsCommon(uniforms, material);
		else if (material.isMeshDistanceMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsDistance(uniforms, material);
		} else if (material.isMeshNormalMaterial) refreshUniformsCommon(uniforms, material);
		else if (material.isLineBasicMaterial) {
			refreshUniformsLine(uniforms, material);
			if (material.isLineDashedMaterial) refreshUniformsDash(uniforms, material);
		} else if (material.isPointsMaterial) refreshUniformsPoints(uniforms, material, pixelRatio, height);
		else if (material.isSpriteMaterial) refreshUniformsSprites(uniforms, material);
		else if (material.isShadowMaterial) {
			uniforms.color.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
		} else if (material.isShaderMaterial) material.uniformsNeedUpdate = false;
	}
	function refreshUniformsCommon(uniforms, material) {
		uniforms.opacity.value = material.opacity;
		if (material.color) uniforms.diffuse.value.copy(material.color);
		if (material.emissive) uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
		if (material.map) {
			uniforms.map.value = material.map;
			refreshTransformUniform(material.map, uniforms.mapTransform);
		}
		if (material.alphaMap) {
			uniforms.alphaMap.value = material.alphaMap;
			refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
		}
		if (material.bumpMap) {
			uniforms.bumpMap.value = material.bumpMap;
			refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
			uniforms.bumpScale.value = material.bumpScale;
			if (material.side === BackSide) uniforms.bumpScale.value *= -1;
		}
		if (material.normalMap) {
			uniforms.normalMap.value = material.normalMap;
			refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
			uniforms.normalScale.value.copy(material.normalScale);
			if (material.side === BackSide) uniforms.normalScale.value.negate();
		}
		if (material.displacementMap) {
			uniforms.displacementMap.value = material.displacementMap;
			refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
		if (material.emissiveMap) {
			uniforms.emissiveMap.value = material.emissiveMap;
			refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
		}
		if (material.specularMap) {
			uniforms.specularMap.value = material.specularMap;
			refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
		}
		if (material.alphaTest > 0) uniforms.alphaTest.value = material.alphaTest;
		const materialProperties = properties.get(material);
		const envMap = materialProperties.envMap;
		const envMapRotation = materialProperties.envMapRotation;
		if (envMap) {
			uniforms.envMap.value = envMap;
			_e1.copy(envMapRotation);
			_e1.x *= -1;
			_e1.y *= -1;
			_e1.z *= -1;
			if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
				_e1.y *= -1;
				_e1.z *= -1;
			}
			uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));
			uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
			uniforms.reflectivity.value = material.reflectivity;
			uniforms.ior.value = material.ior;
			uniforms.refractionRatio.value = material.refractionRatio;
		}
		if (material.lightMap) {
			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;
			refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
		}
		if (material.aoMap) {
			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;
			refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
		}
	}
	function refreshUniformsLine(uniforms, material) {
		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
		if (material.map) {
			uniforms.map.value = material.map;
			refreshTransformUniform(material.map, uniforms.mapTransform);
		}
	}
	function refreshUniformsDash(uniforms, material) {
		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;
	}
	function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * .5;
		if (material.map) {
			uniforms.map.value = material.map;
			refreshTransformUniform(material.map, uniforms.uvTransform);
		}
		if (material.alphaMap) {
			uniforms.alphaMap.value = material.alphaMap;
			refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
		}
		if (material.alphaTest > 0) uniforms.alphaTest.value = material.alphaTest;
	}
	function refreshUniformsSprites(uniforms, material) {
		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;
		if (material.map) {
			uniforms.map.value = material.map;
			refreshTransformUniform(material.map, uniforms.mapTransform);
		}
		if (material.alphaMap) {
			uniforms.alphaMap.value = material.alphaMap;
			refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
		}
		if (material.alphaTest > 0) uniforms.alphaTest.value = material.alphaTest;
	}
	function refreshUniformsPhong(uniforms, material) {
		uniforms.specular.value.copy(material.specular);
		uniforms.shininess.value = Math.max(material.shininess, 1e-4);
	}
	function refreshUniformsToon(uniforms, material) {
		if (material.gradientMap) uniforms.gradientMap.value = material.gradientMap;
	}
	function refreshUniformsStandard(uniforms, material) {
		uniforms.metalness.value = material.metalness;
		if (material.metalnessMap) {
			uniforms.metalnessMap.value = material.metalnessMap;
			refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
		}
		uniforms.roughness.value = material.roughness;
		if (material.roughnessMap) {
			uniforms.roughnessMap.value = material.roughnessMap;
			refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
		}
		if (material.envMap) uniforms.envMapIntensity.value = material.envMapIntensity;
	}
	function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
		uniforms.ior.value = material.ior;
		if (material.sheen > 0) {
			uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
			uniforms.sheenRoughness.value = material.sheenRoughness;
			if (material.sheenColorMap) {
				uniforms.sheenColorMap.value = material.sheenColorMap;
				refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
			}
			if (material.sheenRoughnessMap) {
				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
				refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
			}
		}
		if (material.clearcoat > 0) {
			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
			if (material.clearcoatMap) {
				uniforms.clearcoatMap.value = material.clearcoatMap;
				refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
			}
			if (material.clearcoatRoughnessMap) {
				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
				refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
			}
			if (material.clearcoatNormalMap) {
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
				refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
				uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
				if (material.side === BackSide) uniforms.clearcoatNormalScale.value.negate();
			}
		}
		if (material.dispersion > 0) uniforms.dispersion.value = material.dispersion;
		if (material.iridescence > 0) {
			uniforms.iridescence.value = material.iridescence;
			uniforms.iridescenceIOR.value = material.iridescenceIOR;
			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
			if (material.iridescenceMap) {
				uniforms.iridescenceMap.value = material.iridescenceMap;
				refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
			}
			if (material.iridescenceThicknessMap) {
				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
				refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
			}
		}
		if (material.transmission > 0) {
			uniforms.transmission.value = material.transmission;
			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
			if (material.transmissionMap) {
				uniforms.transmissionMap.value = material.transmissionMap;
				refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
			}
			uniforms.thickness.value = material.thickness;
			if (material.thicknessMap) {
				uniforms.thicknessMap.value = material.thicknessMap;
				refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
			}
			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationColor.value.copy(material.attenuationColor);
		}
		if (material.anisotropy > 0) {
			uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
			if (material.anisotropyMap) {
				uniforms.anisotropyMap.value = material.anisotropyMap;
				refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
			}
		}
		uniforms.specularIntensity.value = material.specularIntensity;
		uniforms.specularColor.value.copy(material.specularColor);
		if (material.specularColorMap) {
			uniforms.specularColorMap.value = material.specularColorMap;
			refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
		}
		if (material.specularIntensityMap) {
			uniforms.specularIntensityMap.value = material.specularIntensityMap;
			refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
		}
	}
	function refreshUniformsMatcap(uniforms, material) {
		if (material.matcap) uniforms.matcap.value = material.matcap;
	}
	function refreshUniformsDistance(uniforms, material) {
		const light = properties.get(material).light;
		uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
		uniforms.nearDistance.value = light.shadow.camera.near;
		uniforms.farDistance.value = light.shadow.camera.far;
	}
	return {
		refreshFogUniforms,
		refreshMaterialUniforms
	};
}
function WebGLUniformsGroups(gl, info, capabilities, state) {
	let buffers = {};
	let updateList = {};
	let allocatedBindingPoints = [];
	const maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
	function bind(uniformsGroup, program) {
		const webglProgram = program.program;
		state.uniformBlockBinding(uniformsGroup, webglProgram);
	}
	function update(uniformsGroup, program) {
		let buffer$2 = buffers[uniformsGroup.id];
		if (buffer$2 === void 0) {
			prepareUniformsGroup(uniformsGroup);
			buffer$2 = createBuffer(uniformsGroup);
			buffers[uniformsGroup.id] = buffer$2;
			uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
		}
		const webglProgram = program.program;
		state.updateUBOMapping(uniformsGroup, webglProgram);
		const frame = info.render.frame;
		if (updateList[uniformsGroup.id] !== frame) {
			updateBufferData(uniformsGroup);
			updateList[uniformsGroup.id] = frame;
		}
	}
	function createBuffer(uniformsGroup) {
		const bindingPointIndex = allocateBindingPointIndex();
		uniformsGroup.__bindingPointIndex = bindingPointIndex;
		const buffer$2 = gl.createBuffer();
		const size = uniformsGroup.__size;
		const usage = uniformsGroup.usage;
		gl.bindBuffer(gl.UNIFORM_BUFFER, buffer$2);
		gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
		gl.bindBuffer(gl.UNIFORM_BUFFER, null);
		gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer$2);
		return buffer$2;
	}
	function allocateBindingPointIndex() {
		for (let i = 0; i < maxBindingPoints; i++) if (allocatedBindingPoints.indexOf(i) === -1) {
			allocatedBindingPoints.push(i);
			return i;
		}
		error("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
		return 0;
	}
	function updateBufferData(uniformsGroup) {
		const buffer$2 = buffers[uniformsGroup.id];
		const uniforms = uniformsGroup.uniforms;
		const cache$2 = uniformsGroup.__cache;
		gl.bindBuffer(gl.UNIFORM_BUFFER, buffer$2);
		for (let i = 0, il = uniforms.length; i < il; i++) {
			const uniformArray$2 = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
			for (let j = 0, jl = uniformArray$2.length; j < jl; j++) {
				const uniform$2 = uniformArray$2[j];
				if (hasUniformChanged(uniform$2, i, j, cache$2) === true) {
					const offset = uniform$2.__offset;
					const values = Array.isArray(uniform$2.value) ? uniform$2.value : [uniform$2.value];
					let arrayOffset = 0;
					for (let k = 0; k < values.length; k++) {
						const value = values[k];
						const info$1 = getUniformSize(value);
						if (typeof value === "number" || typeof value === "boolean") {
							uniform$2.__data[0] = value;
							gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform$2.__data);
						} else if (value.isMatrix3) {
							uniform$2.__data[0] = value.elements[0];
							uniform$2.__data[1] = value.elements[1];
							uniform$2.__data[2] = value.elements[2];
							uniform$2.__data[3] = 0;
							uniform$2.__data[4] = value.elements[3];
							uniform$2.__data[5] = value.elements[4];
							uniform$2.__data[6] = value.elements[5];
							uniform$2.__data[7] = 0;
							uniform$2.__data[8] = value.elements[6];
							uniform$2.__data[9] = value.elements[7];
							uniform$2.__data[10] = value.elements[8];
							uniform$2.__data[11] = 0;
						} else {
							value.toArray(uniform$2.__data, arrayOffset);
							arrayOffset += info$1.storage / Float32Array.BYTES_PER_ELEMENT;
						}
					}
					gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform$2.__data);
				}
			}
		}
		gl.bindBuffer(gl.UNIFORM_BUFFER, null);
	}
	function hasUniformChanged(uniform$2, index, indexArray, cache$2) {
		const value = uniform$2.value;
		const indexString = index + "_" + indexArray;
		if (cache$2[indexString] === void 0) {
			if (typeof value === "number" || typeof value === "boolean") cache$2[indexString] = value;
			else cache$2[indexString] = value.clone();
			return true;
		} else {
			const cachedObject = cache$2[indexString];
			if (typeof value === "number" || typeof value === "boolean") {
				if (cachedObject !== value) {
					cache$2[indexString] = value;
					return true;
				}
			} else if (cachedObject.equals(value) === false) {
				cachedObject.copy(value);
				return true;
			}
		}
		return false;
	}
	function prepareUniformsGroup(uniformsGroup) {
		const uniforms = uniformsGroup.uniforms;
		let offset = 0;
		const chunkSize = 16;
		for (let i = 0, l = uniforms.length; i < l; i++) {
			const uniformArray$2 = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
			for (let j = 0, jl = uniformArray$2.length; j < jl; j++) {
				const uniform$2 = uniformArray$2[j];
				const values = Array.isArray(uniform$2.value) ? uniform$2.value : [uniform$2.value];
				for (let k = 0, kl = values.length; k < kl; k++) {
					const value = values[k];
					const info$1 = getUniformSize(value);
					const chunkOffset$1 = offset % chunkSize;
					const chunkPadding = chunkOffset$1 % info$1.boundary;
					const chunkStart = chunkOffset$1 + chunkPadding;
					offset += chunkPadding;
					if (chunkStart !== 0 && chunkSize - chunkStart < info$1.storage) offset += chunkSize - chunkStart;
					uniform$2.__data = new Float32Array(info$1.storage / Float32Array.BYTES_PER_ELEMENT);
					uniform$2.__offset = offset;
					offset += info$1.storage;
				}
			}
		}
		const chunkOffset = offset % chunkSize;
		if (chunkOffset > 0) offset += chunkSize - chunkOffset;
		uniformsGroup.__size = offset;
		uniformsGroup.__cache = {};
		return this;
	}
	function getUniformSize(value) {
		const info$1 = {
			boundary: 0,
			storage: 0
		};
		if (typeof value === "number" || typeof value === "boolean") {
			info$1.boundary = 4;
			info$1.storage = 4;
		} else if (value.isVector2) {
			info$1.boundary = 8;
			info$1.storage = 8;
		} else if (value.isVector3 || value.isColor) {
			info$1.boundary = 16;
			info$1.storage = 12;
		} else if (value.isVector4) {
			info$1.boundary = 16;
			info$1.storage = 16;
		} else if (value.isMatrix3) {
			info$1.boundary = 48;
			info$1.storage = 48;
		} else if (value.isMatrix4) {
			info$1.boundary = 64;
			info$1.storage = 64;
		} else if (value.isTexture) warn("WebGLRenderer: Texture samplers can not be part of an uniforms group.");
		else warn("WebGLRenderer: Unsupported uniform value type.", value);
		return info$1;
	}
	function onUniformsGroupsDispose(event) {
		const uniformsGroup = event.target;
		uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
		const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
		allocatedBindingPoints.splice(index, 1);
		gl.deleteBuffer(buffers[uniformsGroup.id]);
		delete buffers[uniformsGroup.id];
		delete updateList[uniformsGroup.id];
	}
	function dispose() {
		for (const id in buffers) gl.deleteBuffer(buffers[id]);
		allocatedBindingPoints = [];
		buffers = {};
		updateList = {};
	}
	return {
		bind,
		update,
		dispose
	};
}
/**
* Precomputed DFG LUT for Image-Based Lighting
* Resolution: 32x32
* Samples: 4096 per texel
* Format: RG16F (2 half floats per texel: scale, bias)
*/
var DATA = new Uint16Array([
	11481,
	15204,
	11534,
	15171,
	11808,
	15015,
	12385,
	14843,
	12894,
	14716,
	13396,
	14600,
	13693,
	14483,
	13976,
	14366,
	14237,
	14171,
	14405,
	13961,
	14511,
	13770,
	14605,
	13598,
	14687,
	13444,
	14760,
	13305,
	14822,
	13066,
	14876,
	12857,
	14923,
	12675,
	14963,
	12517,
	14997,
	12379,
	15025,
	12230,
	15049,
	12023,
	15070,
	11843,
	15086,
	11687,
	15100,
	11551,
	15111,
	11433,
	15120,
	11330,
	15127,
	11217,
	15132,
	11060,
	15135,
	10922,
	15138,
	10801,
	15139,
	10695,
	15139,
	10600,
	13012,
	14923,
	13020,
	14917,
	13064,
	14886,
	13176,
	14800,
	13349,
	14666,
	13513,
	14526,
	13724,
	14398,
	13960,
	14230,
	14200,
	14020,
	14383,
	13827,
	14488,
	13651,
	14583,
	13491,
	14667,
	13348,
	14740,
	13132,
	14803,
	12908,
	14856,
	12713,
	14901,
	12542,
	14938,
	12394,
	14968,
	12241,
	14992,
	12017,
	15010,
	11822,
	15024,
	11654,
	15034,
	11507,
	15041,
	11380,
	15044,
	11269,
	15044,
	11081,
	15042,
	10913,
	15037,
	10764,
	15031,
	10635,
	15023,
	10520,
	15014,
	10419,
	15003,
	10330,
	13657,
	14676,
	13658,
	14673,
	13670,
	14660,
	13698,
	14622,
	13750,
	14547,
	13834,
	14442,
	13956,
	14317,
	14112,
	14093,
	14291,
	13889,
	14407,
	13704,
	14499,
	13538,
	14586,
	13389,
	14664,
	13201,
	14733,
	12966,
	14792,
	12758,
	14842,
	12577,
	14882,
	12418,
	14915,
	12272,
	14940,
	12033,
	14959,
	11826,
	14972,
	11646,
	14980,
	11490,
	14983,
	11355,
	14983,
	11212,
	14979,
	11008,
	14971,
	10830,
	14961,
	10675,
	14950,
	10540,
	14936,
	10420,
	14923,
	10315,
	14909,
	10204,
	14894,
	10041,
	14089,
	14460,
	14090,
	14459,
	14096,
	14452,
	14112,
	14431,
	14141,
	14388,
	14186,
	14305,
	14252,
	14130,
	14341,
	13941,
	14399,
	13756,
	14467,
	13585,
	14539,
	13430,
	14610,
	13272,
	14677,
	13026,
	14737,
	12808,
	14790,
	12617,
	14833,
	12449,
	14869,
	12303,
	14896,
	12065,
	14916,
	11845,
	14929,
	11655,
	14937,
	11490,
	14939,
	11347,
	14936,
	11184,
	14930,
	10970,
	14921,
	10783,
	14912,
	10621,
	14900,
	10480,
	14885,
	10356,
	14867,
	10247,
	14848,
	10062,
	14827,
	9894,
	14805,
	9745,
	14400,
	14208,
	14400,
	14206,
	14402,
	14198,
	14406,
	14174,
	14415,
	14122,
	14427,
	14035,
	14444,
	13913,
	14469,
	13767,
	14504,
	13613,
	14548,
	13463,
	14598,
	13324,
	14651,
	13082,
	14704,
	12858,
	14752,
	12658,
	14795,
	12483,
	14831,
	12330,
	14860,
	12106,
	14881,
	11875,
	14895,
	11675,
	14903,
	11501,
	14905,
	11351,
	14903,
	11178,
	14900,
	10953,
	14892,
	10757,
	14880,
	10589,
	14865,
	10442,
	14847,
	10313,
	14827,
	10162,
	14805,
	9965,
	14782,
	9792,
	14757,
	9642,
	14731,
	9507,
	14562,
	13883,
	14562,
	13883,
	14563,
	13877,
	14566,
	13862,
	14570,
	13830,
	14576,
	13773,
	14584,
	13689,
	14595,
	13582,
	14613,
	13461,
	14637,
	13336,
	14668,
	13120,
	14704,
	12897,
	14741,
	12695,
	14776,
	12516,
	14808,
	12358,
	14835,
	12150,
	14856,
	11910,
	14870,
	11701,
	14878,
	11519,
	14882,
	11361,
	14884,
	11187,
	14880,
	10951,
	14871,
	10748,
	14858,
	10572,
	14842,
	10418,
	14823,
	10286,
	14801,
	10099,
	14777,
	9897,
	14751,
	9722,
	14725,
	9567,
	14696,
	9430,
	14666,
	9309,
	14702,
	13604,
	14702,
	13604,
	14702,
	13600,
	14703,
	13591,
	14705,
	13570,
	14707,
	13533,
	14709,
	13477,
	14712,
	13400,
	14718,
	13305,
	14727,
	13106,
	14743,
	12907,
	14762,
	12716,
	14784,
	12539,
	14807,
	12380,
	14827,
	12190,
	14844,
	11943,
	14855,
	11727,
	14863,
	11539,
	14870,
	11376,
	14871,
	11204,
	14868,
	10960,
	14858,
	10748,
	14845,
	10565,
	14829,
	10406,
	14809,
	10269,
	14786,
	10058,
	14761,
	9852,
	14734,
	9671,
	14705,
	9512,
	14674,
	9374,
	14641,
	9253,
	14608,
	9076,
	14821,
	13366,
	14821,
	13365,
	14821,
	13364,
	14821,
	13358,
	14821,
	13344,
	14821,
	13320,
	14819,
	13252,
	14817,
	13145,
	14815,
	13011,
	14814,
	12858,
	14817,
	12698,
	14823,
	12539,
	14832,
	12389,
	14841,
	12214,
	14850,
	11968,
	14856,
	11750,
	14861,
	11558,
	14866,
	11390,
	14867,
	11226,
	14862,
	10972,
	14853,
	10754,
	14840,
	10565,
	14823,
	10401,
	14803,
	10259,
	14780,
	10032,
	14754,
	9820,
	14725,
	9635,
	14694,
	9473,
	14661,
	9333,
	14627,
	9203,
	14593,
	8988,
	14557,
	8798,
	14923,
	13014,
	14922,
	13014,
	14922,
	13012,
	14922,
	13004,
	14920,
	12987,
	14919,
	12957,
	14915,
	12907,
	14909,
	12834,
	14902,
	12738,
	14894,
	12623,
	14888,
	12498,
	14883,
	12370,
	14880,
	12203,
	14878,
	11970,
	14875,
	11759,
	14873,
	11569,
	14874,
	11401,
	14872,
	11243,
	14865,
	10986,
	14855,
	10762,
	14842,
	10568,
	14825,
	10401,
	14804,
	10255,
	14781,
	10017,
	14754,
	9799,
	14725,
	9611,
	14692,
	9445,
	14658,
	9301,
	14623,
	9139,
	14587,
	8920,
	14548,
	8729,
	14509,
	8562,
	15008,
	12672,
	15008,
	12672,
	15008,
	12671,
	15007,
	12667,
	15005,
	12656,
	15001,
	12637,
	14997,
	12605,
	14989,
	12556,
	14978,
	12490,
	14966,
	12407,
	14953,
	12313,
	14940,
	12136,
	14927,
	11934,
	14914,
	11742,
	14903,
	11563,
	14896,
	11401,
	14889,
	11247,
	14879,
	10992,
	14866,
	10767,
	14851,
	10570,
	14833,
	10400,
	14812,
	10252,
	14789,
	10007,
	14761,
	9784,
	14731,
	9592,
	14698,
	9424,
	14663,
	9279,
	14627,
	9088,
	14588,
	8868,
	14548,
	8676,
	14508,
	8508,
	14467,
	8360,
	15080,
	12386,
	15080,
	12386,
	15079,
	12385,
	15078,
	12383,
	15076,
	12378,
	15072,
	12367,
	15066,
	12347,
	15057,
	12315,
	15045,
	12253,
	15030,
	12138,
	15012,
	11998,
	14993,
	11845,
	14972,
	11685,
	14951,
	11530,
	14935,
	11383,
	14920,
	11228,
	14904,
	10981,
	14887,
	10762,
	14870,
	10567,
	14850,
	10397,
	14827,
	10248,
	14803,
	9997,
	14774,
	9771,
	14743,
	9578,
	14710,
	9407,
	14674,
	9259,
	14637,
	9048,
	14596,
	8826,
	14555,
	8632,
	14514,
	8464,
	14471,
	8317,
	14427,
	8182,
	15139,
	12008,
	15139,
	12008,
	15138,
	12008,
	15137,
	12007,
	15135,
	12003,
	15130,
	11990,
	15124,
	11969,
	15115,
	11929,
	15102,
	11872,
	15086,
	11794,
	15064,
	11693,
	15041,
	11581,
	15013,
	11459,
	14987,
	11336,
	14966,
	11170,
	14944,
	10944,
	14921,
	10738,
	14898,
	10552,
	14875,
	10387,
	14850,
	10239,
	14824,
	9983,
	14794,
	9758,
	14762,
	9563,
	14728,
	9392,
	14692,
	9244,
	14653,
	9014,
	14611,
	8791,
	14569,
	8597,
	14526,
	8427,
	14481,
	8281,
	14436,
	8110,
	14391,
	7885,
	15188,
	11617,
	15188,
	11617,
	15187,
	11617,
	15186,
	11618,
	15183,
	11617,
	15179,
	11612,
	15173,
	11601,
	15163,
	11581,
	15150,
	11546,
	15133,
	11495,
	15110,
	11427,
	15083,
	11346,
	15051,
	11246,
	15024,
	11057,
	14996,
	10868,
	14967,
	10687,
	14938,
	10517,
	14911,
	10362,
	14882,
	10206,
	14853,
	9956,
	14821,
	9737,
	14787,
	9543,
	14752,
	9375,
	14715,
	9228,
	14675,
	8980,
	14632,
	8760,
	14589,
	8565,
	14544,
	8395,
	14498,
	8248,
	14451,
	8049,
	14404,
	7824,
	14357,
	7630,
	15228,
	11298,
	15228,
	11298,
	15227,
	11299,
	15226,
	11301,
	15223,
	11303,
	15219,
	11302,
	15213,
	11299,
	15204,
	11290,
	15191,
	11271,
	15174,
	11217,
	15150,
	11129,
	15119,
	11015,
	15087,
	10886,
	15057,
	10744,
	15024,
	10599,
	14990,
	10455,
	14957,
	10318,
	14924,
	10143,
	14891,
	9911,
	14856,
	9701,
	14820,
	9516,
	14782,
	9352,
	14744,
	9200,
	14703,
	8946,
	14659,
	8725,
	14615,
	8533,
	14568,
	8366,
	14521,
	8220,
	14472,
	7992,
	14423,
	7770,
	14374,
	7578,
	14315,
	7408,
	15260,
	10819,
	15260,
	10819,
	15259,
	10822,
	15258,
	10826,
	15256,
	10832,
	15251,
	10836,
	15246,
	10841,
	15237,
	10838,
	15225,
	10821,
	15207,
	10788,
	15183,
	10734,
	15151,
	10660,
	15120,
	10571,
	15087,
	10469,
	15049,
	10359,
	15012,
	10249,
	14974,
	10041,
	14937,
	9837,
	14900,
	9647,
	14860,
	9475,
	14820,
	9320,
	14779,
	9147,
	14736,
	8902,
	14691,
	8688,
	14646,
	8499,
	14598,
	8335,
	14549,
	8189,
	14499,
	7940,
	14448,
	7720,
	14397,
	7529,
	14347,
	7363,
	14256,
	7218,
	15285,
	10410,
	15285,
	10411,
	15285,
	10413,
	15284,
	10418,
	15282,
	10425,
	15278,
	10434,
	15272,
	10442,
	15264,
	10449,
	15252,
	10445,
	15235,
	10433,
	15210,
	10403,
	15179,
	10358,
	15149,
	10301,
	15113,
	10218,
	15073,
	10059,
	15033,
	9894,
	14991,
	9726,
	14951,
	9565,
	14909,
	9413,
	14865,
	9273,
	14822,
	9073,
	14777,
	8845,
	14730,
	8641,
	14682,
	8459,
	14633,
	8300,
	14583,
	8129,
	14531,
	7883,
	14479,
	7670,
	14426,
	7482,
	14373,
	7321,
	14305,
	7176,
	14201,
	6939,
	15305,
	9939,
	15305,
	9940,
	15305,
	9945,
	15304,
	9955,
	15302,
	9967,
	15298,
	9989,
	15293,
	10010,
	15286,
	10033,
	15274,
	10044,
	15258,
	10045,
	15233,
	10022,
	15205,
	9975,
	15174,
	9903,
	15136,
	9808,
	15095,
	9697,
	15053,
	9578,
	15009,
	9451,
	14965,
	9327,
	14918,
	9198,
	14871,
	8973,
	14825,
	8766,
	14775,
	8579,
	14725,
	8408,
	14675,
	8259,
	14622,
	8058,
	14569,
	7821,
	14515,
	7615,
	14460,
	7435,
	14405,
	7276,
	14350,
	7108,
	14256,
	6866,
	14149,
	6653,
	15321,
	9444,
	15321,
	9445,
	15321,
	9448,
	15320,
	9458,
	15317,
	9470,
	15314,
	9490,
	15310,
	9515,
	15302,
	9540,
	15292,
	9562,
	15276,
	9579,
	15251,
	9577,
	15226,
	9559,
	15195,
	9519,
	15156,
	9463,
	15116,
	9389,
	15071,
	9304,
	15025,
	9208,
	14978,
	9023,
	14927,
	8838,
	14878,
	8661,
	14827,
	8496,
	14774,
	8344,
	14722,
	8206,
	14667,
	7973,
	14612,
	7749,
	14556,
	7555,
	14499,
	7382,
	14443,
	7229,
	14385,
	7025,
	14322,
	6791,
	14210,
	6588,
	14100,
	6409,
	15333,
	8920,
	15333,
	8921,
	15332,
	8927,
	15332,
	8943,
	15329,
	8965,
	15326,
	9002,
	15322,
	9048,
	15316,
	9106,
	15307,
	9162,
	15291,
	9204,
	15267,
	9221,
	15244,
	9221,
	15212,
	9196,
	15175,
	9134,
	15133,
	9043,
	15088,
	8930,
	15040,
	8801,
	14990,
	8665,
	14938,
	8526,
	14886,
	8391,
	14830,
	8261,
	14775,
	8087,
	14719,
	7866,
	14661,
	7664,
	14603,
	7482,
	14544,
	7322,
	14485,
	7178,
	14426,
	6936,
	14367,
	6713,
	14281,
	6517,
	14166,
	6348,
	14054,
	6198,
	15341,
	8360,
	15341,
	8361,
	15341,
	8366,
	15341,
	8379,
	15339,
	8399,
	15336,
	8431,
	15332,
	8473,
	15326,
	8527,
	15318,
	8585,
	15302,
	8632,
	15281,
	8670,
	15258,
	8690,
	15227,
	8690,
	15191,
	8664,
	15149,
	8612,
	15104,
	8543,
	15055,
	8456,
	15001,
	8360,
	14948,
	8259,
	14892,
	8122,
	14834,
	7923,
	14776,
	7734,
	14716,
	7558,
	14656,
	7397,
	14595,
	7250,
	14534,
	7070,
	14472,
	6835,
	14410,
	6628,
	14350,
	6443,
	14243,
	6283,
	14125,
	6135,
	14010,
	5889,
	15348,
	7715,
	15348,
	7717,
	15348,
	7725,
	15347,
	7745,
	15345,
	7780,
	15343,
	7836,
	15339,
	7905,
	15334,
	8e3,
	15326,
	8103,
	15310,
	8193,
	15293,
	8239,
	15270,
	8270,
	15240,
	8287,
	15204,
	8283,
	15163,
	8260,
	15118,
	8223,
	15067,
	8143,
	15014,
	8014,
	14958,
	7873,
	14899,
	7723,
	14839,
	7573,
	14778,
	7430,
	14715,
	7293,
	14652,
	7164,
	14588,
	6931,
	14524,
	6720,
	14460,
	6531,
	14396,
	6362,
	14330,
	6210,
	14207,
	6015,
	14086,
	5781,
	13969,
	5576,
	15352,
	7114,
	15352,
	7116,
	15352,
	7128,
	15352,
	7159,
	15350,
	7195,
	15348,
	7237,
	15345,
	7299,
	15340,
	7374,
	15332,
	7457,
	15317,
	7544,
	15301,
	7633,
	15280,
	7703,
	15251,
	7754,
	15216,
	7775,
	15176,
	7767,
	15131,
	7733,
	15079,
	7670,
	15026,
	7588,
	14967,
	7492,
	14906,
	7387,
	14844,
	7278,
	14779,
	7171,
	14714,
	6965,
	14648,
	6770,
	14581,
	6587,
	14515,
	6420,
	14448,
	6269,
	14382,
	6123,
	14299,
	5881,
	14172,
	5665,
	14049,
	5477,
	13929,
	5310,
	15355,
	6329,
	15355,
	6330,
	15355,
	6339,
	15355,
	6362,
	15353,
	6410,
	15351,
	6472,
	15349,
	6572,
	15344,
	6688,
	15337,
	6835,
	15323,
	6985,
	15309,
	7142,
	15287,
	7220,
	15260,
	7277,
	15226,
	7310,
	15188,
	7326,
	15142,
	7318,
	15090,
	7285,
	15036,
	7239,
	14976,
	7177,
	14914,
	7045,
	14849,
	6892,
	14782,
	6736,
	14714,
	6581,
	14645,
	6433,
	14576,
	6293,
	14506,
	6164,
	14438,
	5946,
	14369,
	5733,
	14270,
	5540,
	14140,
	5369,
	14014,
	5216,
	13892,
	5043,
	15357,
	5483,
	15357,
	5484,
	15357,
	5496,
	15357,
	5528,
	15356,
	5597,
	15354,
	5692,
	15351,
	5835,
	15347,
	6011,
	15339,
	6195,
	15328,
	6317,
	15314,
	6446,
	15293,
	6566,
	15268,
	6668,
	15235,
	6746,
	15197,
	6796,
	15152,
	6811,
	15101,
	6790,
	15046,
	6748,
	14985,
	6673,
	14921,
	6583,
	14854,
	6479,
	14785,
	6371,
	14714,
	6259,
	14643,
	6149,
	14571,
	5946,
	14499,
	5750,
	14428,
	5567,
	14358,
	5401,
	14242,
	5250,
	14109,
	5111,
	13980,
	4870,
	13856,
	4657,
	15359,
	4555,
	15359,
	4557,
	15358,
	4573,
	15358,
	4633,
	15357,
	4715,
	15355,
	4841,
	15353,
	5061,
	15349,
	5216,
	15342,
	5391,
	15331,
	5577,
	15318,
	5770,
	15299,
	5967,
	15274,
	6150,
	15243,
	6223,
	15206,
	6280,
	15161,
	6310,
	15111,
	6317,
	15055,
	6300,
	14994,
	6262,
	14928,
	6208,
	14860,
	6141,
	14788,
	5994,
	14715,
	5838,
	14641,
	5684,
	14566,
	5529,
	14492,
	5384,
	14418,
	5247,
	14346,
	5121,
	14216,
	4892,
	14079,
	4682,
	13948,
	4496,
	13822,
	4330,
	15359,
	3498,
	15359,
	3501,
	15359,
	3520,
	15359,
	3598,
	15358,
	3719,
	15356,
	3860,
	15355,
	4137,
	15351,
	4305,
	15344,
	4563,
	15334,
	4809,
	15321,
	5116,
	15303,
	5273,
	15280,
	5418,
	15250,
	5547,
	15214,
	5653,
	15170,
	5722,
	15120,
	5761,
	15064,
	5763,
	15002,
	5733,
	14935,
	5673,
	14865,
	5597,
	14792,
	5504,
	14716,
	5400,
	14640,
	5294,
	14563,
	5185,
	14486,
	5041,
	14410,
	4841,
	14335,
	4655,
	14191,
	4482,
	14051,
	4325,
	13918,
	4183,
	13790,
	4012,
	15360,
	2282,
	15360,
	2285,
	15360,
	2306,
	15360,
	2401,
	15359,
	2547,
	15357,
	2748,
	15355,
	3103,
	15352,
	3349,
	15345,
	3675,
	15336,
	4020,
	15324,
	4272,
	15307,
	4496,
	15285,
	4716,
	15255,
	4908,
	15220,
	5086,
	15178,
	5170,
	15128,
	5214,
	15072,
	5234,
	15010,
	5231,
	14943,
	5206,
	14871,
	5166,
	14796,
	5102,
	14718,
	4971,
	14639,
	4833,
	14559,
	4687,
	14480,
	4541,
	14402,
	4401,
	14315,
	4268,
	14167,
	4142,
	14025,
	3958,
	13888,
	3747,
	13759,
	3556,
	15360,
	923,
	15360,
	925,
	15360,
	946,
	15360,
	1052,
	15359,
	1214,
	15357,
	1494,
	15356,
	1892,
	15352,
	2274,
	15346,
	2663,
	15338,
	3099,
	15326,
	3393,
	15309,
	3679,
	15288,
	3980,
	15260,
	4183,
	15226,
	4325,
	15185,
	4437,
	15136,
	4517,
	15080,
	4570,
	15018,
	4591,
	14950,
	4581,
	14877,
	4545,
	14800,
	4485,
	14720,
	4411,
	14638,
	4325,
	14556,
	4231,
	14475,
	4136,
	14395,
	3988,
	14297,
	3803,
	14145,
	3628,
	13999,
	3465,
	13861,
	3314,
	13729,
	3177,
	15360,
	263,
	15360,
	264,
	15360,
	272,
	15360,
	325,
	15359,
	407,
	15358,
	548,
	15356,
	780,
	15352,
	1144,
	15347,
	1580,
	15339,
	2099,
	15328,
	2425,
	15312,
	2795,
	15292,
	3133,
	15264,
	3329,
	15232,
	3517,
	15191,
	3689,
	15143,
	3819,
	15088,
	3923,
	15025,
	3978,
	14956,
	3999,
	14882,
	3979,
	14804,
	3931,
	14722,
	3855,
	14639,
	3756,
	14554,
	3645,
	14470,
	3529,
	14388,
	3409,
	14279,
	3289,
	14124,
	3173,
	13975,
	3055,
	13834,
	2848,
	13701,
	2658,
	15360,
	49,
	15360,
	49,
	15360,
	52,
	15360,
	75,
	15359,
	111,
	15358,
	201,
	15356,
	283,
	15353,
	519,
	15348,
	726,
	15340,
	1045,
	15329,
	1415,
	15314,
	1795,
	15295,
	2173,
	15269,
	2410,
	15237,
	2649,
	15197,
	2866,
	15150,
	3054,
	15095,
	3140,
	15032,
	3196,
	14963,
	3228,
	14888,
	3236,
	14808,
	3224,
	14725,
	3191,
	14639,
	3146,
	14553,
	3088,
	14466,
	2976,
	14382,
	2836,
	14262,
	2692,
	14103,
	2549,
	13952,
	2409,
	13808,
	2278,
	13674,
	2154,
	15360,
	4,
	15360,
	4,
	15360,
	4,
	15360,
	13,
	15359,
	33,
	15358,
	59,
	15357,
	112,
	15353,
	199,
	15348,
	302,
	15341,
	456,
	15331,
	628,
	15316,
	827,
	15297,
	1082,
	15272,
	1332,
	15241,
	1601,
	15202,
	1851,
	15156,
	2069,
	15101,
	2172,
	15039,
	2256,
	14970,
	2314,
	14894,
	2348,
	14813,
	2358,
	14728,
	2344,
	14640,
	2311,
	14551,
	2263,
	14463,
	2203,
	14376,
	2133,
	14247,
	2059,
	14084,
	1915,
	13930,
	1761,
	13784,
	1609,
	13648,
	1464,
	15360,
	0,
	15360,
	0,
	15360,
	0,
	15360,
	3,
	15359,
	18,
	15358,
	26,
	15357,
	53,
	15354,
	80,
	15348,
	97,
	15341,
	165,
	15332,
	238,
	15318,
	326,
	15299,
	427,
	15275,
	529,
	15245,
	654,
	15207,
	771,
	15161,
	885,
	15108,
	994,
	15046,
	1089,
	14976,
	1170,
	14900,
	1229,
	14817,
	1266,
	14731,
	1284,
	14641,
	1282,
	14550,
	1260,
	14460,
	1223,
	14370,
	1174,
	14232,
	1116,
	14066,
	1050,
	13909,
	981,
	13761,
	910,
	13623,
	839
]);
var lut = null;
function getDFGLUT() {
	if (lut === null) {
		lut = new DataTexture(DATA, 32, 32, RGFormat, HalfFloatType);
		lut.minFilter = LinearFilter;
		lut.magFilter = LinearFilter;
		lut.wrapS = ClampToEdgeWrapping;
		lut.wrapT = ClampToEdgeWrapping;
		lut.generateMipmaps = false;
		lut.needsUpdate = true;
	}
	return lut;
}
/**
* This renderer uses WebGL 2 to display scenes.
*
* WebGL 1 is not supported since `r163`.
*/
var WebGLRenderer = class {
	/**
	* Constructs a new WebGL renderer.
	*
	* @param {WebGLRenderer~Options} [parameters] - The configuration parameter.
	*/
	constructor(parameters = {}) {
		const { canvas = createCanvasElement(), context: context$2 = null, depth: depth$2 = true, stencil = false, alpha = false, antialias = false, premultipliedAlpha = true, preserveDrawingBuffer = false, powerPreference = "default", failIfMajorPerformanceCaveat = false, reversedDepthBuffer = false } = parameters;
		/**
		* This flag can be used for type testing.
		*
		* @type {boolean}
		* @readonly
		* @default true
		*/
		this.isWebGLRenderer = true;
		let _alpha;
		if (context$2 !== null) {
			if (typeof WebGLRenderingContext !== "undefined" && context$2 instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
			_alpha = context$2.getContextAttributes().alpha;
		} else _alpha = alpha;
		const INTEGER_FORMATS = new Set([
			RGBAIntegerFormat,
			RGIntegerFormat,
			RedIntegerFormat
		]);
		const UNSIGNED_TYPES = new Set([
			UnsignedByteType,
			UnsignedIntType,
			UnsignedShortType,
			UnsignedInt248Type,
			UnsignedShort4444Type,
			UnsignedShort5551Type
		]);
		const uintClearColor = new Uint32Array(4);
		const intClearColor = new Int32Array(4);
		let currentRenderList = null;
		let currentRenderState = null;
		const renderListStack = [];
		const renderStateStack = [];
		/**
		* A canvas where the renderer draws its output.This is automatically created by the renderer
		* in the constructor (if not provided already); you just need to add it to your page like so:
		* ```js
		* document.body.appendChild( renderer.domElement );
		* ```
		*
		* @type {HTMLCanvasElement|OffscreenCanvas}
		*/
		this.domElement = canvas;
		/**
		* A object with debug configuration settings.
		*
		* - `checkShaderErrors`: If it is `true`, defines whether material shader programs are
		* checked for errors during compilation and linkage process. It may be useful to disable
		* this check in production for performance gain. It is strongly recommended to keep these
		* checks enabled during development. If the shader does not compile and link - it will not
		* work and associated material will not render.
		* - `onShaderError(gl, program, glVertexShader,glFragmentShader)`: A callback function that
		* can be used for custom error reporting. The callback receives the WebGL context, an instance
		* of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.
		* Assigning a custom function disables the default error reporting.
		*
		* @type {Object}
		*/
		this.debug = {
			checkShaderErrors: true,
			onShaderError: null
		};
		/**
		* Whether the renderer should automatically clear its output before rendering a frame or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.autoClear = true;
		/**
		* If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
		* the color buffer or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.autoClearColor = true;
		/**
		* If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
		* the depth buffer or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.autoClearDepth = true;
		/**
		* If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
		* the stencil buffer or not.
		*
		* @type {boolean}
		* @default true
		*/
		this.autoClearStencil = true;
		/**
		* Whether the renderer should sort objects or not.
		*
		* Note: Sorting is used to attempt to properly render objects that have some
		* degree of transparency. By definition, sorting objects may not work in all
		* cases. Depending on the needs of application, it may be necessary to turn
		* off sorting and use other methods to deal with transparency rendering e.g.
		* manually determining each object's rendering order.
		*
		* @type {boolean}
		* @default true
		*/
		this.sortObjects = true;
		/**
		* User-defined clipping planes specified in world space. These planes apply globally.
		* Points in space whose dot product with the plane is negative are cut away.
		*
		* @type {Array<Plane>}
		*/
		this.clippingPlanes = [];
		/**
		* Whether the renderer respects object-level clipping planes or not.
		*
		* @type {boolean}
		* @default false
		*/
		this.localClippingEnabled = false;
		/**
		* The tone mapping technique of the renderer.
		*
		* @type {(NoToneMapping|LinearToneMapping|ReinhardToneMapping|CineonToneMapping|ACESFilmicToneMapping|CustomToneMapping|AgXToneMapping|NeutralToneMapping)}
		* @default NoToneMapping
		*/
		this.toneMapping = NoToneMapping;
		/**
		* Exposure level of tone mapping.
		*
		* @type {number}
		* @default 1
		*/
		this.toneMappingExposure = 1;
		/**
		* The normalized resolution scale for the transmission render target, measured in percentage
		* of viewport dimensions. Lowering this value can result in significant performance improvements
		* when using {@link MeshPhysicalMaterial#transmission}.
		*
		* @type {number}
		* @default 1
		*/
		this.transmissionResolutionScale = 1;
		const _this = this;
		let _isContextLost = false;
		this._outputColorSpace = SRGBColorSpace;
		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;
		let _currentMaterialId = -1;
		let _currentCamera = null;
		const _currentViewport = new Vector4();
		const _currentScissor = new Vector4();
		let _currentScissorTest = null;
		const _currentClearColor = new Color$1(0);
		let _currentClearAlpha = 0;
		let _width = canvas.width;
		let _height = canvas.height;
		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;
		const _viewport$1 = new Vector4(0, 0, _width, _height);
		const _scissor = new Vector4(0, 0, _width, _height);
		let _scissorTest = false;
		const _frustum$2 = new Frustum();
		let _clippingEnabled = false;
		let _localClippingEnabled = false;
		const _projScreenMatrix$4 = new Matrix4();
		const _vector3 = new Vector3();
		const _vector4$1 = new Vector4();
		const _emptyScene = {
			background: null,
			fog: null,
			environment: null,
			overrideMaterial: null,
			isScene: true
		};
		let _renderBackground = false;
		function getTargetPixelRatio() {
			return _currentRenderTarget === null ? _pixelRatio : 1;
		}
		let _gl = context$2;
		function getContext(contextName, contextAttributes) {
			return canvas.getContext(contextName, contextAttributes);
		}
		try {
			const contextAttributes = {
				alpha: true,
				depth: depth$2,
				stencil,
				antialias,
				premultipliedAlpha,
				preserveDrawingBuffer,
				powerPreference,
				failIfMajorPerformanceCaveat
			};
			if ("setAttribute" in canvas) canvas.setAttribute("data-engine", `three.js r${REVISION}`);
			canvas.addEventListener("webglcontextlost", onContextLost, false);
			canvas.addEventListener("webglcontextrestored", onContextRestore, false);
			canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
			if (_gl === null) {
				const contextName = "webgl2";
				_gl = getContext(contextName, contextAttributes);
				if (_gl === null) if (getContext(contextName)) throw new Error("Error creating WebGL context with your selected attributes.");
				else throw new Error("Error creating WebGL context.");
			}
		} catch (error$1) {
			error$1("WebGLRenderer: " + error$1.message);
			throw error$1;
		}
		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping$1, shadowMap;
		let background, morphtargets, bufferRenderer, indexedBufferRenderer;
		let utils, bindingStates, uniformsGroups;
		function initGLContext() {
			extensions = new WebGLExtensions(_gl);
			extensions.init();
			utils = new WebGLUtils(_gl, extensions);
			capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
			state = new WebGLState(_gl, extensions);
			if (capabilities.reversedDepthBuffer && reversedDepthBuffer) state.buffers.depth.setReversed(true);
			info = new WebGLInfo(_gl);
			properties = new WebGLProperties();
			textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
			cubemaps = new WebGLCubeMaps(_this);
			cubeuvmaps = new WebGLCubeUVMaps(_this);
			attributes = new WebGLAttributes(_gl);
			bindingStates = new WebGLBindingStates(_gl, attributes);
			geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
			objects = new WebGLObjects(_gl, geometries, attributes, info);
			morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
			clipping$1 = new WebGLClipping(properties);
			programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping$1);
			materials = new WebGLMaterials(_this, properties);
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates(extensions);
			background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
			shadowMap = new WebGLShadowMap(_this, objects, capabilities);
			uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
			bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
			indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
			info.programs = programCache.programs;
			/**
			* Holds details about the capabilities of the current rendering context.
			*
			* @name WebGLRenderer#capabilities
			* @type {WebGLRenderer~Capabilities}
			*/
			_this.capabilities = capabilities;
			/**
			* Provides methods for retrieving and testing WebGL extensions.
			*
			* - `get(extensionName:string)`: Used to check whether a WebGL extension is supported
			* and return the extension object if available.
			* - `has(extensionName:string)`: returns `true` if the extension is supported.
			*
			* @name WebGLRenderer#extensions
			* @type {Object}
			*/
			_this.extensions = extensions;
			/**
			* Used to track properties of other objects like native WebGL objects.
			*
			* @name WebGLRenderer#properties
			* @type {Object}
			*/
			_this.properties = properties;
			/**
			* Manages the render lists of the renderer.
			*
			* @name WebGLRenderer#renderLists
			* @type {Object}
			*/
			_this.renderLists = renderLists;
			/**
			* Interface for managing shadows.
			*
			* @name WebGLRenderer#shadowMap
			* @type {WebGLRenderer~ShadowMap}
			*/
			_this.shadowMap = shadowMap;
			/**
			* Interface for managing the WebGL state.
			*
			* @name WebGLRenderer#state
			* @type {Object}
			*/
			_this.state = state;
			/**
			* Holds a series of statistical information about the GPU memory
			* and the rendering process. Useful for debugging and monitoring.
			*
			* By default these data are reset at each render call but when having
			* multiple render passes per frame (e.g. when using post processing) it can
			* be preferred to reset with a custom pattern. First, set `autoReset` to
			* `false`.
			* ```js
			* renderer.info.autoReset = false;
			* ```
			* Call `reset()` whenever you have finished to render a single frame.
			* ```js
			* renderer.info.reset();
			* ```
			*
			* @name WebGLRenderer#info
			* @type {WebGLRenderer~Info}
			*/
			_this.info = info;
		}
		initGLContext();
		const xr = new WebXRManager(_this, _gl);
		/**
		* A reference to the XR manager.
		*
		* @type {WebXRManager}
		*/
		this.xr = xr;
		/**
		* Returns the rendering context.
		*
		* @return {WebGL2RenderingContext} The rendering context.
		*/
		this.getContext = function() {
			return _gl;
		};
		/**
		* Returns the rendering context attributes.
		*
		* @return {WebGLContextAttributes} The rendering context attributes.
		*/
		this.getContextAttributes = function() {
			return _gl.getContextAttributes();
		};
		/**
		* Simulates a loss of the WebGL context. This requires support for the `WEBGL_lose_context` extension.
		*/
		this.forceContextLoss = function() {
			const extension = extensions.get("WEBGL_lose_context");
			if (extension) extension.loseContext();
		};
		/**
		* Simulates a restore of the WebGL context. This requires support for the `WEBGL_lose_context` extension.
		*/
		this.forceContextRestore = function() {
			const extension = extensions.get("WEBGL_lose_context");
			if (extension) extension.restoreContext();
		};
		/**
		* Returns the pixel ratio.
		*
		* @return {number} The pixel ratio.
		*/
		this.getPixelRatio = function() {
			return _pixelRatio;
		};
		/**
		* Sets the given pixel ratio and resizes the canvas if necessary.
		*
		* @param {number} value - The pixel ratio.
		*/
		this.setPixelRatio = function(value) {
			if (value === void 0) return;
			_pixelRatio = value;
			this.setSize(_width, _height, false);
		};
		/**
		* Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
		*
		* @param {Vector2} target - The method writes the result in this target object.
		* @return {Vector2} The renderer's size in logical pixels.
		*/
		this.getSize = function(target) {
			return target.set(_width, _height);
		};
		/**
		* Resizes the output canvas to (width, height) with device pixel ratio taken
		* into account, and also sets the viewport to fit that size, starting in (0,
		* 0). Setting `updateStyle` to false prevents any style changes to the output canvas.
		*
		* @param {number} width - The width in logical pixels.
		* @param {number} height - The height in logical pixels.
		* @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
		*/
		this.setSize = function(width, height, updateStyle = true) {
			if (xr.isPresenting) {
				warn("WebGLRenderer: Can't change size while VR device is presenting.");
				return;
			}
			_width = width;
			_height = height;
			canvas.width = Math.floor(width * _pixelRatio);
			canvas.height = Math.floor(height * _pixelRatio);
			if (updateStyle === true) {
				canvas.style.width = width + "px";
				canvas.style.height = height + "px";
			}
			this.setViewport(0, 0, width, height);
		};
		/**
		* Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
		*
		* @param {Vector2} target - The method writes the result in this target object.
		* @return {Vector2} The drawing buffer size.
		*/
		this.getDrawingBufferSize = function(target) {
			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
		};
		/**
		* This method allows to define the drawing buffer size by specifying
		* width, height and pixel ratio all at once. The size of the drawing
		* buffer is computed with this formula:
		* ```js
		* size.x = width * pixelRatio;
		* size.y = height * pixelRatio;
		* ```
		*
		* @param {number} width - The width in logical pixels.
		* @param {number} height - The height in logical pixels.
		* @param {number} pixelRatio - The pixel ratio.
		*/
		this.setDrawingBufferSize = function(width, height, pixelRatio) {
			_width = width;
			_height = height;
			_pixelRatio = pixelRatio;
			canvas.width = Math.floor(width * pixelRatio);
			canvas.height = Math.floor(height * pixelRatio);
			this.setViewport(0, 0, width, height);
		};
		/**
		* Returns the current viewport definition.
		*
		* @param {Vector2} target - The method writes the result in this target object.
		* @return {Vector2} The current viewport definition.
		*/
		this.getCurrentViewport = function(target) {
			return target.copy(_currentViewport);
		};
		/**
		* Returns the viewport definition.
		*
		* @param {Vector4} target - The method writes the result in this target object.
		* @return {Vector4} The viewport definition.
		*/
		this.getViewport = function(target) {
			return target.copy(_viewport$1);
		};
		/**
		* Sets the viewport to render from `(x, y)` to `(x + width, y + height)`.
		*
		* @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
		* Or alternatively a four-component vector specifying all the parameters of the viewport.
		* @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
		* @param {number} width - The width of the viewport in logical pixel unit.
		* @param {number} height - The height of the viewport in logical pixel unit.
		*/
		this.setViewport = function(x, y, width, height) {
			if (x.isVector4) _viewport$1.set(x.x, x.y, x.z, x.w);
			else _viewport$1.set(x, y, width, height);
			state.viewport(_currentViewport.copy(_viewport$1).multiplyScalar(_pixelRatio).round());
		};
		/**
		* Returns the scissor region.
		*
		* @param {Vector4} target - The method writes the result in this target object.
		* @return {Vector4} The scissor region.
		*/
		this.getScissor = function(target) {
			return target.copy(_scissor);
		};
		/**
		* Sets the scissor region to render from `(x, y)` to `(x + width, y + height)`.
		*
		* @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the scissor region origin in logical pixel unit.
		* Or alternatively a four-component vector specifying all the parameters of the scissor region.
		* @param {number} y - The vertical coordinate for the lower left corner of the scissor region origin  in logical pixel unit.
		* @param {number} width - The width of the scissor region in logical pixel unit.
		* @param {number} height - The height of the scissor region in logical pixel unit.
		*/
		this.setScissor = function(x, y, width, height) {
			if (x.isVector4) _scissor.set(x.x, x.y, x.z, x.w);
			else _scissor.set(x, y, width, height);
			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
		};
		/**
		* Returns `true` if the scissor test is enabled.
		*
		* @return {boolean} Whether the scissor test is enabled or not.
		*/
		this.getScissorTest = function() {
			return _scissorTest;
		};
		/**
		* Enable or disable the scissor test. When this is enabled, only the pixels
		* within the defined scissor area will be affected by further renderer
		* actions.
		*
		* @param {boolean} boolean - Whether the scissor test is enabled or not.
		*/
		this.setScissorTest = function(boolean) {
			state.setScissorTest(_scissorTest = boolean);
		};
		/**
		* Sets a custom opaque sort function for the render lists. Pass `null`
		* to use the default `painterSortStable` function.
		*
		* @param {?Function} method - The opaque sort function.
		*/
		this.setOpaqueSort = function(method) {
			_opaqueSort = method;
		};
		/**
		* Sets a custom transparent sort function for the render lists. Pass `null`
		* to use the default `reversePainterSortStable` function.
		*
		* @param {?Function} method - The opaque sort function.
		*/
		this.setTransparentSort = function(method) {
			_transparentSort = method;
		};
		/**
		* Returns the clear color.
		*
		* @param {Color} target - The method writes the result in this target object.
		* @return {Color} The clear color.
		*/
		this.getClearColor = function(target) {
			return target.copy(background.getClearColor());
		};
		/**
		* Sets the clear color and alpha.
		*
		* @param {Color} color - The clear color.
		* @param {number} [alpha=1] - The clear alpha.
		*/
		this.setClearColor = function() {
			background.setClearColor(...arguments);
		};
		/**
		* Returns the clear alpha. Ranges within `[0,1]`.
		*
		* @return {number} The clear alpha.
		*/
		this.getClearAlpha = function() {
			return background.getClearAlpha();
		};
		/**
		* Sets the clear alpha.
		*
		* @param {number} alpha - The clear alpha.
		*/
		this.setClearAlpha = function() {
			background.setClearAlpha(...arguments);
		};
		/**
		* Tells the renderer to clear its color, depth or stencil drawing buffer(s).
		* This method initializes the buffers to the current clear color values.
		*
		* @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
		* @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
		* @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
		*/
		this.clear = function(color$2 = true, depth$3 = true, stencil$1 = true) {
			let bits = 0;
			if (color$2) {
				let isIntegerFormat = false;
				if (_currentRenderTarget !== null) {
					const targetFormat = _currentRenderTarget.texture.format;
					isIntegerFormat = INTEGER_FORMATS.has(targetFormat);
				}
				if (isIntegerFormat) {
					const targetType = _currentRenderTarget.texture.type;
					const isUnsignedType = UNSIGNED_TYPES.has(targetType);
					const clearColor = background.getClearColor();
					const a$1 = background.getClearAlpha();
					const r = clearColor.r;
					const g$1 = clearColor.g;
					const b$2 = clearColor.b;
					if (isUnsignedType) {
						uintClearColor[0] = r;
						uintClearColor[1] = g$1;
						uintClearColor[2] = b$2;
						uintClearColor[3] = a$1;
						_gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
					} else {
						intClearColor[0] = r;
						intClearColor[1] = g$1;
						intClearColor[2] = b$2;
						intClearColor[3] = a$1;
						_gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
					}
				} else bits |= _gl.COLOR_BUFFER_BIT;
			}
			if (depth$3) bits |= _gl.DEPTH_BUFFER_BIT;
			if (stencil$1) {
				bits |= _gl.STENCIL_BUFFER_BIT;
				this.state.buffers.stencil.setMask(4294967295);
			}
			_gl.clear(bits);
		};
		/**
		* Clears the color buffer. Equivalent to calling `renderer.clear( true, false, false )`.
		*/
		this.clearColor = function() {
			this.clear(true, false, false);
		};
		/**
		* Clears the depth buffer. Equivalent to calling `renderer.clear( false, true, false )`.
		*/
		this.clearDepth = function() {
			this.clear(false, true, false);
		};
		/**
		* Clears the stencil buffer. Equivalent to calling `renderer.clear( false, false, true )`.
		*/
		this.clearStencil = function() {
			this.clear(false, false, true);
		};
		/**
		* Frees the GPU-related resources allocated by this instance. Call this
		* method whenever this instance is no longer used in your app.
		*/
		this.dispose = function() {
			canvas.removeEventListener("webglcontextlost", onContextLost, false);
			canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
			canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
			background.dispose();
			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			uniformsGroups.dispose();
			programCache.dispose();
			xr.dispose();
			xr.removeEventListener("sessionstart", onXRSessionStart);
			xr.removeEventListener("sessionend", onXRSessionEnd);
			animation.stop();
		};
		function onContextLost(event) {
			event.preventDefault();
			log("WebGLRenderer: Context Lost.");
			_isContextLost = true;
		}
		function onContextRestore() {
			log("WebGLRenderer: Context Restored.");
			_isContextLost = false;
			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;
			initGLContext();
			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;
		}
		function onContextCreationError(event) {
			error("WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
		}
		function onMaterialDispose(event) {
			const material = event.target;
			material.removeEventListener("dispose", onMaterialDispose);
			deallocateMaterial(material);
		}
		function deallocateMaterial(material) {
			releaseMaterialProgramReferences(material);
			properties.remove(material);
		}
		function releaseMaterialProgramReferences(material) {
			const programs = properties.get(material).programs;
			if (programs !== void 0) {
				programs.forEach(function(program) {
					programCache.releaseProgram(program);
				});
				if (material.isShaderMaterial) programCache.releaseShaderCache(material);
			}
		}
		this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
			if (scene === null) scene = _emptyScene;
			const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
			const program = setProgram(camera, scene, geometry, material, object);
			state.setMaterial(material, frontFaceCW);
			let index = geometry.index;
			let rangeFactor = 1;
			if (material.wireframe === true) {
				index = geometries.getWireframeAttribute(geometry);
				if (index === void 0) return;
				rangeFactor = 2;
			}
			const drawRange = geometry.drawRange;
			const position = geometry.attributes.position;
			let drawStart = drawRange.start * rangeFactor;
			let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
			if (group !== null) {
				drawStart = Math.max(drawStart, group.start * rangeFactor);
				drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
			}
			if (index !== null) {
				drawStart = Math.max(drawStart, 0);
				drawEnd = Math.min(drawEnd, index.count);
			} else if (position !== void 0 && position !== null) {
				drawStart = Math.max(drawStart, 0);
				drawEnd = Math.min(drawEnd, position.count);
			}
			const drawCount = drawEnd - drawStart;
			if (drawCount < 0 || drawCount === Infinity) return;
			bindingStates.setup(object, material, program, geometry, index);
			let attribute$2;
			let renderer = bufferRenderer;
			if (index !== null) {
				attribute$2 = attributes.get(index);
				renderer = indexedBufferRenderer;
				renderer.setIndex(attribute$2);
			}
			if (object.isMesh) if (material.wireframe === true) {
				state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
				renderer.setMode(_gl.LINES);
			} else renderer.setMode(_gl.TRIANGLES);
			else if (object.isLine) {
				let lineWidth = material.linewidth;
				if (lineWidth === void 0) lineWidth = 1;
				state.setLineWidth(lineWidth * getTargetPixelRatio());
				if (object.isLineSegments) renderer.setMode(_gl.LINES);
				else if (object.isLineLoop) renderer.setMode(_gl.LINE_LOOP);
				else renderer.setMode(_gl.LINE_STRIP);
			} else if (object.isPoints) renderer.setMode(_gl.POINTS);
			else if (object.isSprite) renderer.setMode(_gl.TRIANGLES);
			if (object.isBatchedMesh) if (object._multiDrawInstances !== null) {
				warnOnce("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");
				renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
			} else if (!extensions.get("WEBGL_multi_draw")) {
				const starts = object._multiDrawStarts;
				const counts = object._multiDrawCounts;
				const drawCount$1 = object._multiDrawCount;
				const bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;
				const uniforms = properties.get(material).currentProgram.getUniforms();
				for (let i = 0; i < drawCount$1; i++) {
					uniforms.setValue(_gl, "_gl_DrawID", i);
					renderer.render(starts[i] / bytesPerElement, counts[i]);
				}
			} else renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
			else if (object.isInstancedMesh) renderer.renderInstances(drawStart, drawCount, object.count);
			else if (geometry.isInstancedBufferGeometry) {
				const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
				const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
				renderer.renderInstances(drawStart, drawCount, instanceCount);
			} else renderer.render(drawStart, drawCount);
		};
		function prepareMaterial(material, scene, object) {
			if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
				material.side = BackSide;
				material.needsUpdate = true;
				getProgram(material, scene, object);
				material.side = FrontSide;
				material.needsUpdate = true;
				getProgram(material, scene, object);
				material.side = DoubleSide;
			} else getProgram(material, scene, object);
		}
		/**
		* Compiles all materials in the scene with the camera. This is useful to precompile shaders
		* before the first rendering. If you want to add a 3D object to an existing scene, use the third
		* optional parameter for applying the target scene.
		*
		* Note that the (target) scene's lighting and environment must be configured before calling this method.
		*
		* @param {Object3D} scene - The scene or another type of 3D object to precompile.
		* @param {Camera} camera - The camera.
		* @param {?Scene} [targetScene=null] - The target scene.
		* @return {Set<Material>} The precompiled materials.
		*/
		this.compile = function(scene, camera, targetScene = null) {
			if (targetScene === null) targetScene = scene;
			currentRenderState = renderStates.get(targetScene);
			currentRenderState.init(camera);
			renderStateStack.push(currentRenderState);
			targetScene.traverseVisible(function(object) {
				if (object.isLight && object.layers.test(camera.layers)) {
					currentRenderState.pushLight(object);
					if (object.castShadow) currentRenderState.pushShadow(object);
				}
			});
			if (scene !== targetScene) scene.traverseVisible(function(object) {
				if (object.isLight && object.layers.test(camera.layers)) {
					currentRenderState.pushLight(object);
					if (object.castShadow) currentRenderState.pushShadow(object);
				}
			});
			currentRenderState.setupLights();
			const materials$1 = /* @__PURE__ */ new Set();
			scene.traverse(function(object) {
				if (!(object.isMesh || object.isPoints || object.isLine || object.isSprite)) return;
				const material = object.material;
				if (material) if (Array.isArray(material)) for (let i = 0; i < material.length; i++) {
					const material2 = material[i];
					prepareMaterial(material2, targetScene, object);
					materials$1.add(material2);
				}
				else {
					prepareMaterial(material, targetScene, object);
					materials$1.add(material);
				}
			});
			currentRenderState = renderStateStack.pop();
			return materials$1;
		};
		/**
		* Asynchronous version of {@link WebGLRenderer#compile}.
		*
		* This method makes use of the `KHR_parallel_shader_compile` WebGL extension. Hence,
		* it is recommended to use this version of `compile()` whenever possible.
		*
		* @async
		* @param {Object3D} scene - The scene or another type of 3D object to precompile.
		* @param {Camera} camera - The camera.
		* @param {?Scene} [targetScene=null] - The target scene.
		* @return {Promise} A Promise that resolves when the given scene can be rendered without unnecessary stalling due to shader compilation.
		*/
		this.compileAsync = function(scene, camera, targetScene = null) {
			const materials$1 = this.compile(scene, camera, targetScene);
			return new Promise((resolve) => {
				function checkMaterialsReady() {
					materials$1.forEach(function(material) {
						if (properties.get(material).currentProgram.isReady()) materials$1.delete(material);
					});
					if (materials$1.size === 0) {
						resolve(scene);
						return;
					}
					setTimeout(checkMaterialsReady, 10);
				}
				if (extensions.get("KHR_parallel_shader_compile") !== null) checkMaterialsReady();
				else setTimeout(checkMaterialsReady, 10);
			});
		};
		let onAnimationFrameCallback = null;
		function onAnimationFrame$1(time$2) {
			if (onAnimationFrameCallback) onAnimationFrameCallback(time$2);
		}
		function onXRSessionStart() {
			animation.stop();
		}
		function onXRSessionEnd() {
			animation.start();
		}
		const animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame$1);
		if (typeof self !== "undefined") animation.setContext(self);
		/**
		* Applications are advised to always define the animation loop
		* with this method and not manually with `requestAnimationFrame()`
		* for best compatibility.
		*
		* @param {?onAnimationCallback} callback - The application's animation loop.
		*/
		this.setAnimationLoop = function(callback) {
			onAnimationFrameCallback = callback;
			xr.setAnimationLoop(callback);
			callback === null ? animation.stop() : animation.start();
		};
		xr.addEventListener("sessionstart", onXRSessionStart);
		xr.addEventListener("sessionend", onXRSessionEnd);
		/**
		* Renders the given scene (or other type of 3D object) using the given camera.
		*
		* The render is done to a previously specified render target set by calling {@link WebGLRenderer#setRenderTarget}
		* or to the canvas as usual.
		*
		* By default render buffers are cleared before rendering but you can prevent
		* this by setting the property `autoClear` to `false`. If you want to prevent
		* only certain buffers being cleared you can `autoClearColor`, `autoClearDepth`
		* or `autoClearStencil` to `false`. To force a clear, use {@link WebGLRenderer#clear}.
		*
		* @param {Object3D} scene - The scene to render.
		* @param {Camera} camera - The camera.
		*/
		this.render = function(scene, camera) {
			if (camera !== void 0 && camera.isCamera !== true) {
				error("WebGLRenderer.render: camera is not an instance of THREE.Camera.");
				return;
			}
			if (_isContextLost === true) return;
			if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
			if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
			if (xr.enabled === true && xr.isPresenting === true) {
				if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
				camera = xr.getCamera();
			}
			if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
			currentRenderState = renderStates.get(scene, renderStateStack.length);
			currentRenderState.init(camera);
			renderStateStack.push(currentRenderState);
			_projScreenMatrix$4.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			_frustum$2.setFromProjectionMatrix(_projScreenMatrix$4, WebGLCoordinateSystem, camera.reversedDepth);
			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping$1.init(this.clippingPlanes, _localClippingEnabled);
			currentRenderList = renderLists.get(scene, renderListStack.length);
			currentRenderList.init();
			renderListStack.push(currentRenderList);
			if (xr.enabled === true && xr.isPresenting === true) {
				const depthSensingMesh = _this.xr.getDepthSensingMesh();
				if (depthSensingMesh !== null) projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
			}
			projectObject(scene, camera, 0, _this.sortObjects);
			currentRenderList.finish();
			if (_this.sortObjects === true) currentRenderList.sort(_opaqueSort, _transparentSort);
			_renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
			if (_renderBackground) background.addToRenderList(currentRenderList, scene);
			this.info.render.frame++;
			if (_clippingEnabled === true) clipping$1.beginShadows();
			const shadowsArray = currentRenderState.state.shadowsArray;
			shadowMap.render(shadowsArray, scene, camera);
			if (_clippingEnabled === true) clipping$1.endShadows();
			if (this.info.autoReset === true) this.info.reset();
			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;
			currentRenderState.setupLights();
			if (camera.isArrayCamera) {
				const cameras = camera.cameras;
				if (transmissiveObjects.length > 0) for (let i = 0, l = cameras.length; i < l; i++) {
					const camera2 = cameras[i];
					renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
				}
				if (_renderBackground) background.render(scene);
				for (let i = 0, l = cameras.length; i < l; i++) {
					const camera2 = cameras[i];
					renderScene(currentRenderList, scene, camera2, camera2.viewport);
				}
			} else {
				if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
				if (_renderBackground) background.render(scene);
				renderScene(currentRenderList, scene, camera);
			}
			if (_currentRenderTarget !== null && _currentActiveMipmapLevel === 0) {
				textures.updateMultisampleRenderTarget(_currentRenderTarget);
				textures.updateRenderTargetMipmap(_currentRenderTarget);
			}
			if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
			bindingStates.resetDefaultState();
			_currentMaterialId = -1;
			_currentCamera = null;
			renderStateStack.pop();
			if (renderStateStack.length > 0) {
				currentRenderState = renderStateStack[renderStateStack.length - 1];
				if (_clippingEnabled === true) clipping$1.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
			} else currentRenderState = null;
			renderListStack.pop();
			if (renderListStack.length > 0) currentRenderList = renderListStack[renderListStack.length - 1];
			else currentRenderList = null;
		};
		function projectObject(object, camera, groupOrder, sortObjects) {
			if (object.visible === false) return;
			if (object.layers.test(camera.layers)) {
				if (object.isGroup) groupOrder = object.renderOrder;
				else if (object.isLOD) {
					if (object.autoUpdate === true) object.update(camera);
				} else if (object.isLight) {
					currentRenderState.pushLight(object);
					if (object.castShadow) currentRenderState.pushShadow(object);
				} else if (object.isSprite) {
					if (!object.frustumCulled || _frustum$2.intersectsSprite(object)) {
						if (sortObjects) _vector4$1.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix$4);
						const geometry = objects.update(object);
						const material = object.material;
						if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector4$1.z, null);
					}
				} else if (object.isMesh || object.isLine || object.isPoints) {
					if (!object.frustumCulled || _frustum$2.intersectsObject(object)) {
						const geometry = objects.update(object);
						const material = object.material;
						if (sortObjects) {
							if (object.boundingSphere !== void 0) {
								if (object.boundingSphere === null) object.computeBoundingSphere();
								_vector4$1.copy(object.boundingSphere.center);
							} else {
								if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
								_vector4$1.copy(geometry.boundingSphere.center);
							}
							_vector4$1.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix$4);
						}
						if (Array.isArray(material)) {
							const groups = geometry.groups;
							for (let i = 0, l = groups.length; i < l; i++) {
								const group = groups[i];
								const groupMaterial = material[group.materialIndex];
								if (groupMaterial && groupMaterial.visible) currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector4$1.z, group);
							}
						} else if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector4$1.z, null);
					}
				}
			}
			const children = object.children;
			for (let i = 0, l = children.length; i < l; i++) projectObject(children[i], camera, groupOrder, sortObjects);
		}
		function renderScene(currentRenderList$1, scene, camera, viewport$2) {
			const { opaque: opaqueObjects, transmissive: transmissiveObjects, transparent: transparentObjects } = currentRenderList$1;
			currentRenderState.setupLightsView(camera);
			if (_clippingEnabled === true) clipping$1.setGlobalState(_this.clippingPlanes, camera);
			if (viewport$2) state.viewport(_currentViewport.copy(viewport$2));
			if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
			if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
			if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
			state.buffers.depth.setTest(true);
			state.buffers.depth.setMask(true);
			state.buffers.color.setMask(true);
			state.setPolygonOffset(false);
		}
		function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
			if ((scene.isScene === true ? scene.overrideMaterial : null) !== null) return;
			if (currentRenderState.state.transmissionRenderTarget[camera.id] === void 0) currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
				generateMipmaps: true,
				type: extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType,
				minFilter: LinearMipmapLinearFilter,
				samples: 4,
				stencilBuffer: stencil,
				resolveDepthBuffer: false,
				resolveStencilBuffer: false,
				colorSpace: ColorManagement.workingColorSpace
			});
			const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
			const activeViewport = camera.viewport || _currentViewport;
			transmissionRenderTarget.setSize(activeViewport.z * _this.transmissionResolutionScale, activeViewport.w * _this.transmissionResolutionScale);
			const currentRenderTarget = _this.getRenderTarget();
			const currentActiveCubeFace = _this.getActiveCubeFace();
			const currentActiveMipmapLevel = _this.getActiveMipmapLevel();
			_this.setRenderTarget(transmissionRenderTarget);
			_this.getClearColor(_currentClearColor);
			_currentClearAlpha = _this.getClearAlpha();
			if (_currentClearAlpha < 1) _this.setClearColor(16777215, .5);
			_this.clear();
			if (_renderBackground) background.render(scene);
			const currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;
			const currentCameraViewport = camera.viewport;
			if (camera.viewport !== void 0) camera.viewport = void 0;
			currentRenderState.setupLightsView(camera);
			if (_clippingEnabled === true) clipping$1.setGlobalState(_this.clippingPlanes, camera);
			renderObjects(opaqueObjects, scene, camera);
			textures.updateMultisampleRenderTarget(transmissionRenderTarget);
			textures.updateRenderTargetMipmap(transmissionRenderTarget);
			if (extensions.has("WEBGL_multisampled_render_to_texture") === false) {
				let renderTargetNeedsUpdate = false;
				for (let i = 0, l = transmissiveObjects.length; i < l; i++) {
					const { object, geometry, material, group } = transmissiveObjects[i];
					if (material.side === DoubleSide && object.layers.test(camera.layers)) {
						const currentSide = material.side;
						material.side = BackSide;
						material.needsUpdate = true;
						renderObject(object, scene, camera, geometry, material, group);
						material.side = currentSide;
						material.needsUpdate = true;
						renderTargetNeedsUpdate = true;
					}
				}
				if (renderTargetNeedsUpdate === true) {
					textures.updateMultisampleRenderTarget(transmissionRenderTarget);
					textures.updateRenderTargetMipmap(transmissionRenderTarget);
				}
			}
			_this.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
			_this.setClearColor(_currentClearColor, _currentClearAlpha);
			if (currentCameraViewport !== void 0) camera.viewport = currentCameraViewport;
			_this.toneMapping = currentToneMapping;
		}
		function renderObjects(renderList, scene, camera) {
			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
			for (let i = 0, l = renderList.length; i < l; i++) {
				const renderItem = renderList[i];
				const { object, geometry, group } = renderItem;
				let material = renderItem.material;
				if (material.allowOverride === true && overrideMaterial !== null) material = overrideMaterial;
				if (object.layers.test(camera.layers)) renderObject(object, scene, camera, geometry, material, group);
			}
		}
		function renderObject(object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group);
			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
			material.onBeforeRender(_this, scene, camera, geometry, object, group);
			if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
				material.side = BackSide;
				material.needsUpdate = true;
				_this.renderBufferDirect(camera, scene, geometry, material, object, group);
				material.side = FrontSide;
				material.needsUpdate = true;
				_this.renderBufferDirect(camera, scene, geometry, material, object, group);
				material.side = DoubleSide;
			} else _this.renderBufferDirect(camera, scene, geometry, material, object, group);
			object.onAfterRender(_this, scene, camera, geometry, material, group);
		}
		function getProgram(material, scene, object) {
			if (scene.isScene !== true) scene = _emptyScene;
			const materialProperties = properties.get(material);
			const lights$2 = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;
			const lightsStateVersion = lights$2.state.version;
			const parameters$1 = programCache.getParameters(material, lights$2.state, shadowsArray, scene, object);
			const programCacheKey = programCache.getProgramCacheKey(parameters$1);
			let programs = materialProperties.programs;
			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
			materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
			if (programs === void 0) {
				material.addEventListener("dispose", onMaterialDispose);
				programs = /* @__PURE__ */ new Map();
				materialProperties.programs = programs;
			}
			let program = programs.get(programCacheKey);
			if (program !== void 0) {
				if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
					updateCommonMaterialProperties(material, parameters$1);
					return program;
				}
			} else {
				parameters$1.uniforms = programCache.getUniforms(material);
				material.onBeforeCompile(parameters$1, _this);
				program = programCache.acquireProgram(parameters$1, programCacheKey);
				programs.set(programCacheKey, program);
				materialProperties.uniforms = parameters$1.uniforms;
			}
			const uniforms = materialProperties.uniforms;
			if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) uniforms.clippingPlanes = clipping$1.uniform;
			updateCommonMaterialProperties(material, parameters$1);
			materialProperties.needsLights = materialNeedsLights(material);
			materialProperties.lightsStateVersion = lightsStateVersion;
			if (materialProperties.needsLights) {
				uniforms.ambientLightColor.value = lights$2.state.ambient;
				uniforms.lightProbe.value = lights$2.state.probe;
				uniforms.directionalLights.value = lights$2.state.directional;
				uniforms.directionalLightShadows.value = lights$2.state.directionalShadow;
				uniforms.spotLights.value = lights$2.state.spot;
				uniforms.spotLightShadows.value = lights$2.state.spotShadow;
				uniforms.rectAreaLights.value = lights$2.state.rectArea;
				uniforms.ltc_1.value = lights$2.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights$2.state.rectAreaLTC2;
				uniforms.pointLights.value = lights$2.state.point;
				uniforms.pointLightShadows.value = lights$2.state.pointShadow;
				uniforms.hemisphereLights.value = lights$2.state.hemi;
				uniforms.directionalShadowMap.value = lights$2.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights$2.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights$2.state.spotShadowMap;
				uniforms.spotLightMatrix.value = lights$2.state.spotLightMatrix;
				uniforms.spotLightMap.value = lights$2.state.spotLightMap;
				uniforms.pointShadowMap.value = lights$2.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights$2.state.pointShadowMatrix;
			}
			materialProperties.currentProgram = program;
			materialProperties.uniformsList = null;
			return program;
		}
		function getUniformList(materialProperties) {
			if (materialProperties.uniformsList === null) {
				const progUniforms = materialProperties.currentProgram.getUniforms();
				materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
			}
			return materialProperties.uniformsList;
		}
		function updateCommonMaterialProperties(material, parameters$1) {
			const materialProperties = properties.get(material);
			materialProperties.outputColorSpace = parameters$1.outputColorSpace;
			materialProperties.batching = parameters$1.batching;
			materialProperties.batchingColor = parameters$1.batchingColor;
			materialProperties.instancing = parameters$1.instancing;
			materialProperties.instancingColor = parameters$1.instancingColor;
			materialProperties.instancingMorph = parameters$1.instancingMorph;
			materialProperties.skinning = parameters$1.skinning;
			materialProperties.morphTargets = parameters$1.morphTargets;
			materialProperties.morphNormals = parameters$1.morphNormals;
			materialProperties.morphColors = parameters$1.morphColors;
			materialProperties.morphTargetsCount = parameters$1.morphTargetsCount;
			materialProperties.numClippingPlanes = parameters$1.numClippingPlanes;
			materialProperties.numIntersection = parameters$1.numClipIntersection;
			materialProperties.vertexAlphas = parameters$1.vertexAlphas;
			materialProperties.vertexTangents = parameters$1.vertexTangents;
			materialProperties.toneMapping = parameters$1.toneMapping;
		}
		function setProgram(camera, scene, geometry, material, object) {
			if (scene.isScene !== true) scene = _emptyScene;
			textures.resetTextureUnits();
			const fog$2 = scene.fog;
			const environment$1 = material.isMeshStandardMaterial ? scene.environment : null;
			const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment$1);
			const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
			const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
			const morphTargets = !!geometry.morphAttributes.position;
			const morphNormals = !!geometry.morphAttributes.normal;
			const morphColors = !!geometry.morphAttributes.color;
			let toneMapping$2 = NoToneMapping;
			if (material.toneMapped) {
				if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) toneMapping$2 = _this.toneMapping;
			}
			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
			const materialProperties = properties.get(material);
			const lights$2 = currentRenderState.state.lights;
			if (_clippingEnabled === true) {
				if (_localClippingEnabled === true || camera !== _currentCamera) {
					const useCache = camera === _currentCamera && material.id === _currentMaterialId;
					clipping$1.setState(material, camera, useCache);
				}
			}
			let needsProgramChange = false;
			if (material.version === materialProperties.__version) {
				if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights$2.state.version) needsProgramChange = true;
				else if (materialProperties.outputColorSpace !== colorSpace) needsProgramChange = true;
				else if (object.isBatchedMesh && materialProperties.batching === false) needsProgramChange = true;
				else if (!object.isBatchedMesh && materialProperties.batching === true) needsProgramChange = true;
				else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) needsProgramChange = true;
				else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) needsProgramChange = true;
				else if (object.isInstancedMesh && materialProperties.instancing === false) needsProgramChange = true;
				else if (!object.isInstancedMesh && materialProperties.instancing === true) needsProgramChange = true;
				else if (object.isSkinnedMesh && materialProperties.skinning === false) needsProgramChange = true;
				else if (!object.isSkinnedMesh && materialProperties.skinning === true) needsProgramChange = true;
				else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) needsProgramChange = true;
				else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) needsProgramChange = true;
				else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) needsProgramChange = true;
				else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) needsProgramChange = true;
				else if (materialProperties.envMap !== envMap) needsProgramChange = true;
				else if (material.fog === true && materialProperties.fog !== fog$2) needsProgramChange = true;
				else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping$1.numPlanes || materialProperties.numIntersection !== clipping$1.numIntersection)) needsProgramChange = true;
				else if (materialProperties.vertexAlphas !== vertexAlphas) needsProgramChange = true;
				else if (materialProperties.vertexTangents !== vertexTangents) needsProgramChange = true;
				else if (materialProperties.morphTargets !== morphTargets) needsProgramChange = true;
				else if (materialProperties.morphNormals !== morphNormals) needsProgramChange = true;
				else if (materialProperties.morphColors !== morphColors) needsProgramChange = true;
				else if (materialProperties.toneMapping !== toneMapping$2) needsProgramChange = true;
				else if (materialProperties.morphTargetsCount !== morphTargetsCount) needsProgramChange = true;
			} else {
				needsProgramChange = true;
				materialProperties.__version = material.version;
			}
			let program = materialProperties.currentProgram;
			if (needsProgramChange === true) program = getProgram(material, scene, object);
			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;
			const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
			if (state.useProgram(program.program)) {
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
			}
			if (material.id !== _currentMaterialId) {
				_currentMaterialId = material.id;
				refreshMaterial = true;
			}
			if (refreshProgram || _currentCamera !== camera) {
				if (state.buffers.depth.getReversed() && camera.reversedDepth !== true) {
					camera._reversedDepth = true;
					camera.updateProjectionMatrix();
				}
				p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
				p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
				const uCamPos = p_uniforms.map.cameraPosition;
				if (uCamPos !== void 0) uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
				if (capabilities.logarithmicDepthBuffer) p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
				if (_currentCamera !== camera) {
					_currentCamera = camera;
					refreshMaterial = true;
					refreshLights = true;
				}
			}
			if (object.isSkinnedMesh) {
				p_uniforms.setOptional(_gl, object, "bindMatrix");
				p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
				const skeleton = object.skeleton;
				if (skeleton) {
					if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
					p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
				}
			}
			if (object.isBatchedMesh) {
				p_uniforms.setOptional(_gl, object, "batchingTexture");
				p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures);
				p_uniforms.setOptional(_gl, object, "batchingIdTexture");
				p_uniforms.setValue(_gl, "batchingIdTexture", object._indirectTexture, textures);
				p_uniforms.setOptional(_gl, object, "batchingColorTexture");
				if (object._colorsTexture !== null) p_uniforms.setValue(_gl, "batchingColorTexture", object._colorsTexture, textures);
			}
			const morphAttributes = geometry.morphAttributes;
			if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) morphtargets.update(object, geometry, program);
			if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
			}
			if (material.isMeshGouraudMaterial && material.envMap !== null) {
				m_uniforms.envMap.value = envMap;
				m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
			}
			if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) m_uniforms.envMapIntensity.value = scene.environmentIntensity;
			if (m_uniforms.dfgLUT !== void 0) m_uniforms.dfgLUT.value = getDFGLUT();
			if (refreshMaterial) {
				p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
				if (materialProperties.needsLights) markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
				if (fog$2 && material.fog === true) materials.refreshFogUniforms(m_uniforms, fog$2);
				materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
				WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
			}
			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
				WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
				material.uniformsNeedUpdate = false;
			}
			if (material.isSpriteMaterial) p_uniforms.setValue(_gl, "center", object.center);
			p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
			p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
			p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
			if (material.isShaderMaterial || material.isRawShaderMaterial) {
				const groups = material.uniformsGroups;
				for (let i = 0, l = groups.length; i < l; i++) {
					const group = groups[i];
					uniformsGroups.update(group, program);
					uniformsGroups.bind(group, program);
				}
			}
			return program;
		}
		function markUniformsLightsNeedsUpdate(uniforms, value) {
			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;
			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
		}
		function materialNeedsLights(material) {
			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
		}
		/**
		* Returns the active cube face.
		*
		* @return {number} The active cube face.
		*/
		this.getActiveCubeFace = function() {
			return _currentActiveCubeFace;
		};
		/**
		* Returns the active mipmap level.
		*
		* @return {number} The active mipmap level.
		*/
		this.getActiveMipmapLevel = function() {
			return _currentActiveMipmapLevel;
		};
		/**
		* Returns the active render target.
		*
		* @return {?WebGLRenderTarget} The active render target. Returns `null` if no render target
		* is currently set.
		*/
		this.getRenderTarget = function() {
			return _currentRenderTarget;
		};
		this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
			const renderTargetProperties = properties.get(renderTarget);
			renderTargetProperties.__autoAllocateDepthBuffer = renderTarget.resolveDepthBuffer === false;
			if (renderTargetProperties.__autoAllocateDepthBuffer === false) renderTargetProperties.__useRenderToTexture = false;
			properties.get(renderTarget.texture).__webglTexture = colorTexture;
			properties.get(renderTarget.depthTexture).__webglTexture = renderTargetProperties.__autoAllocateDepthBuffer ? void 0 : depthTexture;
			renderTargetProperties.__hasExternalTextures = true;
		};
		this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
			const renderTargetProperties = properties.get(renderTarget);
			renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
			renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
		};
		const _scratchFrameBuffer = _gl.createFramebuffer();
		/**
		* Sets the active rendertarget.
		*
		* @param {?WebGLRenderTarget} renderTarget - The render target to set. When `null` is given,
		* the canvas is set as the active render target instead.
		* @param {number} [activeCubeFace=0] - The active cube face when using a cube render target.
		* Indicates the z layer to render in to when using 3D or array render targets.
		* @param {number} [activeMipmapLevel=0] - The active mipmap level.
		*/
		this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;
			let useDefaultFramebuffer = true;
			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;
			if (renderTarget) {
				const renderTargetProperties = properties.get(renderTarget);
				if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
					state.bindFramebuffer(_gl.FRAMEBUFFER, null);
					useDefaultFramebuffer = false;
				} else if (renderTargetProperties.__webglFramebuffer === void 0) textures.setupRenderTarget(renderTarget);
				else if (renderTargetProperties.__hasExternalTextures) textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
				else if (renderTarget.depthBuffer) {
					const depthTexture = renderTarget.depthTexture;
					if (renderTargetProperties.__boundDepthTexture !== depthTexture) {
						if (depthTexture !== null && properties.has(depthTexture) && (renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
						textures.setupDepthRenderbuffer(renderTarget);
					}
				}
				const texture$2 = renderTarget.texture;
				if (texture$2.isData3DTexture || texture$2.isDataArrayTexture || texture$2.isCompressedArrayTexture) isRenderTarget3D = true;
				const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
				if (renderTarget.isWebGLCubeRenderTarget) {
					if (Array.isArray(__webglFramebuffer[activeCubeFace])) framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
					else framebuffer = __webglFramebuffer[activeCubeFace];
					isCube = true;
				} else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
				else if (Array.isArray(__webglFramebuffer)) framebuffer = __webglFramebuffer[activeMipmapLevel];
				else framebuffer = __webglFramebuffer;
				_currentViewport.copy(renderTarget.viewport);
				_currentScissor.copy(renderTarget.scissor);
				_currentScissorTest = renderTarget.scissorTest;
			} else {
				_currentViewport.copy(_viewport$1).multiplyScalar(_pixelRatio).floor();
				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
				_currentScissorTest = _scissorTest;
			}
			if (activeMipmapLevel !== 0) framebuffer = _scratchFrameBuffer;
			if (state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer) && useDefaultFramebuffer) state.drawBuffers(renderTarget, framebuffer);
			state.viewport(_currentViewport);
			state.scissor(_currentScissor);
			state.setScissorTest(_currentScissorTest);
			if (isCube) {
				const textureProperties = properties.get(renderTarget.texture);
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
			} else if (isRenderTarget3D) {
				const layer = activeCubeFace;
				for (let i = 0; i < renderTarget.textures.length; i++) {
					const textureProperties = properties.get(renderTarget.textures[i]);
					_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, textureProperties.__webglTexture, activeMipmapLevel, layer);
				}
			} else if (renderTarget !== null && activeMipmapLevel !== 0) {
				const textureProperties = properties.get(renderTarget.texture);
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, textureProperties.__webglTexture, activeMipmapLevel);
			}
			_currentMaterialId = -1;
		};
		/**
		* Reads the pixel data from the given render target into the given buffer.
		*
		* @param {WebGLRenderTarget} renderTarget - The render target to read from.
		* @param {number} x - The `x` coordinate of the copy region's origin.
		* @param {number} y - The `y` coordinate of the copy region's origin.
		* @param {number} width - The width of the copy region.
		* @param {number} height - The height of the copy region.
		* @param {TypedArray} buffer - The result buffer.
		* @param {number} [activeCubeFaceIndex] - The active cube face index.
		* @param {number} [textureIndex=0] - The texture index of an MRT render target.
		*/
		this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer$2, activeCubeFaceIndex, textureIndex = 0) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				error("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
				return;
			}
			let framebuffer = properties.get(renderTarget).__webglFramebuffer;
			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) framebuffer = framebuffer[activeCubeFaceIndex];
			if (framebuffer) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
				try {
					const texture$2 = renderTarget.textures[textureIndex];
					const textureFormat = texture$2.format;
					const textureType = texture$2.type;
					if (!capabilities.textureFormatReadable(textureFormat)) {
						error("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
						return;
					}
					if (!capabilities.textureTypeReadable(textureType)) {
						error("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
						return;
					}
					if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
						if (renderTarget.textures.length > 1) _gl.readBuffer(_gl.COLOR_ATTACHMENT0 + textureIndex);
						_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer$2);
					}
				} finally {
					const framebuffer$1 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
					state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer$1);
				}
			}
		};
		/**
		* Asynchronous, non-blocking version of {@link WebGLRenderer#readRenderTargetPixels}.
		*
		* It is recommended to use this version of `readRenderTargetPixels()` whenever possible.
		*
		* @async
		* @param {WebGLRenderTarget} renderTarget - The render target to read from.
		* @param {number} x - The `x` coordinate of the copy region's origin.
		* @param {number} y - The `y` coordinate of the copy region's origin.
		* @param {number} width - The width of the copy region.
		* @param {number} height - The height of the copy region.
		* @param {TypedArray} buffer - The result buffer.
		* @param {number} [activeCubeFaceIndex] - The active cube face index.
		* @param {number} [textureIndex=0] - The texture index of an MRT render target.
		* @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
		*/
		this.readRenderTargetPixelsAsync = async function(renderTarget, x, y, width, height, buffer$2, activeCubeFaceIndex, textureIndex = 0) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
			let framebuffer = properties.get(renderTarget).__webglFramebuffer;
			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) framebuffer = framebuffer[activeCubeFaceIndex];
			if (framebuffer) if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
				const texture$2 = renderTarget.textures[textureIndex];
				const textureFormat = texture$2.format;
				const textureType = texture$2.type;
				if (!capabilities.textureFormatReadable(textureFormat)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
				if (!capabilities.textureTypeReadable(textureType)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
				const glBuffer = _gl.createBuffer();
				_gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
				_gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer$2.byteLength, _gl.STREAM_READ);
				if (renderTarget.textures.length > 1) _gl.readBuffer(_gl.COLOR_ATTACHMENT0 + textureIndex);
				_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
				const currFramebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
				state.bindFramebuffer(_gl.FRAMEBUFFER, currFramebuffer);
				const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
				_gl.flush();
				await probeAsync(_gl, sync, 4);
				_gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
				_gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer$2);
				_gl.deleteBuffer(glBuffer);
				_gl.deleteSync(sync);
				return buffer$2;
			} else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
		};
		/**
		* Copies pixels from the current bound framebuffer into the given texture.
		*
		* @param {FramebufferTexture} texture - The texture.
		* @param {?Vector2} [position=null] - The start position of the copy operation.
		* @param {number} [level=0] - The mip level. The default represents the base mip.
		*/
		this.copyFramebufferToTexture = function(texture$2, position = null, level = 0) {
			const levelScale = Math.pow(2, -level);
			const width = Math.floor(texture$2.image.width * levelScale);
			const height = Math.floor(texture$2.image.height * levelScale);
			const x = position !== null ? position.x : 0;
			const y = position !== null ? position.y : 0;
			textures.setTexture2D(texture$2, 0);
			_gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y, width, height);
			state.unbindTexture();
		};
		const _srcFramebuffer = _gl.createFramebuffer();
		const _dstFramebuffer = _gl.createFramebuffer();
		/**
		* Copies data of the given source texture into a destination texture.
		*
		* When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are initialized
		* {@link WebGLRenderer#initRenderTarget}.
		*
		* @param {Texture} srcTexture - The source texture.
		* @param {Texture} dstTexture - The destination texture.
		* @param {?(Box2|Box3)} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
		* @param {?(Vector2|Vector3)} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
		* @param {number} [srcLevel=0] - The source mipmap level to copy.
		* @param {?number} [dstLevel=null] - The destination mipmap level.
		*/
		this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = null) {
			if (dstLevel === null) if (srcLevel !== 0) {
				warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.");
				dstLevel = srcLevel;
				srcLevel = 0;
			} else dstLevel = 0;
			let width, height, depth$3, minX, minY, minZ;
			let dstX, dstY, dstZ;
			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[dstLevel] : srcTexture.image;
			if (srcRegion !== null) {
				width = srcRegion.max.x - srcRegion.min.x;
				height = srcRegion.max.y - srcRegion.min.y;
				depth$3 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
				minX = srcRegion.min.x;
				minY = srcRegion.min.y;
				minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
			} else {
				const levelScale = Math.pow(2, -srcLevel);
				width = Math.floor(image.width * levelScale);
				height = Math.floor(image.height * levelScale);
				if (srcTexture.isDataArrayTexture) depth$3 = image.depth;
				else if (srcTexture.isData3DTexture) depth$3 = Math.floor(image.depth * levelScale);
				else depth$3 = 1;
				minX = 0;
				minY = 0;
				minZ = 0;
			}
			if (dstPosition !== null) {
				dstX = dstPosition.x;
				dstY = dstPosition.y;
				dstZ = dstPosition.z;
			} else {
				dstX = 0;
				dstY = 0;
				dstZ = 0;
			}
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			let glTarget;
			if (dstTexture.isData3DTexture) {
				textures.setTexture3D(dstTexture, 0);
				glTarget = _gl.TEXTURE_3D;
			} else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
				textures.setTexture2DArray(dstTexture, 0);
				glTarget = _gl.TEXTURE_2D_ARRAY;
			} else {
				textures.setTexture2D(dstTexture, 0);
				glTarget = _gl.TEXTURE_2D;
			}
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
			const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
			const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
			const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
			const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
			const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
			const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;
			const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;
			if (srcTexture.isDepthTexture) {
				const srcTextureProperties = properties.get(srcTexture);
				const dstTextureProperties = properties.get(dstTexture);
				const srcRenderTargetProperties = properties.get(srcTextureProperties.__renderTarget);
				const dstRenderTargetProperties = properties.get(dstTextureProperties.__renderTarget);
				state.bindFramebuffer(_gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer);
				state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer);
				for (let i = 0; i < depth$3; i++) {
					if (isSrc3D) {
						_gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(srcTexture).__webglTexture, srcLevel, minZ + i);
						_gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(dstTexture).__webglTexture, dstLevel, dstZ + i);
					}
					_gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST);
				}
				state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
				state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
			} else if (srcLevel !== 0 || srcTexture.isRenderTargetTexture || properties.has(srcTexture)) {
				const srcTextureProperties = properties.get(srcTexture);
				const dstTextureProperties = properties.get(dstTexture);
				state.bindFramebuffer(_gl.READ_FRAMEBUFFER, _srcFramebuffer);
				state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, _dstFramebuffer);
				for (let i = 0; i < depth$3; i++) {
					if (isSrc3D) _gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, srcTextureProperties.__webglTexture, srcLevel, minZ + i);
					else _gl.framebufferTexture2D(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, srcTextureProperties.__webglTexture, srcLevel);
					if (isDst3D) _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, dstTextureProperties.__webglTexture, dstLevel, dstZ + i);
					else _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, dstTextureProperties.__webglTexture, dstLevel);
					if (srcLevel !== 0) _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST);
					else if (isDst3D) _gl.copyTexSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ + i, minX, minY, width, height);
					else _gl.copyTexSubImage2D(glTarget, dstLevel, dstX, dstY, minX, minY, width, height);
				}
				state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
				state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
			} else if (isDst3D) if (srcTexture.isDataTexture || srcTexture.isData3DTexture) _gl.texSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth$3, glFormat, glType, image.data);
			else if (dstTexture.isCompressedArrayTexture) _gl.compressedTexSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth$3, glFormat, image.data);
			else _gl.texSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth$3, glFormat, glType, image);
			else if (srcTexture.isDataTexture) _gl.texSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data);
			else if (srcTexture.isCompressedTexture) _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data);
			else _gl.texSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image);
			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
			if (dstLevel === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
			state.unbindTexture();
		};
		/**
		* Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so data
		* can be copied into it using {@link WebGLRenderer#copyTextureToTexture} before it has been
		* rendered to.
		*
		* @param {WebGLRenderTarget} target - The render target.
		*/
		this.initRenderTarget = function(target) {
			if (properties.get(target).__webglFramebuffer === void 0) textures.setupRenderTarget(target);
		};
		/**
		* Initializes the given texture. Useful for preloading a texture rather than waiting until first
		* render (which can cause noticeable lags due to decode and GPU upload overhead).
		*
		* @param {Texture} texture - The texture.
		*/
		this.initTexture = function(texture$2) {
			if (texture$2.isCubeTexture) textures.setTextureCube(texture$2, 0);
			else if (texture$2.isData3DTexture) textures.setTexture3D(texture$2, 0);
			else if (texture$2.isDataArrayTexture || texture$2.isCompressedArrayTexture) textures.setTexture2DArray(texture$2, 0);
			else textures.setTexture2D(texture$2, 0);
			state.unbindTexture();
		};
		/**
		* Can be used to reset the internal WebGL state. This method is mostly
		* relevant for applications which share a single WebGL context across
		* multiple WebGL libraries.
		*/
		this.resetState = function() {
			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;
			state.reset();
			bindingStates.reset();
		};
		if (typeof __THREE_DEVTOOLS__ !== "undefined") __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
	}
	/**
	* Defines the coordinate system of the renderer.
	*
	* In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.
	*
	* @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
	* @default WebGLCoordinateSystem
	* @readonly
	*/
	get coordinateSystem() {
		return WebGLCoordinateSystem;
	}
	/**
	* Defines the output color space of the renderer.
	*
	* @type {SRGBColorSpace|LinearSRGBColorSpace}
	* @default SRGBColorSpace
	*/
	get outputColorSpace() {
		return this._outputColorSpace;
	}
	set outputColorSpace(colorSpace) {
		this._outputColorSpace = colorSpace;
		const gl = this.getContext();
		gl.drawingBufferColorSpace = ColorManagement._getDrawingBufferColorSpace(colorSpace);
		gl.unpackColorSpace = ColorManagement._getUnpackColorSpace();
	}
};

//#endregion
//#region node_modules/shaders/dist/core/transformations-YbhRK-rd.js
function multiplyMatrices(A, B$1) {
	let m$1 = A.length;
	if (!Array.isArray(A[0])) A = [A];
	if (!Array.isArray(B$1[0])) B$1 = B$1.map((x) => [x]);
	let p$1 = B$1[0].length;
	let B_cols = B$1[0].map((_, i) => B$1.map((x) => x[i]));
	let product = A.map((row) => B_cols.map((col) => {
		let ret = 0;
		if (!Array.isArray(row)) {
			for (let c$1 of col) ret += row * c$1;
			return ret;
		}
		for (let i = 0; i < row.length; i++) ret += row[i] * (col[i] || 0);
		return ret;
	}));
	if (m$1 === 1) product = product[0];
	if (p$1 === 1) return product.map((x) => x[0]);
	return product;
}
function isString(str) {
	return type(str) === "string";
}
function type(o) {
	return (Object.prototype.toString.call(o).match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
}
function serializeNumber(n$2, { precision, unit }) {
	if (isNone(n$2)) return "none";
	return toPrecision(n$2, precision) + (unit ?? "");
}
function isNone(n$2) {
	return Number.isNaN(n$2) || n$2 instanceof Number && n$2?.none;
}
function skipNone(n$2) {
	return isNone(n$2) ? 0 : n$2;
}
function toPrecision(n$2, precision) {
	if (n$2 === 0) return 0;
	let integer = ~~n$2;
	let digits = 0;
	if (integer && precision) digits = ~~Math.log10(Math.abs(integer)) + 1;
	const multiplier = 10 ** (precision - digits);
	return Math.floor(n$2 * multiplier + .5) / multiplier;
}
var angleFactor = {
	deg: 1,
	grad: .9,
	rad: 180 / Math.PI,
	turn: 360
};
function parseFunction(str) {
	if (!str) return;
	str = str.trim();
	const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
	const isNumberRegex = /^-?[\d.]+$/;
	const unitValueRegex = /%|deg|g?rad|turn$/;
	const singleArgument = /\/?\s*(none|[-\w.]+(?:%|deg|g?rad|turn)?)/g;
	let parts = str.match(isFunctionRegex);
	if (parts) {
		let args = [];
		parts[2].replace(singleArgument, ($0, rawArg) => {
			let match = rawArg.match(unitValueRegex);
			let arg = rawArg;
			if (match) {
				let unit = match[0];
				let unitlessArg = arg.slice(0, -unit.length);
				if (unit === "%") {
					arg = /* @__PURE__ */ new Number(unitlessArg / 100);
					arg.type = "<percentage>";
				} else {
					arg = new Number(unitlessArg * angleFactor[unit]);
					arg.type = "<angle>";
					arg.unit = unit;
				}
			} else if (isNumberRegex.test(arg)) {
				arg = new Number(arg);
				arg.type = "<number>";
			} else if (arg === "none") {
				arg = /* @__PURE__ */ new Number(NaN);
				arg.none = true;
			}
			if ($0.startsWith("/")) {
				arg = arg instanceof Number ? arg : new Number(arg);
				arg.alpha = true;
			}
			if (typeof arg === "object" && arg instanceof Number) arg.raw = rawArg;
			args.push(arg);
		});
		return {
			name: parts[1].toLowerCase(),
			rawName: parts[1],
			rawArgs: parts[2],
			args
		};
	}
}
function last(arr) {
	return arr[arr.length - 1];
}
function interpolate(start, end, p$1) {
	if (isNaN(start)) return end;
	if (isNaN(end)) return start;
	return start + (end - start) * p$1;
}
function interpolateInv(start, end, value) {
	return (value - start) / (end - start);
}
function mapRange(from, to$1, value) {
	return interpolate(to$1[0], to$1[1], interpolateInv(from[0], from[1], value));
}
function parseCoordGrammar(coordGrammars) {
	return coordGrammars.map((coordGrammar$1) => {
		return coordGrammar$1.split("|").map((type$1) => {
			type$1 = type$1.trim();
			let range$1$1 = type$1.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
			if (range$1$1) {
				let ret = new String(range$1$1[1]);
				ret.range = [+range$1$1[2], +range$1$1[3]];
				return ret;
			}
			return type$1;
		});
	});
}
function clamp$1(min$1$1, val, max$2$1) {
	return Math.max(Math.min(max$2$1, val), min$1$1);
}
function copySign(to$1, from) {
	return Math.sign(to$1) === Math.sign(from) ? to$1 : -to$1;
}
function spow(base, exp$1$1) {
	return copySign(Math.abs(base) ** exp$1$1, base);
}
function zdiv(n$2, d$1) {
	return d$1 === 0 ? 0 : n$2 / d$1;
}
function bisectLeft(arr, value, lo = 0, hi = arr.length) {
	while (lo < hi) {
		const mid = lo + hi >> 1;
		if (arr[mid] < value) lo = mid + 1;
		else hi = mid;
	}
	return lo;
}
var util = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	bisectLeft,
	clamp: clamp$1,
	copySign,
	interpolate,
	interpolateInv,
	isNone,
	isString,
	last,
	mapRange,
	multiplyMatrices,
	parseCoordGrammar,
	parseFunction,
	serializeNumber,
	skipNone,
	spow,
	toPrecision,
	type,
	zdiv
});
var Hooks = class {
	add(name, callback, first) {
		if (typeof arguments[0] != "string") {
			for (var name in arguments[0]) this.add(name, arguments[0][name], arguments[1]);
			return;
		}
		(Array.isArray(name) ? name : [name]).forEach(function(name$1) {
			this[name$1] = this[name$1] || [];
			if (callback) this[name$1][first ? "unshift" : "push"](callback);
		}, this);
	}
	run(name, env) {
		this[name] = this[name] || [];
		this[name].forEach(function(callback) {
			callback.call(env && env.context ? env.context : env, env);
		});
	}
};
var hooks = new Hooks();
var defaults = {
	gamut_mapping: "css",
	precision: 5,
	deltaE: "76",
	verbose: globalThis?.process?.env?.NODE_ENV?.toLowerCase() !== "test",
	warn: function warn$1(msg) {
		if (this.verbose) globalThis?.console?.warn?.(msg);
	}
};
var WHITES = {
	D50: [
		.3457 / .3585,
		1,
		.2958 / .3585
	],
	D65: [
		.3127 / .329,
		1,
		.3583 / .329
	]
};
function getWhite(name) {
	if (Array.isArray(name)) return name;
	return WHITES[name];
}
function adapt$2(W1, W2, XYZ, options = {}) {
	W1 = getWhite(W1);
	W2 = getWhite(W2);
	if (!W1 || !W2) throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
	if (W1 === W2) return XYZ;
	let env = {
		W1,
		W2,
		XYZ,
		options
	};
	hooks.run("chromatic-adaptation-start", env);
	if (!env.M) {
		if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) env.M = [
			[
				1.0479297925449969,
				.022946870601609652,
				-.05019226628920524
			],
			[
				.02962780877005599,
				.9904344267538799,
				-.017073799063418826
			],
			[
				-.009243040646204504,
				.015055191490298152,
				.7518742814281371
			]
		];
		else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) env.M = [
			[
				.955473421488075,
				-.02309845494876471,
				.06325924320057072
			],
			[
				-.0283697093338637,
				1.0099953980813041,
				.021041441191917323
			],
			[
				.012314014864481998,
				-.020507649298898964,
				1.330365926242124
			]
		];
	}
	hooks.run("chromatic-adaptation-end", env);
	if (env.M) return multiplyMatrices(env.M, env.XYZ);
	else throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
}
var noneTypes = new Set([
	"<number>",
	"<percentage>",
	"<angle>"
]);
function coerceCoords(space, format, name, coords) {
	return Object.entries(space.coords).map(([id, coordMeta], i) => {
		let coordGrammar$1 = format.coordGrammar[i];
		let arg = coords[i];
		let providedType = arg?.type;
		let type$1;
		if (arg.none) type$1 = coordGrammar$1.find((c$1) => noneTypes.has(c$1));
		else type$1 = coordGrammar$1.find((c$1) => c$1 == providedType);
		if (!type$1) {
			let coordName = coordMeta.name || id;
			throw new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);
		}
		let fromRange = type$1.range;
		if (providedType === "<percentage>") fromRange ||= [0, 1];
		let toRange = coordMeta.range || coordMeta.refRange;
		if (fromRange && toRange) coords[i] = mapRange(fromRange, toRange, coords[i]);
		return type$1;
	});
}
function parse(str, { meta } = {}) {
	let env = { "str": String(str)?.trim() };
	hooks.run("parse-start", env);
	if (env.color) return env.color;
	env.parsed = parseFunction(env.str);
	if (env.parsed) {
		let name = env.parsed.name;
		if (name === "color") {
			let id = env.parsed.args.shift();
			let alternateId = id.startsWith("--") ? id.substring(2) : `--${id}`;
			let ids = [id, alternateId];
			let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
			for (let space of ColorSpace.all) {
				let colorSpec = space.getFormat("color");
				if (colorSpec) {
					if (ids.includes(colorSpec.id) || colorSpec.ids?.filter((specId) => ids.includes(specId)).length) {
						const coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);
						let types;
						if (colorSpec.coordGrammar) types = coerceCoords(space, colorSpec, "color", coords);
						if (meta) Object.assign(meta, {
							formatId: "color",
							types
						});
						if (colorSpec.id.startsWith("--") && !id.startsWith("--")) defaults.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. Use prefixed color(${colorSpec.id}) instead of color(${id}).`);
						if (id.startsWith("--") && !colorSpec.id.startsWith("--")) defaults.warn(`${space.name} is a standard space and supported in the CSS spec. Use color(${colorSpec.id}) instead of prefixed color(${id}).`);
						return {
							spaceId: space.id,
							coords,
							alpha
						};
					}
				}
			}
			let didYouMean = "";
			let registryId = id in ColorSpace.registry ? id : alternateId;
			if (registryId in ColorSpace.registry) {
				let cssId = ColorSpace.registry[registryId].formats?.color?.id;
				if (cssId) didYouMean = `Did you mean color(${cssId})?`;
			}
			throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
		} else for (let space of ColorSpace.all) {
			let format = space.getFormat(name);
			if (format && format.type === "function") {
				let alpha = 1;
				if (format.lastAlpha || last(env.parsed.args).alpha) alpha = env.parsed.args.pop();
				let coords = env.parsed.args;
				let types;
				if (format.coordGrammar) types = coerceCoords(space, format, name, coords);
				if (meta) Object.assign(meta, {
					formatId: format.name,
					types
				});
				return {
					spaceId: space.id,
					coords,
					alpha
				};
			}
		}
	} else for (let space of ColorSpace.all) for (let formatId in space.formats) {
		let format = space.formats[formatId];
		if (format.type !== "custom") continue;
		if (format.test && !format.test(env.str)) continue;
		let color$2 = format.parse(env.str);
		if (color$2) {
			color$2.alpha ??= 1;
			if (meta) meta.formatId = formatId;
			return color$2;
		}
	}
	throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
}
function getColor(color$2) {
	if (Array.isArray(color$2)) return color$2.map(getColor);
	if (!color$2) throw new TypeError("Empty color reference");
	if (isString(color$2)) color$2 = parse(color$2);
	let space = color$2.space || color$2.spaceId;
	if (!(space instanceof ColorSpace)) color$2.space = ColorSpace.get(space);
	if (color$2.alpha === void 0) color$2.alpha = 1;
	return color$2;
}
var ε$7 = 75e-6;
var ColorSpace = class ColorSpace$1 {
	constructor(options) {
		this.id = options.id;
		this.name = options.name;
		this.base = options.base ? ColorSpace$1.get(options.base) : null;
		this.aliases = options.aliases;
		if (this.base) {
			this.fromBase = options.fromBase;
			this.toBase = options.toBase;
		}
		let coords = options.coords ?? this.base.coords;
		for (let name in coords) if (!("name" in coords[name])) coords[name].name = name;
		this.coords = coords;
		this.white = getWhite(options.white ?? this.base.white ?? "D65");
		this.formats = options.formats ?? {};
		for (let name in this.formats) {
			let format = this.formats[name];
			format.type ||= "function";
			format.name ||= name;
		}
		if (!this.formats.color?.id) this.formats.color = {
			...this.formats.color ?? {},
			id: options.cssId || this.id
		};
		if (options.gamutSpace) this.gamutSpace = options.gamutSpace === "self" ? this : ColorSpace$1.get(options.gamutSpace);
		else if (this.isPolar) this.gamutSpace = this.base;
		else this.gamutSpace = this;
		if (this.gamutSpace.isUnbounded) this.inGamut = (coords$1, options$1) => {
			return true;
		};
		this.referred = options.referred;
		Object.defineProperty(this, "path", {
			value: getPath(this).reverse(),
			writable: false,
			enumerable: true,
			configurable: true
		});
		hooks.run("colorspace-init-end", this);
	}
	inGamut(coords, { epsilon = ε$7 } = {}) {
		if (!this.equals(this.gamutSpace)) {
			coords = this.to(this.gamutSpace, coords);
			return this.gamutSpace.inGamut(coords, { epsilon });
		}
		let coordMeta = Object.values(this.coords);
		return coords.every((c$1, i) => {
			let meta = coordMeta[i];
			if (meta.type !== "angle" && meta.range) {
				if (Number.isNaN(c$1)) return true;
				let [min$1$1, max$2$1] = meta.range;
				return (min$1$1 === void 0 || c$1 >= min$1$1 - epsilon) && (max$2$1 === void 0 || c$1 <= max$2$1 + epsilon);
			}
			return true;
		});
	}
	get isUnbounded() {
		return Object.values(this.coords).every((coord) => !("range" in coord));
	}
	get cssId() {
		return this.formats?.color?.id || this.id;
	}
	get isPolar() {
		for (let id in this.coords) if (this.coords[id].type === "angle") return true;
		return false;
	}
	getFormat(format) {
		if (typeof format === "object") {
			format = processFormat(format, this);
			return format;
		}
		let ret;
		if (format === "default") ret = Object.values(this.formats)[0];
		else ret = this.formats[format];
		if (ret) {
			ret = processFormat(ret, this);
			return ret;
		}
		return null;
	}
	equals(space) {
		if (!space) return false;
		return this === space || this.id === space || this.id === space.id;
	}
	to(space, coords) {
		if (arguments.length === 1) {
			const color$2 = getColor(space);
			[space, coords] = [color$2.space, color$2.coords];
		}
		space = ColorSpace$1.get(space);
		if (this.equals(space)) return coords;
		coords = coords.map((c$1) => Number.isNaN(c$1) ? 0 : c$1);
		let myPath = this.path;
		let otherPath = space.path;
		let connectionSpace, connectionSpaceIndex;
		for (let i = 0; i < myPath.length; i++) if (myPath[i].equals(otherPath[i])) {
			connectionSpace = myPath[i];
			connectionSpaceIndex = i;
		} else break;
		if (!connectionSpace) throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
		for (let i = myPath.length - 1; i > connectionSpaceIndex; i--) coords = myPath[i].toBase(coords);
		for (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) coords = otherPath[i].fromBase(coords);
		return coords;
	}
	from(space, coords) {
		if (arguments.length === 1) {
			const color$2 = getColor(space);
			[space, coords] = [color$2.space, color$2.coords];
		}
		space = ColorSpace$1.get(space);
		return space.to(this, coords);
	}
	toString() {
		return `${this.name} (${this.id})`;
	}
	getMinCoords() {
		let ret = [];
		for (let id in this.coords) {
			let meta = this.coords[id];
			let range$1$1 = meta.range || meta.refRange;
			ret.push(range$1$1?.min ?? 0);
		}
		return ret;
	}
	static registry = {};
	static get all() {
		return [...new Set(Object.values(ColorSpace$1.registry))];
	}
	static register(id, space) {
		if (arguments.length === 1) {
			space = arguments[0];
			id = space.id;
		}
		space = this.get(space);
		if (this.registry[id] && this.registry[id] !== space) throw new Error(`Duplicate color space registration: '${id}'`);
		this.registry[id] = space;
		if (arguments.length === 1 && space.aliases) for (let alias of space.aliases) this.register(alias, space);
		return space;
	}
	static get(space, ...alternatives) {
		if (!space || space instanceof ColorSpace$1) return space;
		if (type(space) === "string") {
			let ret = ColorSpace$1.registry[space.toLowerCase()];
			if (!ret) throw new TypeError(`No color space found with id = "${space}"`);
			return ret;
		}
		if (alternatives.length) return ColorSpace$1.get(...alternatives);
		throw new TypeError(`${space} is not a valid color space`);
	}
	static resolveCoord(ref, workingSpace) {
		let coordType = type(ref);
		let space, coord;
		if (coordType === "string") if (ref.includes(".")) [space, coord] = ref.split(".");
		else [space, coord] = [, ref];
		else if (Array.isArray(ref)) [space, coord] = ref;
		else {
			space = ref.space;
			coord = ref.coordId;
		}
		space = ColorSpace$1.get(space);
		if (!space) space = workingSpace;
		if (!space) throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);
		coordType = type(coord);
		if (coordType === "number" || coordType === "string" && coord >= 0) {
			let meta = Object.entries(space.coords)[coord];
			if (meta) return {
				space,
				id: meta[0],
				index: coord,
				...meta[1]
			};
		}
		space = ColorSpace$1.get(space);
		let normalizedCoord = coord.toLowerCase();
		let i = 0;
		for (let id in space.coords) {
			let meta = space.coords[id];
			if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) return {
				space,
				id,
				index: i,
				...meta
			};
			i++;
		}
		throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
	}
	static DEFAULT_FORMAT = {
		type: "functions",
		name: "color"
	};
};
function getPath(space) {
	let ret = [space];
	for (let s = space; s = s.base;) ret.push(s);
	return ret;
}
function processFormat(format, { coords } = {}) {
	if (format.coords && !format.coordGrammar) {
		format.type ||= "function";
		format.name ||= "color";
		format.coordGrammar = parseCoordGrammar(format.coords);
		let coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {
			let outputType = format.coordGrammar[i][0];
			let fromRange = coordMeta.range || coordMeta.refRange;
			let toRange = outputType.range, suffix = "";
			if (outputType == "<percentage>") {
				toRange = [0, 100];
				suffix = "%";
			} else if (outputType == "<angle>") suffix = "deg";
			return {
				fromRange,
				toRange,
				suffix
			};
		});
		format.serializeCoords = (coords$1, precision) => {
			return coords$1.map((c$1, i) => {
				let { fromRange, toRange, suffix } = coordFormats[i];
				if (fromRange && toRange) c$1 = mapRange(fromRange, toRange, c$1);
				c$1 = serializeNumber(c$1, {
					precision,
					unit: suffix
				});
				return c$1;
			});
		};
	}
	return format;
}
var xyz_d65 = new ColorSpace({
	id: "xyz-d65",
	name: "XYZ D65",
	coords: {
		x: { name: "X" },
		y: { name: "Y" },
		z: { name: "Z" }
	},
	white: "D65",
	formats: { color: { ids: ["xyz-d65", "xyz"] } },
	aliases: ["xyz"]
});
var RGBColorSpace = class extends ColorSpace {
	constructor(options) {
		if (!options.coords) options.coords = {
			r: {
				range: [0, 1],
				name: "Red"
			},
			g: {
				range: [0, 1],
				name: "Green"
			},
			b: {
				range: [0, 1],
				name: "Blue"
			}
		};
		if (!options.base) options.base = xyz_d65;
		if (options.toXYZ_M && options.fromXYZ_M) {
			options.toBase ??= (rgb) => {
				let xyz = multiplyMatrices(options.toXYZ_M, rgb);
				if (this.white !== this.base.white) xyz = adapt$2(this.white, this.base.white, xyz);
				return xyz;
			};
			options.fromBase ??= (xyz) => {
				xyz = adapt$2(this.base.white, this.white, xyz);
				return multiplyMatrices(options.fromXYZ_M, xyz);
			};
		}
		options.referred ??= "display";
		super(options);
	}
};
function getAll(color$2, space) {
	color$2 = getColor(color$2);
	if (!space || color$2.space.equals(space)) return color$2.coords.slice();
	space = ColorSpace.get(space);
	return space.from(color$2);
}
function get(color$2, prop) {
	color$2 = getColor(color$2);
	let { space, index } = ColorSpace.resolveCoord(prop, color$2.space);
	return getAll(color$2, space)[index];
}
function setAll(color$2, space, coords) {
	color$2 = getColor(color$2);
	space = ColorSpace.get(space);
	color$2.coords = space.to(color$2.space, coords);
	return color$2;
}
setAll.returns = "color";
function set(color$2, prop, value) {
	color$2 = getColor(color$2);
	if (arguments.length === 2 && type(arguments[1]) === "object") {
		let object = arguments[1];
		for (let p$1 in object) set(color$2, p$1, object[p$1]);
	} else {
		if (typeof value === "function") value = value(get(color$2, prop));
		let { space, index } = ColorSpace.resolveCoord(prop, color$2.space);
		let coords = getAll(color$2, space);
		coords[index] = value;
		setAll(color$2, space, coords);
	}
	return color$2;
}
set.returns = "color";
var XYZ_D50 = new ColorSpace({
	id: "xyz-d50",
	name: "XYZ D50",
	white: "D50",
	base: xyz_d65,
	fromBase: (coords) => adapt$2(xyz_d65.white, "D50", coords),
	toBase: (coords) => adapt$2("D50", xyz_d65.white, coords)
});
var ε$6 = 216 / 24389;
var ε3$1 = 24 / 116;
var κ$4 = 24389 / 27;
var white$4 = WHITES.D50;
var lab = new ColorSpace({
	id: "lab",
	name: "Lab",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		a: { refRange: [-125, 125] },
		b: { refRange: [-125, 125] }
	},
	white: white$4,
	base: XYZ_D50,
	fromBase(XYZ) {
		let f = XYZ.map((value, i) => value / white$4[i]).map((value) => value > ε$6 ? Math.cbrt(value) : (κ$4 * value + 16) / 116);
		return [
			116 * f[1] - 16,
			500 * (f[0] - f[1]),
			200 * (f[1] - f[2])
		];
	},
	toBase(Lab) {
		let f = [];
		f[1] = (Lab[0] + 16) / 116;
		f[0] = Lab[1] / 500 + f[1];
		f[2] = f[1] - Lab[2] / 200;
		return [
			f[0] > ε3$1 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ$4,
			Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ$4,
			f[2] > ε3$1 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ$4
		].map((value, i) => value * white$4[i]);
	},
	formats: { "lab": { coords: [
		"<number> | <percentage>",
		"<number> | <percentage>[-1,1]",
		"<number> | <percentage>[-1,1]"
	] } }
});
function constrain(angle) {
	return (angle % 360 + 360) % 360;
}
function adjust(arc, angles) {
	if (arc === "raw") return angles;
	let [a1, a2] = angles.map(constrain);
	let angleDiff = a2 - a1;
	if (arc === "increasing") {
		if (angleDiff < 0) a2 += 360;
	} else if (arc === "decreasing") {
		if (angleDiff > 0) a1 += 360;
	} else if (arc === "longer") {
		if (-180 < angleDiff && angleDiff < 180) if (angleDiff > 0) a1 += 360;
		else a2 += 360;
	} else if (arc === "shorter") {
		if (angleDiff > 180) a1 += 360;
		else if (angleDiff < -180) a2 += 360;
	}
	return [a1, a2];
}
var lch = new ColorSpace({
	id: "lch",
	name: "LCH",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		c: {
			refRange: [0, 150],
			name: "Chroma"
		},
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	base: lab,
	fromBase(Lab) {
		let [L, a$1, b$2] = Lab;
		let hue$2;
		const ε$8 = .02;
		if (Math.abs(a$1) < ε$8 && Math.abs(b$2) < ε$8) hue$2 = NaN;
		else hue$2 = Math.atan2(b$2, a$1) * 180 / Math.PI;
		return [
			L,
			Math.sqrt(a$1 ** 2 + b$2 ** 2),
			constrain(hue$2)
		];
	},
	toBase(LCH) {
		let [Lightness, Chroma, Hue] = LCH;
		if (Chroma < 0) Chroma = 0;
		if (isNaN(Hue)) Hue = 0;
		return [
			Lightness,
			Chroma * Math.cos(Hue * Math.PI / 180),
			Chroma * Math.sin(Hue * Math.PI / 180)
		];
	},
	formats: { "lch": { coords: [
		"<number> | <percentage>",
		"<number> | <percentage>",
		"<number> | <angle>"
	] } }
});
var Gfactor = 25 ** 7;
var π$1 = Math.PI;
var r2d = 180 / π$1;
var d2r$1 = π$1 / 180;
function pow7(x) {
	const x2 = x * x;
	return x2 * x2 * x2 * x;
}
function deltaE2000(color$2, sample$2, { kL = 1, kC = 1, kH = 1 } = {}) {
	[color$2, sample$2] = getColor([color$2, sample$2]);
	let [L1, a1, b1] = lab.from(color$2);
	let C1 = lch.from(lab, [
		L1,
		a1,
		b1
	])[1];
	let [L2, a2, b2] = lab.from(sample$2);
	let C2 = lch.from(lab, [
		L2,
		a2,
		b2
	])[1];
	if (C1 < 0) C1 = 0;
	if (C2 < 0) C2 = 0;
	let C7 = pow7((C1 + C2) / 2);
	let G = .5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
	let adash1 = (1 + G) * a1;
	let adash2 = (1 + G) * a2;
	let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
	let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);
	let h1$1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
	let h2 = adash2 === 0 && b2 === 0 ? 0 : Math.atan2(b2, adash2);
	if (h1$1 < 0) h1$1 += 2 * π$1;
	if (h2 < 0) h2 += 2 * π$1;
	h1$1 *= r2d;
	h2 *= r2d;
	let ΔL = L2 - L1;
	let ΔC = Cdash2 - Cdash1;
	let hdiff = h2 - h1$1;
	let hsum = h1$1 + h2;
	let habs = Math.abs(hdiff);
	let Δh;
	if (Cdash1 * Cdash2 === 0) Δh = 0;
	else if (habs <= 180) Δh = hdiff;
	else if (hdiff > 180) Δh = hdiff - 360;
	else if (hdiff < -180) Δh = hdiff + 360;
	else defaults.warn("the unthinkable has happened");
	let ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r$1 / 2);
	let Ldash = (L1 + L2) / 2;
	let Cdash = (Cdash1 + Cdash2) / 2;
	let Cdash7 = pow7(Cdash);
	let hdash;
	if (Cdash1 * Cdash2 === 0) hdash = hsum;
	else if (habs <= 180) hdash = hsum / 2;
	else if (hsum < 360) hdash = (hsum + 360) / 2;
	else hdash = (hsum - 360) / 2;
	let lsq = (Ldash - 50) ** 2;
	let SL = 1 + .015 * lsq / Math.sqrt(20 + lsq);
	let SC = 1 + .045 * Cdash;
	let T$1 = 1;
	T$1 -= .17 * Math.cos((hdash - 30) * d2r$1);
	T$1 += .24 * Math.cos(2 * hdash * d2r$1);
	T$1 += .32 * Math.cos((3 * hdash + 6) * d2r$1);
	T$1 -= .2 * Math.cos((4 * hdash - 63) * d2r$1);
	let SH = 1 + .015 * Cdash * T$1;
	let Δθ = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
	let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
	let RT = -1 * Math.sin(2 * Δθ * d2r$1) * RC;
	let dE = (ΔL / (kL * SL)) ** 2;
	dE += (ΔC / (kC * SC)) ** 2;
	dE += (ΔH / (kH * SH)) ** 2;
	dE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));
	return Math.sqrt(dE);
}
var XYZtoLMS_M$1 = [
	[
		.819022437996703,
		.3619062600528904,
		-.1288737815209879
	],
	[
		.0329836539323885,
		.9292868615863434,
		.0361446663506424
	],
	[
		.0481771893596242,
		.2642395317527308,
		.6335478284694309
	]
];
var LMStoXYZ_M$1 = [
	[
		1.2268798758459243,
		-.5578149944602171,
		.2813910456659647
	],
	[
		-.0405757452148008,
		1.112286803280317,
		-.0717110580655164
	],
	[
		-.0763729366746601,
		-.4214933324022432,
		1.5869240198367816
	]
];
var LMStoLab_M = [
	[
		.210454268309314,
		.7936177747023054,
		-.0040720430116193
	],
	[
		1.9779985324311684,
		-2.42859224204858,
		.450593709617411
	],
	[
		.0259040424655478,
		.7827717124575296,
		-.8086757549230774
	]
];
var LabtoLMS_M = [
	[
		1,
		.3963377773761749,
		.2158037573099136
	],
	[
		1,
		-.1055613458156586,
		-.0638541728258133
	],
	[
		1,
		-.0894841775298119,
		-1.2914855480194092
	]
];
var OKLab = new ColorSpace({
	id: "oklab",
	name: "Oklab",
	coords: {
		l: {
			refRange: [0, 1],
			name: "Lightness"
		},
		a: { refRange: [-.4, .4] },
		b: { refRange: [-.4, .4] }
	},
	white: "D65",
	base: xyz_d65,
	fromBase(XYZ) {
		return multiplyMatrices(LMStoLab_M, multiplyMatrices(XYZtoLMS_M$1, XYZ).map((val) => Math.cbrt(val)));
	},
	toBase(OKLab$1) {
		return multiplyMatrices(LMStoXYZ_M$1, multiplyMatrices(LabtoLMS_M, OKLab$1).map((val) => val ** 3));
	},
	formats: { "oklab": { coords: [
		"<percentage> | <number>",
		"<number> | <percentage>[-1,1]",
		"<number> | <percentage>[-1,1]"
	] } }
});
function deltaEOK(color$2, sample$2) {
	[color$2, sample$2] = getColor([color$2, sample$2]);
	let [L1, a1, b1] = OKLab.from(color$2);
	let [L2, a2, b2] = OKLab.from(sample$2);
	let ΔL = L1 - L2;
	let Δa = a1 - a2;
	let Δb = b1 - b2;
	return Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);
}
var ε$5 = 75e-6;
function inGamut(color$2, space, { epsilon = ε$5 } = {}) {
	color$2 = getColor(color$2);
	if (!space) space = color$2.space;
	space = ColorSpace.get(space);
	let coords = color$2.coords;
	if (space !== color$2.space) coords = space.from(color$2);
	return space.inGamut(coords, { epsilon });
}
function clone(color$2) {
	return {
		space: color$2.space,
		coords: color$2.coords.slice(),
		alpha: color$2.alpha
	};
}
function distance$1(color1, color2, space = "lab") {
	space = ColorSpace.get(space);
	let coords1 = space.from(color1);
	let coords2 = space.from(color2);
	return Math.sqrt(coords1.reduce((acc, c1$3, i) => {
		let c2$3 = coords2[i];
		if (isNaN(c1$3) || isNaN(c2$3)) return acc;
		return acc + (c2$3 - c1$3) ** 2;
	}, 0));
}
function deltaE76(color$2, sample$2) {
	return distance$1(color$2, sample$2, "lab");
}
var d2r = Math.PI / 180;
function deltaECMC(color$2, sample$2, { l = 2, c: c$1 = 1 } = {}) {
	[color$2, sample$2] = getColor([color$2, sample$2]);
	let [L1, a1, b1] = lab.from(color$2);
	let [, C1, H1] = lch.from(lab, [
		L1,
		a1,
		b1
	]);
	let [L2, a2, b2] = lab.from(sample$2);
	let C2 = lch.from(lab, [
		L2,
		a2,
		b2
	])[1];
	if (C1 < 0) C1 = 0;
	if (C2 < 0) C2 = 0;
	let ΔL = L1 - L2;
	let ΔC = C1 - C2;
	let Δa = a1 - a2;
	let Δb = b1 - b2;
	let H2 = Δa ** 2 + Δb ** 2 - ΔC ** 2;
	let SL = .511;
	if (L1 >= 16) SL = .040975 * L1 / (1 + .01765 * L1);
	let SC = .0638 * C1 / (1 + .0131 * C1) + .638;
	let T$1;
	if (Number.isNaN(H1)) H1 = 0;
	if (H1 >= 164 && H1 <= 345) T$1 = .56 + Math.abs(.2 * Math.cos((H1 + 168) * d2r));
	else T$1 = .36 + Math.abs(.4 * Math.cos((H1 + 35) * d2r));
	let C4 = Math.pow(C1, 4);
	let F = Math.sqrt(C4 / (C4 + 1900));
	let SH = SC * (F * T$1 + 1 - F);
	let dE = (ΔL / (l * SL)) ** 2;
	dE += (ΔC / (c$1 * SC)) ** 2;
	dE += H2 / SH ** 2;
	return Math.sqrt(dE);
}
var Yw$1 = 203;
var XYZ_Abs_D65 = new ColorSpace({
	id: "xyz-abs-d65",
	cssId: "--xyz-abs-d65",
	name: "Absolute XYZ D65",
	coords: {
		x: {
			refRange: [0, 9504.7],
			name: "Xa"
		},
		y: {
			refRange: [0, 1e4],
			name: "Ya"
		},
		z: {
			refRange: [0, 10888.3],
			name: "Za"
		}
	},
	base: xyz_d65,
	fromBase(XYZ) {
		return XYZ.map((v) => Math.max(v * Yw$1, 0));
	},
	toBase(AbsXYZ) {
		return AbsXYZ.map((v) => Math.max(v / Yw$1, 0));
	}
});
var b$1 = 1.15;
var g = .66;
var n$1 = 2610 / 2 ** 14;
var ninv$1 = 2 ** 14 / 2610;
var c1$2 = 3424 / 2 ** 12;
var c2$2 = 2413 / 2 ** 7;
var c3$2 = 2392 / 2 ** 7;
var p = 1.7 * 2523 / 2 ** 5;
var pinv = 2 ** 5 / (1.7 * 2523);
var d = -.56;
var d0 = 16295499532821565e-27;
var XYZtoCone_M = [
	[
		.41478972,
		.579999,
		.014648
	],
	[
		-.20151,
		1.120649,
		.0531008
	],
	[
		-.0166008,
		.2648,
		.6684799
	]
];
var ConetoXYZ_M = [
	[
		1.9242264357876067,
		-1.0047923125953657,
		.037651404030618
	],
	[
		.35031676209499907,
		.7264811939316552,
		-.06538442294808501
	],
	[
		-.09098281098284752,
		-.3127282905230739,
		1.5227665613052603
	]
];
var ConetoIab_M = [
	[
		.5,
		.5,
		0
	],
	[
		3.524,
		-4.066708,
		.542708
	],
	[
		.199076,
		1.096799,
		-1.295875
	]
];
var IabtoCone_M = [
	[
		1,
		.1386050432715393,
		.05804731615611886
	],
	[
		.9999999999999999,
		-.1386050432715393,
		-.05804731615611886
	],
	[
		.9999999999999998,
		-.09601924202631895,
		-.8118918960560388
	]
];
var Jzazbz = new ColorSpace({
	id: "jzazbz",
	name: "Jzazbz",
	coords: {
		jz: {
			refRange: [0, 1],
			name: "Jz"
		},
		az: { refRange: [-.5, .5] },
		bz: { refRange: [-.5, .5] }
	},
	base: XYZ_Abs_D65,
	fromBase(XYZ) {
		let [Xa, Ya, Za] = XYZ;
		let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, multiplyMatrices(XYZtoCone_M, [
			b$1 * Xa - (b$1 - 1) * Za,
			g * Ya - (g - 1) * Xa,
			Za
		]).map(function(val) {
			return ((c1$2 + c2$2 * (val / 1e4) ** n$1) / (1 + c3$2 * (val / 1e4) ** n$1)) ** p;
		}));
		return [
			(1 + d) * Iz / (1 + d * Iz) - d0,
			az,
			bz
		];
	},
	toBase(Jzazbz$1) {
		let [Jz, az, bz] = Jzazbz$1;
		let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, multiplyMatrices(IabtoCone_M, [
			(Jz + d0) / (1 + d - d * (Jz + d0)),
			az,
			bz
		]).map(function(val) {
			return 1e4 * ((c1$2 - val ** pinv) / (c3$2 * val ** pinv - c2$2)) ** ninv$1;
		}));
		let Xa = (Xm + (b$1 - 1) * Za) / b$1;
		return [
			Xa,
			(Ym + (g - 1) * Xa) / g,
			Za
		];
	},
	formats: { "color": { coords: [
		"<number> | <percentage>",
		"<number> | <percentage>[-1,1]",
		"<number> | <percentage>[-1,1]"
	] } }
});
var jzczhz = new ColorSpace({
	id: "jzczhz",
	name: "JzCzHz",
	coords: {
		jz: {
			refRange: [0, 1],
			name: "Jz"
		},
		cz: {
			refRange: [0, 1],
			name: "Chroma"
		},
		hz: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	base: Jzazbz,
	fromBase(jzazbz) {
		let [Jz, az, bz] = jzazbz;
		let hue$2;
		const ε$8 = 2e-4;
		if (Math.abs(az) < ε$8 && Math.abs(bz) < ε$8) hue$2 = NaN;
		else hue$2 = Math.atan2(bz, az) * 180 / Math.PI;
		return [
			Jz,
			Math.sqrt(az ** 2 + bz ** 2),
			constrain(hue$2)
		];
	},
	toBase(jzczhz$1) {
		return [
			jzczhz$1[0],
			jzczhz$1[1] * Math.cos(jzczhz$1[2] * Math.PI / 180),
			jzczhz$1[1] * Math.sin(jzczhz$1[2] * Math.PI / 180)
		];
	}
});
function deltaEJz(color$2, sample$2) {
	[color$2, sample$2] = getColor([color$2, sample$2]);
	let [Jz1, Cz1, Hz1] = jzczhz.from(color$2);
	let [Jz2, Cz2, Hz2] = jzczhz.from(sample$2);
	let ΔJ = Jz1 - Jz2;
	let ΔC = Cz1 - Cz2;
	if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
		Hz1 = 0;
		Hz2 = 0;
	} else if (Number.isNaN(Hz1)) Hz1 = Hz2;
	else if (Number.isNaN(Hz2)) Hz2 = Hz1;
	let Δh = Hz1 - Hz2;
	let ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(Δh / 2 * (Math.PI / 180));
	return Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);
}
var c1$1 = 3424 / 4096;
var c2$1 = 2413 / 128;
var c3$1 = 2392 / 128;
var m1$1 = 2610 / 16384;
var m2 = 2523 / 32;
var im1 = 16384 / 2610;
var im2 = 32 / 2523;
var XYZtoLMS_M = [
	[
		.3592832590121217,
		.6976051147779502,
		-.035891593232029
	],
	[
		-.1920808463704993,
		1.100476797037432,
		.0753748658519118
	],
	[
		.0070797844607479,
		.0748396662186362,
		.8433265453898765
	]
];
var LMStoIPT_M = [
	[
		2048 / 4096,
		2048 / 4096,
		0
	],
	[
		6610 / 4096,
		-13613 / 4096,
		7003 / 4096
	],
	[
		17933 / 4096,
		-17390 / 4096,
		-543 / 4096
	]
];
var IPTtoLMS_M = [
	[
		.9999999999999998,
		.0086090370379328,
		.111029625003026
	],
	[
		.9999999999999998,
		-.0086090370379328,
		-.1110296250030259
	],
	[
		.9999999999999998,
		.5600313357106791,
		-.3206271749873188
	]
];
var LMStoXYZ_M = [
	[
		2.0701522183894223,
		-1.3263473389671563,
		.2066510476294053
	],
	[
		.3647385209748072,
		.6805660249472273,
		-.0453045459220347
	],
	[
		-.0497472075358123,
		-.0492609666966131,
		1.1880659249923042
	]
];
var ictcp = new ColorSpace({
	id: "ictcp",
	name: "ICTCP",
	coords: {
		i: {
			refRange: [0, 1],
			name: "I"
		},
		ct: {
			refRange: [-.5, .5],
			name: "CT"
		},
		cp: {
			refRange: [-.5, .5],
			name: "CP"
		}
	},
	base: XYZ_Abs_D65,
	fromBase(XYZ) {
		return LMStoICtCp(multiplyMatrices(XYZtoLMS_M, XYZ));
	},
	toBase(ICtCp) {
		return multiplyMatrices(LMStoXYZ_M, ICtCptoLMS(ICtCp));
	}
});
function LMStoICtCp(LMS) {
	return multiplyMatrices(LMStoIPT_M, LMS.map(function(val) {
		return ((c1$1 + c2$1 * (val / 1e4) ** m1$1) / (1 + c3$1 * (val / 1e4) ** m1$1)) ** m2;
	}));
}
function ICtCptoLMS(ICtCp) {
	return multiplyMatrices(IPTtoLMS_M, ICtCp).map(function(val) {
		return 1e4 * (Math.max(val ** im2 - c1$1, 0) / (c2$1 - c3$1 * val ** im2)) ** im1;
	});
}
function deltaEITP(color$2, sample$2) {
	[color$2, sample$2] = getColor([color$2, sample$2]);
	let [I1, T1, P1] = ictcp.from(color$2);
	let [I2, T2, P2] = ictcp.from(sample$2);
	return 720 * Math.sqrt((I1 - I2) ** 2 + .25 * (T1 - T2) ** 2 + (P1 - P2) ** 2);
}
var white$3 = WHITES.D65;
var adaptedCoef = .42;
var adaptedCoefInv = 1 / adaptedCoef;
var tau = 2 * Math.PI;
var cat16 = [
	[
		.401288,
		.650173,
		-.051461
	],
	[
		-.250268,
		1.204414,
		.045854
	],
	[
		-.002079,
		.048952,
		.953127
	]
];
var cat16Inv = [
	[
		1.8620678550872327,
		-1.0112546305316843,
		.14918677544445175
	],
	[
		.38752654323613717,
		.6214474419314753,
		-.008973985167612518
	],
	[
		-.015841498849333856,
		-.03412293802851557,
		1.0499644368778496
	]
];
var m1 = [
	[
		460,
		451,
		288
	],
	[
		460,
		-891,
		-261
	],
	[
		460,
		-220,
		-6300
	]
];
var surroundMap = {
	dark: [
		.8,
		.525,
		.8
	],
	dim: [
		.9,
		.59,
		.9
	],
	average: [
		1,
		.69,
		1
	]
};
var hueQuadMap = {
	h: [
		20.14,
		90,
		164.25,
		237.53,
		380.14
	],
	e: [
		.8,
		.7,
		1,
		1.2,
		.8
	],
	H: [
		0,
		100,
		200,
		300,
		400
	]
};
var rad2deg = 180 / Math.PI;
var deg2rad$1 = Math.PI / 180;
function adapt$1(coords, fl) {
	return coords.map((c$1) => {
		const x = spow(fl * Math.abs(c$1) * .01, adaptedCoef);
		return 400 * copySign(x, c$1) / (x + 27.13);
	});
}
function unadapt(adapted, fl) {
	const constant = 100 / fl * 27.13 ** adaptedCoefInv;
	return adapted.map((c$1) => {
		const cabs = Math.abs(c$1);
		return copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c$1);
	});
}
function hueQuadrature(h) {
	let hp = constrain(h);
	if (hp <= hueQuadMap.h[0]) hp += 360;
	const i = bisectLeft(hueQuadMap.h, hp) - 1;
	const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
	const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
	const Hi = hueQuadMap.H[i];
	const t = (hp - hi) / ei;
	return Hi + 100 * t / (t + (hii - hp) / eii);
}
function invHueQuadrature(H) {
	let Hp = (H % 400 + 400) % 400;
	const i = Math.floor(.01 * Hp);
	Hp = Hp % 100;
	const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
	const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
	return constrain((Hp * (eii * hi - ei * hii) - 100 * hi * eii) / (Hp * (eii - ei) - 100 * eii));
}
function environment(refWhite, adaptingLuminance, backgroundLuminance, surround, discounting) {
	const env = {};
	env.discounting = discounting;
	env.refWhite = refWhite;
	env.surround = surround;
	const xyzW = refWhite.map((c$1) => {
		return c$1 * 100;
	});
	env.la = adaptingLuminance;
	env.yb = backgroundLuminance;
	const yw = xyzW[1];
	const rgbW = multiplyMatrices(cat16, xyzW);
	surround = surroundMap[env.surround];
	const f = surround[0];
	env.c = surround[1];
	env.nc = surround[2];
	const k4 = (1 / (5 * env.la + 1)) ** 4;
	env.fl = k4 * env.la + .1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la);
	env.flRoot = env.fl ** .25;
	env.n = env.yb / yw;
	env.z = 1.48 + Math.sqrt(env.n);
	env.nbb = .725 * env.n ** -.2;
	env.ncb = env.nbb;
	const d$1 = discounting ? 1 : Math.max(Math.min(f * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1), 0);
	env.dRgb = rgbW.map((c$1) => {
		return interpolate(1, yw / c$1, d$1);
	});
	env.dRgbInv = env.dRgb.map((c$1) => {
		return 1 / c$1;
	});
	const rgbAW = adapt$1(rgbW.map((c$1, i) => {
		return c$1 * env.dRgb[i];
	}), env.fl);
	env.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + .05 * rgbAW[2]);
	return env;
}
var viewingConditions$1 = environment(white$3, 64 / Math.PI * .2, 20, "average", false);
function fromCam16(cam16$1, env) {
	if (!(cam16$1.J !== void 0 ^ cam16$1.Q !== void 0)) throw new Error("Conversion requires one and only one: 'J' or 'Q'");
	if (!(cam16$1.C !== void 0 ^ cam16$1.M !== void 0 ^ cam16$1.s !== void 0)) throw new Error("Conversion requires one and only one: 'C', 'M' or 's'");
	if (!(cam16$1.h !== void 0 ^ cam16$1.H !== void 0)) throw new Error("Conversion requires one and only one: 'h' or 'H'");
	if (cam16$1.J === 0 || cam16$1.Q === 0) return [
		0,
		0,
		0
	];
	let hRad = 0;
	if (cam16$1.h !== void 0) hRad = constrain(cam16$1.h) * deg2rad$1;
	else hRad = invHueQuadrature(cam16$1.H) * deg2rad$1;
	const cosh = Math.cos(hRad);
	const sinh = Math.sin(hRad);
	let Jroot = 0;
	if (cam16$1.J !== void 0) Jroot = spow(cam16$1.J, 1 / 2) * .1;
	else if (cam16$1.Q !== void 0) Jroot = .25 * env.c * cam16$1.Q / ((env.aW + 4) * env.flRoot);
	let alpha = 0;
	if (cam16$1.C !== void 0) alpha = cam16$1.C / Jroot;
	else if (cam16$1.M !== void 0) alpha = cam16$1.M / env.flRoot / Jroot;
	else if (cam16$1.s !== void 0) alpha = 4e-4 * cam16$1.s ** 2 * (env.aW + 4) / env.c;
	const t = spow(alpha * Math.pow(1.64 - Math.pow(.29, env.n), -.73), 10 / 9);
	const et = .25 * (Math.cos(hRad + 2) + 3.8);
	const A = env.aW * spow(Jroot, 2 / env.c / env.z);
	const p1 = 5e4 / 13 * env.nc * env.ncb * et;
	const p2 = A / env.nbb;
	const r = 23 * (p2 + .305) * zdiv(t, 23 * p1 + t * (11 * cosh + 108 * sinh));
	return multiplyMatrices(cat16Inv, unadapt(multiplyMatrices(m1, [
		p2,
		r * cosh,
		r * sinh
	]).map((c$1) => {
		return c$1 * 1 / 1403;
	}), env.fl).map((c$1, i) => {
		return c$1 * env.dRgbInv[i];
	})).map((c$1) => {
		return c$1 / 100;
	});
}
function toCam16(xyzd65, env) {
	const rgbA = adapt$1(multiplyMatrices(cat16, xyzd65.map((c$1) => {
		return c$1 * 100;
	})).map((c$1, i) => {
		return c$1 * env.dRgb[i];
	}), env.fl);
	const a$1 = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;
	const b$2 = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;
	const hRad = (Math.atan2(b$2, a$1) % tau + tau) % tau;
	const et = .25 * (Math.cos(hRad + 2) + 3.8);
	const alpha = spow(5e4 / 13 * env.nc * env.ncb * zdiv(et * Math.sqrt(a$1 ** 2 + b$2 ** 2), rgbA[0] + rgbA[1] + 1.05 * rgbA[2] + .305), .9) * Math.pow(1.64 - Math.pow(.29, env.n), .73);
	const Jroot = spow(env.nbb * (2 * rgbA[0] + rgbA[1] + .05 * rgbA[2]) / env.aW, .5 * env.c * env.z);
	const J = 100 * spow(Jroot, 2);
	const Q = 4 / env.c * Jroot * (env.aW + 4) * env.flRoot;
	const C = alpha * Jroot;
	const M = C * env.flRoot;
	const h = constrain(hRad * rad2deg);
	const H = hueQuadrature(h);
	return {
		J,
		C,
		h,
		s: 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2),
		Q,
		M,
		H
	};
}
var cam16 = new ColorSpace({
	id: "cam16-jmh",
	cssId: "--cam16-jmh",
	name: "CAM16-JMh",
	coords: {
		j: {
			refRange: [0, 100],
			name: "J"
		},
		m: {
			refRange: [0, 105],
			name: "Colorfulness"
		},
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	base: xyz_d65,
	fromBase(xyz) {
		const cam16$1 = toCam16(xyz, viewingConditions$1);
		return [
			cam16$1.J,
			cam16$1.M,
			cam16$1.h
		];
	},
	toBase(cam16$1) {
		return fromCam16({
			J: cam16$1[0],
			M: cam16$1[1],
			h: cam16$1[2]
		}, viewingConditions$1);
	}
});
var white$2 = WHITES.D65;
var ε$4 = 216 / 24389;
var κ$3 = 24389 / 27;
function toLstar(y) {
	return 116 * (y > ε$4 ? Math.cbrt(y) : (κ$3 * y + 16) / 116) - 16;
}
function fromLstar(lstar) {
	return lstar > 8 ? Math.pow((lstar + 16) / 116, 3) : lstar / κ$3;
}
function fromHct(coords, env) {
	let [h, c$1, t] = coords;
	let xyz = [];
	let j = 0;
	if (t === 0) return [
		0,
		0,
		0
	];
	let y = fromLstar(t);
	if (t > 0) j = .00379058511492914 * t ** 2 + .608983189401032 * t + .9155088574762233;
	else j = 9514440756550361e-21 * t ** 2 + .08693057439788597 * t - 21.928975842194614;
	const threshold = 2e-12;
	const max_attempts = 15;
	let attempt = 0;
	let last$1 = Infinity;
	while (attempt <= max_attempts) {
		xyz = fromCam16({
			J: j,
			C: c$1,
			h
		}, env);
		const delta = Math.abs(xyz[1] - y);
		if (delta < last$1) {
			if (delta <= threshold) return xyz;
			last$1 = delta;
		}
		j = j - (xyz[1] - y) * j / (2 * xyz[1]);
		attempt += 1;
	}
	return fromCam16({
		J: j,
		C: c$1,
		h
	}, env);
}
function toHct(xyz, env) {
	const t = toLstar(xyz[1]);
	if (t === 0) return [
		0,
		0,
		0
	];
	const cam16$1 = toCam16(xyz, viewingConditions);
	return [
		constrain(cam16$1.h),
		cam16$1.C,
		t
	];
}
var viewingConditions = environment(white$2, 200 / Math.PI * fromLstar(50), fromLstar(50) * 100, "average", false);
var hct = new ColorSpace({
	id: "hct",
	name: "HCT",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		c: {
			refRange: [0, 145],
			name: "Colorfulness"
		},
		t: {
			refRange: [0, 100],
			name: "Tone"
		}
	},
	base: xyz_d65,
	fromBase(xyz) {
		return toHct(xyz);
	},
	toBase(hct$1) {
		return fromHct(hct$1, viewingConditions);
	},
	formats: { color: {
		id: "--hct",
		coords: [
			"<number> | <angle>",
			"<percentage> | <number>",
			"<percentage> | <number>"
		]
	} }
});
var deg2rad = Math.PI / 180;
var ucsCoeff = [
	1,
	.007,
	.0228
];
function convertUcsAb(coords) {
	if (coords[1] < 0) coords = hct.fromBase(hct.toBase(coords));
	const M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1)) / ucsCoeff[2];
	const hrad = coords[0] * deg2rad;
	const a$1 = M * Math.cos(hrad);
	const b$2 = M * Math.sin(hrad);
	return [
		coords[2],
		a$1,
		b$2
	];
}
function deltaEHCT(color$2, sample$2) {
	[color$2, sample$2] = getColor([color$2, sample$2]);
	let [t1, a1, b1] = convertUcsAb(hct.from(color$2));
	let [t2, a2, b2] = convertUcsAb(hct.from(sample$2));
	return Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);
}
var deltaEMethods = {
	deltaE76,
	deltaECMC,
	deltaE2000,
	deltaEJz,
	deltaEITP,
	deltaEOK,
	deltaEHCT
};
function calcEpsilon(jnd) {
	const order = !jnd ? 0 : Math.floor(Math.log10(Math.abs(jnd)));
	return Math.max(parseFloat(`1e${order - 2}`), 1e-6);
}
var GMAPPRESET = {
	"hct": {
		method: "hct.c",
		jnd: 2,
		deltaEMethod: "hct",
		blackWhiteClamp: {}
	},
	"hct-tonal": {
		method: "hct.c",
		jnd: 0,
		deltaEMethod: "hct",
		blackWhiteClamp: {
			channel: "hct.t",
			min: 0,
			max: 100
		}
	}
};
function toGamut(color$2, { method = defaults.gamut_mapping, space = void 0, deltaEMethod = "", jnd = 2, blackWhiteClamp = {} } = {}) {
	color$2 = getColor(color$2);
	if (isString(arguments[1])) space = arguments[1];
	else if (!space) space = color$2.space;
	space = ColorSpace.get(space);
	if (inGamut(color$2, space, { epsilon: 0 })) return color$2;
	let spaceColor;
	if (method === "css") spaceColor = toGamutCSS(color$2, { space });
	else {
		if (method !== "clip" && !inGamut(color$2, space)) {
			if (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) ({method, jnd, deltaEMethod, blackWhiteClamp} = GMAPPRESET[method]);
			let de = deltaE2000;
			if (deltaEMethod !== "") {
				for (let m$1 in deltaEMethods) if ("deltae" + deltaEMethod.toLowerCase() === m$1.toLowerCase()) {
					de = deltaEMethods[m$1];
					break;
				}
			}
			let clipped = toGamut(to(color$2, space), {
				method: "clip",
				space
			});
			if (de(color$2, clipped) > jnd) {
				if (Object.keys(blackWhiteClamp).length === 3) {
					let channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);
					let channel = get(to(color$2, channelMeta.space), channelMeta.id);
					if (isNone(channel)) channel = 0;
					if (channel >= blackWhiteClamp.max) return to({
						space: "xyz-d65",
						coords: WHITES["D65"]
					}, color$2.space);
					else if (channel <= blackWhiteClamp.min) return to({
						space: "xyz-d65",
						coords: [
							0,
							0,
							0
						]
					}, color$2.space);
				}
				let coordMeta = ColorSpace.resolveCoord(method);
				let mapSpace = coordMeta.space;
				let coordId = coordMeta.id;
				let mappedColor = to(color$2, mapSpace);
				mappedColor.coords.forEach((c$1, i) => {
					if (isNone(c$1)) mappedColor.coords[i] = 0;
				});
				let min$1$1 = (coordMeta.range || coordMeta.refRange)[0];
				let ε$8 = calcEpsilon(jnd);
				let low = min$1$1;
				let high = get(mappedColor, coordId);
				while (high - low > ε$8) {
					let clipped$1 = clone(mappedColor);
					clipped$1 = toGamut(clipped$1, {
						space,
						method: "clip"
					});
					if (de(mappedColor, clipped$1) - jnd < ε$8) low = get(mappedColor, coordId);
					else high = get(mappedColor, coordId);
					set(mappedColor, coordId, (low + high) / 2);
				}
				spaceColor = to(mappedColor, space);
			} else spaceColor = clipped;
		} else spaceColor = to(color$2, space);
		if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
			let bounds = Object.values(space.coords).map((c$1) => c$1.range || []);
			spaceColor.coords = spaceColor.coords.map((c$1, i) => {
				let [min$1$1, max$2$1] = bounds[i];
				if (min$1$1 !== void 0) c$1 = Math.max(min$1$1, c$1);
				if (max$2$1 !== void 0) c$1 = Math.min(c$1, max$2$1);
				return c$1;
			});
		}
	}
	if (space !== color$2.space) spaceColor = to(spaceColor, color$2.space);
	color$2.coords = spaceColor.coords;
	return color$2;
}
toGamut.returns = "color";
var COLORS = {
	WHITE: {
		space: OKLab,
		coords: [
			1,
			0,
			0
		]
	},
	BLACK: {
		space: OKLab,
		coords: [
			0,
			0,
			0
		]
	}
};
function toGamutCSS(origin, { space } = {}) {
	const JND = .02;
	const ε$8 = 1e-4;
	origin = getColor(origin);
	if (!space) space = origin.space;
	space = ColorSpace.get(space);
	const oklchSpace = ColorSpace.get("oklch");
	if (space.isUnbounded) return to(origin, space);
	const origin_OKLCH = to(origin, oklchSpace);
	let L = origin_OKLCH.coords[0];
	if (L >= 1) {
		const white$5 = to(COLORS.WHITE, space);
		white$5.alpha = origin.alpha;
		return to(white$5, space);
	}
	if (L <= 0) {
		const black = to(COLORS.BLACK, space);
		black.alpha = origin.alpha;
		return to(black, space);
	}
	if (inGamut(origin_OKLCH, space, { epsilon: 0 })) return to(origin_OKLCH, space);
	function clip(_color$1) {
		const destColor = to(_color$1, space);
		const spaceCoords = Object.values(space.coords);
		destColor.coords = destColor.coords.map((coord, index) => {
			if ("range" in spaceCoords[index]) {
				const [min$2$1, max$3] = spaceCoords[index].range;
				return clamp$1(min$2$1, coord, max$3);
			}
			return coord;
		});
		return destColor;
	}
	let min$1$1 = 0;
	let max$2$1 = origin_OKLCH.coords[1];
	let min_inGamut = true;
	let current = clone(origin_OKLCH);
	let clipped = clip(current);
	let E = deltaEOK(clipped, current);
	if (E < JND) return clipped;
	while (max$2$1 - min$1$1 > ε$8) {
		const chroma = (min$1$1 + max$2$1) / 2;
		current.coords[1] = chroma;
		if (min_inGamut && inGamut(current, space, { epsilon: 0 })) min$1$1 = chroma;
		else {
			clipped = clip(current);
			E = deltaEOK(clipped, current);
			if (E < JND) if (JND - E < ε$8) break;
			else {
				min_inGamut = false;
				min$1$1 = chroma;
			}
			else max$2$1 = chroma;
		}
	}
	return clipped;
}
function to(color$2, space, { inGamut: inGamut$1 } = {}) {
	color$2 = getColor(color$2);
	space = ColorSpace.get(space);
	let coords = space.from(color$2);
	let ret = {
		space,
		coords,
		alpha: color$2.alpha
	};
	if (inGamut$1) ret = toGamut(ret, inGamut$1 === true ? void 0 : inGamut$1);
	return ret;
}
to.returns = "color";
function serialize(color$2, { precision = defaults.precision, format = "default", inGamut: inGamut$1 = true,...customOptions } = {}) {
	let ret;
	color$2 = getColor(color$2);
	let formatId = format;
	format = color$2.space.getFormat(format) ?? color$2.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
	let coords = color$2.coords.slice();
	inGamut$1 ||= format.toGamut;
	if (inGamut$1 && !inGamut(color$2)) coords = toGamut(clone(color$2), inGamut$1 === true ? void 0 : inGamut$1).coords;
	if (format.type === "custom") {
		customOptions.precision = precision;
		if (format.serialize) ret = format.serialize(coords, color$2.alpha, customOptions);
		else throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
	} else {
		let name = format.name || "color";
		if (format.serializeCoords) coords = format.serializeCoords(coords, precision);
		else if (precision !== null) coords = coords.map((c$1) => {
			return serializeNumber(c$1, { precision });
		});
		let args = [...coords];
		if (name === "color") {
			let cssId = format.id || format.ids?.[0] || color$2.space.id;
			args.unshift(cssId);
		}
		let alpha = color$2.alpha;
		if (precision !== null) alpha = serializeNumber(alpha, { precision });
		let strAlpha = color$2.alpha >= 1 || format.noAlpha ? "" : `${format.commas ? "," : " /"} ${alpha}`;
		ret = `${name}(${args.join(format.commas ? ", " : " ")}${strAlpha})`;
	}
	return ret;
}
var REC2020Linear = new RGBColorSpace({
	id: "rec2020-linear",
	cssId: "--rec2020-linear",
	name: "Linear REC.2020",
	white: "D65",
	toXYZ_M: [
		[
			.6369580483012914,
			.14461690358620832,
			.1688809751641721
		],
		[
			.2627002120112671,
			.6779980715188708,
			.05930171646986196
		],
		[
			0,
			.028072693049087428,
			1.060985057710791
		]
	],
	fromXYZ_M: [
		[
			1.716651187971268,
			-.355670783776392,
			-.25336628137366
		],
		[
			-.666684351832489,
			1.616481236634939,
			.0157685458139111
		],
		[
			.017639857445311,
			-.042770613257809,
			.942103121235474
		]
	]
});
var α = 1.09929682680944;
var β = .018053968510807;
var REC2020 = new RGBColorSpace({
	id: "rec2020",
	name: "REC.2020",
	base: REC2020Linear,
	toBase(RGB) {
		return RGB.map(function(val) {
			if (val < β * 4.5) return val / 4.5;
			return Math.pow((val + α - 1) / α, 1 / .45);
		});
	},
	fromBase(RGB) {
		return RGB.map(function(val) {
			if (val >= β) return α * Math.pow(val, .45) - (α - 1);
			return 4.5 * val;
		});
	}
});
var P3Linear = new RGBColorSpace({
	id: "p3-linear",
	cssId: "--display-p3-linear",
	name: "Linear P3",
	white: "D65",
	toXYZ_M: [
		[
			.4865709486482162,
			.26566769316909306,
			.1982172852343625
		],
		[
			.2289745640697488,
			.6917385218365064,
			.079286914093745
		],
		[
			0,
			.04511338185890264,
			1.043944368900976
		]
	],
	fromXYZ_M: [
		[
			2.493496911941425,
			-.9313836179191239,
			-.40271078445071684
		],
		[
			-.8294889695615747,
			1.7626640603183463,
			.023624685841943577
		],
		[
			.03584583024378447,
			-.07617238926804182,
			.9568845240076872
		]
	]
});
var toXYZ_M$3 = [
	[
		.41239079926595934,
		.357584339383878,
		.1804807884018343
	],
	[
		.21263900587151027,
		.715168678767756,
		.07219231536073371
	],
	[
		.01933081871559182,
		.11919477979462598,
		.9505321522496607
	]
];
var fromXYZ_M$3 = [
	[
		3.2409699419045226,
		-1.537383177570094,
		-.4986107602930034
	],
	[
		-.9692436362808796,
		1.8759675015077202,
		.04155505740717559
	],
	[
		.05563007969699366,
		-.20397695888897652,
		1.0569715142428786
	]
];
var sRGBLinear = new RGBColorSpace({
	id: "srgb-linear",
	name: "Linear sRGB",
	white: "D65",
	toXYZ_M: toXYZ_M$3,
	fromXYZ_M: fromXYZ_M$3
});
var KEYWORDS = {
	"aliceblue": [
		240 / 255,
		248 / 255,
		1
	],
	"antiquewhite": [
		250 / 255,
		235 / 255,
		215 / 255
	],
	"aqua": [
		0,
		1,
		1
	],
	"aquamarine": [
		127 / 255,
		1,
		212 / 255
	],
	"azure": [
		240 / 255,
		1,
		1
	],
	"beige": [
		245 / 255,
		245 / 255,
		220 / 255
	],
	"bisque": [
		1,
		228 / 255,
		196 / 255
	],
	"black": [
		0,
		0,
		0
	],
	"blanchedalmond": [
		1,
		235 / 255,
		205 / 255
	],
	"blue": [
		0,
		0,
		1
	],
	"blueviolet": [
		138 / 255,
		43 / 255,
		226 / 255
	],
	"brown": [
		165 / 255,
		42 / 255,
		42 / 255
	],
	"burlywood": [
		222 / 255,
		184 / 255,
		135 / 255
	],
	"cadetblue": [
		95 / 255,
		158 / 255,
		160 / 255
	],
	"chartreuse": [
		127 / 255,
		1,
		0
	],
	"chocolate": [
		210 / 255,
		105 / 255,
		30 / 255
	],
	"coral": [
		1,
		127 / 255,
		80 / 255
	],
	"cornflowerblue": [
		100 / 255,
		149 / 255,
		237 / 255
	],
	"cornsilk": [
		1,
		248 / 255,
		220 / 255
	],
	"crimson": [
		220 / 255,
		20 / 255,
		60 / 255
	],
	"cyan": [
		0,
		1,
		1
	],
	"darkblue": [
		0,
		0,
		139 / 255
	],
	"darkcyan": [
		0,
		139 / 255,
		139 / 255
	],
	"darkgoldenrod": [
		184 / 255,
		134 / 255,
		11 / 255
	],
	"darkgray": [
		169 / 255,
		169 / 255,
		169 / 255
	],
	"darkgreen": [
		0,
		100 / 255,
		0
	],
	"darkgrey": [
		169 / 255,
		169 / 255,
		169 / 255
	],
	"darkkhaki": [
		189 / 255,
		183 / 255,
		107 / 255
	],
	"darkmagenta": [
		139 / 255,
		0,
		139 / 255
	],
	"darkolivegreen": [
		85 / 255,
		107 / 255,
		47 / 255
	],
	"darkorange": [
		1,
		140 / 255,
		0
	],
	"darkorchid": [
		153 / 255,
		50 / 255,
		204 / 255
	],
	"darkred": [
		139 / 255,
		0,
		0
	],
	"darksalmon": [
		233 / 255,
		150 / 255,
		122 / 255
	],
	"darkseagreen": [
		143 / 255,
		188 / 255,
		143 / 255
	],
	"darkslateblue": [
		72 / 255,
		61 / 255,
		139 / 255
	],
	"darkslategray": [
		47 / 255,
		79 / 255,
		79 / 255
	],
	"darkslategrey": [
		47 / 255,
		79 / 255,
		79 / 255
	],
	"darkturquoise": [
		0,
		206 / 255,
		209 / 255
	],
	"darkviolet": [
		148 / 255,
		0,
		211 / 255
	],
	"deeppink": [
		1,
		20 / 255,
		147 / 255
	],
	"deepskyblue": [
		0,
		191 / 255,
		1
	],
	"dimgray": [
		105 / 255,
		105 / 255,
		105 / 255
	],
	"dimgrey": [
		105 / 255,
		105 / 255,
		105 / 255
	],
	"dodgerblue": [
		30 / 255,
		144 / 255,
		1
	],
	"firebrick": [
		178 / 255,
		34 / 255,
		34 / 255
	],
	"floralwhite": [
		1,
		250 / 255,
		240 / 255
	],
	"forestgreen": [
		34 / 255,
		139 / 255,
		34 / 255
	],
	"fuchsia": [
		1,
		0,
		1
	],
	"gainsboro": [
		220 / 255,
		220 / 255,
		220 / 255
	],
	"ghostwhite": [
		248 / 255,
		248 / 255,
		1
	],
	"gold": [
		1,
		215 / 255,
		0
	],
	"goldenrod": [
		218 / 255,
		165 / 255,
		32 / 255
	],
	"gray": [
		128 / 255,
		128 / 255,
		128 / 255
	],
	"green": [
		0,
		128 / 255,
		0
	],
	"greenyellow": [
		173 / 255,
		1,
		47 / 255
	],
	"grey": [
		128 / 255,
		128 / 255,
		128 / 255
	],
	"honeydew": [
		240 / 255,
		1,
		240 / 255
	],
	"hotpink": [
		1,
		105 / 255,
		180 / 255
	],
	"indianred": [
		205 / 255,
		92 / 255,
		92 / 255
	],
	"indigo": [
		75 / 255,
		0,
		130 / 255
	],
	"ivory": [
		1,
		1,
		240 / 255
	],
	"khaki": [
		240 / 255,
		230 / 255,
		140 / 255
	],
	"lavender": [
		230 / 255,
		230 / 255,
		250 / 255
	],
	"lavenderblush": [
		1,
		240 / 255,
		245 / 255
	],
	"lawngreen": [
		124 / 255,
		252 / 255,
		0
	],
	"lemonchiffon": [
		1,
		250 / 255,
		205 / 255
	],
	"lightblue": [
		173 / 255,
		216 / 255,
		230 / 255
	],
	"lightcoral": [
		240 / 255,
		128 / 255,
		128 / 255
	],
	"lightcyan": [
		224 / 255,
		1,
		1
	],
	"lightgoldenrodyellow": [
		250 / 255,
		250 / 255,
		210 / 255
	],
	"lightgray": [
		211 / 255,
		211 / 255,
		211 / 255
	],
	"lightgreen": [
		144 / 255,
		238 / 255,
		144 / 255
	],
	"lightgrey": [
		211 / 255,
		211 / 255,
		211 / 255
	],
	"lightpink": [
		1,
		182 / 255,
		193 / 255
	],
	"lightsalmon": [
		1,
		160 / 255,
		122 / 255
	],
	"lightseagreen": [
		32 / 255,
		178 / 255,
		170 / 255
	],
	"lightskyblue": [
		135 / 255,
		206 / 255,
		250 / 255
	],
	"lightslategray": [
		119 / 255,
		136 / 255,
		153 / 255
	],
	"lightslategrey": [
		119 / 255,
		136 / 255,
		153 / 255
	],
	"lightsteelblue": [
		176 / 255,
		196 / 255,
		222 / 255
	],
	"lightyellow": [
		1,
		1,
		224 / 255
	],
	"lime": [
		0,
		1,
		0
	],
	"limegreen": [
		50 / 255,
		205 / 255,
		50 / 255
	],
	"linen": [
		250 / 255,
		240 / 255,
		230 / 255
	],
	"magenta": [
		1,
		0,
		1
	],
	"maroon": [
		128 / 255,
		0,
		0
	],
	"mediumaquamarine": [
		102 / 255,
		205 / 255,
		170 / 255
	],
	"mediumblue": [
		0,
		0,
		205 / 255
	],
	"mediumorchid": [
		186 / 255,
		85 / 255,
		211 / 255
	],
	"mediumpurple": [
		147 / 255,
		112 / 255,
		219 / 255
	],
	"mediumseagreen": [
		60 / 255,
		179 / 255,
		113 / 255
	],
	"mediumslateblue": [
		123 / 255,
		104 / 255,
		238 / 255
	],
	"mediumspringgreen": [
		0,
		250 / 255,
		154 / 255
	],
	"mediumturquoise": [
		72 / 255,
		209 / 255,
		204 / 255
	],
	"mediumvioletred": [
		199 / 255,
		21 / 255,
		133 / 255
	],
	"midnightblue": [
		25 / 255,
		25 / 255,
		112 / 255
	],
	"mintcream": [
		245 / 255,
		1,
		250 / 255
	],
	"mistyrose": [
		1,
		228 / 255,
		225 / 255
	],
	"moccasin": [
		1,
		228 / 255,
		181 / 255
	],
	"navajowhite": [
		1,
		222 / 255,
		173 / 255
	],
	"navy": [
		0,
		0,
		128 / 255
	],
	"oldlace": [
		253 / 255,
		245 / 255,
		230 / 255
	],
	"olive": [
		128 / 255,
		128 / 255,
		0
	],
	"olivedrab": [
		107 / 255,
		142 / 255,
		35 / 255
	],
	"orange": [
		1,
		165 / 255,
		0
	],
	"orangered": [
		1,
		69 / 255,
		0
	],
	"orchid": [
		218 / 255,
		112 / 255,
		214 / 255
	],
	"palegoldenrod": [
		238 / 255,
		232 / 255,
		170 / 255
	],
	"palegreen": [
		152 / 255,
		251 / 255,
		152 / 255
	],
	"paleturquoise": [
		175 / 255,
		238 / 255,
		238 / 255
	],
	"palevioletred": [
		219 / 255,
		112 / 255,
		147 / 255
	],
	"papayawhip": [
		1,
		239 / 255,
		213 / 255
	],
	"peachpuff": [
		1,
		218 / 255,
		185 / 255
	],
	"peru": [
		205 / 255,
		133 / 255,
		63 / 255
	],
	"pink": [
		1,
		192 / 255,
		203 / 255
	],
	"plum": [
		221 / 255,
		160 / 255,
		221 / 255
	],
	"powderblue": [
		176 / 255,
		224 / 255,
		230 / 255
	],
	"purple": [
		128 / 255,
		0,
		128 / 255
	],
	"rebeccapurple": [
		102 / 255,
		51 / 255,
		153 / 255
	],
	"red": [
		1,
		0,
		0
	],
	"rosybrown": [
		188 / 255,
		143 / 255,
		143 / 255
	],
	"royalblue": [
		65 / 255,
		105 / 255,
		225 / 255
	],
	"saddlebrown": [
		139 / 255,
		69 / 255,
		19 / 255
	],
	"salmon": [
		250 / 255,
		128 / 255,
		114 / 255
	],
	"sandybrown": [
		244 / 255,
		164 / 255,
		96 / 255
	],
	"seagreen": [
		46 / 255,
		139 / 255,
		87 / 255
	],
	"seashell": [
		1,
		245 / 255,
		238 / 255
	],
	"sienna": [
		160 / 255,
		82 / 255,
		45 / 255
	],
	"silver": [
		192 / 255,
		192 / 255,
		192 / 255
	],
	"skyblue": [
		135 / 255,
		206 / 255,
		235 / 255
	],
	"slateblue": [
		106 / 255,
		90 / 255,
		205 / 255
	],
	"slategray": [
		112 / 255,
		128 / 255,
		144 / 255
	],
	"slategrey": [
		112 / 255,
		128 / 255,
		144 / 255
	],
	"snow": [
		1,
		250 / 255,
		250 / 255
	],
	"springgreen": [
		0,
		1,
		127 / 255
	],
	"steelblue": [
		70 / 255,
		130 / 255,
		180 / 255
	],
	"tan": [
		210 / 255,
		180 / 255,
		140 / 255
	],
	"teal": [
		0,
		128 / 255,
		128 / 255
	],
	"thistle": [
		216 / 255,
		191 / 255,
		216 / 255
	],
	"tomato": [
		1,
		99 / 255,
		71 / 255
	],
	"turquoise": [
		64 / 255,
		224 / 255,
		208 / 255
	],
	"violet": [
		238 / 255,
		130 / 255,
		238 / 255
	],
	"wheat": [
		245 / 255,
		222 / 255,
		179 / 255
	],
	"white": [
		1,
		1,
		1
	],
	"whitesmoke": [
		245 / 255,
		245 / 255,
		245 / 255
	],
	"yellow": [
		1,
		1,
		0
	],
	"yellowgreen": [
		154 / 255,
		205 / 255,
		50 / 255
	]
};
var coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
var coordGrammarNumber = Array(3).fill("<number>[0, 255]");
var sRGB = new RGBColorSpace({
	id: "srgb",
	name: "sRGB",
	base: sRGBLinear,
	fromBase: (rgb) => {
		return rgb.map((val) => {
			let sign$2 = val < 0 ? -1 : 1;
			let abs$1$1 = val * sign$2;
			if (abs$1$1 > .0031308) return sign$2 * (1.055 * abs$1$1 ** (1 / 2.4) - .055);
			return 12.92 * val;
		});
	},
	toBase: (rgb) => {
		return rgb.map((val) => {
			let sign$2 = val < 0 ? -1 : 1;
			let abs$1$1 = val * sign$2;
			if (abs$1$1 <= .04045) return val / 12.92;
			return sign$2 * ((abs$1$1 + .055) / 1.055) ** 2.4;
		});
	},
	formats: {
		"rgb": { coords: coordGrammar },
		"rgb_number": {
			name: "rgb",
			commas: true,
			coords: coordGrammarNumber,
			noAlpha: true
		},
		"color": {},
		"rgba": {
			coords: coordGrammar,
			commas: true,
			lastAlpha: true
		},
		"rgba_number": {
			name: "rgba",
			commas: true,
			coords: coordGrammarNumber
		},
		"hex": {
			type: "custom",
			toGamut: true,
			test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
			parse(str) {
				if (str.length <= 5) str = str.replace(/[a-f0-9]/gi, "$&$&");
				let rgba = [];
				str.replace(/[a-f0-9]{2}/gi, (component) => {
					rgba.push(parseInt(component, 16) / 255);
				});
				return {
					spaceId: "srgb",
					coords: rgba.slice(0, 3),
					alpha: rgba.slice(3)[0]
				};
			},
			serialize: (coords, alpha, { collapse = true } = {}) => {
				if (alpha < 1) coords.push(alpha);
				coords = coords.map((c$1) => Math.round(c$1 * 255));
				let collapsible = collapse && coords.every((c$1) => c$1 % 17 === 0);
				return "#" + coords.map((c$1) => {
					if (collapsible) return (c$1 / 17).toString(16);
					return c$1.toString(16).padStart(2, "0");
				}).join("");
			}
		},
		"keyword": {
			type: "custom",
			test: (str) => /^[a-z]+$/i.test(str),
			parse(str) {
				str = str.toLowerCase();
				let ret = {
					spaceId: "srgb",
					coords: null,
					alpha: 1
				};
				if (str === "transparent") {
					ret.coords = KEYWORDS.black;
					ret.alpha = 0;
				} else ret.coords = KEYWORDS[str];
				if (ret.coords) return ret;
			}
		}
	}
});
var P3 = new RGBColorSpace({
	id: "p3",
	cssId: "display-p3",
	name: "P3",
	base: P3Linear,
	fromBase: sRGB.fromBase,
	toBase: sRGB.toBase
});
defaults.display_space = sRGB;
var supportsNone;
if (typeof CSS !== "undefined" && CSS.supports) for (let space of [
	lab,
	REC2020,
	P3
]) {
	let str = serialize({
		space,
		coords: space.getMinCoords(),
		alpha: 1
	});
	if (CSS.supports("color", str)) {
		defaults.display_space = space;
		break;
	}
}
function display(color$2, { space = defaults.display_space,...options } = {}) {
	let ret = serialize(color$2, options);
	if (typeof CSS === "undefined" || CSS.supports("color", ret) || !defaults.display_space) {
		ret = new String(ret);
		ret.color = color$2;
	} else {
		let fallbackColor = color$2;
		if (color$2.coords.some(isNone) || isNone(color$2.alpha)) {
			if (!(supportsNone ??= CSS.supports("color", "hsl(none 50% 50%)"))) {
				fallbackColor = clone(color$2);
				fallbackColor.coords = fallbackColor.coords.map(skipNone);
				fallbackColor.alpha = skipNone(fallbackColor.alpha);
				ret = serialize(fallbackColor, options);
				if (CSS.supports("color", ret)) {
					ret = new String(ret);
					ret.color = fallbackColor;
					return ret;
				}
			}
		}
		fallbackColor = to(fallbackColor, space);
		ret = new String(serialize(fallbackColor, options));
		ret.color = fallbackColor;
	}
	return ret;
}
function equals(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	return color1.space === color2.space && color1.alpha === color2.alpha && color1.coords.every((c$1, i) => c$1 === color2.coords[i]);
}
function getLuminance$1(color$2) {
	return get(color$2, [xyz_d65, "y"]);
}
function setLuminance(color$2, value) {
	set(color$2, [xyz_d65, "y"], value);
}
function register$2(Color$1$1) {
	Object.defineProperty(Color$1$1.prototype, "luminance", {
		get() {
			return getLuminance$1(this);
		},
		set(value) {
			setLuminance(this, value);
		}
	});
}
var luminance = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	getLuminance: getLuminance$1,
	register: register$2,
	setLuminance
});
function contrastWCAG21(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	let Y1 = Math.max(getLuminance$1(color1), 0);
	let Y2 = Math.max(getLuminance$1(color2), 0);
	if (Y2 > Y1) [Y1, Y2] = [Y2, Y1];
	return (Y1 + .05) / (Y2 + .05);
}
var normBG = .56;
var normTXT = .57;
var revTXT = .62;
var revBG = .65;
var blkThrs = .022;
var blkClmp = 1.414;
var loClip = .1;
var deltaYmin = 5e-4;
var scaleBoW = 1.14;
var loBoWoffset = .027;
var scaleWoB = 1.14;
function fclamp(Y) {
	if (Y >= blkThrs) return Y;
	return Y + (blkThrs - Y) ** blkClmp;
}
function linearize(val) {
	let sign$2 = val < 0 ? -1 : 1;
	let abs$1$1 = Math.abs(val);
	return sign$2 * Math.pow(abs$1$1, 2.4);
}
function contrastAPCA(background, foreground) {
	foreground = getColor(foreground);
	background = getColor(background);
	let S;
	let C;
	let Sapc;
	let R, G, B$1;
	foreground = to(foreground, "srgb");
	[R, G, B$1] = foreground.coords;
	let lumTxt = linearize(R) * .2126729 + linearize(G) * .7151522 + linearize(B$1) * .072175;
	background = to(background, "srgb");
	[R, G, B$1] = background.coords;
	let lumBg = linearize(R) * .2126729 + linearize(G) * .7151522 + linearize(B$1) * .072175;
	let Ytxt = fclamp(lumTxt);
	let Ybg = fclamp(lumBg);
	let BoW = Ybg > Ytxt;
	if (Math.abs(Ybg - Ytxt) < deltaYmin) C = 0;
	else if (BoW) {
		S = Ybg ** normBG - Ytxt ** normTXT;
		C = S * scaleBoW;
	} else {
		S = Ybg ** revBG - Ytxt ** revTXT;
		C = S * scaleWoB;
	}
	if (Math.abs(C) < loClip) Sapc = 0;
	else if (C > 0) Sapc = C - loBoWoffset;
	else Sapc = C + loBoWoffset;
	return Sapc * 100;
}
function contrastMichelson(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	let Y1 = Math.max(getLuminance$1(color1), 0);
	let Y2 = Math.max(getLuminance$1(color2), 0);
	if (Y2 > Y1) [Y1, Y2] = [Y2, Y1];
	let denom = Y1 + Y2;
	return denom === 0 ? 0 : (Y1 - Y2) / denom;
}
var max$1 = 5e4;
function contrastWeber(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	let Y1 = Math.max(getLuminance$1(color1), 0);
	let Y2 = Math.max(getLuminance$1(color2), 0);
	if (Y2 > Y1) [Y1, Y2] = [Y2, Y1];
	return Y2 === 0 ? max$1 : (Y1 - Y2) / Y2;
}
function contrastLstar(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	let L1 = get(color1, [lab, "l"]);
	let L2 = get(color2, [lab, "l"]);
	return Math.abs(L1 - L2);
}
var ε$3 = 216 / 24389;
var ε3 = 24 / 116;
var κ$2 = 24389 / 27;
var white$1 = WHITES.D65;
var lab_d65 = new ColorSpace({
	id: "lab-d65",
	name: "Lab D65",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		a: { refRange: [-125, 125] },
		b: { refRange: [-125, 125] }
	},
	white: white$1,
	base: xyz_d65,
	fromBase(XYZ) {
		let f = XYZ.map((value, i) => value / white$1[i]).map((value) => value > ε$3 ? Math.cbrt(value) : (κ$2 * value + 16) / 116);
		return [
			116 * f[1] - 16,
			500 * (f[0] - f[1]),
			200 * (f[1] - f[2])
		];
	},
	toBase(Lab) {
		let f = [];
		f[1] = (Lab[0] + 16) / 116;
		f[0] = Lab[1] / 500 + f[1];
		f[2] = f[1] - Lab[2] / 200;
		return [
			f[0] > ε3 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ$2,
			Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ$2,
			f[2] > ε3 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ$2
		].map((value, i) => value * white$1[i]);
	},
	formats: { "lab-d65": { coords: [
		"<number> | <percentage>",
		"<number> | <percentage>[-1,1]",
		"<number> | <percentage>[-1,1]"
	] } }
});
var phi = Math.pow(5, .5) * .5 + .5;
function contrastDeltaPhi(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	let Lstr1 = get(color1, [lab_d65, "l"]);
	let Lstr2 = get(color2, [lab_d65, "l"]);
	let deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));
	let contrast$1 = Math.pow(deltaPhiStar, 1 / phi) * Math.SQRT2 - 40;
	return contrast$1 < 7.5 ? 0 : contrast$1;
}
var contrastMethods = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	contrastAPCA,
	contrastDeltaPhi,
	contrastLstar,
	contrastMichelson,
	contrastWCAG21,
	contrastWeber
});
function contrast(background, foreground, o = {}) {
	if (isString(o)) o = { algorithm: o };
	let { algorithm,...rest } = o;
	if (!algorithm) {
		let algorithms = Object.keys(contrastMethods).map((a$1) => a$1.replace(/^contrast/, "")).join(", ");
		throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);
	}
	background = getColor(background);
	foreground = getColor(foreground);
	for (let a$1 in contrastMethods) if ("contrast" + algorithm.toLowerCase() === a$1.toLowerCase()) return contrastMethods[a$1](background, foreground, rest);
	throw new TypeError(`Unknown contrast algorithm: ${algorithm}`);
}
function uv$1(color$2) {
	let [X, Y, Z] = getAll(color$2, xyz_d65);
	let denom = X + 15 * Y + 3 * Z;
	return [4 * X / denom, 9 * Y / denom];
}
function xy(color$2) {
	let [X, Y, Z] = getAll(color$2, xyz_d65);
	let sum = X + Y + Z;
	return [X / sum, Y / sum];
}
function register$1(Color$1$1) {
	Object.defineProperty(Color$1$1.prototype, "uv", { get() {
		return uv$1(this);
	} });
	Object.defineProperty(Color$1$1.prototype, "xy", { get() {
		return xy(this);
	} });
}
var chromaticity = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	register: register$1,
	uv: uv$1,
	xy
});
function deltaE(c1$3, c2$3, o = {}) {
	if (isString(o)) o = { method: o };
	let { method = defaults.deltaE,...rest } = o;
	for (let m$1 in deltaEMethods) if ("deltae" + method.toLowerCase() === m$1.toLowerCase()) return deltaEMethods[m$1](c1$3, c2$3, rest);
	throw new TypeError(`Unknown deltaE method: ${method}`);
}
function lighten(color$2, amount = .25) {
	return set(color$2, [ColorSpace.get("oklch", "lch"), "l"], (l) => l * (1 + amount));
}
function darken(color$2, amount = .25) {
	return set(color$2, [ColorSpace.get("oklch", "lch"), "l"], (l) => l * (1 - amount));
}
var variations = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	darken,
	lighten
});
function mix$1(c1$3, c2$3, p$1 = .5, o = {}) {
	[c1$3, c2$3] = [getColor(c1$3), getColor(c2$3)];
	if (type(p$1) === "object") [p$1, o] = [.5, p$1];
	return range(c1$3, c2$3, o)(p$1);
}
function steps(c1$3, c2$3, options = {}) {
	let colorRange;
	if (isRange(c1$3)) {
		[colorRange, options] = [c1$3, c2$3];
		[c1$3, c2$3] = colorRange.rangeArgs.colors;
	}
	let { maxDeltaE, deltaEMethod, steps: steps$1 = 2, maxSteps = 1e3,...rangeOptions } = options;
	if (!colorRange) {
		[c1$3, c2$3] = [getColor(c1$3), getColor(c2$3)];
		colorRange = range(c1$3, c2$3, rangeOptions);
	}
	let totalDelta = deltaE(c1$3, c2$3);
	let actualSteps = maxDeltaE > 0 ? Math.max(steps$1, Math.ceil(totalDelta / maxDeltaE) + 1) : steps$1;
	let ret = [];
	if (maxSteps !== void 0) actualSteps = Math.min(actualSteps, maxSteps);
	if (actualSteps === 1) ret = [{
		p: .5,
		color: colorRange(.5)
	}];
	else {
		let step$1$1 = 1 / (actualSteps - 1);
		ret = Array.from({ length: actualSteps }, (_, i) => {
			let p$1 = i * step$1$1;
			return {
				p: p$1,
				color: colorRange(p$1)
			};
		});
	}
	if (maxDeltaE > 0) {
		let maxDelta = ret.reduce((acc, cur, i) => {
			if (i === 0) return 0;
			let ΔΕ = deltaE(cur.color, ret[i - 1].color, deltaEMethod);
			return Math.max(acc, ΔΕ);
		}, 0);
		while (maxDelta > maxDeltaE) {
			maxDelta = 0;
			for (let i = 1; i < ret.length && ret.length < maxSteps; i++) {
				let prev = ret[i - 1];
				let cur = ret[i];
				let p$1 = (cur.p + prev.p) / 2;
				let color$2 = colorRange(p$1);
				maxDelta = Math.max(maxDelta, deltaE(color$2, prev.color), deltaE(color$2, cur.color));
				ret.splice(i, 0, {
					p: p$1,
					color: colorRange(p$1)
				});
				i++;
			}
		}
	}
	ret = ret.map((a$1) => a$1.color);
	return ret;
}
function range(color1, color2, options = {}) {
	if (isRange(color1)) {
		let [r, options$1] = [color1, color2];
		return range(...r.rangeArgs.colors, {
			...r.rangeArgs.options,
			...options$1
		});
	}
	let { space, outputSpace, progression, premultiplied } = options;
	color1 = getColor(color1);
	color2 = getColor(color2);
	color1 = clone(color1);
	color2 = clone(color2);
	let rangeArgs = {
		colors: [color1, color2],
		options
	};
	if (space) space = ColorSpace.get(space);
	else space = ColorSpace.registry[defaults.interpolationSpace] || color1.space;
	outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
	color1 = to(color1, space);
	color2 = to(color2, space);
	color1 = toGamut(color1);
	color2 = toGamut(color2);
	if (space.coords.h && space.coords.h.type === "angle") {
		let arc = options.hue = options.hue || "shorter";
		let hue$2 = [space, "h"];
		let [θ1, θ2] = [get(color1, hue$2), get(color2, hue$2)];
		if (isNaN(θ1) && !isNaN(θ2)) θ1 = θ2;
		else if (isNaN(θ2) && !isNaN(θ1)) θ2 = θ1;
		[θ1, θ2] = adjust(arc, [θ1, θ2]);
		set(color1, hue$2, θ1);
		set(color2, hue$2, θ2);
	}
	if (premultiplied) {
		color1.coords = color1.coords.map((c$1) => c$1 * color1.alpha);
		color2.coords = color2.coords.map((c$1) => c$1 * color2.alpha);
	}
	return Object.assign((p$1) => {
		p$1 = progression ? progression(p$1) : p$1;
		let coords = color1.coords.map((start, i) => {
			let end = color2.coords[i];
			return interpolate(start, end, p$1);
		});
		let alpha = interpolate(color1.alpha, color2.alpha, p$1);
		let ret = {
			space,
			coords,
			alpha
		};
		if (premultiplied) ret.coords = ret.coords.map((c$1) => c$1 / alpha);
		if (outputSpace !== space) ret = to(ret, outputSpace);
		return ret;
	}, { rangeArgs });
}
function isRange(val) {
	return type(val) === "function" && !!val.rangeArgs;
}
defaults.interpolationSpace = "lab";
function register(Color$1$1) {
	Color$1$1.defineFunction("mix", mix$1, { returns: "color" });
	Color$1$1.defineFunction("range", range, { returns: "function<color>" });
	Color$1$1.defineFunction("steps", steps, { returns: "array<color>" });
}
var interpolation = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	isRange,
	mix: mix$1,
	range,
	register,
	steps
});
var HSL = new ColorSpace({
	id: "hsl",
	name: "HSL",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		s: {
			range: [0, 100],
			name: "Saturation"
		},
		l: {
			range: [0, 100],
			name: "Lightness"
		}
	},
	base: sRGB,
	fromBase: (rgb) => {
		let max$2$1 = Math.max(...rgb);
		let min$1$1 = Math.min(...rgb);
		let [r, g$1, b$2] = rgb;
		let [h, s, l] = [
			NaN,
			0,
			(min$1$1 + max$2$1) / 2
		];
		let d$1 = max$2$1 - min$1$1;
		if (d$1 !== 0) {
			s = l === 0 || l === 1 ? 0 : (max$2$1 - l) / Math.min(l, 1 - l);
			switch (max$2$1) {
				case r:
					h = (g$1 - b$2) / d$1 + (g$1 < b$2 ? 6 : 0);
					break;
				case g$1:
					h = (b$2 - r) / d$1 + 2;
					break;
				case b$2: h = (r - g$1) / d$1 + 4;
			}
			h = h * 60;
		}
		if (s < 0) {
			h += 180;
			s = Math.abs(s);
		}
		if (h >= 360) h -= 360;
		return [
			h,
			s * 100,
			l * 100
		];
	},
	toBase: (hsl) => {
		let [h, s, l] = hsl;
		h = h % 360;
		if (h < 0) h += 360;
		s /= 100;
		l /= 100;
		function f(n$2) {
			let k = (n$2 + h / 30) % 12;
			let a$1 = s * Math.min(l, 1 - l);
			return l - a$1 * Math.max(-1, Math.min(k - 3, 9 - k, 1));
		}
		return [
			f(0),
			f(8),
			f(4)
		];
	},
	formats: {
		"hsl": { coords: [
			"<number> | <angle>",
			"<percentage>",
			"<percentage>"
		] },
		"hsla": {
			coords: [
				"<number> | <angle>",
				"<percentage>",
				"<percentage>"
			],
			commas: true,
			lastAlpha: true
		}
	}
});
var HSV = new ColorSpace({
	id: "hsv",
	name: "HSV",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		s: {
			range: [0, 100],
			name: "Saturation"
		},
		v: {
			range: [0, 100],
			name: "Value"
		}
	},
	base: HSL,
	fromBase(hsl) {
		let [h, s, l] = hsl;
		s /= 100;
		l /= 100;
		let v = l + s * Math.min(l, 1 - l);
		return [
			h,
			v === 0 ? 0 : 200 * (1 - l / v),
			100 * v
		];
	},
	toBase(hsv) {
		let [h, s, v] = hsv;
		s /= 100;
		v /= 100;
		let l = v * (1 - s / 2);
		return [
			h,
			l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l) * 100,
			l * 100
		];
	},
	formats: { color: {
		id: "--hsv",
		coords: [
			"<number> | <angle>",
			"<percentage> | <number>",
			"<percentage> | <number>"
		]
	} }
});
var hwb = new ColorSpace({
	id: "hwb",
	name: "HWB",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		w: {
			range: [0, 100],
			name: "Whiteness"
		},
		b: {
			range: [0, 100],
			name: "Blackness"
		}
	},
	base: HSV,
	fromBase(hsv) {
		let [h, s, v] = hsv;
		return [
			h,
			v * (100 - s) / 100,
			100 - v
		];
	},
	toBase(hwb$1) {
		let [h, w, b$2] = hwb$1;
		w /= 100;
		b$2 /= 100;
		let sum = w + b$2;
		if (sum >= 1) return [
			h,
			0,
			w / sum * 100
		];
		let v = 1 - b$2;
		return [
			h,
			(v === 0 ? 0 : 1 - w / v) * 100,
			v * 100
		];
	},
	formats: { "hwb": { coords: [
		"<number> | <angle>",
		"<percentage> | <number>",
		"<percentage> | <number>"
	] } }
});
var A98Linear = new RGBColorSpace({
	id: "a98rgb-linear",
	cssId: "--a98-rgb-linear",
	name: "Linear Adobe® 98 RGB compatible",
	white: "D65",
	toXYZ_M: [
		[
			.5766690429101305,
			.1855582379065463,
			.1882286462349947
		],
		[
			.29734497525053605,
			.6273635662554661,
			.07529145849399788
		],
		[
			.02703136138641234,
			.07068885253582723,
			.9913375368376388
		]
	],
	fromXYZ_M: [
		[
			2.0415879038107465,
			-.5650069742788596,
			-.34473135077832956
		],
		[
			-.9692436362808795,
			1.8759675015077202,
			.04155505740717557
		],
		[
			.013444280632031142,
			-.11836239223101838,
			1.0151749943912054
		]
	]
});
var a98rgb = new RGBColorSpace({
	id: "a98rgb",
	cssId: "a98-rgb",
	name: "Adobe® 98 RGB compatible",
	base: A98Linear,
	toBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),
	fromBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val))
});
var ProPhotoLinear = new RGBColorSpace({
	id: "prophoto-linear",
	cssId: "--prophoto-rgb-linear",
	name: "Linear ProPhoto",
	white: "D50",
	base: XYZ_D50,
	toXYZ_M: [
		[
			.7977666449006423,
			.13518129740053308,
			.0313477341283922
		],
		[
			.2880748288194013,
			.711835234241873,
			8993693872564e-17
		],
		[
			0,
			0,
			.8251046025104602
		]
	],
	fromXYZ_M: [
		[
			1.3457868816471583,
			-.25557208737979464,
			-.05110186497554526
		],
		[
			-.5446307051249019,
			1.5082477428451468,
			.02052744743642139
		],
		[
			0,
			0,
			1.2119675456389452
		]
	]
});
var Et = 1 / 512;
var Et2 = 16 / 512;
var prophoto = new RGBColorSpace({
	id: "prophoto",
	cssId: "prophoto-rgb",
	name: "ProPhoto",
	base: ProPhotoLinear,
	toBase(RGB) {
		return RGB.map((v) => v < Et2 ? v / 16 : v ** 1.8);
	},
	fromBase(RGB) {
		return RGB.map((v) => v >= Et ? v ** (1 / 1.8) : 16 * v);
	}
});
var oklch = new ColorSpace({
	id: "oklch",
	name: "Oklch",
	coords: {
		l: {
			refRange: [0, 1],
			name: "Lightness"
		},
		c: {
			refRange: [0, .4],
			name: "Chroma"
		},
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	white: "D65",
	base: OKLab,
	fromBase(oklab) {
		let [L, a$1, b$2] = oklab;
		let h;
		const ε$8 = 2e-4;
		if (Math.abs(a$1) < ε$8 && Math.abs(b$2) < ε$8) h = NaN;
		else h = Math.atan2(b$2, a$1) * 180 / Math.PI;
		return [
			L,
			Math.sqrt(a$1 ** 2 + b$2 ** 2),
			constrain(h)
		];
	},
	toBase(oklch$1) {
		let [L, C, h] = oklch$1;
		let a$1, b$2;
		if (isNaN(h)) {
			a$1 = 0;
			b$2 = 0;
		} else {
			a$1 = C * Math.cos(h * Math.PI / 180);
			b$2 = C * Math.sin(h * Math.PI / 180);
		}
		return [
			L,
			a$1,
			b$2
		];
	},
	formats: { "oklch": { coords: [
		"<percentage> | <number>",
		"<number> | <percentage>[0,1]",
		"<number> | <angle>"
	] } }
});
var white = WHITES.D65;
var ε$2 = 216 / 24389;
var κ$1 = 24389 / 27;
var [U_PRIME_WHITE, V_PRIME_WHITE] = uv$1({
	space: xyz_d65,
	coords: white
});
var Luv = new ColorSpace({
	id: "luv",
	name: "Luv",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		u: { refRange: [-215, 215] },
		v: { refRange: [-215, 215] }
	},
	white,
	base: xyz_d65,
	fromBase(XYZ) {
		let xyz = [
			skipNone(XYZ[0]),
			skipNone(XYZ[1]),
			skipNone(XYZ[2])
		];
		let y = xyz[1];
		let [up, vp] = uv$1({
			space: xyz_d65,
			coords: xyz
		});
		if (!Number.isFinite(up) || !Number.isFinite(vp)) return [
			0,
			0,
			0
		];
		let L = y <= ε$2 ? κ$1 * y : 116 * Math.cbrt(y) - 16;
		return [
			L,
			13 * L * (up - U_PRIME_WHITE),
			13 * L * (vp - V_PRIME_WHITE)
		];
	},
	toBase(Luv$1) {
		let [L, u, v] = Luv$1;
		if (L === 0 || isNone(L)) return [
			0,
			0,
			0
		];
		u = skipNone(u);
		v = skipNone(v);
		let up = u / (13 * L) + U_PRIME_WHITE;
		let vp = v / (13 * L) + V_PRIME_WHITE;
		let y = L <= 8 ? L / κ$1 : Math.pow((L + 16) / 116, 3);
		return [
			y * (9 * up / (4 * vp)),
			y,
			y * ((12 - 3 * up - 20 * vp) / (4 * vp))
		];
	},
	formats: { color: {
		id: "--luv",
		coords: [
			"<number> | <percentage>",
			"<number> | <percentage>[-1,1]",
			"<number> | <percentage>[-1,1]"
		]
	} }
});
var LCHuv = new ColorSpace({
	id: "lchuv",
	name: "LChuv",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		c: {
			refRange: [0, 220],
			name: "Chroma"
		},
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	base: Luv,
	fromBase(Luv$1) {
		let [L, u, v] = Luv$1;
		let hue$2;
		const ε$8 = .02;
		if (Math.abs(u) < ε$8 && Math.abs(v) < ε$8) hue$2 = NaN;
		else hue$2 = Math.atan2(v, u) * 180 / Math.PI;
		return [
			L,
			Math.sqrt(u ** 2 + v ** 2),
			constrain(hue$2)
		];
	},
	toBase(LCH) {
		let [Lightness, Chroma, Hue] = LCH;
		if (Chroma < 0) Chroma = 0;
		if (isNaN(Hue)) Hue = 0;
		return [
			Lightness,
			Chroma * Math.cos(Hue * Math.PI / 180),
			Chroma * Math.sin(Hue * Math.PI / 180)
		];
	},
	formats: { color: {
		id: "--lchuv",
		coords: [
			"<number> | <percentage>",
			"<number> | <percentage>",
			"<number> | <angle>"
		]
	} }
});
var ε$1 = 216 / 24389;
var κ = 24389 / 27;
var m_r0 = fromXYZ_M$3[0][0];
var m_r1 = fromXYZ_M$3[0][1];
var m_r2 = fromXYZ_M$3[0][2];
var m_g0 = fromXYZ_M$3[1][0];
var m_g1 = fromXYZ_M$3[1][1];
var m_g2 = fromXYZ_M$3[1][2];
var m_b0 = fromXYZ_M$3[2][0];
var m_b1 = fromXYZ_M$3[2][1];
var m_b2 = fromXYZ_M$3[2][2];
function distanceFromOriginAngle(slope, intercept, angle) {
	const d$1 = intercept / (Math.sin(angle) - slope * Math.cos(angle));
	return d$1 < 0 ? Infinity : d$1;
}
function calculateBoundingLines(l) {
	const sub1 = Math.pow(l + 16, 3) / 1560896;
	const sub2 = sub1 > ε$1 ? sub1 : l / κ;
	const s1r = sub2 * (284517 * m_r0 - 94839 * m_r2);
	const s2r = sub2 * (838422 * m_r2 + 769860 * m_r1 + 731718 * m_r0);
	const s3r = sub2 * (632260 * m_r2 - 126452 * m_r1);
	const s1g = sub2 * (284517 * m_g0 - 94839 * m_g2);
	const s2g = sub2 * (838422 * m_g2 + 769860 * m_g1 + 731718 * m_g0);
	const s3g = sub2 * (632260 * m_g2 - 126452 * m_g1);
	const s1b = sub2 * (284517 * m_b0 - 94839 * m_b2);
	const s2b = sub2 * (838422 * m_b2 + 769860 * m_b1 + 731718 * m_b0);
	const s3b = sub2 * (632260 * m_b2 - 126452 * m_b1);
	return {
		r0s: s1r / s3r,
		r0i: s2r * l / s3r,
		r1s: s1r / (s3r + 126452),
		r1i: (s2r - 769860) * l / (s3r + 126452),
		g0s: s1g / s3g,
		g0i: s2g * l / s3g,
		g1s: s1g / (s3g + 126452),
		g1i: (s2g - 769860) * l / (s3g + 126452),
		b0s: s1b / s3b,
		b0i: s2b * l / s3b,
		b1s: s1b / (s3b + 126452),
		b1i: (s2b - 769860) * l / (s3b + 126452)
	};
}
function calcMaxChromaHsluv(lines, h) {
	const hueRad = h / 360 * Math.PI * 2;
	const r0 = distanceFromOriginAngle(lines.r0s, lines.r0i, hueRad);
	const r1 = distanceFromOriginAngle(lines.r1s, lines.r1i, hueRad);
	const g0$1 = distanceFromOriginAngle(lines.g0s, lines.g0i, hueRad);
	const g1$1 = distanceFromOriginAngle(lines.g1s, lines.g1i, hueRad);
	const b0 = distanceFromOriginAngle(lines.b0s, lines.b0i, hueRad);
	const b1 = distanceFromOriginAngle(lines.b1s, lines.b1i, hueRad);
	return Math.min(r0, r1, g0$1, g1$1, b0, b1);
}
var hsluv = new ColorSpace({
	id: "hsluv",
	name: "HSLuv",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		s: {
			range: [0, 100],
			name: "Saturation"
		},
		l: {
			range: [0, 100],
			name: "Lightness"
		}
	},
	base: LCHuv,
	gamutSpace: sRGB,
	fromBase(lch$1) {
		let [l, c$1, h] = [
			skipNone(lch$1[0]),
			skipNone(lch$1[1]),
			skipNone(lch$1[2])
		];
		let s;
		if (l > 99.9999999) {
			s = 0;
			l = 100;
		} else if (l < 1e-8) {
			s = 0;
			l = 0;
		} else s = c$1 / calcMaxChromaHsluv(calculateBoundingLines(l), h) * 100;
		return [
			h,
			s,
			l
		];
	},
	toBase(hsl) {
		let [h, s, l] = [
			skipNone(hsl[0]),
			skipNone(hsl[1]),
			skipNone(hsl[2])
		];
		let c$1;
		if (l > 99.9999999) {
			l = 100;
			c$1 = 0;
		} else if (l < 1e-8) {
			l = 0;
			c$1 = 0;
		} else c$1 = calcMaxChromaHsluv(calculateBoundingLines(l), h) / 100 * s;
		return [
			l,
			c$1,
			h
		];
	},
	formats: { color: {
		id: "--hsluv",
		coords: [
			"<number> | <angle>",
			"<percentage> | <number>",
			"<percentage> | <number>"
		]
	} }
});
fromXYZ_M$3[0][0];
fromXYZ_M$3[0][1];
fromXYZ_M$3[0][2];
fromXYZ_M$3[1][0];
fromXYZ_M$3[1][1];
fromXYZ_M$3[1][2];
fromXYZ_M$3[2][0];
fromXYZ_M$3[2][1];
fromXYZ_M$3[2][2];
function distanceFromOrigin(slope, intercept) {
	return Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
}
function calcMaxChromaHpluv(lines) {
	let r0 = distanceFromOrigin(lines.r0s, lines.r0i);
	let r1 = distanceFromOrigin(lines.r1s, lines.r1i);
	let g0$1 = distanceFromOrigin(lines.g0s, lines.g0i);
	let g1$1 = distanceFromOrigin(lines.g1s, lines.g1i);
	let b0 = distanceFromOrigin(lines.b0s, lines.b0i);
	let b1 = distanceFromOrigin(lines.b1s, lines.b1i);
	return Math.min(r0, r1, g0$1, g1$1, b0, b1);
}
var hpluv = new ColorSpace({
	id: "hpluv",
	name: "HPLuv",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		s: {
			range: [0, 100],
			name: "Saturation"
		},
		l: {
			range: [0, 100],
			name: "Lightness"
		}
	},
	base: LCHuv,
	gamutSpace: "self",
	fromBase(lch$1) {
		let [l, c$1, h] = [
			skipNone(lch$1[0]),
			skipNone(lch$1[1]),
			skipNone(lch$1[2])
		];
		let s;
		if (l > 99.9999999) {
			s = 0;
			l = 100;
		} else if (l < 1e-8) {
			s = 0;
			l = 0;
		} else s = c$1 / calcMaxChromaHpluv(calculateBoundingLines(l)) * 100;
		return [
			h,
			s,
			l
		];
	},
	toBase(hsl) {
		let [h, s, l] = [
			skipNone(hsl[0]),
			skipNone(hsl[1]),
			skipNone(hsl[2])
		];
		let c$1;
		if (l > 99.9999999) {
			l = 100;
			c$1 = 0;
		} else if (l < 1e-8) {
			l = 0;
			c$1 = 0;
		} else c$1 = calcMaxChromaHpluv(calculateBoundingLines(l)) / 100 * s;
		return [
			l,
			c$1,
			h
		];
	},
	formats: { color: {
		id: "--hpluv",
		coords: [
			"<number> | <angle>",
			"<percentage> | <number>",
			"<percentage> | <number>"
		]
	} }
});
var Yw = 203;
var n = 2610 / 2 ** 14;
var ninv = 2 ** 14 / 2610;
var m = 2523 / 2 ** 5;
var minv = 2 ** 5 / 2523;
var c1 = 3424 / 2 ** 12;
var c2 = 2413 / 2 ** 7;
var c3 = 2392 / 2 ** 7;
var rec2100Pq = new RGBColorSpace({
	id: "rec2100pq",
	cssId: "rec2100-pq",
	name: "REC.2100-PQ",
	base: REC2020Linear,
	toBase(RGB) {
		return RGB.map(function(val) {
			return (Math.max(val ** minv - c1, 0) / (c2 - c3 * val ** minv)) ** ninv * 1e4 / Yw;
		});
	},
	fromBase(RGB) {
		return RGB.map(function(val) {
			let x = Math.max(val * Yw / 1e4, 0);
			return ((c1 + c2 * x ** n) / (1 + c3 * x ** n)) ** m;
		});
	}
});
var a = .17883277;
var b = .28466892;
var c = .55991073;
var scale = 3.7743;
var rec2100Hlg = new RGBColorSpace({
	id: "rec2100hlg",
	cssId: "rec2100-hlg",
	name: "REC.2100-HLG",
	referred: "scene",
	base: REC2020Linear,
	toBase(RGB) {
		return RGB.map(function(val) {
			if (val <= .5) return val ** 2 / 3 * scale;
			return (Math.exp((val - c) / a) + b) / 12 * scale;
		});
	},
	fromBase(RGB) {
		return RGB.map(function(val) {
			val /= scale;
			if (val <= 1 / 12) return Math.sqrt(3 * val);
			return a * Math.log(12 * val - b) + c;
		});
	}
});
var CATs = {};
hooks.add("chromatic-adaptation-start", (env) => {
	if (env.options.method) env.M = adapt(env.W1, env.W2, env.options.method);
});
hooks.add("chromatic-adaptation-end", (env) => {
	if (!env.M) env.M = adapt(env.W1, env.W2, env.options.method);
});
function defineCAT({ id, toCone_M, fromCone_M }) {
	CATs[id] = arguments[0];
}
function adapt(W1, W2, id = "Bradford") {
	let method = CATs[id];
	let [ρs, γs, βs] = multiplyMatrices(method.toCone_M, W1);
	let [ρd, γd, βd] = multiplyMatrices(method.toCone_M, W2);
	let scaled_cone_M = multiplyMatrices([
		[
			ρd / ρs,
			0,
			0
		],
		[
			0,
			γd / γs,
			0
		],
		[
			0,
			0,
			βd / βs
		]
	], method.toCone_M);
	return multiplyMatrices(method.fromCone_M, scaled_cone_M);
}
defineCAT({
	id: "von Kries",
	toCone_M: [
		[
			.40024,
			.7076,
			-.08081
		],
		[
			-.2263,
			1.16532,
			.0457
		],
		[
			0,
			0,
			.91822
		]
	],
	fromCone_M: [
		[
			1.8599363874558397,
			-1.1293816185800916,
			.21989740959619328
		],
		[
			.3611914362417676,
			.6388124632850422,
			-6370596838649899e-21
		],
		[
			0,
			0,
			1.0890636230968613
		]
	]
});
defineCAT({
	id: "Bradford",
	toCone_M: [
		[
			.8951,
			.2664,
			-.1614
		],
		[
			-.7502,
			1.7135,
			.0367
		],
		[
			.0389,
			-.0685,
			1.0296
		]
	],
	fromCone_M: [
		[
			.9869929054667121,
			-.14705425642099013,
			.15996265166373122
		],
		[
			.4323052697233945,
			.5183602715367774,
			.049291228212855594
		],
		[
			-.00852866457517732,
			.04004282165408486,
			.96848669578755
		]
	]
});
defineCAT({
	id: "CAT02",
	toCone_M: [
		[
			.7328,
			.4296,
			-.1624
		],
		[
			-.7036,
			1.6975,
			.0061
		],
		[
			.003,
			.0136,
			.9834
		]
	],
	fromCone_M: [
		[
			1.0961238208355142,
			-.27886900021828726,
			.18274517938277307
		],
		[
			.4543690419753592,
			.4735331543074117,
			.07209780371722911
		],
		[
			-.009627608738429355,
			-.00569803121611342,
			1.0153256399545427
		]
	]
});
defineCAT({
	id: "CAT16",
	toCone_M: [
		[
			.401288,
			.650173,
			-.051461
		],
		[
			-.250268,
			1.204414,
			.045854
		],
		[
			-.002079,
			.048952,
			.953127
		]
	],
	fromCone_M: [
		[
			1.862067855087233,
			-1.0112546305316845,
			.14918677544445172
		],
		[
			.3875265432361372,
			.6214474419314753,
			-.008973985167612521
		],
		[
			-.01584149884933386,
			-.03412293802851557,
			1.0499644368778496
		]
	]
});
Object.assign(WHITES, {
	A: [
		1.0985,
		1,
		.35585
	],
	C: [
		.98074,
		1,
		1.18232
	],
	D55: [
		.95682,
		1,
		.92149
	],
	D75: [
		.94972,
		1,
		1.22638
	],
	E: [
		1,
		1,
		1
	],
	F2: [
		.99186,
		1,
		.67393
	],
	F7: [
		.95041,
		1,
		1.08747
	],
	F11: [
		1.00962,
		1,
		.6435
	]
});
WHITES.ACES = [
	.32168 / .33767,
	1,
	.34065 / .33767
];
var ACEScg = new RGBColorSpace({
	id: "acescg",
	cssId: "--acescg",
	name: "ACEScg",
	coords: {
		r: {
			range: [0, 65504],
			name: "Red"
		},
		g: {
			range: [0, 65504],
			name: "Green"
		},
		b: {
			range: [0, 65504],
			name: "Blue"
		}
	},
	referred: "scene",
	white: WHITES.ACES,
	toXYZ_M: [
		[
			.6624541811085053,
			.13400420645643313,
			.1561876870049078
		],
		[
			.27222871678091454,
			.6740817658111484,
			.05368951740793705
		],
		[
			-.005574649490394108,
			.004060733528982826,
			1.0103391003129971
		]
	],
	fromXYZ_M: [
		[
			1.6410233796943257,
			-.32480329418479,
			-.23642469523761225
		],
		[
			-.6636628587229829,
			1.6153315916573379,
			.016756347685530137
		],
		[
			.011721894328375376,
			-.008284441996237409,
			.9883948585390215
		]
	]
});
var ε = 2 ** -16;
var ACES_min_nonzero = -.35828683;
var ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52;
var acescc = new RGBColorSpace({
	id: "acescc",
	cssId: "--acescc",
	name: "ACEScc",
	coords: {
		r: {
			range: [ACES_min_nonzero, ACES_cc_max],
			name: "Red"
		},
		g: {
			range: [ACES_min_nonzero, ACES_cc_max],
			name: "Green"
		},
		b: {
			range: [ACES_min_nonzero, ACES_cc_max],
			name: "Blue"
		}
	},
	referred: "scene",
	base: ACEScg,
	toBase(RGB) {
		const low = -5.279999999999999 / 17.52;
		return RGB.map(function(val) {
			if (val <= low) return (2 ** (val * 17.52 - 9.72) - ε) * 2;
			else if (val < ACES_cc_max) return 2 ** (val * 17.52 - 9.72);
			else return 65504;
		});
	},
	fromBase(RGB) {
		return RGB.map(function(val) {
			if (val <= 0) return (Math.log2(ε) + 9.72) / 17.52;
			else if (val < ε) return (Math.log2(ε + val * .5) + 9.72) / 17.52;
			else return (Math.log2(val) + 9.72) / 17.52;
		});
	}
});
var spaces = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	A98RGB: a98rgb,
	A98RGB_Linear: A98Linear,
	ACEScc: acescc,
	ACEScg,
	CAM16_JMh: cam16,
	HCT: hct,
	HPLuv: hpluv,
	HSL,
	HSLuv: hsluv,
	HSV,
	HWB: hwb,
	ICTCP: ictcp,
	JzCzHz: jzczhz,
	Jzazbz,
	LCH: lch,
	LCHuv,
	Lab: lab,
	Lab_D65: lab_d65,
	Luv,
	OKLCH: oklch,
	OKLab,
	P3,
	P3_Linear: P3Linear,
	ProPhoto: prophoto,
	ProPhoto_Linear: ProPhotoLinear,
	REC_2020: REC2020,
	REC_2020_Linear: REC2020Linear,
	REC_2100_HLG: rec2100Hlg,
	REC_2100_PQ: rec2100Pq,
	XYZ_ABS_D65: XYZ_Abs_D65,
	XYZ_D50,
	XYZ_D65: xyz_d65,
	sRGB,
	sRGB_Linear: sRGBLinear
});
var Color = class Color$2 {
	constructor(...args) {
		let color$2;
		if (args.length === 1) color$2 = getColor(args[0]);
		let space, coords, alpha;
		if (color$2) {
			space = color$2.space || color$2.spaceId;
			coords = color$2.coords;
			alpha = color$2.alpha;
		} else [space, coords, alpha] = args;
		Object.defineProperty(this, "space", {
			value: ColorSpace.get(space),
			writable: false,
			enumerable: true,
			configurable: true
		});
		this.coords = coords ? coords.slice() : [
			0,
			0,
			0
		];
		this.alpha = alpha > 1 || alpha === void 0 ? 1 : alpha < 0 ? 0 : alpha;
		for (let i = 0; i < this.coords.length; i++) if (this.coords[i] === "NaN") this.coords[i] = NaN;
		for (let id in this.space.coords) Object.defineProperty(this, id, {
			get: () => this.get(id),
			set: (value) => this.set(id, value)
		});
	}
	get spaceId() {
		return this.space.id;
	}
	clone() {
		return new Color$2(this.space, this.coords, this.alpha);
	}
	toJSON() {
		return {
			spaceId: this.spaceId,
			coords: this.coords,
			alpha: this.alpha
		};
	}
	display(...args) {
		let ret = display(this, ...args);
		ret.color = new Color$2(ret.color);
		return ret;
	}
	static get(color$2, ...args) {
		if (color$2 instanceof Color$2) return color$2;
		return new Color$2(color$2, ...args);
	}
	static defineFunction(name, code$2, o = code$2) {
		let { instance: instance$2 = true, returns } = o;
		let func = function(...args) {
			let ret = code$2(...args);
			if (returns === "color") ret = Color$2.get(ret);
			else if (returns === "function<color>") {
				let f = ret;
				ret = function(...args$1) {
					let ret$1 = f(...args$1);
					return Color$2.get(ret$1);
				};
				Object.assign(ret, f);
			} else if (returns === "array<color>") ret = ret.map((c$1) => Color$2.get(c$1));
			return ret;
		};
		if (!(name in Color$2)) Color$2[name] = func;
		if (instance$2) Color$2.prototype[name] = function(...args) {
			return func(this, ...args);
		};
	}
	static defineFunctions(o) {
		for (let name in o) Color$2.defineFunction(name, o[name], o[name]);
	}
	static extend(exports) {
		if (exports.register) exports.register(Color$2);
		else for (let name in exports) Color$2.defineFunction(name, exports[name]);
	}
};
Color.defineFunctions({
	get,
	getAll,
	set,
	setAll,
	to,
	equals,
	inGamut,
	toGamut,
	distance: distance$1,
	toString: serialize
});
Object.assign(Color, {
	util,
	hooks,
	WHITES,
	Space: ColorSpace,
	spaces: ColorSpace.registry,
	parse,
	defaults
});
for (let key of Object.keys(spaces)) ColorSpace.register(spaces[key]);
for (let id in ColorSpace.registry) addSpaceAccessors(id, ColorSpace.registry[id]);
hooks.add("colorspace-init-end", (space) => {
	addSpaceAccessors(space.id, space);
	space.aliases?.forEach((alias) => {
		addSpaceAccessors(alias, space);
	});
});
function addSpaceAccessors(id, space) {
	let propId = id.replace(/-/g, "_");
	Object.defineProperty(Color.prototype, propId, {
		get() {
			let ret = this.getAll(id);
			if (typeof Proxy === "undefined") return ret;
			return new Proxy(ret, {
				has: (obj, property$2) => {
					try {
						ColorSpace.resolveCoord([space, property$2]);
						return true;
					} catch (e) {}
					return Reflect.has(obj, property$2);
				},
				get: (obj, property$2, receiver) => {
					if (property$2 && typeof property$2 !== "symbol" && !(property$2 in obj)) {
						let { index } = ColorSpace.resolveCoord([space, property$2]);
						if (index >= 0) return obj[index];
					}
					return Reflect.get(obj, property$2, receiver);
				},
				set: (obj, property$2, value, receiver) => {
					if (property$2 && typeof property$2 !== "symbol" && !(property$2 in obj) || property$2 >= 0) {
						let { index } = ColorSpace.resolveCoord([space, property$2]);
						if (index >= 0) {
							obj[index] = value;
							this.setAll(id, obj);
							return true;
						}
					}
					return Reflect.set(obj, property$2, value, receiver);
				}
			});
		},
		set(coords) {
			this.setAll(id, coords);
		},
		configurable: true,
		enumerable: true
	});
}
Color.extend(deltaEMethods);
Color.extend({ deltaE });
Object.assign(Color, { deltaEMethods });
Color.extend(variations);
Color.extend({ contrast });
Color.extend(chromaticity);
Color.extend(luminance);
Color.extend(interpolation);
Color.extend(contrastMethods);
var reusableVector4 = null;
var reusableVector2 = null;
var getReusableVector4 = () => {
	if (!reusableVector4) reusableVector4 = new Vector4();
	return reusableVector4;
};
var getReusableVector2 = () => {
	if (!reusableVector2) reusableVector2 = new Vector2();
	return reusableVector2;
};
var transformColor = (value) => {
	const threeColor = new Color(value);
	const coords = threeColor.to("p3-linear").coords;
	const r = coords[0], g$1 = coords[1], b$2 = coords[2], a$1 = threeColor.alpha;
	return {
		node: vec4(r, g$1, b$2, a$1),
		data: new Vector4(r, g$1, b$2, a$1)
	};
};
var transformColorUpdate = (value) => {
	const threeColor = new Color(value);
	const coords = threeColor.to("p3-linear").coords;
	return getReusableVector4().set(coords[0], coords[1], coords[2], threeColor.alpha);
};
var transformPosition = (value) => {
	let x = .5;
	let y = .5;
	const parsePositionValue = (val, isVertical = false) => {
		if (typeof val === "number") return val;
		const str = val.toLowerCase().trim();
		if (isVertical) {
			if (str === "top") return 0;
			if (str === "bottom") return 1;
			if (str === "center") return .5;
		} else {
			if (str === "left") return 0;
			if (str === "right") return 1;
			if (str === "center") return .5;
		}
		console.warn(`Invalid position value: ${val}. Defaulting to center.`);
		return .5;
	};
	if (typeof value === "string") {
		const parts = value.toLowerCase().trim().split(/\s+/);
		if (parts.includes("left")) x = 0;
		else if (parts.includes("right")) x = 1;
		else if (parts.includes("center") || parts.length === 1 && (parts[0] === "top" || parts[0] === "bottom")) x = .5;
		if (parts.includes("top")) y = 0;
		else if (parts.includes("bottom")) y = 1;
		else if (parts.includes("center") || parts.length === 1 && (parts[0] === "left" || parts[0] === "right")) y = .5;
		if (parts.length === 1 && parts[0] === "center") {
			x = .5;
			y = .5;
		}
	} else if (typeof value === "object" && value !== null) {
		x = parsePositionValue(value.x, false);
		y = parsePositionValue(value.y, true);
	} else console.warn(`Invalid position value provided: ${value}. Defaulting to center.`);
	const finalY = 1 - y;
	return {
		node: vec2(x, finalY),
		data: new Vector2(x, finalY)
	};
};
var transformPositionUpdate = (value) => {
	let x = .5;
	let y = .5;
	const parsePositionValue = (val, isVertical = false) => {
		if (typeof val === "number") return val;
		const str = val.toLowerCase().trim();
		if (isVertical) {
			if (str === "top") return 0;
			if (str === "bottom") return 1;
			if (str === "center") return .5;
		} else {
			if (str === "left") return 0;
			if (str === "right") return 1;
			if (str === "center") return .5;
		}
		return .5;
	};
	if (typeof value === "string") {
		const parts = value.toLowerCase().trim().split(/\s+/);
		if (parts.includes("left")) x = 0;
		else if (parts.includes("right")) x = 1;
		else if (parts.includes("center") || parts.length === 1 && (parts[0] === "top" || parts[0] === "bottom")) x = .5;
		if (parts.includes("top")) y = 0;
		else if (parts.includes("bottom")) y = 1;
		else if (parts.includes("center") || parts.length === 1 && (parts[0] === "left" || parts[0] === "right")) y = .5;
		if (parts.length === 1 && parts[0] === "center") {
			x = .5;
			y = .5;
		}
	} else if (typeof value === "object" && value !== null) {
		x = parsePositionValue(value.x, false);
		y = parsePositionValue(value.y, true);
	}
	return getReusableVector2().set(x, 1 - y);
};
var transformAngle = (value) => {
	if (typeof value === "number") return (value % 360 + 360) % 360;
	const str = value.toLowerCase().trim();
	switch (str) {
		case "to right": return 0;
		case "to bottom": return 90;
		case "to left": return 180;
		case "to top": return 270;
		case "to bottom right":
		case "to right bottom": return 45;
		case "to bottom left":
		case "to left bottom": return 135;
		case "to top left":
		case "to left top": return 225;
		case "to top right":
		case "to right top": return 315;
		case "from left": return 0;
		case "from top": return 90;
		case "from right": return 180;
		case "from bottom": return 270;
		case "from top left": return 45;
		case "from top right": return 135;
		case "from bottom right": return 225;
		case "from bottom left": return 315;
		default:
			const numMatch = str.match(/^(-?\d*\.?\d+)(deg|rad|turn)?$/);
			if (numMatch) {
				const [, valueStr, unit = "deg"] = numMatch;
				const numValue = parseFloat(valueStr);
				switch (unit) {
					case "deg": return (numValue % 360 + 360) % 360;
					case "rad": return (numValue * 180 / Math.PI % 360 + 360) % 360;
					case "turn": return (numValue * 360 % 360 + 360) % 360;
					default: return (numValue % 360 + 360) % 360;
				}
			}
			console.warn(`Invalid angle value: ${value}. Defaulting to 0 degrees.`);
			return 0;
	}
};
var transformEdges = (value) => {
	const mode = {
		"stretch": 0,
		"transparent": 1,
		"mirror": 2,
		"wrap": 3
	}[value.toLowerCase()];
	if (mode === void 0) {
		console.warn(`Invalid edge mode: ${value}. Defaulting to 'stretch'.`);
		return 0;
	}
	return mode;
};
var colorSpaceOptions = [
	{
		label: "Linear RGB",
		value: "linear"
	},
	{
		label: "OKLCh",
		value: "oklch"
	},
	{
		label: "OKLAB",
		value: "oklab"
	}
];
var transformColorSpace = (value) => {
	const mode = {
		"linear": 0,
		"oklch": 1,
		"oklab": 2
	}[value.toLowerCase()];
	if (mode === void 0) {
		console.warn(`Invalid color space mode: ${value}. Defaulting to 'linear'.`);
		return 0;
	}
	return mode;
};

//#endregion
//#region node_modules/shaders/dist/core/time-BZqyVJXt.js
var accumulatedTimeCache = /* @__PURE__ */ new WeakMap();
var createAnimatedTime = (params, speedUniform, seedUniform) => {
	let accumulatedTime = accumulatedTimeCache.get(speedUniform);
	if (!accumulatedTime) {
		accumulatedTime = uniform(0);
		accumulatedTimeCache.set(speedUniform, accumulatedTime);
	}
	params.onBeforeRender(({ deltaTime: deltaTime$2 }) => {
		accumulatedTime.value += deltaTime$2 * speedUniform.uniform.value;
	});
	if (seedUniform) return accumulatedTime.add(seedUniform.uniform);
	return accumulatedTime;
};

//#endregion
//#region node_modules/shaders/dist/core/index.js
function normal_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(overlay$2.rgb, overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
var p3ToSRGB$1 = (p3) => {
	return vec3(p3.x.mul(1.2249401).sub(p3.y.mul(.2249404)).sub(p3.z.mul(0)), p3.x.mul(-.0420569).add(p3.y.mul(1.0420571)).add(p3.z.mul(0)), p3.x.mul(-.0196376).sub(p3.y.mul(.0786361)).add(p3.z.mul(1.0982735)));
};
var sRGBToP3$1 = (srgb) => {
	return vec3(srgb.x.mul(.8224621).add(srgb.y.mul(.177538)).add(srgb.z.mul(0)), srgb.x.mul(.0331941).add(srgb.y.mul(.9668058)).add(srgb.z.mul(0)), srgb.x.mul(.0170826).add(srgb.y.mul(.0723974)).add(srgb.z.mul(.9105199)));
};
var rgbToOklab$1 = (rgb) => {
	const r = rgb.x;
	const g$1 = rgb.y;
	const b$2 = rgb.z;
	const l = r.mul(.4122214708).add(g$1.mul(.5363325363)).add(b$2.mul(.0514459929));
	const m$1 = r.mul(.2119034982).add(g$1.mul(.6806995451).add(b$2.mul(.1073969566)));
	const s = r.mul(.0883024619).add(g$1.mul(.2817188376)).add(b$2.mul(.6299787005));
	const l_ = pow(l, float(1 / 3));
	const m_ = pow(m$1, float(1 / 3));
	const s_ = pow(s, float(1 / 3));
	return vec3(l_.mul(.2104542553).add(m_.mul(.793617785)).sub(s_.mul(.0040720468)), l_.mul(1.9779984951).sub(m_.mul(2.428592205)).add(s_.mul(.4505937099)), l_.mul(.0259040371).add(m_.mul(.7827717662)).sub(s_.mul(.808675766)));
};
var oklabToRgb$1 = (lab$1) => {
	const L = lab$1.x;
	const a$1 = lab$1.y;
	const b$2 = lab$1.z;
	const l_ = L.add(a$1.mul(.3963377774)).add(b$2.mul(.2158037573));
	const m_ = L.sub(a$1.mul(.1055613458)).sub(b$2.mul(.0638541728));
	const s_ = L.sub(a$1.mul(.0894841775)).sub(b$2.mul(1.291485548));
	const l = pow(l_, float(3));
	const m$1 = pow(m_, float(3));
	const s = pow(s_, float(3));
	return vec3(l.mul(4.0767416621).sub(m$1.mul(3.3077115913)).add(s.mul(.2309699292)), l.mul(-1.2684380046).add(m$1.mul(2.6097574011)).sub(s.mul(.3413193965)), l.mul(-.0041960863).sub(m$1.mul(.7034186147)).add(s.mul(1.707614701)));
};
var oklabToOklch$1 = (lab$1) => {
	const L = lab$1.x;
	const a$1 = lab$1.y;
	const b$2 = lab$1.z;
	return vec3(L, sqrt(a$1.mul(a$1).add(b$2.mul(b$2))), atan(b$2, a$1));
};
var oklchToOklab$1 = (lch$1) => {
	const L = lch$1.x;
	const C = lch$1.y;
	const h = lch$1.z;
	return vec3(L, C.mul(cos(h)), C.mul(sin(h)));
};
function normal_oklch_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const baseSRGB = p3ToSRGB$1(vec3(base.r, base.g, base.b));
	const overlaySRGB = p3ToSRGB$1(vec3(overlay$2.r, overlay$2.g, overlay$2.b));
	const baseOklab = rgbToOklab$1(baseSRGB);
	const overlayOklab = rgbToOklab$1(overlaySRGB);
	const baseOklch = oklabToOklch$1(baseOklab);
	return vec4(sRGBToP3$1(oklabToRgb$1(oklchToOklab$1(add(mul(oklabToOklch$1(overlayOklab), overlayAlpha), mul(baseOklch, mul(base.a, sub(1, overlayAlpha))))))), finalAlpha);
}
var p3ToSRGB$2 = (p3) => {
	return vec3(p3.x.mul(1.2249401).sub(p3.y.mul(.2249404)).sub(p3.z.mul(0)), p3.x.mul(-.0420569).add(p3.y.mul(1.0420571)).add(p3.z.mul(0)), p3.x.mul(-.0196376).sub(p3.y.mul(.0786361)).add(p3.z.mul(1.0982735)));
};
var sRGBToP3$2 = (srgb) => {
	return vec3(srgb.x.mul(.8224621).add(srgb.y.mul(.177538)).add(srgb.z.mul(0)), srgb.x.mul(.0331941).add(srgb.y.mul(.9668058)).add(srgb.z.mul(0)), srgb.x.mul(.0170826).add(srgb.y.mul(.0723974)).add(srgb.z.mul(.9105199)));
};
var rgbToOklab$2 = (rgb) => {
	const r = rgb.x;
	const g$1 = rgb.y;
	const b$2 = rgb.z;
	const l = r.mul(.4122214708).add(g$1.mul(.5363325363)).add(b$2.mul(.0514459929));
	const m$1 = r.mul(.2119034982).add(g$1.mul(.6806995451).add(b$2.mul(.1073969566)));
	const s = r.mul(.0883024619).add(g$1.mul(.2817188376)).add(b$2.mul(.6299787005));
	const l_ = pow(l, float(1 / 3));
	const m_ = pow(m$1, float(1 / 3));
	const s_ = pow(s, float(1 / 3));
	return vec3(l_.mul(.2104542553).add(m_.mul(.793617785)).sub(s_.mul(.0040720468)), l_.mul(1.9779984951).sub(m_.mul(2.428592205)).add(s_.mul(.4505937099)), l_.mul(.0259040371).add(m_.mul(.7827717662)).sub(s_.mul(.808675766)));
};
var oklabToRgb$2 = (lab$1) => {
	const L = lab$1.x;
	const a$1 = lab$1.y;
	const b$2 = lab$1.z;
	const l_ = L.add(a$1.mul(.3963377774)).add(b$2.mul(.2158037573));
	const m_ = L.sub(a$1.mul(.1055613458)).sub(b$2.mul(.0638541728));
	const s_ = L.sub(a$1.mul(.0894841775)).sub(b$2.mul(1.291485548));
	const l = pow(l_, float(3));
	const m$1 = pow(m_, float(3));
	const s = pow(s_, float(3));
	return vec3(l.mul(4.0767416621).sub(m$1.mul(3.3077115913)).add(s.mul(.2309699292)), l.mul(-1.2684380046).add(m$1.mul(2.6097574011)).sub(s.mul(.3413193965)), l.mul(-.0041960863).sub(m$1.mul(.7034186147)).add(s.mul(1.707614701)));
};
function normal_oklab_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const baseSRGB = p3ToSRGB$2(vec3(base.r, base.g, base.b));
	const overlaySRGB = p3ToSRGB$2(vec3(overlay$2.r, overlay$2.g, overlay$2.b));
	const baseOklab = rgbToOklab$2(baseSRGB);
	return vec4(sRGBToP3$2(oklabToRgb$2(add(mul(rgbToOklab$2(overlaySRGB), overlayAlpha), mul(baseOklab, mul(base.a, sub(1, overlayAlpha)))))), finalAlpha);
}
function multiply_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(mul(base.rgb, overlay$2.rgb), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function screen_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(sub(1, mul(sub(1, base.rgb), sub(1, overlay$2.rgb))), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function linearDodge_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(min(add(base.rgb, overlay$2.rgb), 1), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function overlay_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(mix(mul(2, mul(base.rgb, overlay$2.rgb)), sub(1, mul(2, mul(sub(1, base.rgb), sub(1, overlay$2.rgb)))), step(.5, base.rgb)), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function difference_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(abs(sub(base.rgb, overlay$2.rgb)), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function colorDodge_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(mix(base.rgb, min(div(base.rgb, sub(1, overlay$2.rgb)), 1), step(.001, sub(1, overlay$2.rgb))), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function exclusion_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(sub(add(base.rgb, overlay$2.rgb), mul(2, mul(base.rgb, overlay$2.rgb))), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function getLuminance(rgb) {
	return add(add(mul(rgb.r, .2126), mul(rgb.g, .7152)), mul(rgb.b, .0722));
}
function color_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const lumDiff = sub(getLuminance(base.rgb), getLuminance(overlay$2.rgb));
	return vec4(add(mul(add(overlay$2.rgb, lumDiff), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function luminosity_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const baseLum = getLuminance(base.rgb);
	const lumRatio = getLuminance(overlay$2.rgb).div(add(baseLum, 1e-4));
	return vec4(add(mul(mul(base.rgb, lumRatio), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function darken_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(min(base.rgb, overlay$2.rgb), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function lighten_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(max(base.rgb, overlay$2.rgb), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function colorBurn_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(mix(vec4(0, 0, 0, 1).rgb, max(sub(1, sub(1, base.rgb).div(add(overlay$2.rgb, 1e-4))), 0), step(1e-4, overlay$2.rgb)), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function linearBurn_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(max(add(add(base.rgb, overlay$2.rgb), -1), 0), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function softLight_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const softLightDark = add(mul(2, mul(base.rgb, overlay$2.rgb)), mul(mul(base.rgb, base.rgb), sub(1, mul(2, overlay$2.rgb))));
	const baseSqrt = sqrt(base.rgb);
	return vec4(add(mul(mix(softLightDark, add(mul(2, mul(base.rgb, sub(1, overlay$2.rgb))), mul(baseSqrt, sub(mul(2, overlay$2.rgb), 1))), step(.5, overlay$2.rgb)), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function hardLight_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(mix(mul(2, mul(base.rgb, overlay$2.rgb)), sub(1, mul(2, mul(sub(1, base.rgb), sub(1, overlay$2.rgb)))), step(.5, overlay$2.rgb)), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function hue_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const baseLum = getLuminance(base.rgb);
	const overlayLum = getLuminance(overlay$2.rgb);
	const baseChromaticity = base.rgb.sub(baseLum);
	const overlayChromaticity = overlay$2.rgb.sub(overlayLum);
	const baseChromaLength = baseChromaticity.length();
	return vec4(add(mul(add(mul(overlayChromaticity.normalize(), baseChromaLength), baseLum), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function saturation_default(base, overlay$2, opacity = 1) {
	const overlayAlpha = mul(overlay$2.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const baseLum = getLuminance(base.rgb);
	const overlayLum = getLuminance(overlay$2.rgb);
	const baseChromaticity = base.rgb.sub(baseLum);
	const overlayChromaticity = overlay$2.rgb.sub(overlayLum);
	return vec4(add(mul(add(mul(baseChromaticity.normalize(), overlayChromaticity.length()), baseLum), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
var blendModes = {
	normal: normal_default,
	"normal-oklch": normal_oklch_default,
	"normal-oklab": normal_oklab_default,
	multiply: multiply_default,
	screen: screen_default,
	linearDodge: linearDodge_default,
	overlay: overlay_default,
	difference: difference_default,
	colorDodge: colorDodge_default,
	exclusion: exclusion_default,
	color: color_default,
	luminosity: luminosity_default,
	darken: darken_default,
	lighten: lighten_default,
	colorBurn: colorBurn_default,
	linearBurn: linearBurn_default,
	softLight: softLight_default,
	hardLight: hardLight_default,
	hue: hue_default,
	saturation: saturation_default
};
function applyBlendMode(baseNode, overlayNode, blendMode = "normal", opacity = 1) {
	return (blendModes[blendMode] || blendModes.normal)(baseNode, overlayNode, opacity);
}
function alpha_default(target, mask) {
	const maskedAlpha = mul(target.a, mask.a);
	return vec4(target.rgb, maskedAlpha);
}
function alphaInverted_default(target, mask) {
	const invertedMaskAlpha = sub(1, mask.a);
	const maskedAlpha = mul(target.a, invertedMaskAlpha);
	return vec4(target.rgb, maskedAlpha);
}
function luminance_default(target, mask) {
	const luminanceWeights = vec3(.2126, .7152, .0722);
	const luminance$3 = dot(mask.rgb, luminanceWeights);
	const maskedAlpha = mul(target.a, luminance$3);
	return vec4(target.rgb, maskedAlpha);
}
function luminanceInverted_default(target, mask) {
	const luminanceWeights = vec3(.2126, .7152, .0722);
	const invertedLuminance = sub(1, dot(mask.rgb, luminanceWeights));
	const maskedAlpha = mul(target.a, invertedLuminance);
	return vec4(target.rgb, maskedAlpha);
}
var maskFunctions = {
	"alpha": alpha_default,
	"alphaInverted": alphaInverted_default,
	"luminance": luminance_default,
	"luminanceInverted": luminanceInverted_default
};
function applyMask(target, mask, maskType = "alpha") {
	return (maskFunctions[maskType] || maskFunctions["alpha"])(target, mask);
}
var PerformanceTracker = class {
	frameTimesMs = [];
	maxSamples = 60;
	targetFrameTime = 16.67;
	jankFrameCount = 0;
	totalFrameCount = 0;
	memorySnapshots = [];
	memorySnapshotIndex = 0;
	maxMemorySnapshots = 300;
	nodeCount = 0;
	rttNodeCount = 0;
	lastCpuTime = null;
	lastGpuTime = null;
	isRendering = false;
	lastFrameTimestamp = 0;
	frameIntervals = [];
	recordFrame(frameTimeMs) {
		this.frameTimesMs.push(frameTimeMs);
		if (this.frameTimesMs.length > this.maxSamples) this.frameTimesMs.shift();
		this.totalFrameCount++;
		if (frameTimeMs > this.targetFrameTime) this.jankFrameCount++;
		const now = performance.now();
		if (this.lastFrameTimestamp > 0) {
			const interval = now - this.lastFrameTimestamp;
			this.frameIntervals.push(interval);
			if (this.frameIntervals.length > this.maxSamples) this.frameIntervals.shift();
		}
		this.lastFrameTimestamp = now;
		this.recordMemorySnapshot();
	}
	recordCpuTime(timeMs) {
		this.lastCpuTime = timeMs;
	}
	recordGpuTime(timeMs) {
		this.lastGpuTime = timeMs;
	}
	updateNodeCounts(nodeCount, rttNodeCount) {
		this.nodeCount = nodeCount;
		this.rttNodeCount = rttNodeCount;
	}
	setRendering(rendering) {
		this.isRendering = rendering;
	}
	recordMemorySnapshot() {
		if (!performance.memory) return;
		const now = performance.now();
		const bytes = performance.memory.usedJSHeapSize;
		if (this.memorySnapshots.length < this.maxMemorySnapshots) this.memorySnapshots.push({
			time: now,
			bytes
		});
		else {
			const entry = this.memorySnapshots[this.memorySnapshotIndex];
			entry.time = now;
			entry.bytes = bytes;
			this.memorySnapshotIndex = (this.memorySnapshotIndex + 1) % this.maxMemorySnapshots;
		}
	}
	calculateMemoryGrowthRate() {
		if (this.memorySnapshots.length < 2) return null;
		const len = this.memorySnapshots.length;
		const oldestIdx = len < this.maxMemorySnapshots ? 0 : this.memorySnapshotIndex;
		const newestIdx = len < this.maxMemorySnapshots ? len - 1 : (this.memorySnapshotIndex - 1 + len) % len;
		const oldest = this.memorySnapshots[oldestIdx];
		const newest = this.memorySnapshots[newestIdx];
		const timeDeltaSeconds = (newest.time - oldest.time) / 1e3;
		if (timeDeltaSeconds <= 0) return null;
		return (newest.bytes - oldest.bytes) / (1024 * 1024) / timeDeltaSeconds;
	}
	calculateStdDev(values) {
		if (values.length === 0) return 0;
		const mean = values.reduce((a$1, b$2) => a$1 + b$2, 0) / values.length;
		let sumSquaredDiff = 0;
		for (let i = 0; i < values.length; i++) {
			const diff = values[i] - mean;
			sumSquaredDiff += diff * diff;
		}
		return Math.sqrt(sumSquaredDiff / values.length);
	}
	sortBuffer = [];
	calculateP99(values) {
		const len = values.length;
		if (len === 0) return 0;
		while (this.sortBuffer.length < len) this.sortBuffer.push(0);
		for (let i = 0; i < len; i++) this.sortBuffer[i] = values[i];
		for (let i = 1; i < len; i++) {
			const current = this.sortBuffer[i];
			let j = i - 1;
			while (j >= 0 && this.sortBuffer[j] > current) {
				this.sortBuffer[j + 1] = this.sortBuffer[j];
				j--;
			}
			this.sortBuffer[j + 1] = current;
		}
		const index = Math.floor(len * .99);
		return this.sortBuffer[Math.min(index, len - 1)];
	}
	calculateComplexityScore() {
		return this.nodeCount + this.rttNodeCount * 10;
	}
	calculateIntensityScore() {
		const frameCount = this.frameTimesMs.length;
		if (frameCount === 0) return {
			score: 0,
			label: "N/A"
		};
		const avgFrameTime = this.frameTimesMs.reduce((a$1, b$2) => a$1 + b$2, 0) / frameCount;
		const frameTimeScore = Math.min(avgFrameTime / 16.67 * 100, 100);
		const complexity = this.calculateComplexityScore();
		const complexityScore = Math.min(complexity / 100 * 100, 100);
		let gpuTimeScore = 0;
		if (this.lastGpuTime !== null) gpuTimeScore = Math.min(this.lastGpuTime / 16.67 * 100, 100);
		const weights = this.lastGpuTime !== null ? {
			frame: .4,
			gpu: .4,
			complexity: .2
		} : {
			frame: .7,
			gpu: 0,
			complexity: .3
		};
		const finalScore = Math.round(frameTimeScore * weights.frame + gpuTimeScore * weights.gpu + complexityScore * weights.complexity);
		let label$2;
		if (finalScore <= 20) label$2 = "Very Light";
		else if (finalScore <= 40) label$2 = "Light";
		else if (finalScore <= 60) label$2 = "Medium";
		else if (finalScore <= 80) label$2 = "Heavy";
		else label$2 = "Very Heavy";
		return {
			score: Math.min(finalScore, 100),
			label: label$2
		};
	}
	getStats(rendererInfo) {
		const frameCount = this.frameTimesMs.length;
		const fps = this.frameIntervals.length > 0 ? 1e3 / (this.frameIntervals.reduce((a$1, b$2) => a$1 + b$2, 0) / this.frameIntervals.length) : 0;
		const avgFrameTime = frameCount > 0 ? this.frameTimesMs.reduce((a$1, b$2) => a$1 + b$2, 0) / frameCount : 0;
		const minFrameTime = frameCount > 0 ? Math.min(...this.frameTimesMs) : 0;
		const maxFrameTime = frameCount > 0 ? Math.max(...this.frameTimesMs) : 0;
		const p99FrameTime = this.calculateP99(this.frameTimesMs);
		const stdDevFrameTime = this.calculateStdDev(this.frameTimesMs);
		const jankPercent = this.totalFrameCount > 0 ? this.jankFrameCount / this.totalFrameCount * 100 : 0;
		const memory = performance.memory;
		const memoryUsedMB = memory ? memory.usedJSHeapSize / (1024 * 1024) : null;
		const memoryGrowthRate = this.calculateMemoryGrowthRate();
		const budgetUsed = avgFrameTime > 0 ? avgFrameTime / this.targetFrameTime * 100 : 0;
		const drawCalls = rendererInfo?.render?.calls ?? null;
		const shaderPrograms = rendererInfo?.programs?.length ?? null;
		const textureCount = rendererInfo?.memory?.textures ?? null;
		const intensity = this.calculateIntensityScore();
		return {
			fps: Math.round(fps),
			avgFrameTime: Math.round(avgFrameTime * 100) / 100,
			minFrameTime: Math.round(minFrameTime * 100) / 100,
			maxFrameTime: Math.round(maxFrameTime * 100) / 100,
			p99FrameTime: Math.round(p99FrameTime * 100) / 100,
			stdDevFrameTime: Math.round(stdDevFrameTime * 100) / 100,
			jankCount: this.jankFrameCount,
			jankPercent: Math.round(jankPercent * 10) / 10,
			nodeCount: this.nodeCount,
			rttNodeCount: this.rttNodeCount,
			complexityScore: this.calculateComplexityScore(),
			memoryUsedMB: memoryUsedMB !== null ? Math.round(memoryUsedMB * 100) / 100 : null,
			memoryGrowthRate: memoryGrowthRate !== null ? Math.round(memoryGrowthRate * 1e3) / 1e3 : null,
			cpuTime: this.lastCpuTime !== null ? Math.round(this.lastCpuTime * 100) / 100 : null,
			gpuTime: this.lastGpuTime !== null ? Math.round(this.lastGpuTime * 100) / 100 : null,
			budgetUsed: Math.round(budgetUsed * 10) / 10,
			drawCalls,
			shaderPrograms,
			textureCount,
			intensityScore: intensity.score,
			intensityLabel: intensity.label,
			isRendering: this.isRendering
		};
	}
	reset() {
		this.frameTimesMs.length = 0;
		this.frameIntervals.length = 0;
		this.lastFrameTimestamp = 0;
		this.jankFrameCount = 0;
		this.totalFrameCount = 0;
		this.memorySnapshots.length = 0;
		this.memorySnapshotIndex = 0;
		this.sortBuffer.length = 0;
		this.lastCpuTime = null;
		this.lastGpuTime = null;
	}
};
var needsTransformation = (transform) => {
	if (!transform) return false;
	return transform.offsetX !== 0 || transform.offsetY !== 0 || transform.rotation !== 0 || transform.scale !== 1 || transform.anchorX !== .5 || transform.anchorY !== .5;
};
var applyUVTransform = (uv$1$2, offsetXUniform, offsetYUniform, rotationUniform, scaleUniform, anchorXUniform, anchorYUniform, aspectRatioUniform) => {
	const rotationRad = rotationUniform.mul(PI).div(float(180));
	const cosAngle = cos(rotationRad);
	const sinAngle = sin(rotationRad);
	const anchor = vec2(anchorXUniform, anchorYUniform);
	const scaledUV = uv$1$2.sub(anchor).div(scaleUniform);
	const squareUV = vec2(scaledUV.x.mul(aspectRatioUniform), scaledUV.y);
	const rotatedSquareUV = vec2(squareUV.x.mul(cosAngle).sub(squareUV.y.mul(sinAngle)), squareUV.x.mul(sinAngle).add(squareUV.y.mul(cosAngle)));
	return vec2(rotatedSquareUV.x.div(aspectRatioUniform), rotatedSquareUV.y).sub(vec2(offsetXUniform, offsetYUniform)).add(anchor);
};
var updateTransformMap = new Map([[transformColor, transformColorUpdate], [transformPosition, transformPositionUpdate]]);
function createUniformsMap(component, reactiveProps, instanceId) {
	const uniformsMap = {};
	Object.entries(component.props).forEach(([propName, propConfig]) => {
		const initialValue = reactiveProps[propName];
		let uniformValue = initialValue;
		if (propConfig.transform) {
			const transformed = propConfig.transform(initialValue);
			uniformValue = transformed?.node ?? transformed;
		}
		if (uniformValue === null || uniformValue === void 0) {
			uniformValue = propConfig.default;
			if (propConfig.transform && uniformValue !== null && uniformValue !== void 0) {
				const transformed = propConfig.transform(uniformValue);
				uniformValue = transformed?.node ?? transformed;
			}
		}
		if (uniformValue === null || uniformValue === void 0) {
			console.error(`[Shaders] Uniform "${propName}" is null/undefined after fallback. PropConfig:`, {
				propName,
				initialValue,
				default: propConfig.default,
				hasTransform: !!propConfig.transform
			});
			uniformValue = 0;
		}
		const uniformNode = uniform(uniformValue).setName(`${propName}_${instanceId}`);
		if (typeof uniformValue === "string" && uniformNode.value === null) uniformNode.value = uniformValue;
		uniformsMap[propName] = {
			uniform: uniformNode,
			transform: propConfig.transform || void 0
		};
	});
	return uniformsMap;
}
function updateUniformValue(uniform$1$1, newValue) {
	if (uniform$1$1?.transform) {
		const updateTransform = updateTransformMap.get(uniform$1$1.transform);
		if (updateTransform) {
			const newData = updateTransform(newValue);
			if (uniform$1$1.uniform.value && typeof uniform$1$1.uniform.value.copy === "function") uniform$1$1.uniform.value.copy(newData);
			else uniform$1$1.uniform.value = newData;
		} else {
			const transformed = uniform$1$1.transform(newValue);
			const dataValue = transformed?.data ?? transformed;
			if (uniform$1$1.uniform.value && typeof uniform$1$1.uniform.value.copy === "function" && dataValue && typeof dataValue.copy === "function") uniform$1$1.uniform.value.copy(dataValue);
			else uniform$1$1.uniform.value = dataValue;
		}
	} else uniform$1$1.uniform.value = newValue;
}
var hasLoggedLicenseInfo = false;
var globalEventManager = (() => {
	let instanceCount = 0;
	const callbacks = /* @__PURE__ */ new Set();
	const globalMouseMoveHandler = (e) => {
		callbacks.forEach((cb) => {
			try {
				cb.onMouseMove(e);
			} catch (error$1) {
				console.error("[Shaders] Error in mouse move handler:", error$1);
			}
		});
	};
	const globalTouchMoveHandler = (e) => {
		callbacks.forEach((cb) => {
			try {
				cb.onTouchMove(e);
			} catch (error$1) {
				console.error("[Shaders] Error in touch move handler:", error$1);
			}
		});
	};
	const globalMouseUpHandler = () => {
		callbacks.forEach((cb) => {
			try {
				cb.onMouseUp();
			} catch (error$1) {
				console.error("[Shaders] Error in mouse up handler:", error$1);
			}
		});
	};
	const globalTouchEndHandler = () => {
		callbacks.forEach((cb) => {
			try {
				cb.onTouchEnd();
			} catch (error$1) {
				console.error("[Shaders] Error in touch end handler:", error$1);
			}
		});
	};
	return { register(handlers) {
		callbacks.add(handlers);
		instanceCount++;
		if (instanceCount === 1) {
			window.addEventListener("mousemove", globalMouseMoveHandler);
			window.addEventListener("touchmove", globalTouchMoveHandler);
			window.addEventListener("mouseup", globalMouseUpHandler);
			window.addEventListener("touchend", globalTouchEndHandler);
		}
		return () => {
			callbacks.delete(handlers);
			instanceCount--;
			if (instanceCount === 0) {
				window.removeEventListener("mousemove", globalMouseMoveHandler);
				window.removeEventListener("touchmove", globalTouchMoveHandler);
				window.removeEventListener("mouseup", globalMouseUpHandler);
				window.removeEventListener("touchend", globalTouchEndHandler);
			}
		};
	} };
})();
var isDevelopment = () => {
	try {
		{
			const { MODE, DEV } = {
				"DEV": false,
				"MODE": "production"
			};
			return DEV || MODE === "development";
		}
		if (typeof window !== "undefined" && window.location) {
			const hostname = window.location.hostname;
			return hostname === "localhost" || hostname === "127.0.0.1" || hostname.endsWith(".local") || hostname.includes("dev.") || hostname.startsWith("dev-");
		}
		return false;
	} catch (error$1) {
		return false;
	}
};
function shaderRenderer() {
	let canvasElement = null;
	let renderer;
	let camera;
	let scene;
	let mesh;
	let material;
	const nodeRegistry = {
		nodes: /* @__PURE__ */ new Map(),
		rootId: null,
		idToNodeId: /* @__PURE__ */ new Map()
	};
	const parentToChildren = /* @__PURE__ */ new Map();
	let animationFrameId = null;
	let resizeObserver = null;
	let intersectionObserver = null;
	let isInitialized = false;
	let isInitializing = false;
	let hasInitialDimensions = false;
	let initializationAbortController = null;
	let isVisible = false;
	let shouldAnimate = true;
	let currentWidth = 0;
	let currentHeight = 0;
	let lastRenderTime = 0;
	let needsMaterialRefresh = false;
	let pointerX = .5;
	let pointerY = .5;
	let pointerActive = false;
	let isUpdatingMaterial = false;
	let globalEventUnregister = null;
	let unloadHandler = null;
	let enablePerformanceTracking = false;
	const performanceTracker = new PerformanceTracker();
	let pendingRegistrationQueue = [];
	let isRendererReady = false;
	let materialUpdateBatchRAF = null;
	let lastComposedNodes = /* @__PURE__ */ new Set();
	let activeRTTNodes = /* @__PURE__ */ new Set();
	let actualRTTOperations = 0;
	let currentTextures = /* @__PURE__ */ new Set();
	let previousTextures = /* @__PURE__ */ new Set();
	let pendingResize = null;
	let isResizeScheduled = false;
	const updateRendererDimensions = (width, height) => {
		if (width <= 0 || height <= 0) return;
		if (width === currentWidth && height === currentHeight) return;
		pendingResize = {
			width,
			height
		};
		if (!isResizeScheduled) {
			isResizeScheduled = true;
			requestAnimationFrame(() => {
				isResizeScheduled = false;
				if (!pendingResize) return;
				const { width: width$1, height: height$1 } = pendingResize;
				pendingResize = null;
				currentWidth = width$1;
				currentHeight = height$1;
				if (!hasInitialDimensions) hasInitialDimensions = true;
				renderer.setSize(width$1, height$1, false);
				const aspectRatio = width$1 / height$1;
				const frustumHeight = 2;
				const frustumWidth = frustumHeight * aspectRatio;
				camera.left = -frustumWidth / 2;
				camera.right = frustumWidth / 2;
				camera.top = frustumHeight / 2;
				camera.bottom = -frustumHeight / 2;
				camera.updateProjectionMatrix();
				mesh.scale.set(frustumWidth, frustumHeight, 1);
				nodeRegistry.nodes.forEach((nodeInfo) => {
					if (nodeInfo.transformUniforms?.aspectRatio) nodeInfo.transformUniforms.aspectRatio.value = aspectRatio;
					nodeInfo.resizeCallbacks.forEach((callback) => {
						try {
							callback({
								width: width$1,
								height: height$1
							});
						} catch (error$1) {
							console.error("Error in resize callback:", error$1);
						}
					});
				});
				if (!animationFrameId) renderFrame().catch(console.warn);
			});
		}
	};
	const canRender = () => {
		return isInitialized && !!renderer && !!scene && !!camera && !!material && currentWidth > 0 && currentHeight > 0;
	};
	const handleResize = (entries) => {
		if (!renderer || !camera || !mesh) return;
		const entry = entries[0];
		if (!entry) return;
		let width, height;
		if (entry.contentBoxSize) {
			const boxSize = Array.isArray(entry.contentBoxSize) ? entry.contentBoxSize[0] : entry.contentBoxSize;
			if (boxSize) {
				width = Math.round(boxSize.inlineSize);
				height = Math.round(boxSize.blockSize);
			} else {
				width = Math.round(entry.contentRect.width);
				height = Math.round(entry.contentRect.height);
			}
		} else {
			width = Math.round(entry.contentRect.width);
			height = Math.round(entry.contentRect.height);
		}
		if (width === 0 || height === 0) return;
		updateRendererDimensions(width, height);
	};
	const handleVisibilityChange = (entries) => {
		const entry = entries[0];
		if (!entry) return;
		isVisible = entry.isIntersecting;
	};
	const setsAreEqual = (set1, set2) => {
		if (set1.size !== set2.size) return false;
		for (const item of set1) if (!set2.has(item)) return false;
		return true;
	};
	const trackConvertToTexture = (node) => {
		actualRTTOperations++;
		const texture$1$1 = convertToTexture(node);
		currentTextures.add(texture$1$1);
		return texture$1$1;
	};
	const disposePreviousTextures = () => {
		previousTextures.forEach((texture$1$1) => {
			try {
				if (texture$1$1?.renderTarget?.dispose) texture$1$1.renderTarget.dispose();
			} catch (e) {}
		});
		previousTextures.clear();
	};
	let materialUpdatePending = false;
	const updateMaterial = () => {
		if (!nodeRegistry.rootId || !material || isUpdatingMaterial) return;
		if (!nodeRegistry.nodes.get(nodeRegistry.rootId)) return;
		if (currentWidth === 0 || currentHeight === 0) {
			if (!materialUpdatePending) {
				materialUpdatePending = true;
				requestAnimationFrame(() => {
					materialUpdatePending = false;
					if (currentWidth > 0 && currentHeight > 0) updateMaterial();
				});
			}
			return;
		}
		isUpdatingMaterial = true;
		try {
			previousTextures = new Set(currentTextures);
			currentTextures.clear();
			const currentComposedNodes = /* @__PURE__ */ new Set();
			activeRTTNodes.clear();
			nodeRegistry.nodes.forEach((nodeInfo, nodeId) => {
				if (nodeInfo.requiresRTT || nodeInfo.transformRTTActive) activeRTTNodes.add(nodeId);
			});
			actualRTTOperations = 0;
			const composedNode = composeNodeTree(nodeRegistry.rootId, /* @__PURE__ */ new Set(), currentComposedNodes);
			if (composedNode && material) {
				const compositionChanged = !setsAreEqual(lastComposedNodes, currentComposedNodes);
				const nodeChanged = material.fragmentNode !== composedNode;
				if (compositionChanged || needsMaterialRefresh || nodeChanged) {
					disposePreviousTextures();
					try {
						material.dispose();
						if (renderer.renderTarget) renderer.renderTarget.dispose();
					} catch (e) {}
					const newMaterial = new MeshBasicNodeMaterial({ transparent: true });
					newMaterial.fragmentNode = composedNode;
					newMaterial.needsUpdate = true;
					mesh.material = newMaterial;
					material = newMaterial;
					needsMaterialRefresh = false;
					lastComposedNodes = currentComposedNodes;
				}
			}
		} catch (error$1) {
			console.error("Error composing shader tree:", error$1);
		} finally {
			isUpdatingMaterial = false;
		}
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const findChildNodes = (parentId) => {
		const childIds = parentToChildren.get(parentId);
		if (!childIds) return [];
		const children = [];
		for (const childId of childIds) {
			const nodeInfo = nodeRegistry.nodes.get(childId);
			if (nodeInfo) children.push(nodeInfo);
		}
		return children;
	};
	const findNodeByCustomId = (customId) => {
		for (const [nodeId, info] of nodeRegistry.nodes.entries()) if (info.metadata.id === customId) return nodeId;
		return null;
	};
	const applyMaskIfNeeded = (result, nodeInfo, nodeId, processedMasks, distortedUV) => {
		if (!nodeInfo.metadata.mask?.source) return result;
		const maskSourceId = nodeInfo.metadata.mask.source;
		const maskNodeId = findNodeByCustomId(maskSourceId);
		if (!maskNodeId) return result;
		if (processedMasks.has(maskNodeId)) {
			console.error(`Uh oh, looks like you've got a circular dependency in your shader masks.`);
			return result;
		}
		const newProcessedMasks = new Set(processedMasks);
		newProcessedMasks.add(nodeId);
		const maskNode = composeNodeTree(maskNodeId, newProcessedMasks);
		let finalMaskNode = maskNode;
		if (distortedUV) finalMaskNode = trackConvertToTexture(maskNode).sample(distortedUV);
		const maskType = nodeInfo.metadata.mask.type || "alpha";
		return applyMask(result, finalMaskNode, maskType);
	};
	const applyNodeTransformation = (result, nodeInfo) => {
		if (!nodeInfo.metadata.transform || !nodeInfo.transformUniforms || !needsTransformation(nodeInfo.metadata.transform) && !nodeInfo.transformRTTActive) return result;
		const texture$1$1 = trackConvertToTexture(result);
		const transformedUV = applyUVTransform(screenUV, nodeInfo.transformUniforms.offsetX, nodeInfo.transformUniforms.offsetY, nodeInfo.transformUniforms.rotation, nodeInfo.transformUniforms.scale, nodeInfo.transformUniforms.anchorX, nodeInfo.transformUniforms.anchorY, nodeInfo.transformUniforms.aspectRatio);
		return applyEdgeHandling(transformedUV, texture$1$1.sample(transformedUV), texture$1$1, nodeInfo.transformUniforms.edges);
	};
	const composeNodeTree = (nodeId, processedMasks = /* @__PURE__ */ new Set(), currentlyComposedNodes) => {
		if (currentWidth === 0 || currentHeight === 0) return vec4(0, 0, 0, 0);
		const nodeInfo = nodeRegistry.nodes.get(nodeId);
		if (!nodeInfo) return vec4(0, 0, 0, 0);
		const nodeSpecificOnCleanup = (callback) => {
			nodeInfo.cleanupCallbacks.push(callback);
		};
		const nodeSpecificOnBeforeRender = (callback) => {
			nodeInfo.beforeRenderCallbacks.push(callback);
		};
		const nodeSpecificOnAfterRender = (callback) => {
			nodeInfo.afterRenderCallbacks.push(callback);
		};
		const nodeSpecificOnResize = (callback) => {
			nodeInfo.resizeCallbacks.push(callback);
		};
		const childNodes = findChildNodes(nodeId);
		if (childNodes.length === 0) {
			nodeInfo.cleanupCallbacks.forEach((callback) => {
				try {
					callback();
				} catch (e) {
					console.error("Error in cleanup callback:", e);
				}
			});
			nodeInfo.cleanupCallbacks = [];
			nodeInfo.beforeRenderCallbacks = [];
			nodeInfo.afterRenderCallbacks = [];
			nodeInfo.resizeCallbacks = [];
			return applyMaskIfNeeded(applyNodeTransformation(nodeInfo.fragmentNodeFunc({
				uniforms: nodeInfo.uniforms ?? {},
				childNode: void 0,
				onCleanup: nodeSpecificOnCleanup,
				onBeforeRender: nodeSpecificOnBeforeRender,
				onAfterRender: nodeSpecificOnAfterRender,
				onResize: nodeSpecificOnResize,
				canvas: canvasElement,
				dimensions: {
					width: currentWidth,
					height: currentHeight
				},
				renderer
			}), nodeInfo), nodeInfo, nodeId, processedMasks);
		} else {
			const sortedChildren = [...childNodes].sort((a$1, b$2) => a$1.metadata.renderOrder - b$2.metadata.renderOrder);
			if (nodeInfo.parentId === null) {
				let composedChildren = void 0;
				for (let i = 0; i < sortedChildren.length; i++) {
					const childInfo = sortedChildren[i];
					let effectiveOpacity;
					if (childInfo.metadata.opacity === void 0) {
						effectiveOpacity = 1;
						childInfo.opacityUniform.value = effectiveOpacity;
					} else {
						effectiveOpacity = childInfo.metadata.opacity;
						childInfo.opacityUniform.value = effectiveOpacity;
					}
					if (childInfo.metadata.visible === false) continue;
					if (currentlyComposedNodes) currentlyComposedNodes.add(childInfo.id);
					const childHasChildren = findChildNodes(childInfo.id).length > 0;
					let childResult;
					if (childHasChildren) childResult = composeNodeTree(childInfo.id, processedMasks, currentlyComposedNodes);
					else {
						const childSpecificOnCleanup = (callback) => {
							childInfo.cleanupCallbacks.push(callback);
						};
						const childSpecificOnBeforeRender = (callback) => {
							childInfo.beforeRenderCallbacks.push(callback);
						};
						const childSpecificOnAfterRender = (callback) => {
							childInfo.afterRenderCallbacks.push(callback);
						};
						const childSpecificOnResize = (callback) => {
							childInfo.resizeCallbacks.push(callback);
						};
						let effectiveChildNode = composedChildren;
						if (childInfo.requiresRTT && composedChildren !== void 0) effectiveChildNode = applyBlendMode(vec4(0, 0, 0, 0), composedChildren, "normal", 1);
						childInfo.cleanupCallbacks.forEach((callback) => {
							try {
								callback();
							} catch (e) {
								console.error("Error in cleanup callback:", e);
							}
						});
						childInfo.cleanupCallbacks = [];
						childInfo.beforeRenderCallbacks = [];
						childInfo.afterRenderCallbacks = [];
						childInfo.resizeCallbacks = [];
						childResult = applyMaskIfNeeded(applyNodeTransformation(childInfo.fragmentNodeFunc({
							uniforms: childInfo.uniforms ?? {},
							childNode: effectiveChildNode,
							onCleanup: childSpecificOnCleanup,
							onBeforeRender: childSpecificOnBeforeRender,
							onAfterRender: childSpecificOnAfterRender,
							onResize: childSpecificOnResize,
							canvas: canvasElement,
							dimensions: {
								width: currentWidth,
								height: currentHeight
							},
							renderer
						}), childInfo), childInfo, childInfo.id, processedMasks);
					}
					if (childInfo.requiresChild && childInfo.metadata.blendMode === "normal" && !childHasChildren) composedChildren = applyBlendMode(vec4(0, 0, 0, 0), childResult, "normal", childInfo.opacityUniform);
					else if (composedChildren === void 0) if (nodeInfo.requiresRTT || effectiveOpacity !== 1) composedChildren = applyBlendMode(vec4(1, 1, 1, 0), childResult, childInfo.metadata.blendMode, childInfo.opacityUniform);
					else composedChildren = childResult;
					else composedChildren = applyBlendMode(composedChildren, childResult, childInfo.metadata.blendMode, childInfo.opacityUniform);
				}
				nodeInfo.cleanupCallbacks.forEach((callback) => {
					try {
						callback();
					} catch (e) {
						console.error("Error in cleanup callback:", e);
					}
				});
				nodeInfo.cleanupCallbacks = [];
				nodeInfo.beforeRenderCallbacks = [];
				nodeInfo.afterRenderCallbacks = [];
				nodeInfo.resizeCallbacks = [];
				return applyMaskIfNeeded(applyNodeTransformation(nodeInfo.fragmentNodeFunc({
					uniforms: nodeInfo.uniforms ?? {},
					childNode: composedChildren,
					onCleanup: nodeSpecificOnCleanup,
					onBeforeRender: nodeSpecificOnBeforeRender,
					onAfterRender: nodeSpecificOnAfterRender,
					onResize: nodeSpecificOnResize,
					canvas: canvasElement,
					dimensions: {
						width: currentWidth,
						height: currentHeight
					},
					renderer
				}), nodeInfo), nodeInfo, nodeId, processedMasks);
			} else {
				let composedChildrenResult = void 0;
				for (let i = 0; i < sortedChildren.length; i++) {
					const childInfo = sortedChildren[i];
					let effectiveOpacity;
					if (childInfo.metadata.opacity === void 0) {
						effectiveOpacity = 1;
						childInfo.opacityUniform.value = effectiveOpacity;
					} else {
						effectiveOpacity = childInfo.metadata.opacity;
						childInfo.opacityUniform.value = effectiveOpacity;
					}
					if (childInfo.metadata.visible === false) continue;
					if (currentlyComposedNodes) currentlyComposedNodes.add(childInfo.id);
					const childHasChildren = findChildNodes(childInfo.id).length > 0;
					let childResult;
					if (childHasChildren) childResult = composeNodeTree(childInfo.id, processedMasks, currentlyComposedNodes);
					else {
						const childSpecificOnCleanup = (callback) => {
							childInfo.cleanupCallbacks.push(callback);
						};
						const childSpecificOnBeforeRender = (callback) => {
							childInfo.beforeRenderCallbacks.push(callback);
						};
						const childSpecificOnAfterRender = (callback) => {
							childInfo.afterRenderCallbacks.push(callback);
						};
						const childSpecificOnResize = (callback) => {
							childInfo.resizeCallbacks.push(callback);
						};
						let effectiveChildNode = composedChildrenResult;
						if (childInfo.requiresRTT && composedChildrenResult !== void 0) effectiveChildNode = applyBlendMode(vec4(0, 0, 0, 0), composedChildrenResult, "normal", 1);
						childInfo.cleanupCallbacks = [];
						childInfo.beforeRenderCallbacks = [];
						childInfo.afterRenderCallbacks = [];
						childInfo.resizeCallbacks = [];
						childResult = applyMaskIfNeeded(applyNodeTransformation(childInfo.fragmentNodeFunc({
							uniforms: childInfo.uniforms ?? {},
							childNode: effectiveChildNode,
							onCleanup: childSpecificOnCleanup,
							onBeforeRender: childSpecificOnBeforeRender,
							onAfterRender: childSpecificOnAfterRender,
							onResize: childSpecificOnResize,
							canvas: canvasElement,
							dimensions: {
								width: currentWidth,
								height: currentHeight
							},
							renderer
						}), childInfo), childInfo, childInfo.id, processedMasks);
					}
					if (childInfo.requiresChild && childInfo.metadata.blendMode === "normal" && !childHasChildren) composedChildrenResult = applyBlendMode(vec4(0, 0, 0, 0), childResult, "normal", childInfo.opacityUniform);
					else if (composedChildrenResult === void 0) if (nodeInfo.requiresRTT || effectiveOpacity !== 1) composedChildrenResult = applyBlendMode(vec4(1, 1, 1, 0), childResult, childInfo.metadata.blendMode, childInfo.opacityUniform);
					else composedChildrenResult = childResult;
					else composedChildrenResult = applyBlendMode(composedChildrenResult, childResult, childInfo.metadata.blendMode, childInfo.opacityUniform);
				}
				nodeInfo.cleanupCallbacks.forEach((callback) => {
					try {
						callback();
					} catch (e) {
						console.error("Error in cleanup callback:", e);
					}
				});
				nodeInfo.cleanupCallbacks = [];
				nodeInfo.beforeRenderCallbacks = [];
				nodeInfo.afterRenderCallbacks = [];
				nodeInfo.resizeCallbacks = [];
				return applyMaskIfNeeded(applyNodeTransformation(nodeInfo.fragmentNodeFunc({
					uniforms: nodeInfo.uniforms ?? {},
					childNode: composedChildrenResult,
					onCleanup: nodeSpecificOnCleanup,
					onBeforeRender: nodeSpecificOnBeforeRender,
					onAfterRender: nodeSpecificOnAfterRender,
					onResize: nodeSpecificOnResize,
					canvas: canvasElement,
					dimensions: {
						width: currentWidth,
						height: currentHeight
					},
					renderer
				}), nodeInfo), nodeInfo, nodeId, processedMasks);
			}
		}
	};
	const registerNode = (id, fragmentNodeFunc, parentId, metadata, uniforms = {}, componentDefinition$62) => {
		if (fragmentNodeFunc === null) {
			const queueIndex = pendingRegistrationQueue.findIndex((item) => item.id === id);
			if (queueIndex !== -1) {
				pendingRegistrationQueue.splice(queueIndex, 1);
				return;
			}
			removeNode(id);
			return;
		}
		if (!isRendererReady) {
			const existing = pendingRegistrationQueue.findIndex((item) => item.id === id);
			if (existing !== -1) pendingRegistrationQueue[existing] = {
				id,
				fragmentNodeFunc,
				parentId,
				metadata,
				uniforms,
				componentDefinition: componentDefinition$62
			};
			else pendingRegistrationQueue.push({
				id,
				fragmentNodeFunc,
				parentId,
				metadata,
				uniforms,
				componentDefinition: componentDefinition$62
			});
			return;
		}
		let defaultRenderOrder = 0;
		if (parentId !== null) {
			const siblings = parentToChildren.get(parentId);
			if (siblings && siblings.size > 0) {
				let maxOrder = 0;
				for (const siblingId of siblings) {
					const sibling = nodeRegistry.nodes.get(siblingId);
					if (sibling && sibling.metadata.renderOrder > maxOrder) maxOrder = sibling.metadata.renderOrder;
				}
				defaultRenderOrder = maxOrder + 1;
			}
		}
		const opacityUniform = uniform(metadata?.opacity !== void 0 ? metadata.opacity : 1);
		let transformUniforms = void 0;
		if (metadata?.transform) {
			const aspectRatio = currentWidth / Math.max(1, currentHeight);
			transformUniforms = {
				offsetX: uniform(metadata.transform.offsetX),
				offsetY: uniform(metadata.transform.offsetY),
				rotation: uniform(metadata.transform.rotation),
				scale: uniform(metadata.transform.scale),
				anchorX: uniform(metadata.transform.anchorX),
				anchorY: uniform(metadata.transform.anchorY),
				edges: uniform(metadata.transform.edges === "stretch" ? 0 : metadata.transform.edges === "transparent" ? 1 : metadata.transform.edges === "mirror" ? 2 : 3),
				aspectRatio: uniform(aspectRatio)
			};
		}
		const nodeInfo = {
			id,
			componentName: componentDefinition$62?.name || "Unknown",
			fragmentNodeFunc,
			parentId,
			requiresRTT: componentDefinition$62?.requiresRTT || false,
			requiresChild: componentDefinition$62?.requiresChild || false,
			opacityUniform,
			metadata: {
				blendMode: metadata?.blendMode || "normal",
				opacity: metadata?.opacity,
				visible: metadata?.visible === false ? false : true,
				id: metadata?.id,
				mask: metadata?.mask,
				renderOrder: metadata?.renderOrder !== void 0 ? metadata?.renderOrder : defaultRenderOrder,
				transform: metadata?.transform
			},
			uniforms,
			cleanupCallbacks: [],
			beforeRenderCallbacks: [],
			afterRenderCallbacks: [],
			resizeCallbacks: [],
			transformUniforms,
			transformRTTActive: false
		};
		nodeRegistry.nodes.set(id, nodeInfo);
		if (parentId === null) nodeRegistry.rootId = id;
		const childrenSet = parentToChildren.get(parentId) || /* @__PURE__ */ new Set();
		childrenSet.add(id);
		parentToChildren.set(parentId, childrenSet);
		if (material && isInitialized && currentWidth > 0 && currentHeight > 0) {
			if (materialUpdateBatchRAF === null) materialUpdateBatchRAF = requestAnimationFrame(() => {
				materialUpdateBatchRAF = null;
				updateMaterial();
			});
		} else if (material && isInitialized) {
			if (!materialUpdatePending) {
				materialUpdatePending = true;
				requestAnimationFrame(() => {
					materialUpdatePending = false;
					if (currentWidth > 0 && currentHeight > 0) updateMaterial();
				});
			}
		}
	};
	const updateUniformValue$1 = (nodeId, uniformName, value) => {
		const nodeInfo = nodeRegistry.nodes.get(nodeId);
		if (!nodeInfo || !nodeInfo.uniforms) return;
		const uniformDefinition = nodeInfo.uniforms[uniformName];
		if (!uniformDefinition || !uniformDefinition.uniform) return;
		if (uniformDefinition.transform) updateUniformValue(uniformDefinition, value);
		else uniformDefinition.uniform.value = value;
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const updateNodeMetadata = (nodeId, metadata) => {
		const existingNode = nodeRegistry.nodes.get(nodeId);
		if (!existingNode) return;
		let needsRecompose = false;
		if (metadata.blendMode !== void 0 && existingNode.metadata.blendMode !== metadata.blendMode) {
			existingNode.metadata.blendMode = metadata.blendMode;
			needsRecompose = true;
		}
		if (metadata.opacity !== void 0 && existingNode.metadata.opacity !== metadata.opacity) {
			existingNode.metadata.opacity = metadata.opacity;
			existingNode.opacityUniform.value = metadata.opacity;
		}
		if (metadata.renderOrder !== void 0 && existingNode.metadata.renderOrder !== metadata.renderOrder) {
			existingNode.metadata.renderOrder = metadata.renderOrder;
			needsRecompose = true;
		}
		const newVisible = metadata.visible === false ? false : true;
		if (existingNode.metadata.visible !== newVisible) {
			existingNode.metadata.visible = newVisible;
			needsRecompose = true;
		}
		if (metadata.id !== void 0 && existingNode.metadata.id !== metadata.id) {
			existingNode.metadata.id = metadata.id;
			needsRecompose = true;
		}
		if (metadata.mask !== void 0 && (existingNode.metadata.mask?.source !== metadata.mask?.source || existingNode.metadata.mask?.type !== metadata.mask?.type)) {
			existingNode.metadata.mask = metadata.mask;
			needsRecompose = true;
		}
		if (metadata.transform !== void 0) {
			existingNode.metadata.transform && needsTransformation(existingNode.metadata.transform);
			const newTransformState = needsTransformation(metadata.transform);
			existingNode.metadata.transform = metadata.transform;
			if (!existingNode.transformUniforms && metadata.transform) {
				const aspectRatio = currentWidth / Math.max(1, currentHeight);
				existingNode.transformUniforms = {
					offsetX: uniform(metadata.transform.offsetX),
					offsetY: uniform(metadata.transform.offsetY),
					rotation: uniform(metadata.transform.rotation),
					scale: uniform(metadata.transform.scale),
					anchorX: uniform(metadata.transform.anchorX),
					anchorY: uniform(metadata.transform.anchorY),
					edges: uniform(metadata.transform.edges === "stretch" ? 0 : metadata.transform.edges === "transparent" ? 1 : metadata.transform.edges === "mirror" ? 2 : 3),
					aspectRatio: uniform(aspectRatio)
				};
			} else if (existingNode.transformUniforms) {
				existingNode.transformUniforms.offsetX.value = metadata.transform.offsetX;
				existingNode.transformUniforms.offsetY.value = metadata.transform.offsetY;
				existingNode.transformUniforms.rotation.value = metadata.transform.rotation;
				existingNode.transformUniforms.scale.value = metadata.transform.scale;
				existingNode.transformUniforms.anchorX.value = metadata.transform.anchorX;
				existingNode.transformUniforms.anchorY.value = metadata.transform.anchorY;
				existingNode.transformUniforms.edges.value = metadata.transform.edges === "stretch" ? 0 : metadata.transform.edges === "transparent" ? 1 : metadata.transform.edges === "mirror" ? 2 : 3;
			}
			if (newTransformState && !existingNode.transformRTTActive) {
				existingNode.transformRTTActive = true;
				needsRecompose = true;
			}
		}
		if (needsRecompose && material && isInitialized) {
			if (materialUpdateBatchRAF === null) materialUpdateBatchRAF = requestAnimationFrame(() => {
				materialUpdateBatchRAF = null;
				updateMaterial();
			});
		} else if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const removeNode = (id) => {
		if (!nodeRegistry.nodes.has(id)) return;
		const nodeInfo = nodeRegistry.nodes.get(id);
		if (nodeInfo && nodeInfo.cleanupCallbacks.length > 0) for (const callback of nodeInfo.cleanupCallbacks) try {
			callback();
		} catch (e) {
			console.error(`Error executing cleanup callback for node ${id}:`, e);
		}
		const childNodes = findChildNodes(id);
		for (const child of childNodes) removeNode(child.id);
		if (nodeRegistry.rootId === id) nodeRegistry.rootId = null;
		if (nodeInfo) {
			const childrenSet = parentToChildren.get(nodeInfo.parentId);
			if (childrenSet) {
				childrenSet.delete(id);
				if (childrenSet.size === 0) parentToChildren.delete(nodeInfo.parentId);
			}
		}
		nodeRegistry.nodes.delete(id);
		if (material && isInitialized) updateMaterial();
	};
	const executeBeforeRenderCallbacks = (deltaTime$2) => {
		const params = {
			deltaTime: deltaTime$2,
			pointer: {
				x: pointerX,
				y: pointerY
			},
			pointerActive,
			dimensions: {
				width: currentWidth,
				height: currentHeight
			}
		};
		for (const nodeInfo of nodeRegistry.nodes.values()) if (nodeInfo.beforeRenderCallbacks.length > 0) for (const callback of nodeInfo.beforeRenderCallbacks) try {
			callback(params);
		} catch (e) {
			console.error(`Error executing before render callback for node ${nodeInfo.id}:`, e);
		}
	};
	const executeAfterRenderCallbacks = (deltaTime$2) => {
		const params = {
			deltaTime: deltaTime$2,
			pointer: {
				x: pointerX,
				y: pointerY
			},
			pointerActive,
			dimensions: {
				width: currentWidth,
				height: currentHeight
			}
		};
		for (const nodeInfo of nodeRegistry.nodes.values()) if (nodeInfo.afterRenderCallbacks.length > 0) for (const callback of nodeInfo.afterRenderCallbacks) try {
			callback(params);
		} catch (e) {
			console.error(`Error executing after render callback for node ${nodeInfo.id}:`, e);
		}
	};
	const renderAndWait = async () => {
		if (!canRender()) throw new Error("Renderer is not ready");
		await renderFrame();
		if (renderer instanceof WebGPURenderer) try {
			const backend = renderer.backend;
			if (backend?.device) await backend.device.queue.onSubmittedWorkDone();
		} catch (e) {
			await new Promise((resolve) => setTimeout(resolve, 16));
		}
	};
	const renderFrame = async () => {
		if (!canRender()) return;
		const frameStartTime = enablePerformanceTracking ? performance.now() : 0;
		const currentTime = frameStartTime || performance.now();
		const deltaTime$2 = lastRenderTime > 0 ? (currentTime - lastRenderTime) / 1e3 : .016;
		const OFF_SCREEN_FPS_INTERVAL = 1e3;
		const MIN_FRAME_INTERVAL = 1e3 / 120;
		if (lastRenderTime > 0) {
			const timeSinceLastRender = currentTime - lastRenderTime;
			if (!isVisible && timeSinceLastRender < OFF_SCREEN_FPS_INTERVAL) return;
			if (isVisible && timeSinceLastRender < MIN_FRAME_INTERVAL) return;
		}
		const cappedDeltaTime = Math.min(deltaTime$2, .1);
		lastRenderTime = currentTime;
		if (enablePerformanceTracking) performance.mark("shader-cpu-start");
		executeBeforeRenderCallbacks(cappedDeltaTime);
		try {
			if (isUpdatingMaterial) return;
			if (enablePerformanceTracking) performance.mark("shader-gpu-start");
			renderer.render(scene, camera);
			executeAfterRenderCallbacks(cappedDeltaTime);
			if (enablePerformanceTracking) {
				performance.mark("shader-gpu-end");
				if (renderer instanceof WebGPURenderer) try {
					const backend = renderer.backend;
					if (backend && backend.get && backend.get(renderer)) {
						const renderContext = backend.get(renderer);
						if (renderContext?.timestampQuery) {
							const gpuTime = renderContext.timestampQuery.getResult();
							if (gpuTime !== null && gpuTime !== void 0) performanceTracker.recordGpuTime(gpuTime / 1e6);
						}
					}
				} catch (e) {}
				try {
					performance.measure("shader-gpu-time", "shader-gpu-start", "shader-gpu-end");
					const gpuMeasure = performance.getEntriesByName("shader-gpu-time")[0];
					if (gpuMeasure) performanceTracker.recordGpuTime(gpuMeasure.duration);
					performance.clearMarks("shader-gpu-start");
					performance.clearMarks("shader-gpu-end");
					performance.clearMeasures("shader-gpu-time");
				} catch (e) {}
			}
			if (enablePerformanceTracking) {
				performance.mark("shader-cpu-end");
				try {
					performance.measure("shader-cpu-time", "shader-cpu-start", "shader-cpu-end");
					const cpuMeasure = performance.getEntriesByName("shader-cpu-time")[0];
					if (cpuMeasure) performanceTracker.recordCpuTime(cpuMeasure.duration);
					performance.clearMarks("shader-cpu-start");
					performance.clearMarks("shader-cpu-end");
					performance.clearMeasures("shader-cpu-time");
				} catch (e) {}
				const frameTime = performance.now() - frameStartTime;
				performanceTracker.recordFrame(frameTime);
			}
		} catch (error$1) {
			console.error("Render frame error:", error$1);
		}
	};
	const updatePerformanceNodeCounts = () => {
		const nodeCount = Math.max(0, nodeRegistry.nodes.size - 1);
		const rttNodeCount = actualRTTOperations;
		performanceTracker.updateNodeCounts(nodeCount, rttNodeCount);
	};
	const getPerformanceStats = () => {
		updatePerformanceNodeCounts();
		const rendererInfo = renderer?.info;
		return performanceTracker.getStats(rendererInfo);
	};
	const startAnimation = () => {
		if (animationFrameId || !shouldAnimate) return;
		performanceTracker.setRendering(true);
		const animate = () => {
			animationFrameId = requestAnimationFrame(animate);
			renderFrame().catch(console.warn);
		};
		animate();
	};
	const stopAnimation = () => {
		if (animationFrameId) {
			cancelAnimationFrame(animationFrameId);
			animationFrameId = null;
		}
		performanceTracker.setRendering(false);
	};
	const updatePointerCoords = (event) => {
		if (!canvasElement) return;
		let clientX;
		let clientY;
		if ("touches" in event) {
			if (event.touches.length === 0) return;
			clientX = event.touches[0].clientX;
			clientY = event.touches[0].clientY;
		} else {
			clientX = event.clientX;
			clientY = event.clientY;
		}
		const rect = canvasElement.getBoundingClientRect();
		const x = (clientX - rect.left) / rect.width;
		const y = (clientY - rect.top) / rect.height;
		pointerX = x;
		pointerY = y;
	};
	const globalMouseMoveHandler = (event) => {
		if (!isInitialized || !canvasElement) return;
		updatePointerCoords(event);
	};
	const globalTouchMoveHandler = (event) => {
		if (!isInitialized || !canvasElement) return;
		updatePointerCoords(event);
	};
	const globalMouseUpHandler = () => {
		if (!isInitialized) return;
		pointerActive = false;
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const globalTouchEndHandler = () => {
		if (!isInitialized) return;
		pointerActive = false;
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const canvasMouseDownHandler = () => {
		pointerActive = true;
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const canvasTouchStartHandler = () => {
		pointerActive = true;
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const processQueuedRegistrations = () => {
		if (pendingRegistrationQueue.length === 0) return;
		const queue = [...pendingRegistrationQueue];
		pendingRegistrationQueue = [];
		for (const { id, fragmentNodeFunc, parentId, metadata, uniforms, componentDefinition: componentDefinition$62 } of queue) if (fragmentNodeFunc) registerNode(id, fragmentNodeFunc, parentId, metadata, uniforms, componentDefinition$62);
	};
	const initialize = async ({ canvas, enablePerformanceTracking: enableTracking = false }) => {
		if (isInitialized || isInitializing) return;
		enablePerformanceTracking = enableTracking;
		isInitializing = true;
		initializationAbortController = new AbortController();
		const localAbortController = initializationAbortController;
		try {
			canvasElement = canvas;
			scene = new Scene();
			scene.background = null;
			camera = new OrthographicCamera(-1, 1, 1, -1, .1, 10);
			camera.position.z = 1;
			camera.lookAt(0, 0, 0);
			globalEventUnregister = globalEventManager.register({
				onMouseMove: globalMouseMoveHandler,
				onTouchMove: globalTouchMoveHandler,
				onMouseUp: globalMouseUpHandler,
				onTouchEnd: globalTouchEndHandler
			});
			canvas.addEventListener("mousedown", canvasMouseDownHandler);
			canvas.addEventListener("touchstart", canvasTouchStartHandler);
			unloadHandler = () => {
				cleanup();
			};
			window.addEventListener("beforeunload", unloadHandler);
			if (localAbortController.signal.aborted) return;
			try {
				const rendererOptions = {
					canvas,
					antialias: true,
					alpha: true,
					depth: false,
					powerPreference: "high-performance"
				};
				if (enablePerformanceTracking) {
					rendererOptions.forceWebGL = false;
					rendererOptions.requiredFeatures = ["timestamp-query"];
				}
				renderer = new WebGPURenderer(rendererOptions);
				await renderer.init();
				if (localAbortController.signal.aborted) return;
			} catch (e) {
				if (localAbortController.signal.aborted) return;
				console.warn("[Shaders] WebGPU initialization failed, falling back to WebGL:", e);
				try {
					renderer = new WebGLRenderer({
						canvas,
						antialias: true,
						alpha: true,
						depth: false,
						powerPreference: "high-performance"
					});
					if (localAbortController.signal.aborted) return;
				} catch (webglError) {
					if (localAbortController.signal.aborted) return;
					console.error("[Shaders] Both WebGPU and WebGL initialization failed:", webglError);
					return;
				}
			}
			if (localAbortController.signal.aborted) return;
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			renderer.outputColorSpace = SRGBColorSpace;
			material = new MeshBasicNodeMaterial({ transparent: true });
			material.fragmentNode = vec4(0, 0, 0, 0);
			mesh = new Mesh(new PlaneGeometry(2, 2), material);
			scene.add(mesh);
			const parentElement = canvas.parentElement;
			if (!parentElement) {
				console.warn("[Shaders] Canvas has no parent element for resize observation");
				return;
			}
			resizeObserver = new ResizeObserver(handleResize);
			resizeObserver.observe(parentElement);
			intersectionObserver = new IntersectionObserver(handleVisibilityChange, { threshold: 0 });
			intersectionObserver.observe(canvas);
			const rect = canvas.getBoundingClientRect();
			isVisible = rect.width > 0 && rect.height > 0 && rect.top < window.innerHeight && rect.bottom > 0 && rect.left < window.innerWidth && rect.right > 0;
			shouldAnimate = true;
			const { width, height } = canvas.getBoundingClientRect();
			const roundedWidth = Math.round(width);
			const roundedHeight = Math.round(height);
			if (roundedWidth > 0 && roundedHeight > 0) {
				currentWidth = roundedWidth;
				currentHeight = roundedHeight;
				hasInitialDimensions = true;
				renderer.setSize(roundedWidth, roundedHeight, false);
				const aspectRatio = roundedWidth / roundedHeight;
				const frustumHeight = 2;
				const frustumWidth = frustumHeight * aspectRatio;
				camera.left = -frustumWidth / 2;
				camera.right = frustumWidth / 2;
				camera.top = frustumHeight / 2;
				camera.bottom = -frustumHeight / 2;
				camera.updateProjectionMatrix();
				mesh.scale.set(frustumWidth, frustumHeight, 1);
				await renderFrame();
			} else hasInitialDimensions = false;
			if (shouldAnimate) startAnimation();
			if (!localAbortController.signal.aborted) {
				isInitialized = true;
				isRendererReady = true;
				processQueuedRegistrations();
			}
		} catch (error$1) {
			console.error("[Shaders] Initialization error:", error$1);
		} finally {
			isInitializing = false;
			if (initializationAbortController === localAbortController) initializationAbortController = null;
		}
	};
	const showLicenseWarning = () => {
		if (!isDevelopment() || hasLoggedLicenseInfo) return;
		console.warn("Shaders is running in development mode. Please purchase a license at https://shaders.com to use it in production.");
		hasLoggedLicenseInfo = true;
	};
	const cleanup = () => {
		if (initializationAbortController) initializationAbortController.abort();
		if (resizeObserver) {
			resizeObserver.disconnect();
			resizeObserver = null;
		}
		if (intersectionObserver) {
			intersectionObserver.disconnect();
			intersectionObserver = null;
		}
		if (globalEventUnregister) {
			globalEventUnregister();
			globalEventUnregister = null;
		}
		if (canvasElement) {
			canvasElement.removeEventListener("mousedown", canvasMouseDownHandler);
			canvasElement.removeEventListener("touchstart", canvasTouchStartHandler);
		}
		if (unloadHandler) {
			window.removeEventListener("beforeunload", unloadHandler);
			unloadHandler = null;
		}
		stopAnimation();
		disposePreviousTextures();
		currentTextures.forEach((texture$1$1) => {
			try {
				if (texture$1$1?.renderTarget?.dispose) texture$1$1.renderTarget.dispose();
			} catch (e) {}
		});
		currentTextures.clear();
		nodeRegistry.nodes.clear();
		nodeRegistry.rootId = null;
		nodeRegistry.idToNodeId.clear();
		parentToChildren.clear();
		pendingRegistrationQueue = [];
		isRendererReady = false;
		if (materialUpdateBatchRAF !== null) {
			cancelAnimationFrame(materialUpdateBatchRAF);
			materialUpdateBatchRAF = null;
		}
		pendingResize = null;
		isResizeScheduled = false;
		if (mesh) {
			if (scene) scene.remove(mesh);
			try {
				if (mesh.geometry && typeof mesh.geometry.dispose === "function") mesh.geometry.dispose();
			} catch (e) {}
			try {
				if (mesh.material instanceof Material && typeof mesh.material.dispose === "function") mesh.material.dispose();
			} catch (e) {}
		}
		if (renderer && typeof renderer.dispose === "function") try {
			renderer.dispose();
		} catch (e) {}
		canvasElement = null;
		renderer = null;
		camera = null;
		scene = null;
		mesh = null;
		material = null;
		isInitialized = false;
		isInitializing = false;
		hasInitialDimensions = false;
		initializationAbortController = null;
		currentWidth = 0;
		currentHeight = 0;
		isVisible = false;
		shouldAnimate = true;
		pointerX = .5;
		pointerY = .5;
		pointerActive = false;
	};
	const getRendererType = () => {
		if (!renderer) return null;
		return renderer instanceof WebGPURenderer ? "webgpu" : "webgl";
	};
	return {
		initialize,
		cleanup,
		registerNode,
		removeNode,
		updateUniformValue: updateUniformValue$1,
		updateNodeMetadata,
		showLicenseWarning,
		isInitialized: () => isInitialized,
		startAnimation,
		stopAnimation,
		renderAndWait,
		getPerformanceStats,
		getNodeRegistry: () => ({ nodes: new Map(nodeRegistry.nodes) }),
		getRendererType,
		__testing: {
			needsTransformation,
			findChildNodes,
			applyMaskIfNeeded,
			applyNodeTransformation,
			getNodeRegistry: () => nodeRegistry,
			getParentToChildren: () => parentToChildren
		}
	};
}

//#endregion
//#region node_modules/shaders/dist/core/telemetry/index.js
var TELEMETRY_CONFIG = {
	samplingRate: .05,
	collectionDuration: 1e4,
	warmupDuration: 1e3,
	sampleInterval: 100,
	apiEndpoint: "https://shaders.com/api/telemetry"
};
function collectEnvironment() {
	if (typeof window === "undefined" || typeof navigator === "undefined") return {
		domain: "unknown",
		url: "unknown",
		userAgent: "unknown",
		viewport: {
			width: 0,
			height: 0
		},
		devicePixelRatio: 1,
		locale: "en-US"
	};
	return {
		domain: window.location.hostname,
		url: window.location.pathname,
		userAgent: navigator.userAgent,
		viewport: {
			width: window.innerWidth,
			height: window.innerHeight
		},
		devicePixelRatio: window.devicePixelRatio,
		locale: navigator.language
	};
}
var TelemetryCollector = class {
	renderer;
	sessionId;
	frameSamples = [];
	sampleInterval = null;
	stopped = false;
	constructor(renderer) {
		this.renderer = renderer;
		this.sessionId = `tel_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
	}
	stop() {
		this.stopped = true;
		if (this.sampleInterval) {
			clearInterval(this.sampleInterval);
			this.sampleInterval = null;
		}
	}
	async start() {
		try {
			await this.sleep(TELEMETRY_CONFIG.warmupDuration);
			if (this.stopped) return;
			this.sampleInterval = setInterval(() => {
				if (this.stopped) return;
				try {
					const stats = this.renderer.getPerformanceStats();
					this.frameSamples.push(stats);
				} catch (error$1) {
					console.error("Telemetry sampling error:", error$1);
				}
			}, TELEMETRY_CONFIG.sampleInterval);
			await this.sleep(TELEMETRY_CONFIG.collectionDuration - TELEMETRY_CONFIG.warmupDuration);
			if (this.stopped) return;
			if (this.sampleInterval) {
				clearInterval(this.sampleInterval);
				this.sampleInterval = null;
			}
			if (!this.stopped && this.frameSamples.length >= 10) {
				const payload = this.aggregateData();
				await this.sendTelemetry(payload);
			} else if (this.frameSamples.length < 10) console.log("[Telemetry] Insufficient samples collected, skipping send");
		} catch (error$1) {
			console.error("Telemetry collection error:", error$1);
		}
	}
	sleep(ms) {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}
	aggregateData() {
		const performance$1 = this.aggregatePerformance();
		const renderer = this.detectRendererType();
		const components = this.extractComponents();
		const environment$1 = collectEnvironment();
		return {
			sessionId: this.sessionId,
			timestamp: Date.now(),
			collectionDuration: TELEMETRY_CONFIG.collectionDuration,
			performance: performance$1,
			renderer,
			components,
			environment: environment$1
		};
	}
	aggregatePerformance() {
		if (this.frameSamples.length === 0) return {
			fps: 0,
			frameTime: {
				avg: 0,
				min: 0,
				max: 0,
				p99: 0
			},
			jankPercent: 0,
			budgetUsed: 0
		};
		const frameTimes = this.frameSamples.map((s) => s.avgFrameTime);
		const jankPercents = this.frameSamples.map((s) => s.jankPercent);
		const budgetUseds = this.frameSamples.map((s) => s.budgetUsed);
		const fpsValues = this.frameSamples.map((s) => s.fps);
		const fps = this.calculateMedian(fpsValues);
		const avgFrameTime = this.calculateMean(frameTimes);
		const minFrameTime = Math.min(...frameTimes);
		const maxFrameTime = Math.max(...frameTimes);
		const p99FrameTime = this.calculatePercentile(frameTimes, 99);
		const jankPercent = this.calculateMean(jankPercents);
		const budgetUsed = this.calculateMean(budgetUseds);
		return {
			fps: Math.round(fps * 10) / 10,
			frameTime: {
				avg: Math.round(avgFrameTime * 10) / 10,
				min: Math.round(minFrameTime * 10) / 10,
				max: Math.round(maxFrameTime * 10) / 10,
				p99: Math.round(p99FrameTime * 10) / 10
			},
			jankPercent: Math.round(jankPercent * 10) / 10,
			budgetUsed: Math.round(budgetUsed * 10) / 10
		};
	}
	detectRendererType() {
		const latestSample = this.frameSamples[this.frameSamples.length - 1];
		return {
			type: this.renderer.getRendererType?.() || "webgl",
			drawCalls: latestSample?.drawCalls ?? null,
			textureCount: latestSample?.textureCount ?? null
		};
	}
	extractComponents() {
		try {
			const nodeRegistry = this.renderer.getNodeRegistry();
			const components = [];
			for (const [_, nodeInfo] of nodeRegistry.nodes) {
				if (nodeInfo.parentId === null) continue;
				components.push({
					name: nodeInfo.componentName,
					requiresRTT: nodeInfo.requiresRTT,
					renderOrder: nodeInfo.metadata.renderOrder
				});
			}
			return components.sort((a$1, b$2) => a$1.renderOrder - b$2.renderOrder);
		} catch (error$1) {
			console.error("Failed to extract components:", error$1);
			return [];
		}
	}
	async sendTelemetry(payload) {
		try {
			const response = await fetch(TELEMETRY_CONFIG.apiEndpoint, {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify(payload)
			});
			if (!response.ok) console.warn("Telemetry send failed:", response.status, response.statusText);
		} catch (error$1) {
			console.error("Telemetry send error:", error$1);
		}
	}
	calculateMean(values) {
		if (values.length === 0) return 0;
		return values.reduce((a$1, b$2) => a$1 + b$2, 0) / values.length;
	}
	calculateMedian(values) {
		if (values.length === 0) return 0;
		const sorted = [...values].sort((a$1, b$2) => a$1 - b$2);
		const mid = Math.floor(sorted.length / 2);
		if (sorted.length % 2 === 0) return (sorted[mid - 1] + sorted[mid]) / 2;
		else return sorted[mid];
	}
	calculatePercentile(values, percentile) {
		if (values.length === 0) return 0;
		const sorted = [...values].sort((a$1, b$2) => a$1 - b$2);
		const index = Math.ceil(percentile / 100 * sorted.length) - 1;
		return sorted[Math.max(0, index)];
	}
};
function shouldCollectTelemetry() {
	if (typeof window !== "undefined" && window.location?.search?.includes("telemetry=true")) return true;
	return Math.random() < TELEMETRY_CONFIG.samplingRate;
}
function isExternalUser() {
	if (typeof window === "undefined" || !window.location) return false;
	const hostname = window.location.hostname;
	return !hostname.includes("shaders.com") && hostname !== "localhost" && hostname !== "127.0.0.1";
}

//#endregion
//#region node_modules/shaders/dist/react/Shader.js
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime(), 1);
var OmbreContext = (0, import_react.createContext)(null);
var Shader = ({ children, hideNotice = false, style = {}, className = "",...rest }) => {
	const containerRef = (0, import_react.useRef)(null);
	const canvasRef = (0, import_react.useRef)(null);
	const rootId = (0, import_react.useMemo)(() => "ombre-root-" + Math.random().toString(36).substring(7), []);
	const rendererRef = (0, import_react.useRef)(null);
	if (rendererRef.current === null) rendererRef.current = shaderRenderer();
	const telemetryCollectorRef = (0, import_react.useRef)(null);
	const nodeRegister = (0, import_react.useMemo)(() => {
		return (id, fragmentNodeFunc, parentId, metadata, uniforms = null, componentDefinition$62 = null) => {
			if (fragmentNodeFunc === null) {
				try {
					rendererRef.current.removeNode(id);
				} catch (err) {
					console.warn("Error removing node:", err);
				}
				return;
			}
			try {
				rendererRef.current.registerNode(id, fragmentNodeFunc, parentId, metadata, uniforms, componentDefinition$62);
			} catch (err) {
				console.error("Error registering node:", err, {
					id,
					parentId,
					metadata
				});
			}
		};
	}, []);
	const uniformUpdate = (0, import_react.useMemo)(() => {
		return (nodeId, uniformName, value) => {
			try {
				rendererRef.current.updateUniformValue(nodeId, uniformName, value);
			} catch (err) {
				console.warn("Error updating uniform:", err);
			}
		};
	}, []);
	const metadataUpdate = (0, import_react.useMemo)(() => {
		return (nodeId, metadata) => {
			try {
				rendererRef.current.updateNodeMetadata(nodeId, metadata);
			} catch (err) {
				console.warn("Error updating metadata:", err);
			}
		};
	}, []);
	const contextValue = (0, import_react.useMemo)(() => {
		return {
			ombreParentId: rootId,
			ombreNodeRegister: nodeRegister,
			ombreUniformUpdate: uniformUpdate,
			ombreMetadataUpdate: metadataUpdate
		};
	}, [
		rootId,
		nodeRegister,
		uniformUpdate,
		metadataUpdate
	]);
	const isInitializedRef = (0, import_react.useRef)(false);
	const isInitializingRef = (0, import_react.useRef)(false);
	const isCleanedUpRef = (0, import_react.useRef)(false);
	const wasVisibleRef = (0, import_react.useRef)(false);
	const visibilityObserverRef = (0, import_react.useRef)(null);
	const initializeRenderer = async () => {
		const canvas = canvasRef.current;
		if (!canvas || isInitializedRef.current || isInitializingRef.current) return;
		isInitializingRef.current = true;
		try {
			const renderer = rendererRef.current;
			if (!renderer.isInitialized()) await renderer.initialize({ canvas });
			renderer.registerNode(rootId, ({ childNode }) => childNode || vec4(0, 0, 0, 0), null, null, {});
			isInitializedRef.current = true;
			isInitializingRef.current = false;
			if (!hideNotice) renderer.showLicenseWarning();
			if (isExternalUser() && shouldCollectTelemetry()) {
				telemetryCollectorRef.current = new TelemetryCollector(renderer);
				telemetryCollectorRef.current.start();
			}
		} catch (err) {
			console.error("[Shader] Initialization failed:", err);
			isInitializingRef.current = false;
			throw err;
		}
	};
	const setupVisibilityObserver = () => {
		const container = containerRef.current;
		if (!container || visibilityObserverRef.current) return;
		visibilityObserverRef.current = new IntersectionObserver((entries) => {
			const entry = entries[0];
			if (!entry) return;
			const rect = container.getBoundingClientRect();
			const isCurrentlyVisible = entry.isIntersecting && rect && rect.width > 0 && rect.height > 0;
			if (isCurrentlyVisible && !wasVisibleRef.current) {
				if (rendererRef.current.isInitialized()) rendererRef.current.startAnimation();
				else initializeRenderer().catch(console.error);
				wasVisibleRef.current = true;
			} else if (!isCurrentlyVisible && wasVisibleRef.current) {
				rendererRef.current.stopAnimation();
				wasVisibleRef.current = false;
			}
		}, { threshold: 0 });
		visibilityObserverRef.current.observe(container);
	};
	(0, import_react.useEffect)(() => {
		isCleanedUpRef.current = false;
		const container = containerRef.current;
		if (!container) return;
		const rect = container.getBoundingClientRect();
		if (rect.width > 0 && rect.height > 0) {
			initializeRenderer().catch(console.error);
			wasVisibleRef.current = true;
		} else wasVisibleRef.current = false;
		setupVisibilityObserver();
		return () => {
			if (isCleanedUpRef.current) return;
			isCleanedUpRef.current = true;
			if (telemetryCollectorRef.current) {
				telemetryCollectorRef.current.stop();
				telemetryCollectorRef.current = null;
			}
			if (visibilityObserverRef.current) {
				visibilityObserverRef.current.disconnect();
				visibilityObserverRef.current = null;
			}
			if (rendererRef.current && isInitializedRef.current) try {
				rendererRef.current.cleanup();
			} catch (err) {
				console.warn("[Shader] Error during cleanup:", err);
			}
			isInitializedRef.current = false;
			isInitializingRef.current = false;
		};
	}, []);
	(0, import_react.useEffect)(() => {
		if (!hideNotice && rendererRef.current && isInitializedRef.current) try {
			rendererRef.current.showLicenseWarning();
		} catch (err) {}
	}, [hideNotice]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: contextValue,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			ref: containerRef,
			className: "shader" + (className ? " " + className : ""),
			style,
			...rest,
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("canvas", {
				"data-renderer": "shaders",
				ref: canvasRef,
				style: {
					width: "100%",
					height: "100%",
					display: "block"
				}
			}), children]
		})
	});
};
var Shader_default = Shader;

//#endregion
//#region node_modules/shaders/dist/core/AngularBlur-CuwAjUOA.js
var componentDefinition$61 = {
	name: "AngularBlur",
	category: "Blurs",
	description: "Radial motion blur rotating around a center point",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 20,
			description: "Intensity of the angular blur effect",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Blur Intensity"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the rotation",
			ui: {
				type: "position",
				label: "Center Position"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const center = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const angle = uniforms.intensity.uniform.mul(.005);
		return Fn(() => {
			const initialCoord = screenUV.sub(center);
			const total = vec4(0).toVar();
			const totalWeight = float(0).toVar();
			const angleStep = angle.div(float(31));
			for (let i = 0; i < 32; i++) {
				const t = float(i).div(float(31)).sub(.5).mul(2);
				const weight = float(1).div(float(2.506628)).mul(float(-.5).mul(t).mul(t).div(float(.64)).exp());
				const currentAngle = angleStep.mul(float(i));
				const cosAngle = cos(currentAngle);
				const sinAngle = sin(currentAngle);
				const sampleCoord = vec2(initialCoord.x.mul(cosAngle).sub(initialCoord.y.mul(sinAngle)), initialCoord.x.mul(sinAngle).add(initialCoord.y.mul(cosAngle))).add(center);
				const sample$2 = childTexture.sample(sampleCoord).mul(weight);
				total.assign(total.add(sample$2));
				totalWeight.assign(totalWeight.add(weight));
			}
			return total.div(totalWeight);
		})();
	}
};

//#endregion
//#region node_modules/shaders/dist/react/AngularBlur.js
function computeEffectiveProps$61(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$62 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$61 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$61 && componentDefinition$61.props) Object.entries(componentDefinition$61.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$61[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$61 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$61.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$61(props, defaultProps$61);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$62,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$61, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$61.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$61);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var AngularBlur_default = OmbreComponent$61;

//#endregion
//#region node_modules/shaders/dist/core/Ascii-Dxk6VaBp.js
var componentDefinition$60 = {
	name: "Ascii",
	category: "Stylize",
	description: "Convert imagery to ASCII character art",
	requiresRTT: true,
	requiresChild: true,
	props: {
		characters: {
			default: "@%#*+=-:.",
			description: "Characters to use for ASCII effect (light to dark)",
			ui: {
				type: "text",
				label: "Characters"
			}
		},
		cellSize: {
			default: 30,
			description: "Size of each ASCII character cell in pixels",
			ui: {
				type: "range",
				min: 8,
				max: 100,
				step: 1,
				label: "Cell Size"
			}
		},
		fontFamily: {
			default: "JetBrains Mono",
			description: "Font family for characters",
			ui: {
				type: "select",
				options: [
					{
						label: "JetBrains Mono",
						value: "JetBrains Mono"
					},
					{
						label: "Fira Code",
						value: "Fira Code"
					},
					{
						label: "Source Code Pro",
						value: "Source Code Pro"
					},
					{
						label: "IBM Plex Mono",
						value: "IBM Plex Mono"
					},
					{
						label: "Space Mono",
						value: "Space Mono"
					},
					{
						label: "Roboto Mono",
						value: "Roboto Mono"
					},
					{
						label: "Courier Prime",
						value: "Courier Prime"
					}
				],
				label: "Font Family"
			}
		},
		spacing: {
			default: 1,
			description: "Character size within each cell (1.0 = optimal size, 0.0 = smallest)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .05,
				label: "Character Size"
			},
			transform: (value) => .1 + value * 1.4
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup, onBeforeRender }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const ATLAS_TEXTURE_SIZE = 2048;
		const GOOGLE_FONTS_MAP = {
			"JetBrains Mono": "JetBrains+Mono",
			"Fira Code": "Fira+Code",
			"Source Code Pro": "Source+Code+Pro",
			"IBM Plex Mono": "IBM+Plex+Mono",
			"Space Mono": "Space+Mono",
			"Roboto Mono": "Roboto+Mono",
			"Courier Prime": "Courier+Prime"
		};
		const loadedFonts = /* @__PURE__ */ new Set();
		async function loadGoogleFont(fontFamily) {
			if (loadedFonts.has(fontFamily)) return;
			if (!GOOGLE_FONTS_MAP[fontFamily]) return;
			const googleFontName = GOOGLE_FONTS_MAP[fontFamily];
			if (!document.querySelector(`link[href*="${googleFontName}"]`)) {
				const link = document.createElement("link");
				link.rel = "stylesheet";
				link.href = `https://fonts.googleapis.com/css2?family=${googleFontName}:wght@400&display=swap`;
				document.head.appendChild(link);
			}
			try {
				if (document.fonts && document.fonts.load) {
					const specs = [
						`400 12px "${fontFamily}"`,
						`12px "${fontFamily}"`,
						`400 12px ${fontFamily}`,
						`12px ${fontFamily}`
					];
					for (const spec of specs) try {
						await document.fonts.load(spec);
						break;
					} catch (e) {}
					await new Promise((resolve) => setTimeout(resolve, 500));
					loadedFonts.add(fontFamily);
				} else {
					await new Promise((resolve) => setTimeout(resolve, 1e3));
					loadedFonts.add(fontFamily);
				}
			} catch (error$1) {}
		}
		let reusableCanvas = null;
		let reusableCtx = null;
		let reusableDataBuffer = null;
		const createCharacterAtlas = async (characters, cellSize, fontFamily, spacing) => {
			if (!characters || characters.length === 0) throw new Error("Characters string cannot be empty");
			const charCount$1 = characters.length;
			const atlasSize$1 = Math.max(2, Math.ceil(Math.sqrt(charCount$1)));
			const baseAtlasCellSize = 128;
			const spacingMultiplier = Math.max(1, 2 / spacing);
			const actualCellSize = Math.min(baseAtlasCellSize * spacingMultiplier, ATLAS_TEXTURE_SIZE / atlasSize$1);
			const fontSize = actualCellSize * .75;
			if (!reusableCanvas) {
				reusableCanvas = document.createElement("canvas");
				reusableCanvas.width = ATLAS_TEXTURE_SIZE;
				reusableCanvas.height = ATLAS_TEXTURE_SIZE;
				reusableCtx = reusableCanvas.getContext("2d");
				if (!reusableCtx) {
					console.error("[Ascii] Failed to create 2D canvas context for character atlas");
					throw new Error("Ascii shader: Canvas 2D context unavailable");
				}
			}
			if (!reusableCtx) {
				console.error("[Ascii] Canvas context unexpectedly null during atlas creation");
				throw new Error("Ascii shader: Canvas 2D context unavailable");
			}
			const ctx = reusableCtx;
			ctx.clearRect(0, 0, ATLAS_TEXTURE_SIZE, ATLAS_TEXTURE_SIZE);
			ctx.fillStyle = "#ffffff";
			ctx.font = `${fontSize}px "${fontFamily}", ${fontFamily}, monospace`;
			if (!ctx.font.includes(fontFamily) && !ctx.font.includes("IBM") && !ctx.font.includes("Plex")) ctx.font = `${fontSize}px ${fontFamily}, monospace`;
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			for (let i = 0; i < charCount$1; i++) {
				const char = characters[i];
				const row = Math.floor(i / atlasSize$1);
				const x = i % atlasSize$1 * actualCellSize + actualCellSize / 2;
				const y = row * actualCellSize + actualCellSize / 2;
				ctx.fillText(char, x, y);
			}
			const imageData = ctx.getImageData(0, 0, ATLAS_TEXTURE_SIZE, ATLAS_TEXTURE_SIZE);
			if (!reusableDataBuffer) reusableDataBuffer = new Uint8Array(ATLAS_TEXTURE_SIZE * ATLAS_TEXTURE_SIZE * 4);
			reusableDataBuffer.set(imageData.data);
			return {
				data: reusableDataBuffer,
				width: ATLAS_TEXTURE_SIZE,
				height: ATLAS_TEXTURE_SIZE,
				atlasSize: atlasSize$1,
				cellSize,
				charCount: charCount$1,
				characters,
				fontFamily,
				uvScale: atlasSize$1 * actualCellSize / ATLAS_TEXTURE_SIZE
			};
		};
		const defaultCharacters = componentDefinition$60.props.characters.default;
		const defaultCellSize = componentDefinition$60.props.cellSize.default;
		const defaultFontFamily = componentDefinition$60.props.fontFamily.default;
		const defaultSpacing = componentDefinition$60.props.spacing.transform ? componentDefinition$60.props.spacing.transform(componentDefinition$60.props.spacing.default) : componentDefinition$60.props.spacing.default;
		const initialCharacters = uniforms?.characters?.uniform?.value ?? defaultCharacters;
		const initialCellSize = uniforms?.cellSize?.uniform?.value ?? defaultCellSize;
		const initialFontFamily = uniforms?.fontFamily?.uniform?.value ?? defaultFontFamily;
		const initialSpacing = uniforms?.spacing?.uniform?.value ?? defaultSpacing;
		let atlasData = {
			data: new Uint8Array(ATLAS_TEXTURE_SIZE * ATLAS_TEXTURE_SIZE * 4),
			width: ATLAS_TEXTURE_SIZE,
			height: ATLAS_TEXTURE_SIZE,
			atlasSize: 3,
			cellSize: initialCellSize,
			charCount: initialCharacters.length,
			characters: initialCharacters,
			fontFamily: initialFontFamily,
			uvScale: 1
		};
		const atlasTexture = new DataTexture(atlasData.data, ATLAS_TEXTURE_SIZE, ATLAS_TEXTURE_SIZE, RGBAFormat, UnsignedByteType);
		atlasTexture.minFilter = NearestFilter;
		atlasTexture.magFilter = NearestFilter;
		atlasTexture.generateMipmaps = false;
		atlasTexture.needsUpdate = true;
		const atlasField = texture(atlasTexture);
		const charCountUniform = uniform(atlasData.charCount);
		const cellSizeUniform = uniform(atlasData.cellSize);
		const atlasScaleUniform = uniform(atlasData.uvScale);
		let lastCharacters = initialCharacters;
		let lastCellSize = initialCellSize;
		let lastFontFamily = initialFontFamily;
		let lastSpacing = initialSpacing;
		const initializeAtlas = async () => {
			const currentCharacters = uniforms?.characters?.uniform?.value ?? lastCharacters;
			const currentCellSize = uniforms?.cellSize?.uniform?.value ?? lastCellSize;
			const currentFontFamily = uniforms?.fontFamily?.uniform?.value ?? lastFontFamily;
			const currentSpacing = uniforms?.spacing?.uniform?.value ?? lastSpacing;
			atlasData = await createCharacterAtlas(currentCharacters, currentCellSize, currentFontFamily, currentSpacing);
			atlasTexture.image.data = atlasData.data;
			atlasTexture.needsUpdate = true;
			charCountUniform.value = atlasData.charCount;
			cellSizeUniform.value = atlasData.cellSize;
			atlasScaleUniform.value = atlasData.uvScale;
			lastCharacters = currentCharacters;
			lastCellSize = currentCellSize;
			lastFontFamily = currentFontFamily;
			lastSpacing = currentSpacing;
		};
		setTimeout(() => {
			initializeAtlas().catch((error$1) => {
				console.error("Failed to initialize atlas:", error$1);
			});
			loadGoogleFont(uniforms?.fontFamily?.uniform?.value ?? initialFontFamily).then(() => {
				initializeAtlas().catch((error$1) => {
					console.error("Failed to update atlas with custom font:", error$1);
				});
			}).catch((error$1) => {
				console.error("Failed to load font:", error$1);
			});
		}, 0);
		let lastUpdateTime = 0;
		let isUpdating = false;
		onBeforeRender(() => {
			const now = Date.now();
			if (now - lastUpdateTime < 16 || isUpdating) return;
			const currentCharacters = uniforms.characters?.uniform?.value ?? lastCharacters;
			const currentCellSize = uniforms.cellSize?.uniform?.value ?? lastCellSize;
			const currentFontFamily = uniforms.fontFamily?.uniform?.value ?? lastFontFamily;
			const currentSpacing = uniforms.spacing?.uniform?.value ?? lastSpacing;
			if (!currentCharacters || currentCharacters.length === 0) return;
			if (currentCharacters !== lastCharacters || currentCellSize !== lastCellSize || currentFontFamily !== lastFontFamily || currentSpacing !== lastSpacing) {
				lastUpdateTime = now;
				isUpdating = true;
				createCharacterAtlas(currentCharacters, currentCellSize, currentFontFamily, currentSpacing).then((newAtlasData) => {
					atlasData = newAtlasData;
					atlasTexture.image.data = atlasData.data;
					atlasTexture.needsUpdate = true;
					charCountUniform.value = atlasData.charCount;
					cellSizeUniform.value = atlasData.cellSize;
					atlasScaleUniform.value = atlasData.uvScale;
					lastCharacters = currentCharacters;
					lastCellSize = currentCellSize;
					lastFontFamily = currentFontFamily;
					lastSpacing = currentSpacing;
					isUpdating = false;
				}).catch((error$1) => {
					console.error("Failed to update atlas:", error$1);
					isUpdating = false;
				});
			}
		});
		onCleanup(() => {
			atlasTexture.dispose();
			if (reusableCanvas) {
				reusableCanvas.width = 0;
				reusableCanvas.height = 0;
				reusableCanvas = null;
				reusableCtx = null;
			}
			reusableDataBuffer = null;
		});
		const effectiveCellSize = cellSizeUniform.mul(1.5);
		const mainGridSize = viewportSize.div(effectiveCellSize);
		const gridCoords = screenUV.mul(mainGridSize);
		const cellCoords = floor(gridCoords);
		const rawCellUV = fract(gridCoords);
		const characterSize = uniforms.spacing?.uniform ?? uniform(initialSpacing);
		const center = vec2(.5);
		const centeredUV = rawCellUV.sub(center);
		const cellUV = centeredUV.div(characterSize).add(center);
		const isOutsideBounds = any(greaterThan(abs(centeredUV), vec2(characterSize.mul(.5))));
		const cellCenter = cellCoords.add(vec2(.5)).div(mainGridSize);
		const cellColor = childTexture.sample(cellCenter);
		const rawBrightness = dot(cellColor.rgb, vec3(.299, .587, .114));
		const charCount = charCountUniform;
		const charIndex = floor(rawBrightness.mul(.8).add(.1).mul(charCount).min(charCount.sub(1e-4)));
		const atlasSize = ceil(sqrt(charCount));
		const atlasCol = charIndex.mod(atlasSize);
		const atlasRow = floor(charIndex.div(atlasSize));
		const atlasCellSize = float(1).div(atlasSize).mul(atlasScaleUniform);
		const atlasSampleUV = vec2(atlasCol, atlasRow).mul(atlasCellSize).add(cellUV.mul(atlasCellSize));
		const asciiChar = atlasField.sample(atlasSampleUV);
		const isBackground = dot(asciiChar.rgb, vec3(.299, .587, .114)).lessThan(.1);
		return vec4(asciiChar.rgb.mul(cellColor.rgb), select(or(isBackground, isOutsideBounds), float(0), cellColor.a));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Ascii.js
function computeEffectiveProps$60(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$61 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$60 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$60 && componentDefinition$60.props) Object.entries(componentDefinition$60.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$60[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$60 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$60.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$60(props, defaultProps$60);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$61,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$60, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$60.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$60);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Ascii_default = OmbreComponent$60;

//#endregion
//#region node_modules/shaders/dist/core/colorMixing-CZPFmiT4.js
var p3ToSRGB = (p3) => {
	return vec3(p3.x.mul(1.2249401).sub(p3.y.mul(.2249404)).sub(p3.z.mul(0)), p3.x.mul(-.0420569).add(p3.y.mul(1.0420571)).add(p3.z.mul(0)), p3.x.mul(-.0196376).sub(p3.y.mul(.0786361)).add(p3.z.mul(1.0982735)));
};
var sRGBToP3 = (srgb) => {
	return vec3(srgb.x.mul(.8224621).add(srgb.y.mul(.177538)).add(srgb.z.mul(0)), srgb.x.mul(.0331941).add(srgb.y.mul(.9668058)).add(srgb.z.mul(0)), srgb.x.mul(.0170826).add(srgb.y.mul(.0723974)).add(srgb.z.mul(.9105199)));
};
var rgbToOklab = (rgb) => {
	const r = rgb.x;
	const g$1 = rgb.y;
	const b$2 = rgb.z;
	const l = r.mul(.4122214708).add(g$1.mul(.5363325363)).add(b$2.mul(.0514459929));
	const m$1 = r.mul(.2119034982).add(g$1.mul(.6806995451).add(b$2.mul(.1073969566)));
	const s = r.mul(.0883024619).add(g$1.mul(.2817188376)).add(b$2.mul(.6299787005));
	const l_ = pow(l, float(1 / 3));
	const m_ = pow(m$1, float(1 / 3));
	const s_ = pow(s, float(1 / 3));
	return vec3(l_.mul(.2104542553).add(m_.mul(.793617785)).sub(s_.mul(.0040720468)), l_.mul(1.9779984951).sub(m_.mul(2.428592205)).add(s_.mul(.4505937099)), l_.mul(.0259040371).add(m_.mul(.7827717662)).sub(s_.mul(.808675766)));
};
var oklabToRgb = (lab$1) => {
	const L = lab$1.x;
	const a$1 = lab$1.y;
	const b$2 = lab$1.z;
	const l_ = L.add(a$1.mul(.3963377774)).add(b$2.mul(.2158037573));
	const m_ = L.sub(a$1.mul(.1055613458)).sub(b$2.mul(.0638541728));
	const s_ = L.sub(a$1.mul(.0894841775)).sub(b$2.mul(1.291485548));
	const l = pow(l_, float(3));
	const m$1 = pow(m_, float(3));
	const s = pow(s_, float(3));
	return vec3(l.mul(4.0767416621).sub(m$1.mul(3.3077115913)).add(s.mul(.2309699292)), l.mul(-1.2684380046).add(m$1.mul(2.6097574011)).sub(s.mul(.3413193965)), l.mul(-.0041960863).sub(m$1.mul(.7034186147)).add(s.mul(1.707614701)));
};
var oklabToOklch = (lab$1) => {
	const L = lab$1.x;
	const a$1 = lab$1.y;
	const b$2 = lab$1.z;
	return vec3(L, sqrt(a$1.mul(a$1).add(b$2.mul(b$2))), atan(b$2, a$1));
};
var oklchToOklab = (lch$1) => {
	const L = lch$1.x;
	const C = lch$1.y;
	const h = lch$1.z;
	return vec3(L, C.mul(cos(h)), C.mul(sin(h)));
};
var mixColors = (colorA, colorB, t, colorSpaceMode) => {
	const p3A = vec3(colorA.x, colorA.y, colorA.z);
	const p3B = vec3(colorB.x, colorB.y, colorB.z);
	const alphaA = colorA.w;
	const alphaB = colorB.w;
	const weightA = alphaA.mul(float(1).sub(t));
	const weightB = alphaB.mul(t);
	const totalWeight = weightA.add(weightB);
	const safeWeight = max(totalWeight, float(.001));
	const alphaWeightedMix = (rgbA, rgbB) => {
		return rgbA.mul(weightA).add(rgbB.mul(weightB)).div(safeWeight);
	};
	const linearMix = alphaWeightedMix(p3A, p3B);
	const srgbA = p3ToSRGB(p3A);
	const srgbB = p3ToSRGB(p3B);
	const oklabA = rgbToOklab(srgbA);
	const oklabB = rgbToOklab(srgbB);
	const oklchResult = sRGBToP3(oklabToRgb(oklchToOklab(alphaWeightedMix(oklabToOklch(oklabA), oklabToOklch(oklabB)))));
	const oklabResult = sRGBToP3(oklabToRgb(alphaWeightedMix(oklabA, oklabB)));
	const isMode1OrHigher = colorSpaceMode.greaterThanEqual(float(.5));
	const rgb = colorSpaceMode.greaterThanEqual(float(1.5)).select(oklabResult, isMode1OrHigher.select(oklchResult, linearMix));
	const alpha = totalWeight;
	return vec4(rgb.x, rgb.y, rgb.z, alpha);
};

//#endregion
//#region node_modules/shaders/dist/core/Beam-CbG4MkLo.js
var componentDefinition$59 = {
	name: "Beam",
	category: "Base Layers",
	description: "A beam of light from one point to another.",
	props: {
		startPosition: {
			default: {
				x: .2,
				y: .5
			},
			transform: transformPosition,
			description: "Starting point of the beam",
			ui: {
				type: "position",
				label: "Start Position"
			}
		},
		endPosition: {
			default: {
				x: .8,
				y: .5
			},
			transform: transformPosition,
			description: "Ending point of the beam",
			ui: {
				type: "position",
				label: "End Position"
			}
		},
		startThickness: {
			default: .2,
			description: "Thickness at the start of the beam",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Start Thickness"
			}
		},
		endThickness: {
			default: .2,
			description: "Thickness at the end of the beam",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "End Thickness"
			}
		},
		startSoftness: {
			default: .5,
			description: "Edge softness at the start of the beam",
			ui: {
				type: "range",
				min: 0,
				max: 50,
				step: .01,
				label: "Start Softness"
			}
		},
		endSoftness: {
			default: .5,
			description: "Edge softness at the end of the beam",
			ui: {
				type: "range",
				min: 0,
				max: 20,
				step: .01,
				label: "End Softness"
			}
		},
		insideColor: {
			default: "#FF0000",
			transform: transformColor,
			description: "Color at the center of the beam",
			ui: {
				type: "color",
				label: "Inside Color"
			}
		},
		outsideColor: {
			default: "#0000FF",
			transform: transformColor,
			description: "Color at the edges of the beam",
			ui: {
				type: "color",
				label: "Outside Color"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms }) => {
		const baseUV = screenUV;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const startPos = vec2(uniforms.startPosition.uniform.x, uniforms.startPosition.uniform.y.oneMinus());
		const endPos = vec2(uniforms.endPosition.uniform.x, uniforms.endPosition.uniform.y.oneMinus());
		const aspectCorrectedStart = vec2(startPos.x.mul(aspect$1), startPos.y);
		const aspectCorrectedEnd = vec2(endPos.x.mul(aspect$1), endPos.y);
		const aspectCorrectedUV = vec2(baseUV.x.mul(aspect$1), baseUV.y);
		const lineVec = vec2(aspectCorrectedEnd.x.sub(aspectCorrectedStart.x), aspectCorrectedEnd.y.sub(aspectCorrectedStart.y));
		const toPoint = vec2(aspectCorrectedUV.x.sub(aspectCorrectedStart.x), aspectCorrectedUV.y.sub(aspectCorrectedStart.y));
		const dotProduct = toPoint.x.mul(lineVec.x).add(toPoint.y.mul(lineVec.y));
		const lineLengthSq = lineVec.x.mul(lineVec.x).add(lineVec.y.mul(lineVec.y));
		const t = clamp(dotProduct.div(max(lineLengthSq, float(1e-4))), float(0), float(1));
		const closestPoint = vec2(aspectCorrectedStart.x.add(lineVec.x.mul(t)), aspectCorrectedStart.y.add(lineVec.y.mul(t)));
		const distVec = vec2(aspectCorrectedUV.x.sub(closestPoint.x), aspectCorrectedUV.y.sub(closestPoint.y));
		const distance$1$1 = sqrt(distVec.x.mul(distVec.x).add(distVec.y.mul(distVec.y)));
		const thickness$2 = mix(uniforms.startThickness.uniform.mul(.25), uniforms.endThickness.uniform.mul(.25), t);
		const startSoft = uniforms.startSoftness.uniform;
		const endSoft = uniforms.endSoftness.uniform;
		const softness = mix(startSoft, endSoft, t);
		const normalizedDist = distance$1$1.div(max(thickness$2, float(1e-4)));
		const edgeEnd = float(1).add(softness);
		const alpha = pow(float(1).sub(smoothstep(float(1), edgeEnd, normalizedDist)), float(1).add(softness.mul(1.5)));
		const colorT = smoothstep(float(1).sub(softness), float(1).add(softness), normalizedDist);
		const insideCol = uniforms.insideColor.uniform;
		const outsideCol = uniforms.outsideColor.uniform;
		const beamColorRGB = mixColors(insideCol, outsideCol, colorT, uniforms.colorSpace.uniform).rgb;
		return vec4(beamColorRGB, insideCol.a.add(outsideCol.a).div(float(2)).mul(alpha));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Beam.js
function computeEffectiveProps$59(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$60 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$59 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$59 && componentDefinition$59.props) Object.entries(componentDefinition$59.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$59[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$59 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$59.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$59(props, defaultProps$59);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$60,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$59, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$59.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$59);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Beam_default = OmbreComponent$59;

//#endregion
//#region node_modules/shaders/dist/core/Blob-Ck1tVOL_.js
var componentDefinition$58 = {
	name: "Blob",
	category: "Base Layers",
	description: "Organic animated blob with 3D lighting and gradients",
	props: {
		colorA: {
			default: "#ff6b35",
			transform: transformColor,
			description: "Primary color of the blob",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#e91e63",
			transform: transformColor,
			description: "Secondary color of the blob",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		size: {
			default: .5,
			description: "Size of the blob",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Size"
			}
		},
		deformation: {
			default: .5,
			description: "How organic and blobby the shape is (0 = circle, 1 = very blobby)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Deformation"
			}
		},
		softness: {
			default: .5,
			description: "Softness of the blob edges (combines edge width and transition curve)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Softness"
			}
		},
		highlightIntensity: {
			default: .5,
			description: "Intensity of specular highlight effect",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Highlight Intensity"
			}
		},
		highlightX: {
			default: .3,
			description: "Light direction X component",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Highlight X"
			}
		},
		highlightY: {
			default: -.3,
			description: "Light direction Y component",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Highlight Y"
			}
		},
		highlightZ: {
			default: .4,
			description: "Light direction Z component",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Highlight Z"
			}
		},
		highlightColor: {
			default: "#ffe11a",
			transform: transformColor,
			description: "Color of the specular highlight",
			ui: {
				type: "color",
				label: "Highlight Color"
			}
		},
		speed: {
			default: .5,
			description: "Animation speed",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .1,
				label: "Speed"
			}
		},
		seed: {
			default: 1,
			description: "Adjusts the starting state, useful for variation",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Seed"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the blob",
			ui: {
				type: "position",
				label: "Center Position"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const baseUV = screenUV;
		const animTime = createAnimatedTime(params, uniforms.speed, uniforms.seed);
		const colorA = uniforms.colorA.uniform;
		const colorB = uniforms.colorB.uniform;
		const size = uniforms.size.uniform;
		const deformation = uniforms.deformation.uniform;
		const softness = uniforms.softness.uniform;
		const highlightIntensity = uniforms.highlightIntensity.uniform;
		const highlightX = uniforms.highlightX.uniform;
		const highlightY = uniforms.highlightY.uniform;
		const highlightZ = uniforms.highlightZ.uniform;
		const highlightColor = uniforms.highlightColor.uniform;
		const edgeWidth = softness.mul(float(.3));
		const edgeCurve = softness.mul(float(2)).add(float(.5));
		const edgeComplexity = float(.5);
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(baseUV.x.mul(aspect$1), baseUV.y);
		const centerPos = vec2(uniforms.center.uniform.x.mul(aspect$1), uniforms.center.uniform.y.oneMinus());
		const uv$1$2 = aspectCorrectedUV.sub(centerPos);
		const dist = length(uv$1$2);
		const baseRadius = size;
		const noiseScale = float(4);
		const noise1 = sin(uv$1$2.x.mul(noiseScale.mul(float(.8))).add(animTime.mul(float(.8)))).mul(sin(uv$1$2.y.mul(noiseScale.mul(float(.7))).add(animTime.mul(float(.6))))).add(sin(uv$1$2.x.mul(noiseScale.mul(float(1.2))).sub(uv$1$2.y.mul(noiseScale.mul(float(.9))).add(animTime.mul(float(.4)))))).mul(float(.15)).mul(deformation);
		const noise2 = sin(uv$1$2.x.mul(noiseScale.mul(float(1.4))).sub(animTime.mul(float(.5)))).mul(sin(uv$1$2.y.mul(noiseScale.mul(float(1.1))).add(animTime.mul(float(.7))))).mul(float(.12)).mul(deformation).mul(smoothstep(float(.15), float(.25), edgeComplexity));
		const noise3 = sin(uv$1$2.x.mul(noiseScale.mul(float(1.8))).add(uv$1$2.y.mul(noiseScale.mul(float(1.6))).add(animTime.mul(float(.3))))).add(sin(uv$1$2.x.mul(noiseScale.mul(float(.6))).sub(animTime.mul(float(.9))))).mul(float(.1)).mul(deformation).mul(smoothstep(float(.3), float(.4), edgeComplexity));
		const noise4 = sin(uv$1$2.x.mul(noiseScale.mul(float(2.2))).add(animTime.mul(float(.2)))).mul(sin(uv$1$2.y.mul(noiseScale.mul(float(1.9))).sub(animTime.mul(float(.8))))).mul(float(.08)).mul(deformation).mul(smoothstep(float(.45), float(.55), edgeComplexity));
		const noise5 = sin(uv$1$2.x.mul(noiseScale.mul(float(2.8))).sub(uv$1$2.y.mul(noiseScale.mul(float(2.4))).add(animTime.mul(float(.6))))).mul(float(.06)).mul(deformation).mul(smoothstep(float(.6), float(.7), edgeComplexity));
		const noise6 = sin(uv$1$2.x.mul(noiseScale.mul(float(3.2))).add(animTime.mul(float(1.1)))).add(sin(uv$1$2.y.mul(noiseScale.mul(float(3.5))).sub(animTime.mul(float(.4))))).mul(float(.04)).mul(deformation).mul(smoothstep(float(.75), float(.85), edgeComplexity));
		const noiseAmount = noise1.add(noise2).add(noise3).add(noise4).add(noise5).add(noise6);
		const organicRadius = baseRadius.add(noiseAmount);
		const blobMask = pow(smoothstep(organicRadius.add(edgeWidth), organicRadius.sub(edgeWidth), dist), edgeCurve);
		const distFromCenter = length(uv$1$2);
		const sphereRadius = organicRadius;
		const normalTilt = smoothstep(float(0), sphereRadius, distFromCenter);
		const fakeZ = float(1).sub(normalTilt.mul(float(.1)));
		const surfaceNormal = normalize(vec3(uv$1$2.x.mul(normalTilt.add(float(.2))), uv$1$2.y.mul(normalTilt.add(float(.2))), fakeZ));
		const lightDir = normalize(vec3(highlightX, highlightY, highlightZ));
		const viewDir = vec3(float(0), float(0), float(1));
		const reflectDir = reflect(lightDir.negate(), surfaceNormal);
		const specularPower = float(32);
		const specular = pow(max(float(0), dot(reflectDir, viewDir)), specularPower);
		const curvatureBoost = normalTilt.mul(float(.5)).add(float(.5));
		const finalHighlight = specular.mul(curvatureBoost).mul(highlightIntensity).mul(blobMask);
		const posX = uv$1$2.x.mul(float(3));
		const posY = uv$1$2.y.mul(float(3));
		const colorNoise1 = sin(posX.add(animTime.mul(float(.4)))).mul(sin(posY.add(animTime.mul(float(.3))))).add(sin(posX.mul(float(.7)).add(posY.mul(float(.8))).add(animTime.mul(float(.2))))).mul(float(.5)).add(float(.5));
		const colorNoise2 = sin(posX.mul(float(1.3)).sub(animTime.mul(float(.5)))).mul(sin(posY.mul(float(1.1)).add(animTime.mul(float(.6))))).add(sin(posX.mul(float(.5)).sub(posY.mul(float(.6)).sub(animTime.mul(float(.3)))))).mul(float(.5)).add(float(.5));
		const combinedNoise = colorNoise1.mul(float(.6)).add(colorNoise2.mul(float(.4)));
		const finalColorRGB = mixColors(colorA, colorB, smoothstep(float(.1), float(.9), combinedNoise), uniforms.colorSpace.uniform).rgb;
		const avgAlpha = colorA.a.add(colorB.a).div(float(2));
		const highlightContribution = highlightColor.rgb.mul(finalHighlight);
		return vec4(finalColorRGB.add(highlightContribution), avgAlpha.mul(blobMask));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Blob.js
function computeEffectiveProps$58(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$59 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$58 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$58 && componentDefinition$58.props) Object.entries(componentDefinition$58.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$58[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$58 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$58.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$58(props, defaultProps$58);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$59,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$58, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$58.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$58);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Blob_default = OmbreComponent$58;

//#endregion
//#region node_modules/shaders/dist/core/Blur-k37gOaRA.js
var componentDefinition$57 = {
	name: "Blur",
	category: "Blurs",
	description: "A simple Gaussian blur effect",
	requiresRTT: true,
	requiresChild: true,
	props: { intensity: {
		default: 50,
		description: "Intensity of the blur effect",
		ui: {
			type: "range",
			min: 0,
			max: 100,
			step: 1,
			label: "Intensity"
		}
	} },
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const weights = [
			.056,
			.135,
			.278,
			.487,
			.726,
			.923,
			1,
			.923,
			.726,
			.487,
			.278,
			.135,
			.056
		];
		const weightSum = 6.214;
		const scaledIntensity = uniforms.intensity.uniform.mul(.06);
		const horizontalTexture = convertToTexture(Fn(() => {
			const uv$1$2 = screenUV;
			const blurRadius = scaledIntensity;
			const pixelSize = vec2(1).div(viewportSize);
			const total = vec4(0).toVar();
			for (let x = -6; x <= 6; x++) {
				const weight = float(weights[x + 6] / weightSum);
				const offset = vec2(float(x), float(0)).mul(blurRadius).mul(pixelSize);
				const sampleCoord = uv$1$2.add(offset);
				const sample$2 = childTexture.sample(sampleCoord).mul(weight);
				total.assign(total.add(sample$2));
			}
			return total;
		})());
		onCleanup(() => {
			if (horizontalTexture?.renderTarget?.dispose) horizontalTexture.renderTarget.dispose();
		});
		return Fn(() => {
			const uv$1$2 = screenUV;
			const blurRadius = scaledIntensity;
			const pixelSize = vec2(1).div(viewportSize);
			const total = vec4(0).toVar();
			for (let y = -6; y <= 6; y++) {
				const weight = float(weights[y + 6] / weightSum);
				const offset = vec2(float(0), float(y)).mul(blurRadius).mul(pixelSize);
				const sampleCoord = uv$1$2.add(offset);
				const sample$2 = horizontalTexture.sample(sampleCoord).mul(weight);
				total.assign(total.add(sample$2));
			}
			return total;
		})();
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Blur.js
function computeEffectiveProps$57(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$58 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$57 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$57 && componentDefinition$57.props) Object.entries(componentDefinition$57.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$57[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$57 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$57.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$57(props, defaultProps$57);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$58,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$57, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$57.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$57);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Blur_default = OmbreComponent$57;

//#endregion
//#region node_modules/shaders/dist/core/BrightnessContrast-CaErceqR.js
var componentDefinition$56 = {
	name: "BrightnessContrast",
	category: "Adjustments",
	description: "Adjust brightness and contrast of the image",
	requiresChild: true,
	props: {
		brightness: {
			default: 0,
			description: "Brightness adjustment (-1 to 1)",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Brightness"
			}
		},
		contrast: {
			default: 0,
			description: "Contrast adjustment (-1 to 1)",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Contrast"
			},
			transform: (value) => value + 1
		}
	},
	fragmentNode: ({ uniforms, childNode }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Brightness Contrast shader.");
			return vec4(0);
		}
		const brightness = uniforms.brightness.uniform;
		const contrast$1 = uniforms.contrast.uniform;
		return vec4(vec3(childNode.r, childNode.g, childNode.b).sub(.5).mul(contrast$1).add(.5).add(brightness), childNode.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/BrightnessContrast.js
function computeEffectiveProps$56(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$57 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$56 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$56 && componentDefinition$56.props) Object.entries(componentDefinition$56.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$56[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$56 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$56.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$56(props, defaultProps$56);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$57,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$56, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$56.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$56);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var BrightnessContrast_default = OmbreComponent$56;

//#endregion
//#region node_modules/shaders/dist/core/Bulge-BVcWo6On.js
var componentDefinition$55 = {
	name: "Bulge",
	category: "Distortions",
	description: "Magnify or pinch content around a center point",
	requiresRTT: true,
	requiresChild: true,
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the bulge effect",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		strength: {
			default: 1,
			description: "The intensity of the bulge effect (positive = bulge out, negative = pinch in)",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Strength"
			}
		},
		radius: {
			default: 1,
			description: "The radius of the bulge effect area",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .01,
				label: "Radius"
			}
		},
		falloff: {
			default: .5,
			description: "Controls the smoothness of the transition (0 = hard edge, 1 = very smooth)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Falloff"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(screenUV.x.mul(aspect$1), screenUV.y);
		const centerPos = vec2(uniforms.center.uniform.x.mul(aspect$1), uniforms.center.uniform.y.oneMinus());
		const delta = aspectCorrectedUV.sub(centerPos);
		const distance$1$1 = length(delta);
		const effectRadius = uniforms.radius.uniform.mul(.5);
		const falloffAmount = uniforms.falloff.uniform;
		const smoothFalloff = smoothstep(effectRadius.mul(float(1).sub(falloffAmount).sub(float(.001)).max(float(0))), effectRadius, distance$1$1).oneMinus();
		const normalizedDist = distance$1$1.div(effectRadius);
		const distSq = normalizedDist.mul(normalizedDist);
		const quadraticFalloff = max(float(0), float(1).sub(distSq));
		const falloff = smoothFalloff.mul(quadraticFalloff);
		const displacementAmount = uniforms.strength.uniform.negate().mul(falloff);
		const scaleFactor = float(1).add(displacementAmount);
		const bulgedDelta = delta.mul(scaleFactor);
		const bulgedUV = centerPos.add(bulgedDelta);
		const finalUV = vec2(bulgedUV.x.div(aspect$1), bulgedUV.y);
		return applyEdgeHandling(finalUV, childTexture.sample(finalUV), childTexture, uniforms.edges.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Bulge.js
function computeEffectiveProps$55(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$56 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$55 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$55 && componentDefinition$55.props) Object.entries(componentDefinition$55.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$55[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$55 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$55.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$55(props, defaultProps$55);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$56,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$55, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$55.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$55);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Bulge_default = OmbreComponent$55;

//#endregion
//#region node_modules/shaders/dist/core/CRTScreen-CcAYeqoI.js
var componentDefinition$54 = {
	name: "CRTScreen",
	category: "Stylize",
	description: "Retro CRT monitor simulation with scanlines",
	requiresRTT: true,
	requiresChild: true,
	props: {
		pixelSize: {
			default: 128,
			description: "Size of individual TV pixels (lower = more pixels)",
			ui: {
				type: "range",
				min: 8,
				max: 128,
				step: 1,
				label: "Pixel Size"
			}
		},
		colorShift: {
			default: 1,
			description: "Chromatic aberration amount",
			ui: {
				type: "range",
				min: 0,
				max: 10,
				step: .1,
				label: "Color Shift"
			}
		},
		scanlineIntensity: {
			default: .3,
			description: "Strength of horizontal scanlines",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Scanline Intensity"
			}
		},
		scanlineFrequency: {
			default: 200,
			description: "Number of scanlines across screen",
			ui: {
				type: "range",
				min: 100,
				max: 800,
				step: 10,
				label: "Scanline Frequency"
			}
		},
		brightness: {
			default: 1.1,
			description: "Screen brightness boost",
			ui: {
				type: "range",
				min: .5,
				max: 2,
				step: .01,
				label: "Brightness"
			}
		},
		contrast: {
			default: 1.2,
			description: "Screen contrast enhancement",
			ui: {
				type: "range",
				min: .5,
				max: 2,
				step: .01,
				label: "Contrast"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const pixelSize = uniforms.pixelSize.uniform;
		const colorShift = uniforms.colorShift.uniform;
		const scanlineIntensity = uniforms.scanlineIntensity.uniform;
		const scanlineFrequency = uniforms.scanlineFrequency.uniform;
		const brightness = uniforms.brightness.uniform;
		const contrast$1 = uniforms.contrast.uniform;
		const scaledColorShift = colorShift.mul(float(.002));
		const redUV = screenUV.add(vec2(scaledColorShift, float(0)));
		const greenUV = screenUV;
		const blueUV = screenUV.sub(vec2(scaledColorShift, float(0)));
		const redSample = childTexture.sample(redUV).r;
		const greenSample = childTexture.sample(greenUV).g;
		const blueSample = childTexture.sample(blueUV).b;
		const adjustedColor = vec3(redSample, greenSample, blueSample).sub(float(.5)).mul(contrast$1).add(float(.5)).mul(brightness);
		const scanlineWave = sin(screenUV.y.mul(scanlineFrequency).mul(float(3.14159 * 2)));
		const scanlineEffect = float(1).sub(scanlineIntensity.mul(scanlineWave.mul(float(.5)).add(float(.5))));
		const scanlinedColor = adjustedColor.mul(scanlineEffect);
		const phosphorScale = pixelSize.mul(float(.5));
		const pixelPhase = fract(screenUV.mul(phosphorScale));
		const redMask = sin(pixelPhase.x.mul(float(6.28318))).mul(float(.1)).add(float(.95));
		const greenMask = sin(pixelPhase.x.mul(float(6.28318)).add(float(2.09))).mul(float(.1)).add(float(.95));
		const blueMask = sin(pixelPhase.x.mul(float(6.28318)).add(float(4.18))).mul(float(.1)).add(float(.95));
		const phosphorColor = vec3(scanlinedColor.r.mul(redMask), scanlinedColor.g.mul(greenMask), scanlinedColor.b.mul(blueMask));
		const vignetteDistance = length(screenUV.sub(vec2(.5, .5)));
		const vignette = smoothstep(float(.8), float(.3), vignetteDistance);
		return vec4(phosphorColor.mul(vignette), float(1));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/CRTScreen.js
function computeEffectiveProps$54(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$55 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$54 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$54 && componentDefinition$54.props) Object.entries(componentDefinition$54.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$54[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$54 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$54.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$54(props, defaultProps$54);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$55,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$54, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$54.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$54);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var CRTScreen_default = OmbreComponent$54;

//#endregion
//#region node_modules/shaders/dist/core/ChannelBlur-CQoP7Igg.js
var componentDefinition$53 = {
	name: "ChannelBlur",
	category: "Blurs",
	description: "Independent blur for red, green, and blue channels",
	requiresRTT: true,
	requiresChild: true,
	props: {
		redIntensity: {
			default: 0,
			description: "Blur intensity for red channel",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Red Intensity"
			}
		},
		greenIntensity: {
			default: 20,
			description: "Blur intensity for green channel",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Green Intensity"
			}
		},
		blueIntensity: {
			default: 40,
			description: "Blur intensity for blue channel",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Blue Intensity"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const weights = [
			.056,
			.135,
			.278,
			.487,
			.726,
			.923,
			1,
			.923,
			.726,
			.487,
			.278,
			.135,
			.056
		];
		const weightSum = 6.214;
		const redRadius = uniforms.redIntensity.uniform.mul(.1);
		const greenRadius = uniforms.greenIntensity.uniform.mul(.1);
		const blueRadius = uniforms.blueIntensity.uniform.mul(.1);
		const horizontalTexture = convertToTexture(Fn(() => {
			const uv$1$2 = screenUV;
			const pixelSize = vec2(1).div(viewportSize);
			const redTotal = float(0).toVar();
			const greenTotal = float(0).toVar();
			const blueTotal = float(0).toVar();
			for (let x = -6; x <= 6; x++) {
				const weight = float(weights[x + 6] / weightSum);
				const xOffset = float(x).mul(pixelSize.x);
				const redOffset = vec2(xOffset.mul(redRadius), float(0));
				const greenOffset = vec2(xOffset.mul(greenRadius), float(0));
				const blueOffset = vec2(xOffset.mul(blueRadius), float(0));
				const redSample = childTexture.sample(uv$1$2.add(redOffset)).r.mul(weight);
				const greenSample = childTexture.sample(uv$1$2.add(greenOffset)).g.mul(weight);
				const blueSample = childTexture.sample(uv$1$2.add(blueOffset)).b.mul(weight);
				redTotal.assign(redTotal.add(redSample));
				greenTotal.assign(greenTotal.add(greenSample));
				blueTotal.assign(blueTotal.add(blueSample));
			}
			return vec4(redTotal, greenTotal, blueTotal, float(1));
		})());
		onCleanup(() => {
			if (horizontalTexture?.renderTarget?.dispose) horizontalTexture.renderTarget.dispose();
		});
		return Fn(() => {
			const uv$1$2 = screenUV;
			const pixelSize = vec2(1).div(viewportSize);
			const redTotal = float(0).toVar();
			const greenTotal = float(0).toVar();
			const blueTotal = float(0).toVar();
			for (let y = -6; y <= 6; y++) {
				const weight = float(weights[y + 6] / weightSum);
				const yOffset = float(y).mul(pixelSize.y);
				const redOffset = vec2(float(0), yOffset.mul(redRadius));
				const greenOffset = vec2(float(0), yOffset.mul(greenRadius));
				const blueOffset = vec2(float(0), yOffset.mul(blueRadius));
				const redSample = horizontalTexture.sample(uv$1$2.add(redOffset)).r.mul(weight);
				const greenSample = horizontalTexture.sample(uv$1$2.add(greenOffset)).g.mul(weight);
				const blueSample = horizontalTexture.sample(uv$1$2.add(blueOffset)).b.mul(weight);
				redTotal.assign(redTotal.add(redSample));
				greenTotal.assign(greenTotal.add(greenSample));
				blueTotal.assign(blueTotal.add(blueSample));
			}
			const originalAlpha = childTexture.sample(uv$1$2).a;
			return vec4(redTotal, greenTotal, blueTotal, originalAlpha);
		})();
	}
};

//#endregion
//#region node_modules/shaders/dist/react/ChannelBlur.js
function computeEffectiveProps$53(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$54 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$53 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$53 && componentDefinition$53.props) Object.entries(componentDefinition$53.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$53[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$53 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$53.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$53(props, defaultProps$53);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$54,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$53, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$53.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$53);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var ChannelBlur_default = OmbreComponent$53;

//#endregion
//#region node_modules/shaders/dist/core/Checkerboard-D_hGvoO7.js
var componentDefinition$52 = {
	name: "Checkerboard",
	category: "Base Layers",
	description: "Classic checkerboard pattern with two alternating colors",
	props: {
		colorA: {
			default: "#cccccc",
			transform: transformColor,
			description: "First color of the checkerboard pattern",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#999999",
			transform: transformColor,
			description: "Second color of the checkerboard pattern",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		cells: {
			default: 8,
			description: "Number of cells along the shortest canvas edge (creates square cells)",
			ui: {
				type: "range",
				min: 1,
				max: 50,
				step: 1,
				label: "Cells"
			}
		},
		softness: {
			default: 0,
			description: "Smoothness of the transition between colors (0 = hard edges, 1 = very soft)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Softness"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms }) => {
		const uv$1$2 = screenUV;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const correctedUV = vec2(uv$1$2.x.mul(aspect$1), uv$1$2.y.oneMinus());
		const cells = uniforms.cells.uniform;
		const softness = uniforms.softness.uniform;
		const gridUV = correctedUV.mul(cells);
		const gridCoords = floor(gridUV);
		const checkerValue = mod(gridCoords.x.add(gridCoords.y), 2);
		let blendFactor = checkerValue;
		if (softness) {
			const cellUV = fract(gridUV);
			const distToEdge = min(min(cellUV.x, float(1).sub(cellUV.x)), min(cellUV.y, float(1).sub(cellUV.y)));
			const softRange = softness.mul(.5);
			const edgeBlend = smoothstep(float(0), softRange, distToEdge);
			blendFactor = checkerValue.mul(edgeBlend).add(float(.5).mul(float(1).sub(edgeBlend)));
		}
		return mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, blendFactor, uniforms.colorSpace.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Checkerboard.js
function computeEffectiveProps$52(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$53 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$52 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$52 && componentDefinition$52.props) Object.entries(componentDefinition$52.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$52[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$52 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$52.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$52(props, defaultProps$52);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$53,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$52, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$52.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$52);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Checkerboard_default = OmbreComponent$52;

//#endregion
//#region node_modules/shaders/dist/core/ChromaFlow-DizYQSgf.js
var componentDefinition$51 = {
	name: "ChromaFlow",
	category: "Interactive",
	description: "Interactive liquid flow effect that follows your cursor",
	props: {
		baseColor: {
			default: "#0066ff",
			transform: transformColor,
			description: "Base liquid color",
			ui: {
				type: "color",
				label: "Base Color"
			}
		},
		upColor: {
			default: "#00ff00",
			transform: transformColor,
			description: "Color for upward movement",
			ui: {
				type: "color",
				label: "Up Color"
			}
		},
		downColor: {
			default: "#ff0000",
			transform: transformColor,
			description: "Color for downward movement",
			ui: {
				type: "color",
				label: "Down Color"
			}
		},
		leftColor: {
			default: "#0000ff",
			transform: transformColor,
			description: "Color for leftward movement",
			ui: {
				type: "color",
				label: "Left Color"
			}
		},
		rightColor: {
			default: "#ffff00",
			transform: transformColor,
			description: "Color for rightward movement",
			ui: {
				type: "color",
				label: "Right Color"
			}
		},
		intensity: {
			default: 1,
			description: "Strength of the liquid effect",
			ui: {
				type: "range",
				min: .5,
				max: 1.5,
				step: .1,
				label: "Intensity"
			}
		},
		radius: {
			default: 2,
			description: "Radius of the liquid effect",
			ui: {
				type: "range",
				min: 0,
				max: 3,
				step: .01,
				label: "Radius"
			}
		},
		momentum: {
			default: 30,
			description: "How much momentum colors retain in their flow direction",
			ui: {
				type: "range",
				min: 10,
				max: 60,
				step: 1,
				label: "Momentum"
			}
		}
	},
	fragmentNode: ({ uniforms, onBeforeRender, onCleanup }) => {
		const GRID_SIZE$1 = 128;
		const displacementData = new Float32Array(GRID_SIZE$1 * GRID_SIZE$1 * 2);
		const liquidData = new Float32Array(GRID_SIZE$1 * GRID_SIZE$1 * 2);
		const tempDisplacementData = new Float32Array(GRID_SIZE$1 * GRID_SIZE$1 * 2);
		const tempLiquidData = new Float32Array(GRID_SIZE$1 * GRID_SIZE$1 * 2);
		const displacementTexture = new DataTexture(displacementData, GRID_SIZE$1, GRID_SIZE$1, RGFormat, FloatType);
		displacementTexture.magFilter = LinearFilter;
		displacementTexture.minFilter = LinearFilter;
		displacementTexture.needsUpdate = true;
		const liquidTexture = new DataTexture(liquidData, GRID_SIZE$1, GRID_SIZE$1, RGFormat, FloatType);
		liquidTexture.magFilter = LinearFilter;
		liquidTexture.minFilter = LinearFilter;
		liquidTexture.needsUpdate = true;
		const displacementField = texture(displacementTexture);
		const liquidField = texture(liquidTexture);
		const mouseX = uniform(.5);
		const mouseY = uniform(.5);
		const mouseVelX = uniform(0);
		const mouseVelY = uniform(0);
		let prevX = .5;
		let prevY = .5;
		let lastTime = Date.now();
		onBeforeRender(({ pointer }) => {
			const currentTime = Date.now();
			const dt = Math.min((currentTime - lastTime) / 1e3, .016);
			lastTime = currentTime;
			const velX = dt > 0 ? (pointer.x - prevX) / dt : 0;
			const velY = dt > 0 ? (pointer.y - prevY) / dt : 0;
			mouseVelX.value = mouseVelX.value * .85 + velX * .15;
			mouseVelY.value = mouseVelY.value * .85 + velY * .15;
			mouseX.value = pointer.x;
			mouseY.value = pointer.y;
			const intensity = uniforms.intensity.uniform.value;
			const radius = uniforms.radius.uniform.value * .05;
			const momentum = uniforms.momentum.uniform.value;
			tempDisplacementData.set(displacementData);
			tempLiquidData.set(liquidData);
			const flowFadeRate = 1 - dt / Math.max(.1, 1);
			for (let i = 0; i < GRID_SIZE$1 * GRID_SIZE$1 * 2; i++) tempDisplacementData[i] = displacementData[i] * flowFadeRate;
			for (let i = 0; i < GRID_SIZE$1; i++) for (let j = 0; j < GRID_SIZE$1; j++) {
				const idx = (i * GRID_SIZE$1 + j) * 2;
				const liquidFadeRate = 1 - dt / Math.max(.4, 1);
				tempLiquidData[idx] = liquidData[idx] * liquidFadeRate;
				tempLiquidData[idx + 1] = liquidData[idx + 1] * liquidFadeRate;
				if (Math.abs(displacementData[idx]) > .001 || Math.abs(displacementData[idx + 1]) > .001) {
					const flowSpeed = momentum * 50 * dt;
					const advectX = j - displacementData[idx] * flowSpeed;
					const advectY = i - displacementData[idx + 1] * flowSpeed;
					const x0 = Math.floor(advectX);
					const y0 = Math.floor(advectY);
					const x1 = x0 + 1;
					const y1 = y0 + 1;
					if (x0 >= 0 && y0 >= 0 && x1 < GRID_SIZE$1 && y1 < GRID_SIZE$1) {
						const fx = advectX - x0;
						const fy = advectY - y0;
						const idx00 = (y0 * GRID_SIZE$1 + x0) * 2;
						const idx01 = (y0 * GRID_SIZE$1 + x1) * 2;
						const idx10 = (y1 * GRID_SIZE$1 + x0) * 2;
						const idx11 = (y1 * GRID_SIZE$1 + x1) * 2;
						tempLiquidData[idx] = (liquidData[idx00] * (1 - fx) * (1 - fy) + liquidData[idx01] * fx * (1 - fy) + liquidData[idx10] * (1 - fx) * fy + liquidData[idx11] * fx * fy) * liquidFadeRate;
					}
				}
			}
			for (let i = 0; i < GRID_SIZE$1; i++) for (let j = 0; j < GRID_SIZE$1; j++) {
				const idx = (i * GRID_SIZE$1 + j) * 2;
				const cellX = (j + .5) / GRID_SIZE$1;
				const cellY = (i + .5) / GRID_SIZE$1;
				const dx = cellX - pointer.x;
				const dy = cellY - pointer.y;
				const dist = Math.sqrt(dx * dx + dy * dy);
				const speed = Math.sqrt(mouseVelX.value * mouseVelX.value + mouseVelY.value * mouseVelY.value);
				const effectiveRadius = radius * Math.min(speed * speed * 20, 1);
				if (dist < effectiveRadius * 2 && Math.abs(velX) + Math.abs(velY) > .01) {
					const influence = Math.exp(-dist * dist / (effectiveRadius * effectiveRadius));
					tempDisplacementData[idx] += mouseVelX.value * influence * (intensity * 100) * dt * .01;
					tempDisplacementData[idx + 1] += mouseVelY.value * influence * (intensity * 100) * dt * .01;
					const speedMultiplier = Math.min(speed * 10, 1);
					tempLiquidData[idx] += influence * (intensity * 100) * dt * .01 * speedMultiplier;
					tempLiquidData[idx + 1] = 0;
				}
				tempDisplacementData[idx] = Math.max(-1, Math.min(1, tempDisplacementData[idx]));
				tempDisplacementData[idx + 1] = Math.max(-1, Math.min(1, tempDisplacementData[idx + 1]));
				tempLiquidData[idx] = Math.max(0, Math.min(1, tempLiquidData[idx]));
				tempLiquidData[idx + 1] = 0;
			}
			displacementData.set(tempDisplacementData);
			liquidData.set(tempLiquidData);
			displacementTexture.needsUpdate = true;
			liquidTexture.needsUpdate = true;
			prevX = pointer.x;
			prevY = pointer.y;
		});
		onCleanup(() => {
			displacementTexture.dispose();
			liquidTexture.dispose();
		});
		const liquidDensity = liquidField.sample(screenUV).x;
		const pixelSize = vec2(float(1 / 128), float(1 / 128));
		const sample1 = liquidField.sample(screenUV.add(vec2(pixelSize.x, float(0)))).x;
		const sample2 = liquidField.sample(screenUV.add(vec2(float(0), pixelSize.y))).x;
		const sample3 = liquidField.sample(screenUV.add(vec2(pixelSize.x.negate(), float(0)))).x;
		const sample4 = liquidField.sample(screenUV.add(vec2(float(0), pixelSize.y.negate()))).x;
		const smoothedLiquid = liquidDensity.add(sample1).add(sample2).add(sample3).add(sample4).mul(float(.2));
		const liquidIntensity = smoothstep(float(0), float(.1), smoothedLiquid);
		const flowPixelSize = vec2(float(1 / 128), float(1 / 128));
		const centerFlow = displacementField.sample(screenUV).xy;
		const flowSample1 = displacementField.sample(screenUV.add(vec2(flowPixelSize.x, float(0)))).xy;
		const flowSample2 = displacementField.sample(screenUV.add(vec2(float(0), flowPixelSize.y))).xy;
		const flowSample3 = displacementField.sample(screenUV.add(vec2(flowPixelSize.x.negate(), float(0)))).xy;
		const flowSample4 = displacementField.sample(screenUV.add(vec2(float(0), flowPixelSize.y.negate()))).xy;
		const flowVectors = centerFlow.add(flowSample1).add(flowSample2).add(flowSample3).add(flowSample4).mul(float(.2));
		const baseColor = uniforms.baseColor.uniform;
		const upColor = uniforms.upColor.uniform;
		const downColor = uniforms.downColor.uniform;
		const leftColor = uniforms.leftColor.uniform;
		const rightColor = uniforms.rightColor.uniform;
		const flowMagnitude = flowVectors.x.mul(flowVectors.x).add(flowVectors.y.mul(flowVectors.y)).sqrt();
		const hasFlow = smoothstep(float(.01), float(.1), flowMagnitude);
		const normalizedX = flowVectors.x.div(flowMagnitude.add(float(.001)));
		const normalizedY = flowVectors.y.div(flowMagnitude.add(float(.001)));
		const rightAmount = smoothstep(float(0), float(.7), normalizedX.max(float(0)));
		const leftAmount = smoothstep(float(0), float(.7), normalizedX.negate().max(float(0)));
		const upAmount = smoothstep(float(0), float(.7), normalizedY.max(float(0)));
		const downAmount = smoothstep(float(0), float(.7), normalizedY.negate().max(float(0)));
		const horizontalColor = leftColor.mul(leftAmount).add(rightColor.mul(rightAmount));
		const verticalColor = downColor.mul(downAmount).add(upColor.mul(upAmount));
		const horizontalWeight = leftAmount.add(rightAmount);
		const verticalWeight = upAmount.add(downAmount);
		const totalWeight = horizontalWeight.add(verticalWeight).add(float(.001));
		const finalColor = mix(baseColor, horizontalColor.mul(horizontalWeight.div(totalWeight)).add(verticalColor.mul(verticalWeight.div(totalWeight))), hasFlow);
		return vec4(finalColor.rgb.mul(liquidIntensity), finalColor.a.mul(liquidIntensity));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/ChromaFlow.js
function computeEffectiveProps$51(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$52 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$51 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$51 && componentDefinition$51.props) Object.entries(componentDefinition$51.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$51[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$51 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$51.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$51(props, defaultProps$51);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$52,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$51, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$51.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$51);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var ChromaFlow_default = OmbreComponent$51;

//#endregion
//#region node_modules/shaders/dist/core/ChromaticAberration-Bk_DMYJm.js
var componentDefinition$50 = {
	name: "ChromaticAberration",
	category: "Stylize",
	description: "Separate RGB channels for a prismatic distortion effect",
	requiresRTT: true,
	requiresChild: true,
	props: {
		strength: {
			default: .2,
			description: "Overall strength of the chromatic aberration effect",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Strength"
			}
		},
		angle: {
			default: 0,
			transform: transformAngle,
			description: "Direction of the chromatic aberration in degrees",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		redOffset: {
			default: -1,
			description: "Red channel offset multiplier",
			ui: {
				type: "range",
				min: -2,
				max: 2,
				step: .1,
				label: "Red Offset"
			}
		},
		greenOffset: {
			default: 0,
			description: "Green channel offset multiplier",
			ui: {
				type: "range",
				min: -2,
				max: 2,
				step: .1,
				label: "Green Offset"
			}
		},
		blueOffset: {
			default: 1,
			description: "Blue channel offset multiplier",
			ui: {
				type: "range",
				min: -2,
				max: 2,
				step: .1,
				label: "Blue Offset"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const angleRad = radians(uniforms.angle.uniform);
		const direction = vec2(cos(angleRad), sin(angleRad));
		const scaledStrength = uniforms.strength.uniform.mul(.1);
		const redUV = screenUV.add(direction.mul(scaledStrength).mul(uniforms.redOffset.uniform));
		const greenUV = screenUV.add(direction.mul(scaledStrength).mul(uniforms.greenOffset.uniform));
		const blueUV = screenUV.add(direction.mul(scaledStrength).mul(uniforms.blueOffset.uniform));
		const redChannel = childTexture.sample(redUV).r;
		const greenChannel = childTexture.sample(greenUV).g;
		const blueChannel = childTexture.sample(blueUV).b;
		const alpha = childTexture.sample(screenUV).a;
		return vec4(redChannel, greenChannel, blueChannel, alpha);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/ChromaticAberration.js
function computeEffectiveProps$50(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$51 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$50 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$50 && componentDefinition$50.props) Object.entries(componentDefinition$50.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$50[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$50 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$50.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$50(props, defaultProps$50);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$51,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$50, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$50.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$50);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var ChromaticAberration_default = OmbreComponent$50;

//#endregion
//#region node_modules/shaders/dist/core/Circle-BlVzkeyl.js
var componentDefinition$49 = {
	name: "Circle",
	category: "Base Layers",
	description: "Generate a circle with adjustable size and softness",
	props: {
		color: {
			default: "#ffffff",
			transform: transformColor,
			description: "The color of the circle",
			ui: {
				type: "color",
				label: "Color"
			}
		},
		radius: {
			default: 1,
			description: "The radius of the circle. A value of one (1) is sets the circle to fit the canvas.",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Radius"
			}
		},
		softness: {
			default: 0,
			description: "Edge softness. Lower values like zero (0) are sharp, higher values like one (1) are softer.",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Softness"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the circle",
			ui: {
				type: "position",
				label: "Center Position"
			}
		}
	},
	fragmentNode: ({ uniforms }) => {
		const uv$1$2 = screenUV;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(uv$1$2.x.mul(aspect$1), uv$1$2.y);
		const centerPos = vec2(uniforms.center.uniform.x.mul(aspect$1), uniforms.center.uniform.y.oneMinus());
		const distanceFromCenter = length(aspectCorrectedUV.sub(centerPos));
		const edgeSoftness = uniforms.softness.uniform;
		const circleEdge = uniforms.radius.uniform.mul(.5);
		const circleMask = smoothstep(circleEdge, circleEdge.sub(edgeSoftness), distanceFromCenter);
		return vec4(uniforms.color.uniform.rgb, uniforms.color.uniform.a.mul(circleMask));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Circle.js
function computeEffectiveProps$49(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$50 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$49 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$49 && componentDefinition$49.props) Object.entries(componentDefinition$49.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$49[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$49 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$49.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$49(props, defaultProps$49);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$50,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$49, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$49.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$49);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Circle_default = OmbreComponent$49;

//#endregion
//#region node_modules/shaders/dist/core/CursorTrail-CxXWV7KH.js
var componentDefinition$48 = {
	name: "CursorTrail",
	category: "Interactive",
	description: "Animated trail effect that tracks cursor movement",
	props: {
		colorA: {
			default: "#00aaff",
			transform: transformColor,
			description: "Color of fresh trails",
			ui: {
				type: "color",
				label: "Start Color"
			}
		},
		colorB: {
			default: "#ff00aa",
			transform: transformColor,
			description: "Color trails transition to as they fade",
			ui: {
				type: "color",
				label: "End Color"
			}
		},
		radius: {
			default: .5,
			description: "Base radius of trail circles",
			ui: {
				type: "range",
				min: .5,
				max: 2,
				step: .01,
				label: "Radius"
			}
		},
		length: {
			default: .5,
			description: "How long trail circles persist (in seconds)",
			ui: {
				type: "range",
				min: .1,
				max: 2,
				step: .1,
				label: "Trail Length"
			}
		},
		shrink: {
			default: 1,
			description: "How much circles shrink as they fade out (0 = no shrink, 1 = full shrink)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Shrink Amount"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms, onBeforeRender, onCleanup }) => {
		const GRID_SIZE$1 = 128;
		const trailData = new Float32Array(GRID_SIZE$1 * GRID_SIZE$1 * 4);
		const trailTexture = new DataTexture(trailData, GRID_SIZE$1, GRID_SIZE$1, RGBAFormat, FloatType);
		trailTexture.magFilter = LinearFilter;
		trailTexture.minFilter = LinearFilter;
		trailTexture.needsUpdate = true;
		const trailField = texture(trailTexture);
		let prevX = .5;
		let prevY = .5;
		let lastTime = Date.now();
		onBeforeRender(({ pointer }) => {
			const currentTime = Date.now();
			const dt = Math.min((currentTime - lastTime) / 1e3, .016);
			lastTime = currentTime;
			const radius = uniforms.radius.uniform.value * .1;
			const length$1$1 = uniforms.length.uniform.value;
			const shrink = uniforms.shrink.uniform.value;
			const dx = pointer.x - prevX;
			const dy = pointer.y - prevY;
			const speed = Math.sqrt(dx * dx + dy * dy);
			const fadeRate = 1 - dt / Math.max(.1, length$1$1);
			const ageRate = dt / Math.max(.1, length$1$1);
			for (let i = 0; i < GRID_SIZE$1 * GRID_SIZE$1 * 4; i += 4) {
				trailData[i] *= fadeRate;
				trailData[i + 1] = 1 - (1 - trailData[i]) * shrink;
				trailData[i + 2] = Math.min(1, trailData[i + 2] + ageRate);
			}
			if (speed > .001) {
				const influenceRadius = radius * 3;
				const minJ = Math.max(0, Math.floor((pointer.x - influenceRadius) * GRID_SIZE$1));
				const maxJ = Math.min(GRID_SIZE$1 - 1, Math.ceil((pointer.x + influenceRadius) * GRID_SIZE$1));
				const minI = Math.max(0, Math.floor((pointer.y - influenceRadius) * GRID_SIZE$1));
				const maxI = Math.min(GRID_SIZE$1 - 1, Math.ceil((pointer.y + influenceRadius) * GRID_SIZE$1));
				for (let i = minI; i <= maxI; i++) for (let j = minJ; j <= maxJ; j++) {
					const idx = (i * GRID_SIZE$1 + j) * 4;
					const cellX = (j + .5) / GRID_SIZE$1;
					const cellY = (i + .5) / GRID_SIZE$1;
					const cellDx = cellX - pointer.x;
					const cellDy = cellY - pointer.y;
					const dist = Math.sqrt(cellDx * cellDx + cellDy * cellDy);
					if (dist < influenceRadius) {
						const addAmount = Math.exp(-dist * dist / (radius * radius)) * speed * 50 * dt;
						trailData[idx] = Math.min(1, trailData[idx] + addAmount);
						trailData[idx + 1] = 1;
						trailData[idx + 2] = 0;
					}
				}
			}
			trailTexture.needsUpdate = true;
			prevX = pointer.x;
			prevY = pointer.y;
		});
		onCleanup(() => {
			trailTexture.dispose();
		});
		const pixelSize = float(1 / GRID_SIZE$1);
		const centerSample = trailField.sample(screenUV);
		const sample1 = trailField.sample(screenUV.add(vec2(pixelSize, float(0))));
		const sample2 = trailField.sample(screenUV.add(vec2(float(0), pixelSize)));
		const sample3 = trailField.sample(screenUV.add(vec2(pixelSize.negate(), float(0))));
		const sample4 = trailField.sample(screenUV.add(vec2(float(0), pixelSize.negate())));
		const trailIntensity = centerSample.x.mul(float(.5)).add(sample1.x.mul(float(.125))).add(sample2.x.mul(float(.125))).add(sample3.x.mul(float(.125))).add(sample4.x.mul(float(.125)));
		const trailAge = centerSample.z.mul(float(.5)).add(sample1.z.mul(float(.125))).add(sample2.z.mul(float(.125))).add(sample3.z.mul(float(.125))).add(sample4.z.mul(float(.125)));
		const circleMask = step(float(.01), trailIntensity);
		const colorA = uniforms.colorA.uniform;
		const colorB = uniforms.colorB.uniform;
		const trailColor = mixColors(colorA, colorB, trailAge, uniforms.colorSpace.uniform);
		return vec4(trailColor.rgb, trailColor.a.mul(circleMask));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/CursorTrail.js
function computeEffectiveProps$48(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$49 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$48 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$48 && componentDefinition$48.props) Object.entries(componentDefinition$48.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$48[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$48 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$48.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$48(props, defaultProps$48);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$49,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$48, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$48.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$48);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var CursorTrail_default = OmbreComponent$48;

//#endregion
//#region node_modules/shaders/dist/core/DiffuseBlur-BTSRl65K.js
var componentDefinition$47 = {
	name: "DiffuseBlur",
	category: "Blurs",
	description: "Grain-like pixel displacement at random",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 30,
			description: "Intensity of the diffuse blur effect",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Intensity"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const hash$3 = (p$1) => {
			return fract(sin(dot(p$1, vec2(12.9898, 78.233).mul(2))).mul(43758.5453));
		};
		const uv$1$2 = screenUV;
		const pixelSize = vec2(1).div(viewportSize);
		const seed = uv$1$2.mul(1e3);
		const rand1 = hash$3(seed);
		const rand2 = hash$3(seed.add(vec2(73.2, 41.9)));
		const offset = vec2(rand1.mul(2).sub(1), rand2.mul(2).sub(1)).mul(uniforms.intensity.uniform).mul(pixelSize);
		const displacedUV = uv$1$2.add(offset);
		return applyEdgeHandling(displacedUV, childTexture.sample(displacedUV), childTexture, uniforms.edges.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/DiffuseBlur.js
function computeEffectiveProps$47(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$48 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$47 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$47 && componentDefinition$47.props) Object.entries(componentDefinition$47.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$47[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$47 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$47.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$47(props, defaultProps$47);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$48,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$47, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$47.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$47);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var DiffuseBlur_default = OmbreComponent$47;

//#endregion
//#region node_modules/shaders/dist/core/Dither-C1KyBYuE.js
var componentDefinition$46 = {
	name: "Dither",
	category: "Stylize",
	description: "Bayer matrix dithering to reduce colors",
	requiresChild: true,
	props: {
		pixelSize: {
			default: 4,
			description: "Size of dithering pixels",
			ui: {
				type: "range",
				min: 1,
				max: 20,
				step: 1,
				label: "Pixel Size"
			}
		},
		threshold: {
			default: .5,
			description: "Luminance threshold for dithering",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Threshold"
			}
		},
		colorA: {
			default: "transparent",
			transform: transformColor,
			description: "Dark color for dithering",
			ui: {
				type: "color",
				label: "Dark Color"
			}
		},
		colorB: {
			default: "#ffffff",
			transform: transformColor,
			description: "Light color for dithering",
			ui: {
				type: "color",
				label: "Light Color"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const sourceColor = childNode;
		const luminance$3 = dot(sourceColor.rgb, vec3(.299, .587, .114)).mul(sourceColor.a);
		const pixelSize = uniforms.pixelSize.uniform;
		const bayerPos = floor(screenUV.mul(viewportSize).div(pixelSize)).mod(vec2(4));
		const x = bayerPos.x;
		const y = bayerPos.y;
		const bayerValue = y.equal(0).select(x.equal(0).select(0 / 16, x.equal(1).select(8 / 16, x.equal(2).select(2 / 16, 10 / 16))), y.equal(1).select(x.equal(0).select(12 / 16, x.equal(1).select(4 / 16, x.equal(2).select(14 / 16, 6 / 16))), y.equal(2).select(x.equal(0).select(3 / 16, x.equal(1).select(11 / 16, x.equal(2).select(1 / 16, 9 / 16))), x.equal(0).select(15 / 16, x.equal(1).select(7 / 16, x.equal(2).select(13 / 16, 5 / 16))))));
		const threshold = uniforms.threshold.uniform;
		const ditherResult = step(bayerValue, luminance$3.add(threshold.sub(.5)));
		return vec4(mix(uniforms.colorA.uniform.rgb, uniforms.colorB.uniform.rgb, ditherResult), mix(uniforms.colorA.uniform.a, uniforms.colorB.uniform.a, ditherResult));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Dither.js
function computeEffectiveProps$46(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$47 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$46 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$46 && componentDefinition$46.props) Object.entries(componentDefinition$46.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$46[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$46 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$46.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$46(props, defaultProps$46);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$47,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$46, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$46.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$46);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Dither_default = OmbreComponent$46;

//#endregion
//#region node_modules/shaders/dist/core/DotGrid-ll8XCA0p.js
var componentDefinition$45 = {
	name: "DotGrid",
	category: "Base Layers",
	description: "Grid of dots with optional twinkling animation",
	props: {
		color: {
			default: "#ffffff",
			description: "The color of the dot",
			transform: transformColor,
			ui: {
				type: "color",
				label: "Color"
			}
		},
		density: {
			default: 100,
			description: "The number of dots on the longest canvas edge",
			ui: {
				type: "range",
				min: 10,
				max: 500,
				step: 10,
				label: "Density"
			}
		},
		dotSize: {
			default: .3,
			description: "The size of each dot, zero (0) being invisible, one (1) filled the grid with no gaps",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Dot Size"
			}
		},
		twinkle: {
			default: 0,
			description: "Intensity of the twinkle effect (0 = off, 1 = full twinkle)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Twinkle"
			}
		}
	},
	fragmentNode: ({ uniforms }) => {
		const uvCoords = screenUV;
		const density = uniforms.density.uniform;
		const dotSize = uniforms.dotSize.uniform;
		const dotColor = uniforms.color.uniform;
		const twinkleIntensity = uniforms.twinkle.uniform;
		const resolution = viewportSize;
		const aspect$1 = resolution.x.div(resolution.y);
		const correctedUV = vec2(uvCoords.x.mul(aspect$1), uvCoords.y.oneMinus());
		const gridUV = correctedUV.mul(density);
		const centerDistance = length(gridUV.sub(floor(gridUV)).sub(.5));
		const pixelSize = length(fwidth(correctedUV.mul(density)));
		const dot$1$1 = float(1).sub(smoothstep(dotSize.mul(.5), dotSize.mul(.5).add(pixelSize.mul(.5)), centerDistance));
		const gridPosition = floor(gridUV);
		const dotPhase = gridPosition.x.mul(12.9898).add(gridPosition.y.mul(78.233)).sin().mul(43758.5453).fract();
		const twinkleValue = sin(time.mul(2).add(dotPhase.mul(6.28318))).mul(.5).add(.5);
		const twinkleModifier = mix(float(1), twinkleValue, twinkleIntensity);
		const twinkledAlpha = dot$1$1.mul(twinkleModifier);
		return vec4(dotColor.rgb, twinkledAlpha);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/DotGrid.js
function computeEffectiveProps$45(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$46 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$45 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$45 && componentDefinition$45.props) Object.entries(componentDefinition$45.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$45[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$45 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$45.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$45(props, defaultProps$45);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$46,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$45, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$45.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$45);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var DotGrid_default = OmbreComponent$45;

//#endregion
//#region node_modules/shaders/dist/core/Duotone-d2gQJr4M.js
var componentDefinition$44 = {
	name: "Duotone",
	category: "Adjustments",
	description: "Map colors to two tones based on luminance",
	requiresRTT: true,
	requiresChild: true,
	props: {
		colorA: {
			default: "#ff0000",
			transform: transformColor,
			description: "First color (used for darker areas)",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#023af4",
			transform: transformColor,
			description: "Second color (used for brighter areas)",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		blend: {
			default: .5,
			description: "Blend point between the two colors",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Blend"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const inputColor = childTexture.sample(screenUV);
		const luminance$3 = dot(inputColor.rgb, vec3(.299, .587, .114));
		const adjustedLuminance = smoothstep(uniforms.blend.uniform.sub(.5), uniforms.blend.uniform.add(.5), luminance$3);
		return vec4(mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, adjustedLuminance, uniforms.colorSpace.uniform).rgb, inputColor.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Duotone.js
function computeEffectiveProps$44(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$45 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$44 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$44 && componentDefinition$44.props) Object.entries(componentDefinition$44.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$44[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$44 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$44.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$44(props, defaultProps$44);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$45,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$44, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$44.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$44);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Duotone_default = OmbreComponent$44;

//#endregion
//#region node_modules/shaders/dist/core/FilmGrain-3h6TIe1T.js
var componentDefinition$43 = {
	name: "FilmGrain",
	category: "Stylize",
	description: "Analog film grain texture overlay",
	requiresChild: true,
	props: { strength: {
		default: .5,
		description: "Intensity of the film grain noise",
		ui: {
			type: "range",
			min: 0,
			max: 1,
			step: .01,
			label: "Strength"
		}
	} },
	fragmentNode: ({ uniforms, childNode }) => {
		const strength = uniforms.strength.uniform;
		const sourceColor = childNode || vec4(0, 0, 0, 0);
		const grainIntensity = fract(sin(dot(screenUV, vec2(float(12.9898), float(78.233)).mul(float(2)))).mul(float(43758.5453))).mul(float(2)).sub(float(1)).mul(strength.mul(float(.1)));
		return vec4(sourceColor.rgb.add(grainIntensity), sourceColor.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/FilmGrain.js
function computeEffectiveProps$43(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$44 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$43 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$43 && componentDefinition$43.props) Object.entries(componentDefinition$43.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$43[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$43 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$43.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$43(props, defaultProps$43);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$44,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$43, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$43.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$43);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var FilmGrain_default = OmbreComponent$43;

//#endregion
//#region node_modules/shaders/dist/core/FloatingParticles-D95-rj4h.js
var hash1_2 = Fn(([p$1]) => {
	return fract(sin(dot(p$1, vec2(127.1, 311.7))).mul(43758.5453123));
});
var hash2_2 = Fn(([p$1]) => {
	return fract(sin(vec2(dot(p$1, vec2(127.1, 311.7)), dot(p$1, vec2(269.5, 183.3)))).mul(43758.5453));
});
var voronoiPointFromRoot = Fn(([root, deg]) => {
	const point = hash2_2(root).sub(.5);
	const s = sin(deg);
	const c$1 = cos(deg);
	return vec2(c$1.mul(point.x).sub(s.mul(point.y)).mul(.66), s.mul(point.x).add(c$1.mul(point.y)).mul(.66)).add(root).add(.5);
});
var degFromRootUV = Fn(([uv$1$2, randomness]) => {
	return time.mul(randomness).mul(hash1_2(uv$1$2).sub(.5)).mul(2);
});
var getParticleDistance = Fn(([uv$1$2, cellUV, randomness]) => {
	const pointUV$2 = voronoiPointFromRoot(cellUV, degFromRootUV(cellUV, randomness));
	return length(uv$1$2.sub(pointUV$2));
});
var componentDefinition$42 = {
	name: "FloatingParticles",
	category: "Base Layers",
	description: "Animated floating particles with twinkle effects",
	requiresRTT: false,
	props: {
		randomness: {
			default: .25,
			description: "Randomness of particle animation",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Randomness"
			}
		},
		speed: {
			default: .25,
			description: "Speed of particle movement",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Speed"
			}
		},
		angle: {
			default: 90,
			description: "Movement angle in degrees (0=right, 90=down, 180=left, 270=up)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		particleSize: {
			default: 1,
			description: "Size of particles",
			ui: {
				type: "range",
				min: .1,
				max: 20,
				step: .1,
				label: "Particle Size"
			}
		},
		particleSoftness: {
			default: 0,
			description: "Edge softness of particles (0 = sharp, 1 = very soft)",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .01,
				label: "Particle Softness"
			}
		},
		twinkle: {
			default: .5,
			description: "Intensity of the twinkle effect (0 = off, 1 = full twinkle)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Twinkle"
			}
		},
		count: {
			default: 5,
			description: "Number of particle layers",
			ui: {
				type: "range",
				min: 1,
				max: 5,
				step: 1,
				label: "Count"
			}
		},
		particleColor: {
			default: "#ffffff",
			transform: transformColor,
			description: "Color of the particles",
			ui: {
				type: "color",
				label: "Particle Color"
			}
		},
		speedVariance: {
			default: .3,
			description: "Per-layer speed variance (0 = all layers same speed, 1 = high variance)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Speed Variance"
			}
		},
		angleVariance: {
			default: 30,
			description: "Per-layer angle variance in degrees (0 = all layers same angle, 180 = full variance)",
			ui: {
				type: "range",
				min: 0,
				max: 180,
				step: 1,
				label: "Angle Variance"
			}
		},
		particleDensity: {
			default: 3,
			description: "Particle density (lower = more spread out, higher = more dense)",
			ui: {
				type: "range",
				min: .5,
				max: 3,
				step: .1,
				label: "Particle Density"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms, childNode } = params;
		const baseUV = screenUV;
		const animTime = createAnimatedTime(params, uniforms.speed);
		const renderParticle = Fn(([uv$2$1]) => {
			const rootUV = floor(uv$2$1);
			const localPos = fract(uv$2$1);
			let minDist = getParticleDistance(uv$2$1, rootUV, uniforms.randomness.uniform);
			const softness = uniforms.particleSoftness.uniform;
			const scaledSize = uniforms.particleSize.uniform.mul(.01);
			const outerRadius = scaledSize.mul(.6).add(softness.mul(scaledSize.mul(2.4)));
			const needsNeighbors = outerRadius.greaterThan(.35);
			const nearLeft = localPos.x.lessThan(.4);
			const nearRight = localPos.x.greaterThan(.6);
			const nearTop = localPos.y.lessThan(.4);
			const nearBottom = localPos.y.greaterThan(.6);
			const checkLeft = needsNeighbors.and(nearLeft);
			const checkRight = needsNeighbors.and(nearRight);
			const checkTop = needsNeighbors.and(nearTop);
			const checkBottom = needsNeighbors.and(nearBottom);
			minDist = checkLeft.select(min(minDist, getParticleDistance(uv$2$1, rootUV.add(vec2(-1, 0)), uniforms.randomness.uniform)), minDist);
			minDist = checkRight.select(min(minDist, getParticleDistance(uv$2$1, rootUV.add(vec2(1, 0)), uniforms.randomness.uniform)), minDist);
			minDist = checkTop.select(min(minDist, getParticleDistance(uv$2$1, rootUV.add(vec2(0, -1)), uniforms.randomness.uniform)), minDist);
			minDist = checkBottom.select(min(minDist, getParticleDistance(uv$2$1, rootUV.add(vec2(0, 1)), uniforms.randomness.uniform)), minDist);
			const baseIntensity = smoothstep(outerRadius, scaledSize.mul(.6), minDist);
			const twinkleIntensity = uniforms.twinkle.uniform;
			const particlePhase = rootUV.x.mul(12.9898).add(rootUV.y.mul(78.233)).sin().mul(43758.5453).fract();
			const twinkleValue = sin(time.mul(2).add(particlePhase.mul(6.28318))).mul(.5).add(.5);
			const twinkleModifier = mix(float(1), twinkleValue, twinkleIntensity);
			return baseIntensity.mul(twinkleModifier).mul(uniforms.particleColor.uniform.rgb);
		});
		const layeredParticles = Fn(([uv$2$1]) => {
			const sizeMod = float(1.05);
			const alphaMod = float(.9);
			const layers = uniforms.count.uniform;
			const particles$1 = vec3(0).toVar();
			const size = float(1).toVar();
			const alpha = float(1).toVar();
			const offset = vec2(0).toVar();
			const angleRad = uniforms.angle.uniform.mul(3.14159).div(180);
			const baseMovementDir = vec2(cos(angleRad), sin(angleRad));
			const baseMovement = animTime.mul(baseMovementDir);
			const speedVar = uniforms.speedVariance.uniform;
			const angleVar = uniforms.angleVariance.uniform.mul(3.14159).div(180);
			for (let i = 0; i < 4; i++) {
				const layerActive = float(i).lessThan(layers).and(alpha.greaterThan(.02));
				const layerHash = hash2_2(vec2(alpha, float(i).mul(7.919)));
				const speedMod = float(1).add(layerHash.x.sub(.5).mul(speedVar));
				const angleDelta = layerHash.y.sub(.5).mul(angleVar).mul(2);
				const variedAngle = angleRad.add(angleDelta);
				const variedDir = vec2(cos(variedAngle), sin(variedAngle));
				const movement = baseMovement.mul(speedMod).add(variedDir.sub(baseMovementDir).mul(animTime));
				const layerParticles = renderParticle(uv$2$1.mul(size).add(movement).add(offset)).mul(alpha);
				particles$1.assign(particles$1.add(layerActive.select(layerParticles, vec3(0))));
				offset.assign(offset.add(layerHash.mul(10)));
				alpha.assign(alpha.mul(alphaMod));
				size.assign(size.mul(sizeMod));
			}
			return particles$1;
		});
		const uv$1$2 = baseUV.mul(2).sub(1);
		const aspectRatio = viewportSize.x.div(viewportSize.y);
		const particles = layeredParticles(vec2(uv$1$2.x.mul(aspectRatio), uv$1$2.y).mul(uniforms.particleDensity.uniform));
		const particleAlpha = length(particles);
		if (childNode) return vec4(mix(childNode.xyz, particles, particleAlpha.greaterThan(.01).select(particleAlpha, 0)), childNode.w);
		return vec4(particles, particleAlpha);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/FloatingParticles.js
function computeEffectiveProps$42(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$43 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$42 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$42 && componentDefinition$42.props) Object.entries(componentDefinition$42.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$42[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$42 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$42.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$42(props, defaultProps$42);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$43,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$42, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$42.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$42);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var FloatingParticles_default = OmbreComponent$42;

//#endregion
//#region node_modules/shaders/dist/core/GlassTiles-DqT67iqr.js
var componentDefinition$41 = {
	name: "GlassTiles",
	category: "Distortions",
	description: "Refraction-like distortion in a tile grid pattern",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 2,
			description: "The intensity of the glass tiles effect",
			ui: {
				type: "range",
				min: 0,
				max: 10,
				step: .1,
				label: "Intensity"
			}
		},
		tileCount: {
			default: 20,
			description: "Number of tiles across the shortest dimension",
			ui: {
				type: "range",
				min: 5,
				max: 50,
				step: 1,
				label: "Tile Count"
			}
		},
		rotation: {
			default: 0,
			description: "Rotation angle of the tile grid in degrees",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Rotation"
			}
		},
		roundness: {
			default: 0,
			description: "Makes tiles more circular instead of square",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Roundness"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, dimensions, onCleanup }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Glass Tiles shader.");
			return vec4(0);
		}
		const texture$1$1 = convertToTexture(childNode);
		onCleanup(() => {
			if (texture$1$1?.renderTarget?.dispose) texture$1$1.renderTarget.dispose();
		});
		const aspectRatioUniform = uniform(dimensions.width / dimensions.height);
		const baseUV = screenUV;
		const intensity = uniforms.intensity.uniform;
		const baseTileCount = uniforms.tileCount.uniform;
		const rotationDegrees = uniforms.rotation.uniform;
		const roundnessAmount = uniforms.roundness.uniform;
		const tileCount = vec2(aspectRatioUniform.greaterThanEqual(1).select(mul(baseTileCount, aspectRatioUniform), baseTileCount), aspectRatioUniform.lessThan(1).select(div(baseTileCount, aspectRatioUniform), baseTileCount));
		const aspectCorrectedUV = vec2(mul(baseUV.x, aspectRatioUniform), baseUV.y);
		const rotationRadians = mul(rotationDegrees, Math.PI / 180);
		const cosAngle = cos(rotationRadians);
		const sinAngle = sin(rotationRadians);
		const centered = sub(aspectCorrectedUV, vec2(mul(.5, aspectRatioUniform), .5));
		const rotatedUV = add(vec2(sub(mul(centered.x, cosAngle), mul(centered.y, sinAngle)), add(mul(centered.x, sinAngle), mul(centered.y, cosAngle))), vec2(mul(.5, aspectRatioUniform), .5));
		const gridUV = vec2(div(rotatedUV.x, aspectRatioUniform), rotatedUV.y);
		const fromCenter = sub(div(sub(gridUV, div(floor(mul(gridUV, tileCount)), tileCount)), div(vec2(1), tileCount)), vec2(.5, .5));
		const clampedRoundness = sub(1, mul(mul(fromCenter.x, fromCenter.x).add(mul(fromCenter.y, fromCenter.y)), mul(roundnessAmount, 4))).max(0);
		const distortedUV = add(baseUV, mul(fromCenter, mul(mul(intensity, .025), clampedRoundness)));
		return vec4(texture$1$1.sample(distortedUV));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/GlassTiles.js
function computeEffectiveProps$41(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$42 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$41 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$41 && componentDefinition$41.props) Object.entries(componentDefinition$41.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$41[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$41 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$41.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$41(props, defaultProps$41);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$42,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$41, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$41.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$41);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var GlassTiles_default = OmbreComponent$41;

//#endregion
//#region node_modules/shaders/dist/core/Glow-BYNKuw0E.js
var componentDefinition$40 = {
	name: "Glow",
	category: "Stylize",
	description: "Soft glow effect with adjustable intensity",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 1,
			description: "Glow intensity (brightness of the glow effect)",
			ui: {
				type: "range",
				min: 0,
				max: 10,
				step: .01,
				label: "Intensity"
			}
		},
		threshold: {
			default: .5,
			description: "Brightness threshold for glow extraction (lower = more glow)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Threshold"
			}
		},
		size: {
			default: 10,
			description: "Size/spread of the glow effect",
			ui: {
				type: "range",
				min: 1,
				max: 20,
				step: .01,
				label: "Glow Size"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const originalColor = childTexture.sample(screenUV);
		const glowEffect = Fn(() => {
			const blurRadius = uniforms.size.uniform;
			const threshold = uniforms.threshold.uniform;
			const pixelSize = vec2(1).div(viewportSize);
			const blurredGlow = vec4(0, 0, 0, 0).toVar();
			const radius = 5;
			for (let dx = -radius; dx <= radius; dx++) for (let dy = -radius; dy <= radius; dy++) {
				const offset = vec2(float(dx), float(dy)).mul(pixelSize).mul(blurRadius);
				const sampleUV = screenUV.add(offset);
				const sampleColor = childTexture.sample(sampleUV);
				const luminance$3 = dot(sampleColor.rgb, vec3(.299, .587, .114));
				const brightnessMask = max(float(0), luminance$3.sub(threshold));
				const brightColor = sampleColor.mul(brightnessMask);
				blurredGlow.assign(blurredGlow.add(brightColor));
			}
			const totalSamples = float((radius * 2 + 1) * (radius * 2 + 1));
			return blurredGlow.div(totalSamples);
		})();
		const intensity = uniforms.intensity.uniform;
		const intensifiedGlow = glowEffect.mul(intensity);
		return vec4(originalColor.rgb.add(intensifiedGlow.rgb), max(originalColor.a, intensifiedGlow.a));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Glow.js
function computeEffectiveProps$40(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$41 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$40 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$40 && componentDefinition$40.props) Object.entries(componentDefinition$40.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$40[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$40 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$40.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$40(props, defaultProps$40);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$41,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$40, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$40.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$40);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Glow_default = OmbreComponent$40;

//#endregion
//#region node_modules/shaders/dist/core/Godrays-DCk1c8sQ.js
var componentDefinition$39 = {
	name: "Godrays",
	category: "Base Layers",
	description: "Volumetric light rays emanating from a point",
	requiresRTT: false,
	props: {
		center: {
			default: {
				x: 0,
				y: 0
			},
			transform: transformPosition,
			description: "The center point of the god rays",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		density: {
			default: .3,
			description: "Frequency of ray sectors",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Density"
			}
		},
		intensity: {
			default: .8,
			description: "Ray visibility within sectors",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Intensity"
			}
		},
		spotty: {
			default: 1,
			description: "Density of spots on rays (higher = more spots)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Spotty"
			}
		},
		speed: {
			default: .5,
			description: "Animation speed of the rays",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Speed"
			}
		},
		rayColor: {
			default: "#4283fb",
			transform: transformColor,
			description: "Color of the light rays",
			ui: {
				type: "color",
				label: "Ray Color"
			}
		},
		backgroundColor: {
			default: "transparent",
			transform: transformColor,
			description: "Background color",
			ui: {
				type: "color",
				label: "Background Color"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const uv$1$2 = screenUV;
		const centerPos = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const shapeUV = uv$1$2.sub(centerPos);
		const valueNoise = Fn(([st]) => {
			const i = st.floor();
			const f = st.fract();
			const hash$3 = (p$1) => {
				return sin(p$1.x.mul(127.1).add(p$1.y.mul(311.7))).mul(43758.5453).fract();
			};
			const a$1 = hash$3(i);
			const b$2 = hash$3(i.add(vec2(1, 0)));
			const c$1 = hash$3(i.add(vec2(0, 1)));
			const d$1 = hash$3(i.add(vec2(1, 1)));
			const u = f.mul(f).mul(f.mul(-2).add(3));
			return mix(mix(a$1, b$2, u.x), mix(c$1, d$1, u.x), u.y);
		});
		const raysShape = Fn(([uv$2$1, r, freq, intensity]) => {
			const a$1 = atan(uv$2$1.y, uv$2$1.x);
			const left = vec2(a$1.mul(freq), r);
			const right = vec2(a$1.mod(PI.mul(2)).mul(freq), r);
			const nLeft = pow(valueNoise(left), intensity);
			return mix(pow(valueNoise(right), intensity), nLeft, smoothstep(-.15, .15, uv$2$1.x));
		});
		const animTime = createAnimatedTime(params, uniforms.speed).mul(.2);
		const rayEffect = Fn(() => {
			const radius = length(shapeUV);
			const spots = float(6.5).mul(abs(uniforms.spotty.uniform));
			const intensityCalc = float(4).sub(float(3).mul(clamp(uniforms.intensity.uniform, 0, 1)));
			const density = float(6).mul(uniforms.density.uniform);
			const accumRay = float(0).toVar();
			const r1 = radius.mul(1).sub(animTime.mul(3));
			const r2 = radius.mul(.5).mul(float(1).add(spots)).sub(animTime.mul(2));
			const f1 = density.mul(5);
			const ray = raysShape(shapeUV, r1, f1, intensityCalc).toVar();
			ray.assign(ray.mul(raysShape(shapeUV, r2, f1.mul(4), intensityCalc)));
			accumRay.assign(accumRay.add(ray));
			const r3 = radius.mul(1.4).sub(animTime.mul(2.5));
			const r4 = radius.mul(.7).mul(float(1).add(spots)).sub(animTime.mul(1.8));
			const f2 = density.mul(4.5);
			const ray2 = raysShape(shapeUV, r3, f2, intensityCalc).toVar();
			ray2.assign(ray2.mul(raysShape(shapeUV, r4, f2.mul(3.5), intensityCalc)));
			accumRay.assign(accumRay.add(ray2.mul(.7)));
			return clamp(accumRay, 0, 1);
		})();
		const rayColorRGB = uniforms.rayColor.uniform.rgb;
		const rayColorA = uniforms.rayColor.uniform.a;
		const bgColorRGB = uniforms.backgroundColor.uniform.rgb;
		const bgColorA = uniforms.backgroundColor.uniform.a;
		const rayAlpha = rayEffect.mul(rayColorA);
		const finalAlpha = rayAlpha.add(bgColorA.mul(float(1).sub(rayAlpha)));
		const safeAlpha = clamp(finalAlpha, .001, 1);
		const rayContribution = rayColorRGB.mul(rayAlpha);
		const bgContribution = bgColorRGB.mul(bgColorA).mul(float(1).sub(rayAlpha));
		return vec4(rayContribution.add(bgContribution).div(safeAlpha), finalAlpha);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Godrays.js
function computeEffectiveProps$39(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$40 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$39 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$39 && componentDefinition$39.props) Object.entries(componentDefinition$39.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$39[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$39 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$39.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$39(props, defaultProps$39);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$40,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$39, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$39.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$39);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Godrays_default = OmbreComponent$39;

//#endregion
//#region node_modules/shaders/dist/core/Grayscale-BH3tLDGN.js
var componentDefinition$38 = {
	name: "Grayscale",
	category: "Adjustments",
	description: "Convert colors to black and white",
	requiresChild: true,
	props: {},
	fragmentNode: ({ childNode }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Grayscale shader.");
			return vec4(0);
		}
		const luminance$3 = dot(childNode.rgb, vec3(.2126, .7152, .0722));
		return vec4(luminance$3, luminance$3, luminance$3, childNode.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Grayscale.js
function computeEffectiveProps$38(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$39 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$38 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$38 && componentDefinition$38.props) Object.entries(componentDefinition$38.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$38[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$38 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$38.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$38(props, defaultProps$38);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$39,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$38, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$38.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$38);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Grayscale_default = OmbreComponent$38;

//#endregion
//#region node_modules/shaders/dist/core/Grid-CdslWvoH.js
var componentDefinition$37 = {
	name: "Grid",
	category: "Base Layers",
	description: "Simple grid lines pattern with adjustable thickness",
	props: {
		color: {
			default: "#ffffff",
			transform: transformColor,
			description: "The color of the grid lines",
			ui: {
				type: "color",
				label: "Color"
			}
		},
		cells: {
			default: 10,
			description: "Number of cells along the shortest canvas edge (creates square cells)",
			ui: {
				type: "range",
				min: 1,
				max: 50,
				step: 1,
				label: "Cells"
			}
		},
		thickness: {
			default: 1,
			description: "Thickness of grid lines (normalized, 0.0-1.0)",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Thickness"
			}
		}
	},
	fragmentNode: ({ uniforms }) => {
		const uv$1$2 = screenUV;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const correctedUV = vec2(uv$1$2.x.mul(aspect$1), uv$1$2.y.oneMinus());
		const cells = uniforms.cells.uniform;
		const gridUV = correctedUV.mul(cells);
		const gridFract = fract(gridUV);
		const lineWidth = uniforms.thickness.uniform.mul(.01);
		const distToLineX = gridFract.x.min(gridFract.x.oneMinus());
		const distToLineY = gridFract.y.min(gridFract.y.oneMinus());
		const pixelSize = fwidth(gridUV);
		const gridMask = max(smoothstep(lineWidth.add(pixelSize.x), lineWidth, distToLineX), smoothstep(lineWidth.add(pixelSize.y), lineWidth, distToLineY));
		return vec4(uniforms.color.uniform.rgb, uniforms.color.uniform.a.mul(gridMask));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Grid.js
function computeEffectiveProps$37(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$38 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$37 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$37 && componentDefinition$37.props) Object.entries(componentDefinition$37.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$37[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$37 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$37.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$37(props, defaultProps$37);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$38,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$37, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$37.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$37);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Grid_default = OmbreComponent$37;

//#endregion
//#region node_modules/shaders/dist/core/GridDistortion-D-iiGELF.js
var DEFAULT_GRID_SIZE = 20;
var displacementStateCache$1 = /* @__PURE__ */ new WeakMap();
var getOrCreateDisplacementState$1 = (uniforms) => {
	let state = displacementStateCache$1.get(uniforms);
	const gridSize = uniforms?.gridSize?.uniform?.value ? Math.max(8, Math.min(128, Math.floor(uniforms.gridSize.uniform.value))) : DEFAULT_GRID_SIZE;
	if (state && state.gridSize !== gridSize) {
		state.dataTexture.dispose();
		state = void 0;
		displacementStateCache$1.delete(uniforms);
	}
	if (!state) {
		const data = new Float32Array(gridSize * gridSize * 2);
		const dataTexture = new DataTexture(data, gridSize, gridSize, RGFormat, FloatType);
		dataTexture.magFilter = LinearFilter;
		dataTexture.minFilter = LinearFilter;
		dataTexture.needsUpdate = true;
		state = {
			dataTexture,
			data,
			tslNode: texture(dataTexture),
			gridSize
		};
		displacementStateCache$1.set(uniforms, state);
	}
	return state;
};
var componentDefinition$36 = {
	name: "GridDistortion",
	category: "Interactive",
	description: "Interactive grid distortion controlled by mouse position",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 1,
			description: "Strength of the distortion effect",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Intensity"
			}
		},
		swirl: {
			default: 0,
			description: "Amount of swirl motion",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .1,
				label: "Swirl"
			}
		},
		decay: {
			default: 3,
			description: "Rate of distortion decay (higher = faster)",
			ui: {
				type: "range",
				min: 0,
				max: 10,
				step: .1,
				label: "Decay"
			}
		},
		radius: {
			default: 1,
			description: "Radius of the distortion effect",
			ui: {
				type: "range",
				min: 0,
				max: 3,
				step: .01,
				label: "Radius"
			}
		},
		gridSize: {
			default: 20,
			description: "Resolution of the distortion grid (higher = more detailed)",
			ui: {
				type: "range",
				min: 8,
				max: 128,
				step: 1,
				label: "Grid Size"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, onBeforeRender, childNode, onCleanup }) => {
		const { dataTexture: displacementTexture, data: displacementData, tslNode: displacementField, gridSize: GRID_SIZE$1 } = getOrCreateDisplacementState$1(uniforms);
		const mouseVelX = uniform(0);
		const mouseVelY = uniform(0);
		let prevX = .5;
		let prevY = .5;
		let lastTime = Date.now();
		onBeforeRender(({ pointer }) => {
			const currentTime = Date.now();
			const dt = Math.min((currentTime - lastTime) / 1e3, .016);
			lastTime = currentTime;
			const velX = dt > 0 ? (pointer.x - prevX) / dt : 0;
			const velY = dt > 0 ? (pointer.y - prevY) / dt : 0;
			mouseVelX.value = mouseVelX.value * .85 + velX * .15;
			mouseVelY.value = mouseVelY.value * .85 + velY * .15;
			const decay = uniforms.decay.uniform.value;
			const intensity = uniforms.intensity.uniform.value;
			const radius = uniforms.radius.uniform.value * .05;
			const swirl = uniforms.swirl.uniform.value;
			for (let i = 0; i < GRID_SIZE$1; i++) for (let j = 0; j < GRID_SIZE$1; j++) {
				const idx = (i * GRID_SIZE$1 + j) * 2;
				displacementData[idx] *= 1 - decay * dt;
				displacementData[idx + 1] *= 1 - decay * dt;
				const cellX = (j + .5) / GRID_SIZE$1;
				const cellY = (i + .5) / GRID_SIZE$1;
				const dx = cellX - pointer.x;
				const dy = cellY - pointer.y;
				const dist = Math.sqrt(dx * dx + dy * dy);
				if (dist < radius * 2 && Math.abs(velX) + Math.abs(velY) > .01) {
					const influence = Math.exp(-dist * dist / (radius * radius));
					displacementData[idx] += mouseVelX.value * influence * intensity * dt * .5;
					displacementData[idx + 1] += mouseVelY.value * influence * intensity * dt * .5;
					if (swirl > 0) {
						const angle = Math.atan2(dy, dx) + Math.PI * .5;
						displacementData[idx] += Math.cos(angle) * swirl * influence * dt * 2;
						displacementData[idx + 1] += Math.sin(angle) * swirl * influence * dt * 2;
					}
				}
				displacementData[idx] = Math.max(-1, Math.min(1, displacementData[idx]));
				displacementData[idx + 1] = Math.max(-1, Math.min(1, displacementData[idx + 1]));
			}
			displacementTexture.needsUpdate = true;
			prevX = pointer.x;
			prevY = pointer.y;
		});
		onCleanup(() => {
			displacementTexture.dispose();
			displacementStateCache$1.delete(uniforms);
		});
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const gridSizeUniform = uniforms.gridSize.uniform;
		const gridScale = float(1).div(gridSizeUniform);
		const gridCellUV = screenUV.div(gridScale).floor().mul(gridScale).add(gridScale.mul(.5));
		const displacement = displacementField.sample(gridCellUV).xy;
		const maxDisplacement = float(.1);
		const negMaxDisplacement = float(-.1);
		const clampedDisplacement = displacement.clamp(vec2(negMaxDisplacement, negMaxDisplacement), vec2(maxDisplacement, maxDisplacement));
		const distortedUV = screenUV.sub(clampedDisplacement);
		return applyEdgeHandling(distortedUV, childTexture.sample(distortedUV), childTexture, uniforms.edges.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/GridDistortion.js
function computeEffectiveProps$36(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$37 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$36 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$36 && componentDefinition$36.props) Object.entries(componentDefinition$36.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$36[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$36 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$36.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$36(props, defaultProps$36);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$37,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$36, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$36.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$36);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var GridDistortion_default = OmbreComponent$36;

//#endregion
//#region node_modules/shaders/dist/core/Group-ByGv48Lm.js
var componentDefinition$35 = {
	name: "Group",
	category: "Utilities",
	description: "Container for organizing and composing child effects",
	requiresChild: true,
	props: {},
	fragmentNode: ({ childNode }) => {
		return childNode || vec4(0);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Group.js
function computeEffectiveProps$35(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$36 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$35 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$35 && componentDefinition$35.props) Object.entries(componentDefinition$35.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$35[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$35 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$35.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$35(props, defaultProps$35);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$36,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$35, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$35.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$35);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Group_default = OmbreComponent$35;

//#endregion
//#region node_modules/shaders/dist/core/Halftone-CV0aFuRG.js
var componentDefinition$34 = {
	name: "Halftone",
	category: "Stylize",
	description: "Halftone dot pattern effect for printing aesthetics",
	requiresChild: true,
	props: {
		frequency: {
			default: 100,
			description: "Frequency of the halftone dots",
			ui: {
				type: "range",
				min: 10,
				max: 300,
				step: 1,
				label: "Frequency"
			}
		},
		angle: {
			default: 45,
			transform: transformAngle,
			description: "Rotation angle of the pattern (in degrees)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		smoothness: {
			default: .1,
			description: "Edge smoothness of the dots",
			ui: {
				type: "range",
				min: 0,
				max: .3,
				step: .01,
				label: "Smoothness"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode }) => {
		if (!childNode) return vec4(0);
		const _uv = screenUV;
		const frequency = uniforms.frequency.uniform;
		const angleDegrees = uniforms.angle.uniform;
		const smoothness = uniforms.smoothness.uniform;
		const angle = radians(angleDegrees);
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(_uv.x.mul(aspect$1), _uv.y);
		const c$1 = cos(angle);
		const s = sin(angle);
		const gridUV = fract(vec2(dot(aspectCorrectedUV, vec2(c$1, s.negate())), dot(aspectCorrectedUV, vec2(s, c$1))).mul(frequency)).sub(.5);
		const originalColor = childNode;
		const dotSize = dot(originalColor.rgb, vec3(.299, .587, .114)).mul(.7).add(.15);
		const dist = length(gridUV);
		const dotPattern = smoothstep(dotSize.add(smoothness), dotSize.sub(smoothness), dist);
		return vec4(originalColor.rgb.mul(dotPattern), originalColor.a.mul(dotPattern));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Halftone.js
function computeEffectiveProps$34(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$35 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$34 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$34 && componentDefinition$34.props) Object.entries(componentDefinition$34.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$34[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$34 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$34.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$34(props, defaultProps$34);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$35,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$34, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$34.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$34);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Halftone_default = OmbreComponent$34;

//#endregion
//#region node_modules/shaders/dist/core/HueShift-DQ2WgImx.js
var componentDefinition$33 = {
	name: "HueShift",
	category: "Adjustments",
	description: "Rotate hue around the color wheel",
	requiresChild: true,
	props: { shift: {
		default: 0,
		description: "The amount to shift the hue by",
		ui: {
			type: "range",
			min: -180,
			max: 180,
			step: 1,
			label: "Shift"
		},
		transform: (value) => value * Math.PI / 180
	} },
	fragmentNode: ({ uniforms, childNode }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Hue Shift shader.");
			return vec4(0);
		}
		const angle = uniforms.shift.uniform;
		const cosA = cos(angle);
		const sinA = sin(angle);
		const k = 1 / 3;
		const sqrt3 = 1.7320508075688772;
		const kOneMinusCos = cosA.oneMinus().mul(k);
		const sinOverSqrt3 = sinA.div(sqrt3);
		const m00 = cosA.add(kOneMinusCos);
		const m01 = kOneMinusCos.sub(sinOverSqrt3);
		const m02 = kOneMinusCos.add(sinOverSqrt3);
		const m10 = kOneMinusCos.add(sinOverSqrt3);
		const m11 = cosA.add(kOneMinusCos);
		const m12 = kOneMinusCos.sub(sinOverSqrt3);
		const m20 = kOneMinusCos.sub(sinOverSqrt3);
		const m21 = kOneMinusCos.add(sinOverSqrt3);
		const m22 = cosA.add(kOneMinusCos);
		const r = childNode.r;
		const g$1 = childNode.g;
		const b$2 = childNode.b;
		return vec4(vec3(r.mul(m00).add(g$1.mul(m01)).add(b$2.mul(m02)), r.mul(m10).add(g$1.mul(m11)).add(b$2.mul(m12)), r.mul(m20).add(g$1.mul(m21)).add(b$2.mul(m22))), childNode.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/HueShift.js
function computeEffectiveProps$33(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$34 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$33 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$33 && componentDefinition$33.props) Object.entries(componentDefinition$33.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$33[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$33 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$33.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$33(props, defaultProps$33);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$34,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$33, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$33.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$33);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var HueShift_default = OmbreComponent$33;

//#endregion
//#region node_modules/shaders/dist/core/ImageTexture-DKFb8ze3.js
var componentDefinition$32 = {
	name: "ImageTexture",
	category: "Base Layers",
	description: "Display an image with customizable object-fit modes",
	props: {
		url: {
			default: "https://shaders.com/sample.jpg",
			description: "Upload an image or provide a URL",
			ui: {
				type: "image-upload",
				label: "Image"
			}
		},
		objectFit: {
			default: "cover",
			description: "How the image should be sized within the viewport",
			transform: (value) => {
				return {
					"cover": 0,
					"contain": 1,
					"fill": 2,
					"scale-down": 3,
					"none": 4
				}[value] ?? 0;
			},
			ui: {
				type: "select",
				options: [
					{
						label: "Cover",
						value: "cover"
					},
					{
						label: "Contain",
						value: "contain"
					},
					{
						label: "Fill",
						value: "fill"
					},
					{
						label: "Scale Down",
						value: "scale-down"
					},
					{
						label: "None",
						value: "none"
					}
				],
				label: "Object Fit"
			}
		}
	},
	fragmentNode: ({ uniforms, onCleanup, onBeforeRender }) => {
		const baseUV = screenUV;
		const loader = new TextureLoader();
		let currentUrl = "";
		let isLoading = false;
		const placeholderTexture = new Texture();
		placeholderTexture.colorSpace = SRGBColorSpace;
		const textureNode = texture(placeholderTexture);
		const imageAspectUniform = uniform(1);
		const imageWidthUniform = uniform(0);
		const imageHeightUniform = uniform(0);
		const loadImage = (url) => {
			if (!url || url.trim() === "" || isLoading) return;
			isLoading = true;
			try {
				let resolvedUrl = url;
				try {
					resolvedUrl = new URL(url, window.location.href).href;
				} catch (e) {}
				loader.load(url, (loadedTexture) => {
					loadedTexture.colorSpace = SRGBColorSpace;
					const img = loadedTexture.image;
					const newWidth = img.width || 1;
					const newHeight = img.height || 1;
					const newAspect = newWidth / newHeight;
					loadedTexture.dispose();
					currentUrl = url;
					requestAnimationFrame(() => {
						const currentImage = placeholderTexture.image;
						if (currentImage && typeof currentImage === "object" && (currentImage.width !== newWidth || currentImage.height !== newHeight)) placeholderTexture.dispose();
						imageAspectUniform.value = newAspect;
						imageWidthUniform.value = newWidth;
						imageHeightUniform.value = newHeight;
						placeholderTexture.image = img;
						placeholderTexture.colorSpace = SRGBColorSpace;
						placeholderTexture.needsUpdate = true;
					});
					isLoading = false;
				}, void 0, (error$1) => {
					const isRelative = !url.startsWith("http://") && !url.startsWith("https://") && !url.startsWith("data:");
					console.error(`[ImageTexture] Failed to load image\n  Requested URL: ${url}\n  Resolved URL: ${resolvedUrl}\n  Path type: ${isRelative ? "relative" : "absolute"}\n  Error:`, error$1);
					isLoading = false;
				});
			} catch (error$1) {
				console.error(`[ImageTexture] Error initiating image load:`, error$1);
				isLoading = false;
			}
		};
		setTimeout(() => {
			const initialUrl = uniforms?.url?.uniform?.value ?? "";
			if (initialUrl && initialUrl.trim() !== "") loadImage(initialUrl);
		}, 0);
		onBeforeRender(() => {
			const newUrl = uniforms?.url?.uniform?.value ?? "";
			if (newUrl !== currentUrl && !isLoading) loadImage(newUrl);
		});
		onCleanup(() => {
			placeholderTexture.dispose();
		});
		const uv$1$2 = baseUV;
		const viewportAspect = viewportSize.x.div(viewportSize.y);
		const objectFitMode = uniforms.objectFit.uniform;
		const coverScale = max(viewportAspect.div(imageAspectUniform), float(1));
		const coverUVScale = vec2(imageAspectUniform.div(viewportAspect).mul(coverScale), coverScale);
		const containScale = min(viewportAspect.div(imageAspectUniform), float(1));
		const containUVScale = vec2(imageAspectUniform.div(viewportAspect).mul(containScale), containScale);
		const fillUVScale = vec2(1, 1);
		const scaleDownScale = min(min(viewportAspect.div(imageAspectUniform), float(1)), min(viewportSize.x.div(imageWidthUniform), viewportSize.y.div(imageHeightUniform)));
		const scaleDownUVScale = vec2(imageAspectUniform.div(viewportAspect).mul(scaleDownScale), scaleDownScale);
		const noneScale = min(viewportSize.x.div(imageWidthUniform), viewportSize.y.div(imageHeightUniform));
		const noneUVScale = vec2(imageAspectUniform.div(viewportAspect).mul(noneScale), noneScale);
		const isCover = step(objectFitMode, float(.5));
		const isContain = step(float(.5), objectFitMode).mul(step(objectFitMode, float(1.5)));
		const isFill = step(float(1.5), objectFitMode).mul(step(objectFitMode, float(2.5)));
		const isScaleDown = step(float(2.5), objectFitMode).mul(step(objectFitMode, float(3.5)));
		const isNone$1 = step(float(3.5), objectFitMode);
		const uvScale = vec2(0).add(coverUVScale.mul(isCover)).add(containUVScale.mul(isContain)).add(fillUVScale.mul(isFill)).add(scaleDownUVScale.mul(isScaleDown)).add(noneUVScale.mul(isNone$1));
		const adjustedUV = uv$1$2.sub(vec2(.5)).div(uvScale).add(vec2(.5));
		const finalUV = vec2(adjustedUV.x, float(1).sub(adjustedUV.y));
		const sampledColor = textureNode.sample(finalUV);
		const isOutOfBounds = or(or(finalUV.x.lessThan(0), finalUV.x.greaterThan(1)), or(finalUV.y.lessThan(0), finalUV.y.greaterThan(1)));
		return vec4(sampledColor.rgb, select(isOutOfBounds, float(0), sampledColor.a));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/ImageTexture.js
function computeEffectiveProps$32(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$33 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$32 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$32 && componentDefinition$32.props) Object.entries(componentDefinition$32.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$32[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$32 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$32.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$32(props, defaultProps$32);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$33,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$32, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$32.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$32);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var ImageTexture_default = OmbreComponent$32;

//#endregion
//#region node_modules/shaders/dist/core/Invert-w9duGaUu.js
var componentDefinition$31 = {
	name: "Invert",
	category: "Adjustments",
	description: "Invert RGB colors while preserving alpha",
	requiresChild: true,
	props: {},
	fragmentNode: ({ childNode }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Invert shader.");
			return vec4(0);
		}
		const sourceColor = childNode || vec4(0, 0, 0, 0);
		const alpha = sourceColor.a;
		const unpremultiplied = alpha.greaterThan(0).select(sourceColor.rgb.div(alpha), vec3(0, 0, 0));
		return vec4(vec3(1, 1, 1).sub(unpremultiplied).mul(alpha), alpha);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Invert.js
function computeEffectiveProps$31(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$32 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$31 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$31 && componentDefinition$31.props) Object.entries(componentDefinition$31.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$31[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$31 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$31.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$31(props, defaultProps$31);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$32,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$31, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$31.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$31);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Invert_default = OmbreComponent$31;

//#endregion
//#region node_modules/shaders/dist/core/LinearBlur-CTXjolzL.js
var componentDefinition$30 = {
	name: "LinearBlur",
	category: "Blurs",
	description: "Directional motion blur in a specific angle",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 30,
			description: "Intensity of the linear blur effect",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Intensity"
			}
		},
		angle: {
			default: 0,
			transform: transformAngle,
			description: "Direction of the linear blur (in degrees)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const angleRad = radians(uniforms.angle.uniform);
		const blurDirection = vec2(cos(angleRad), sin(angleRad));
		return Fn(() => {
			const uv$1$2 = screenUV;
			const texel = vec2(1).div(viewportSize);
			const blurVector = blurDirection.mul(uniforms.intensity.uniform).mul(texel).mul(2);
			const total = vec4(0).toVar();
			const totalWeight = float(0).toVar();
			for (let i = 0; i < 32; i++) {
				const t = float(i).div(float(31)).sub(.5).mul(2);
				const weight = float(1).div(float(2.506628)).mul(float(-.5).mul(t).mul(t).div(float(.64)).exp());
				const coord = uv$1$2.add(blurVector.mul(t.mul(.5)));
				const sample$2 = childTexture.sample(coord).mul(weight);
				total.assign(total.add(sample$2));
				totalWeight.assign(totalWeight.add(weight));
			}
			return total.div(totalWeight);
		})();
	}
};

//#endregion
//#region node_modules/shaders/dist/react/LinearBlur.js
function computeEffectiveProps$30(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$31 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$30 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$30 && componentDefinition$30.props) Object.entries(componentDefinition$30.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$30[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$30 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$30.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$30(props, defaultProps$30);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$31,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$30, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$30.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$30);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var LinearBlur_default = OmbreComponent$30;

//#endregion
//#region node_modules/shaders/dist/core/LinearGradient-CZo6e7r8.js
var componentDefinition$29 = {
	name: "LinearGradient",
	category: "Base Layers",
	description: "Create smooth linear color gradients",
	props: {
		colorA: {
			default: "#1aff00",
			transform: transformColor,
			description: "The starting color of the gradient",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#0000ff",
			transform: transformColor,
			description: "The ending color of the gradient",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		start: {
			default: {
				x: 0,
				y: .5
			},
			transform: transformPosition,
			description: "The starting point of the gradient",
			ui: {
				type: "position",
				label: "Start"
			}
		},
		end: {
			default: {
				x: 1,
				y: .5
			},
			transform: transformPosition,
			description: "The ending point of the gradient",
			ui: {
				type: "position",
				label: "End"
			}
		},
		angle: {
			default: 0,
			transform: transformAngle,
			description: "Additional rotation angle of the gradient (in degrees)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		edges: {
			default: "stretch",
			transform: transformEdges,
			description: "How to handle areas beyond the gradient endpoints",
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms }) => {
		const uv$1$2 = screenUV;
		const startPos = vec2(uniforms.start.uniform[0], uniforms.start.uniform[1].oneMinus());
		const endPos = vec2(uniforms.end.uniform[0], uniforms.end.uniform[1].oneMinus());
		const gradientVector = endPos.sub(startPos);
		const gradientLength = length(gradientVector);
		const gradientDir = normalize(gradientVector);
		const angleRad = radians(uniforms.angle.uniform).negate();
		const cosAngle = cos(angleRad);
		const sinAngle = sin(angleRad);
		const midpoint = startPos.add(endPos).mul(.5);
		const centeredUV = uv$1$2.sub(midpoint);
		const t = dot(vec2(centeredUV.x.mul(cosAngle).sub(centeredUV.y.mul(sinAngle)), centeredUV.x.mul(sinAngle).add(centeredUV.y.mul(cosAngle))).add(midpoint).sub(startPos), gradientDir).div(gradientLength.max(1e-6));
		const edgeMode = uniforms.edges.uniform;
		const stretchT = t.clamp(float(0), float(1));
		const inBoundsX = t.greaterThanEqual(float(0)).select(float(1), float(0));
		const inBoundsY = t.lessThanEqual(float(1)).select(float(1), float(0));
		const inBounds = inBoundsX.mul(inBoundsY);
		const mirrorT = mod(abs(t), float(2));
		const finalMirrorT = mirrorT.greaterThan(float(1)).select(float(2).sub(mirrorT), mirrorT);
		const wrapT = fract(t);
		const isMode1OrHigher = edgeMode.greaterThanEqual(float(.5));
		const isMode2OrHigher = edgeMode.greaterThanEqual(float(1.5));
		const finalT = edgeMode.greaterThanEqual(float(2.5)).select(wrapT, isMode2OrHigher.select(finalMirrorT, isMode1OrHigher.select(t, stretchT)));
		const mixedColor = mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, finalT.clamp(float(0), float(1)), uniforms.colorSpace.uniform);
		const finalAlpha = isMode1OrHigher.and(edgeMode.lessThan(float(1.5))).select(mixedColor.w.mul(inBounds), mixedColor.w);
		return vec4(mixedColor.x, mixedColor.y, mixedColor.z, finalAlpha);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/LinearGradient.js
function computeEffectiveProps$29(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$30 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$29 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$29 && componentDefinition$29.props) Object.entries(componentDefinition$29.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$29[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$29 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$29.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$29(props, defaultProps$29);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$30,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$29, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$29.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$29);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var LinearGradient_default = OmbreComponent$29;

//#endregion
//#region node_modules/shaders/dist/core/Liquify-BbfDBMNZ.js
var GRID_SIZE = 32;
var displacementStateCache = /* @__PURE__ */ new WeakMap();
var getOrCreateDisplacementState = (uniforms) => {
	let state = displacementStateCache.get(uniforms);
	if (!state) {
		const data = new Float32Array(GRID_SIZE * GRID_SIZE * 2);
		const dataTexture = new DataTexture(data, GRID_SIZE, GRID_SIZE, RGFormat, FloatType);
		dataTexture.magFilter = LinearFilter;
		dataTexture.minFilter = LinearFilter;
		dataTexture.needsUpdate = true;
		state = {
			dataTexture,
			data,
			tslNode: texture(dataTexture),
			initialized: false
		};
		displacementStateCache.set(uniforms, state);
	}
	return state;
};
var componentDefinition$28 = {
	name: "Liquify",
	category: "Interactive",
	description: "Liquid-like interactive deformation effect",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 1,
			description: "Strength of the distortion effect",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Intensity"
			}
		},
		swirl: {
			default: 0,
			description: "Amount of swirl motion (0-1)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Swirl"
			}
		},
		decay: {
			default: 3,
			description: "Rate of distortion decay (higher = faster)",
			ui: {
				type: "range",
				min: 0,
				max: 10,
				step: .1,
				label: "Decay"
			}
		},
		radius: {
			default: 1,
			description: "Radius of the distortion effect",
			ui: {
				type: "range",
				min: 0,
				max: 3,
				step: .01,
				label: "Radius"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, onBeforeRender, childNode, onCleanup }) => {
		const { dataTexture: displacementTexture, data: displacementData, tslNode: displacementField } = getOrCreateDisplacementState(uniforms);
		const mouseVelX = uniform(0);
		const mouseVelY = uniform(0);
		let prevX = .5;
		let prevY = .5;
		let lastTime = Date.now();
		onBeforeRender(({ pointer }) => {
			const currentTime = Date.now();
			const dt = Math.min((currentTime - lastTime) / 1e3, .016);
			lastTime = currentTime;
			const velX = dt > 0 ? (pointer.x - prevX) / dt : 0;
			const velY = dt > 0 ? (pointer.y - prevY) / dt : 0;
			mouseVelX.value = mouseVelX.value * .85 + velX * .15;
			mouseVelY.value = mouseVelY.value * .85 + velY * .15;
			const decay = uniforms.decay.uniform.value;
			const intensity = uniforms.intensity.uniform.value;
			const radius = uniforms.radius.uniform.value * .05;
			const swirl = uniforms.swirl.uniform.value;
			for (let i = 0; i < GRID_SIZE; i++) for (let j = 0; j < GRID_SIZE; j++) {
				const idx = (i * GRID_SIZE + j) * 2;
				displacementData[idx] *= 1 - decay * dt;
				displacementData[idx + 1] *= 1 - decay * dt;
				const cellX = (j + .5) / GRID_SIZE;
				const cellY = (i + .5) / GRID_SIZE;
				const dx = cellX - pointer.x;
				const dy = cellY - pointer.y;
				const dist = Math.sqrt(dx * dx + dy * dy);
				if (dist < radius * 2 && Math.abs(velX) + Math.abs(velY) > .01) {
					const influence = Math.exp(-dist * dist / (radius * radius));
					displacementData[idx] += mouseVelX.value * influence * intensity * dt * .5;
					displacementData[idx + 1] += mouseVelY.value * influence * intensity * dt * .5;
					if (swirl > 0) {
						const angle = Math.atan2(dy, dx) + Math.PI * .5;
						displacementData[idx] += Math.cos(angle) * swirl * influence * dt * 2;
						displacementData[idx + 1] += Math.sin(angle) * swirl * influence * dt * 2;
					}
				}
				displacementData[idx] = Math.max(-1, Math.min(1, displacementData[idx]));
				displacementData[idx + 1] = Math.max(-1, Math.min(1, displacementData[idx + 1]));
			}
			displacementTexture.needsUpdate = true;
			prevX = pointer.x;
			prevY = pointer.y;
		});
		onCleanup(() => {
			displacementTexture.dispose();
			displacementStateCache.delete(uniforms);
		});
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const displacement = displacementField.sample(screenUV).xy;
		const maxDisplacement = float(.2);
		const negMaxDisplacement = float(-.2);
		const clampedDisplacement = displacement.clamp(vec2(negMaxDisplacement, negMaxDisplacement), vec2(maxDisplacement, maxDisplacement));
		const distortedUV = screenUV.sub(clampedDisplacement);
		return applyEdgeHandling(distortedUV, childTexture.sample(distortedUV), childTexture, uniforms.edges.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Liquify.js
function computeEffectiveProps$28(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$29 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$28 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$28 && componentDefinition$28.props) Object.entries(componentDefinition$28.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$28[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$28 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$28.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$28(props, defaultProps$28);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$29,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$28, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$28.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$28);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Liquify_default = OmbreComponent$28;

//#endregion
//#region node_modules/shaders/dist/core/Perspective-CSP2Hb16.js
var componentDefinition$27 = {
	name: "Perspective",
	category: "Distortions",
	description: "Rotate the plane in 3D space with pan and tilt",
	requiresRTT: true,
	requiresChild: true,
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "Center point of rotation",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		pan: {
			default: 0,
			description: "Horizontal rotation (left/right)",
			ui: {
				type: "range",
				min: -90,
				max: 90,
				step: .1,
				label: "Pan"
			}
		},
		tilt: {
			default: 0,
			description: "Vertical rotation (up/down)",
			ui: {
				type: "range",
				min: -90,
				max: 90,
				step: .1,
				label: "Tilt"
			}
		},
		fov: {
			default: 60,
			description: "Field of view - controls perspective intensity",
			ui: {
				type: "range",
				min: 30,
				max: 120,
				step: 1,
				label: "FOV"
			}
		},
		zoom: {
			default: 1,
			description: "Zoom in to fill the frame after rotation",
			ui: {
				type: "range",
				min: .5,
				max: 3,
				step: .01,
				label: "Zoom"
			}
		},
		offset: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "Shift the result in X/Y",
			ui: {
				type: "position",
				label: "Offset"
			}
		},
		edges: {
			default: "transparent",
			description: "How to handle edges",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const centerPos = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const zoom = uniforms.zoom.uniform;
		const x = screenUV.x.sub(centerPos.x).div(zoom);
		const y = screenUV.y.sub(centerPos.y).div(zoom);
		const panRad = uniforms.pan.uniform.mul(Math.PI / 180);
		const tiltRad = uniforms.tilt.uniform.mul(Math.PI / 180);
		const fovRad = uniforms.fov.uniform.mul(Math.PI / 180);
		const cosPan = cos(panRad);
		const sinPan = sin(panRad);
		const cosTilt = cos(tiltRad);
		const sinTilt = sin(tiltRad);
		const perspectiveFactor = tan(fovRad.mul(.5)).mul(2);
		const safePanDivisor = max(cosPan.add(sinPan.mul(x).mul(perspectiveFactor)), float(.001));
		const afterPanX = x.div(safePanDivisor);
		const afterPanY = y.mul(cosPan).div(safePanDivisor);
		const safeTiltDivisor = max(cosTilt.add(sinTilt.mul(afterPanY).mul(perspectiveFactor)), float(.001));
		const finalX = afterPanX.mul(cosTilt).div(safeTiltDivisor);
		const finalY = afterPanY.div(safeTiltDivisor);
		const offsetPos = vec2(uniforms.offset.uniform.x, uniforms.offset.uniform.y.oneMinus());
		const finalUV = vec2(finalX, finalY).add(centerPos).sub(offsetPos).add(vec2(.5, .5));
		return applyEdgeHandling(finalUV, childTexture.sample(finalUV), childTexture, uniforms.edges.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Perspective.js
function computeEffectiveProps$27(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$28 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$27 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$27 && componentDefinition$27.props) Object.entries(componentDefinition$27.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$27[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$27 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$27.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$27(props, defaultProps$27);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$28,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$27, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$27.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$27);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Perspective_default = OmbreComponent$27;

//#endregion
//#region node_modules/shaders/dist/core/Pixelate-BAoi-CSx.js
var componentDefinition$26 = {
	name: "Pixelate",
	category: "Stylize",
	description: "Pixelation effect with adjustable cell size",
	requiresRTT: true,
	requiresChild: true,
	props: { scale: {
		default: 50,
		description: "Pixel size - higher values create larger, more visible pixels",
		ui: {
			type: "range",
			min: 1,
			max: 200,
			step: 1,
			label: "Scale"
		}
	} },
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const pixelSize = uniforms.scale.uniform;
		const pixelatedUV = floor(screenUV.mul(pixelSize)).div(pixelSize);
		return childTexture.sample(pixelatedUV);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Pixelate.js
function computeEffectiveProps$26(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$27 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$26 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$26 && componentDefinition$26.props) Object.entries(componentDefinition$26.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$26[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$26 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$26.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$26(props, defaultProps$26);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$27,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$26, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$26.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$26);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Pixelate_default = OmbreComponent$26;

//#endregion
//#region node_modules/shaders/dist/core/PolarCoordinates-BwN9HhFK.js
var componentDefinition$25 = {
	name: "PolarCoordinates",
	category: "Distortions",
	description: "Convert rectangular coordinates to polar space",
	requiresRTT: true,
	requiresChild: true,
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point for polar coordinate conversion",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		wrap: {
			default: 1,
			description: "Controls how much of the angular range to use (1 = full 360°, 0.5 = 180°)",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Wrap"
			}
		},
		radius: {
			default: 1,
			description: "Controls how much of the radius range to use (affects the radial mapping)",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Radius"
			}
		},
		intensity: {
			default: 1,
			description: "Blends between original UVs (0) and polar coordinates (1)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Intensity"
			}
		},
		edges: {
			default: "transparent",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(screenUV.x.mul(aspect$1), screenUV.y);
		const centerPos = vec2(uniforms.center.uniform.x.mul(aspect$1), uniforms.center.uniform.y.oneMinus());
		const delta = aspectCorrectedUV.sub(centerPos);
		const normalizedAngle = atan(delta.y, delta.x).add(PI).div(PI.mul(2));
		const r = length(delta);
		const blendedUV = mix(screenUV, vec2(normalizedAngle.mul(uniforms.wrap.uniform), r.mul(uniforms.radius.uniform)), uniforms.intensity.uniform);
		return applyEdgeHandling(blendedUV, childTexture.sample(blendedUV), childTexture, uniforms.edges.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/PolarCoordinates.js
function computeEffectiveProps$25(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$26 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$25 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$25 && componentDefinition$25.props) Object.entries(componentDefinition$25.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$25[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$25 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$25.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$25(props, defaultProps$25);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$26,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$25, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$25.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$25);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var PolarCoordinates_default = OmbreComponent$25;

//#endregion
//#region node_modules/shaders/dist/core/Posterize-XoAqPWv2.js
var componentDefinition$24 = {
	name: "Posterize",
	category: "Adjustments",
	description: "Reduce color depth to create a poster effect",
	requiresChild: true,
	props: { intensity: {
		default: 5,
		description: "The intensity of the posterization effect (lower is more posterized)",
		ui: {
			type: "range",
			min: 2,
			max: 20,
			step: 1,
			label: "Intensity"
		}
	} },
	fragmentNode: ({ uniforms, childNode }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Posterize shader.");
			return vec4(0);
		}
		const steps$1 = float(uniforms.intensity.uniform);
		return vec4(floor(childNode.r.mul(steps$1)).div(steps$1), floor(childNode.g.mul(steps$1)).div(steps$1), floor(childNode.b.mul(steps$1)).div(steps$1), childNode.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Posterize.js
function computeEffectiveProps$24(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$25 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$24 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$24 && componentDefinition$24.props) Object.entries(componentDefinition$24.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$24[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$24 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$24.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$24(props, defaultProps$24);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$25,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$24, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$24.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$24);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Posterize_default = OmbreComponent$24;

//#endregion
//#region node_modules/shaders/dist/core/ProgressiveBlur-RuAm_BKx.js
var componentDefinition$23 = {
	name: "ProgressiveBlur",
	category: "Blurs",
	description: "Blur that increases progressively in one direction",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 50,
			description: "Maximum intensity of the blur effect",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Intensity"
			}
		},
		angle: {
			default: 0,
			transform: transformAngle,
			description: "Direction of the blur gradient (in degrees)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		center: {
			default: {
				x: 0,
				y: .5
			},
			transform: transformPosition,
			description: "Center point where blur begins",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		falloff: {
			default: 1,
			description: "Distance over which blur transitions to full strength",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Falloff"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const angleRad = radians(uniforms.angle.uniform);
		const direction = vec2(cos(angleRad), sin(angleRad));
		const centerPosition = vec2(uniforms.center.uniform[0], uniforms.center.uniform[1].oneMinus());
		const centeredUV = screenUV.sub(centerPosition);
		const directionalDist = max(float(0), centeredUV.dot(direction));
		const falloff = max(float(.001), uniforms.falloff.uniform);
		const blurAmount = smoothstep(float(0), falloff, directionalDist);
		const scaledIntensity = uniforms.intensity.uniform.mul(.06);
		const blurRadius = blurAmount.mul(scaledIntensity);
		const weights = [
			.056,
			.135,
			.278,
			.487,
			.726,
			.923,
			1,
			.923,
			.726,
			.487,
			.278,
			.135,
			.056
		];
		const weightSum = 6.214;
		const horizontalTexture = convertToTexture(Fn(() => {
			const uv$1$2 = screenUV;
			const pixelSize = vec2(1).div(viewportSize);
			const total = vec4(0).toVar();
			for (let x = -6; x <= 6; x++) {
				const weight = float(weights[x + 6] / weightSum);
				const offset = vec2(float(x), float(0)).mul(blurRadius).mul(pixelSize);
				const sampleCoord = uv$1$2.add(offset);
				const sample$2 = childTexture.sample(sampleCoord).mul(weight);
				total.assign(total.add(sample$2));
			}
			return total;
		})());
		onCleanup(() => {
			if (horizontalTexture?.renderTarget?.dispose) horizontalTexture.renderTarget.dispose();
		});
		return Fn(() => {
			const uv$1$2 = screenUV;
			const pixelSize = vec2(1).div(viewportSize);
			const total = vec4(0).toVar();
			for (let y = -6; y <= 6; y++) {
				const weight = float(weights[y + 6] / weightSum);
				const offset = vec2(float(0), float(y)).mul(blurRadius).mul(pixelSize);
				const sampleCoord = uv$1$2.add(offset);
				const sample$2 = horizontalTexture.sample(sampleCoord).mul(weight);
				total.assign(total.add(sample$2));
			}
			return total;
		})();
	}
};

//#endregion
//#region node_modules/shaders/dist/react/ProgressiveBlur.js
function computeEffectiveProps$23(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$24 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$23 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$23 && componentDefinition$23.props) Object.entries(componentDefinition$23.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$23[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$23 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$23.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$23(props, defaultProps$23);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$24,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$23, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$23.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$23);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var ProgressiveBlur_default = OmbreComponent$23;

//#endregion
//#region node_modules/shaders/dist/core/RadialGradient-BfFuRbIl.js
var componentDefinition$22 = {
	name: "RadialGradient",
	category: "Base Layers",
	description: "Radial gradient radiating from a center point",
	props: {
		colorA: {
			default: "#ff0000",
			transform: transformColor,
			description: "The starting color at the center of the gradient",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#0000ff",
			transform: transformColor,
			description: "The ending color at the edge of the gradient",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the radial gradient",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		radius: {
			default: 1,
			description: "The radius of the gradient (normalized, 0.0-1.0)",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Radius"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms }) => {
		const uv$1$2 = screenUV;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const t = distance(vec2(uv$1$2.x.mul(aspect$1), uv$1$2.y), vec2(uniforms.center.uniform.x.mul(aspect$1), uniforms.center.uniform.y.oneMinus())).div(uniforms.radius.uniform).clamp(float(0), float(1));
		return mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, t, uniforms.colorSpace.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/RadialGradient.js
function computeEffectiveProps$22(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$23 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$22 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$22 && componentDefinition$22.props) Object.entries(componentDefinition$22.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$22[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$22 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$22.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$22(props, defaultProps$22);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$23,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$22, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$22.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$22);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var RadialGradient_default = OmbreComponent$22;

//#endregion
//#region node_modules/shaders/dist/core/RectangularCoordinates-CiW3J4UT.js
var componentDefinition$21 = {
	name: "RectangularCoordinates",
	category: "Distortions",
	description: "Convert polar coordinates back to rectangular space",
	requiresRTT: true,
	requiresChild: true,
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point for rectangular coordinate conversion",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		scale: {
			default: 1,
			description: "Scale factor for the rectangular output",
			ui: {
				type: "range",
				min: .1,
				max: 3,
				step: .01,
				label: "Scale"
			}
		},
		intensity: {
			default: 1,
			description: "Blends between original UVs (0) and rectangular coordinates (1)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Intensity"
			}
		},
		edges: {
			default: "transparent",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const theta = screenUV.x.mul(PI.mul(2)).sub(PI);
		const r = screenUV.y.mul(uniforms.scale.uniform);
		const rectX = r.mul(cos(theta));
		const rectY = r.mul(sin(theta));
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const centerPos = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const blendedUV = mix(screenUV, vec2(rectX.div(aspect$1).add(centerPos.x), rectY.add(centerPos.y)), uniforms.intensity.uniform);
		return applyEdgeHandling(blendedUV, childTexture.sample(blendedUV), childTexture, uniforms.edges.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/RectangularCoordinates.js
function computeEffectiveProps$21(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$22 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$21 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$21 && componentDefinition$21.props) Object.entries(componentDefinition$21.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$21[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$21 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$21.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$21(props, defaultProps$21);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$22,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$21, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$21.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$21);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var RectangularCoordinates_default = OmbreComponent$21;

//#endregion
//#region node_modules/shaders/dist/core/Ripples-DKBIp3Qq.js
var componentDefinition$20 = {
	name: "Ripples",
	category: "Base Layers",
	description: "Concentric animated ripples emanating from a point",
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point where ripples emanate from",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		colorA: {
			default: "#ffffff",
			transform: transformColor,
			description: "Color of the ripple waves",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#000000",
			transform: transformColor,
			description: "Background color between ripples",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		speed: {
			default: 1,
			description: "Speed of ripple animation",
			ui: {
				type: "range",
				min: -5,
				max: 5,
				step: .1,
				label: "Speed"
			}
		},
		frequency: {
			default: 20,
			description: "Number of ripples/spacing between them",
			ui: {
				type: "range",
				min: 1,
				max: 80,
				step: .1,
				label: "Frequency"
			}
		},
		softness: {
			default: 0,
			description: "Softness of ripple edges",
			ui: {
				type: "range",
				min: 0,
				max: 3,
				step: .01,
				label: "Softness"
			}
		},
		thickness: {
			default: .5,
			description: "Thickness of each ripple band",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Thickness"
			}
		},
		phase: {
			default: 0,
			description: "Phase offset for ripple animation",
			ui: {
				type: "range",
				min: 0,
				max: 6.28,
				step: .01,
				label: "Phase"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const uv$1$2 = screenUV;
		const center = uniforms.center.uniform;
		const colorA = uniforms.colorA.uniform;
		const colorB = uniforms.colorB.uniform;
		const frequency = uniforms.frequency.uniform;
		const softness = uniforms.softness.uniform;
		const thickness$2 = uniforms.thickness.uniform;
		const phase = uniforms.phase.uniform;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const dist = distance(vec2(uv$1$2.x.mul(aspect$1), uv$1$2.y), vec2(center.x.mul(aspect$1), center.y.oneMinus()));
		const animTime = createAnimatedTime(params, uniforms.speed);
		const baseWave = sin(dist.mul(frequency).sub(animTime).add(phase));
		const thicknessThreshold = thickness$2.mul(float(2)).sub(float(1));
		return mixColors(colorB, colorA, smoothstep(thicknessThreshold.add(softness), thicknessThreshold.sub(softness), baseWave), float(0));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Ripples.js
function computeEffectiveProps$20(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$21 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$20 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$20 && componentDefinition$20.props) Object.entries(componentDefinition$20.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$20[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$20 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$20.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$20(props, defaultProps$20);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$21,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$20, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$20.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$20);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Ripples_default = OmbreComponent$20;

//#endregion
//#region node_modules/shaders/dist/core/Saturation-DVVlpikK.js
var componentDefinition$19 = {
	name: "Saturation",
	category: "Adjustments",
	description: "Adjust color saturation intensity",
	requiresChild: true,
	props: { intensity: {
		default: 1,
		description: "The intensity of the saturation effect (1 being no change)",
		ui: {
			type: "range",
			min: 0,
			max: 3,
			step: .01,
			label: "Intensity"
		}
	} },
	fragmentNode: ({ uniforms, childNode }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Saturation shader.");
			return vec4(0);
		}
		const luminance$3 = dot(childNode.rgb, vec3(.2126, .7152, .0722));
		return vec4(mix(vec3(luminance$3, luminance$3, luminance$3), childNode.rgb, uniforms.intensity.uniform), childNode.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Saturation.js
function computeEffectiveProps$19(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$20 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$19 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$19 && componentDefinition$19.props) Object.entries(componentDefinition$19.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$19[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$19 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$19.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$19(props, defaultProps$19);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$20,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$19, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$19.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$19);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Saturation_default = OmbreComponent$19;

//#endregion
//#region node_modules/shaders/dist/core/Sharpness-cw57bW0s.js
var componentDefinition$18 = {
	name: "Sharpness",
	category: "Adjustments",
	description: "Adjust image sharpness using a convolution kernel",
	requiresRTT: true,
	requiresChild: true,
	props: { sharpness: {
		default: 0,
		description: "How sharp to make the underlying image",
		ui: {
			type: "range",
			min: 0,
			max: 5,
			step: .01,
			label: "Sharpness"
		}
	} },
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		return Fn(() => {
			const uv$1$2 = screenUV;
			const amount = uniforms.sharpness.uniform;
			const pixelSize = vec2(1).div(viewportSize);
			const center = childTexture.sample(uv$1$2);
			const top = childTexture.sample(uv$1$2.add(vec2(0, pixelSize.y)));
			const bottom = childTexture.sample(uv$1$2.sub(vec2(0, pixelSize.y)));
			const left = childTexture.sample(uv$1$2.sub(vec2(pixelSize.x, 0)));
			const right = childTexture.sample(uv$1$2.add(vec2(pixelSize.x, 0)));
			const centerWeight = float(1).add(amount.mul(4));
			const neighborWeight = amount.negate();
			return vec4(clamp(center.mul(centerWeight).add(top.mul(neighborWeight)).add(bottom.mul(neighborWeight)).add(left.mul(neighborWeight)).add(right.mul(neighborWeight)).rgb, 0, 1), center.a);
		})();
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Sharpness.js
function computeEffectiveProps$18(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$19 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$18 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$18 && componentDefinition$18.props) Object.entries(componentDefinition$18.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$18[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$18 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$18.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$18(props, defaultProps$18);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$19,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$18, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$18.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$18);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Sharpness_default = OmbreComponent$18;

//#endregion
//#region node_modules/shaders/dist/core/Shatter-COjV2jLy.js
var seededRandom = (seed) => {
	const x = Math.sin(seed) * 1e4;
	return x - Math.floor(x);
};
var componentDefinition$17 = {
	name: "Shatter",
	category: "Interactive",
	description: "Broken glass effect with tectonic plate displacement",
	requiresRTT: true,
	requiresChild: true,
	props: {
		crackWidth: {
			default: 1,
			description: "Thickness of crack lines",
			ui: {
				type: "range",
				min: .5,
				max: 5,
				step: .1,
				label: "Crack Width"
			}
		},
		intensity: {
			default: 4,
			description: "How much shards shift",
			ui: {
				type: "range",
				min: 0,
				max: 20,
				step: 1,
				label: "Intensity"
			}
		},
		radius: {
			default: .4,
			description: "Cursor influence radius",
			ui: {
				type: "range",
				min: .1,
				max: 1,
				step: .1,
				label: "Radius"
			}
		},
		decay: {
			default: 1,
			description: "How fast shards return to rest",
			ui: {
				type: "range",
				min: .1,
				max: 10,
				step: .1,
				label: "Decay"
			}
		},
		seed: {
			default: 2,
			description: "Random seed for pattern",
			ui: {
				type: "range",
				min: 0,
				max: 50,
				step: 1,
				label: "Seed"
			}
		},
		chromaticSplit: {
			default: 1,
			description: "RGB separation for prismatic glass effect",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Chromatic Split"
			}
		},
		refractionStrength: {
			default: 5,
			description: "How much cracks bend/distort the underlying image",
			ui: {
				type: "range",
				min: 0,
				max: 10,
				step: .1,
				label: "Refraction"
			}
		},
		shardLighting: {
			default: .1,
			description: "Subtle lighting on tilted shards for 3D depth",
			ui: {
				type: "range",
				min: 0,
				max: .5,
				step: .1,
				label: "Shard Lighting"
			}
		},
		edges: {
			default: "mirror",
			description: "How to handle edges when displacement pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, onBeforeRender, childNode, onCleanup }) => {
		const SHARD_COUNT = 16;
		const FRICTION = 1;
		const cellData = new Float32Array(SHARD_COUNT * 4);
		const cellTexture = new DataTexture(cellData, 4, 4, RGBAFormat, FloatType);
		cellTexture.magFilter = LinearFilter;
		cellTexture.minFilter = LinearFilter;
		const displacementData = new Float32Array(SHARD_COUNT * 4);
		const displacementTexture = new DataTexture(displacementData, 4, 4, RGBAFormat, FloatType);
		displacementTexture.magFilter = LinearFilter;
		displacementTexture.minFilter = LinearFilter;
		const generateCells = (seed) => {
			for (let i = 0; i < SHARD_COUNT; i++) {
				cellData[i * 4] = seededRandom(seed + i * 2);
				cellData[i * 4 + 1] = seededRandom(seed + i * 2 + 1);
				cellData[i * 4 + 2] = seededRandom(seed + i * 3);
				cellData[i * 4 + 3] = seededRandom(seed + i * 3 + 1);
			}
			cellTexture.needsUpdate = true;
		};
		let currentSeed = uniforms.seed.uniform.value;
		generateCells(currentSeed);
		displacementData.fill(0);
		displacementTexture.needsUpdate = true;
		let prevX = .5;
		let prevY = .5;
		let lastTime = Date.now();
		onBeforeRender(({ pointer }) => {
			const currentTime = Date.now();
			const dt = Math.min((currentTime - lastTime) / 1e3, .016);
			lastTime = currentTime;
			const newSeed = uniforms.seed.uniform.value;
			if (newSeed !== currentSeed) {
				currentSeed = newSeed;
				generateCells(currentSeed);
				displacementData.fill(0);
			}
			const intensity = uniforms.intensity.uniform.value;
			const radius = uniforms.radius.uniform.value;
			const decay = uniforms.decay.uniform.value;
			const friction = FRICTION;
			let velX = dt > 0 ? (pointer.x - prevX) / dt : 0;
			let velY = dt > 0 ? (pointer.y - prevY) / dt : 0;
			let speed = Math.sqrt(velX * velX + velY * velY);
			const maxVelocity = 5 + intensity * 2;
			if (speed > maxVelocity) {
				const scale$3 = maxVelocity / speed;
				velX *= scale$3;
				velY *= scale$3;
				speed = maxVelocity;
			}
			for (let i = 0; i < SHARD_COUNT; i++) {
				const cellX = cellData[i * 4];
				const cellY = cellData[i * 4 + 1];
				const randomDirX = cellData[i * 4 + 2] - .5;
				const randomDirY = cellData[i * 4 + 3] - .5;
				const dx = cellX - pointer.x;
				const dy = cellY - pointer.y;
				const dist = Math.sqrt(dx * dx + dy * dy);
				let currentDx = displacementData[i * 4];
				let currentDy = displacementData[i * 4 + 1];
				const decayTime = Math.max(.01, decay);
				const decayFactor = Math.exp(-dt / decayTime);
				currentDx *= decayFactor;
				currentDy *= decayFactor;
				let velocityDx = 0;
				let velocityDy = 0;
				if (dist < radius && speed > .01) {
					const influence = Math.max(0, 1 - dist / radius);
					const influenceCurve = influence * influence;
					const pushForce = influenceCurve * speed * intensity * dt * .5;
					velocityDx = velX * pushForce;
					velocityDy = velY * pushForce;
					const jitterForce = influenceCurve * speed * intensity * dt * .1;
					velocityDx += randomDirX * jitterForce;
					velocityDy += randomDirY * jitterForce;
				}
				const lerpFactor = Math.min(1, friction * dt);
				displacementData[i * 4] = currentDx + velocityDx * lerpFactor;
				displacementData[i * 4 + 1] = currentDy + velocityDy * lerpFactor;
				displacementData[i * 4 + 2] = 0;
				displacementData[i * 4 + 3] = 0;
			}
			displacementTexture.needsUpdate = true;
			prevX = pointer.x;
			prevY = pointer.y;
		});
		onCleanup(() => {
			cellTexture.dispose();
			displacementTexture.dispose();
		});
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const cellField = texture(cellTexture);
		const dispField = texture(displacementTexture);
		const cells = [];
		for (let i = 0; i < SHARD_COUNT; i++) {
			const u = (i % 4 + .5) / 4;
			const v = (Math.floor(i / 4) + .5) / 4;
			const cellPos = cellField.sample(vec2(u, v)).xy;
			const dist = screenUV.sub(cellPos).length();
			cells.push({
				dist,
				index: float(i)
			});
		}
		let minDist1 = cells[0].dist;
		let minDist2 = float(1e3);
		let nearestIdx = cells[0].index;
		for (let i = 1; i < SHARD_COUNT; i++) {
			const dist = cells[i].dist;
			const isNewNearest = dist.lessThan(minDist1);
			const isNewSecond = dist.lessThan(minDist2).and(isNewNearest.not());
			const nextMin2 = isNewNearest.select(minDist1, isNewSecond.select(dist, minDist2));
			const nextMin1 = isNewNearest.select(dist, minDist1);
			const nextIdx = isNewNearest.select(cells[i].index, nearestIdx);
			minDist2 = nextMin2;
			minDist1 = nextMin1;
			nearestIdx = nextIdx;
		}
		const dispU = nearestIdx.mod(float(4)).add(.5).div(4);
		const dispV = nearestIdx.div(float(4)).floor().add(.5).div(4);
		const displacement = dispField.sample(vec2(dispU, dispV)).xy;
		const displacementMag = displacement.length();
		const edgeDiff = minDist2.sub(minDist1);
		const crackThreshold = uniforms.crackWidth.uniform.mul(.005);
		const baseCrackIntensity = float(1).sub(smoothstep(float(0), crackThreshold, edgeDiff));
		const displacementFactor = smoothstep(float(0), float(.01), displacementMag);
		const crackIntensity = baseCrackIntensity.mul(displacementFactor);
		const nearestCellU = nearestIdx.mod(float(4)).add(.5).div(4);
		const nearestCellV = nearestIdx.div(float(4)).floor().add(.5).div(4);
		const nearestCellPos = cellField.sample(vec2(nearestCellU, nearestCellV)).xy;
		const toNearest = screenUV.sub(nearestCellPos).normalize();
		const edgeNormal = vec2(toNearest.y.negate(), toNearest.x);
		const displacedUV = screenUV.sub(displacement);
		const refractionOffset = edgeNormal.mul(uniforms.refractionStrength.uniform).mul(.01);
		const chromaticOffset = uniforms.chromaticSplit.uniform.mul(.005);
		const rOffset = refractionOffset.add(edgeNormal.mul(chromaticOffset));
		const gOffset = refractionOffset;
		const bOffset = refractionOffset.sub(edgeNormal.mul(chromaticOffset));
		const rUV = displacedUV.add(rOffset.mul(crackIntensity));
		const gUV = displacedUV.add(gOffset.mul(crackIntensity));
		const bUV = displacedUV.add(bOffset.mul(crackIntensity));
		const rSample = childTexture.sample(rUV);
		const gSample = childTexture.sample(gUV);
		const bSample = childTexture.sample(bUV);
		const rFinal = applyEdgeHandling(rUV, rSample, childTexture, uniforms.edges.uniform);
		const gFinal = applyEdgeHandling(gUV, gSample, childTexture, uniforms.edges.uniform);
		const bFinal = applyEdgeHandling(bUV, bSample, childTexture, uniforms.edges.uniform);
		const refractedColor = vec4(rFinal.r, gFinal.g, bFinal.b, gFinal.a);
		const normalColor = applyEdgeHandling(displacedUV, childTexture.sample(displacedUV), childTexture, uniforms.edges.uniform);
		let shadedRGB = normalColor.rgb.mul(float(1).sub(crackIntensity)).add(refractedColor.rgb.mul(crackIntensity));
		const displacementLength = displacement.length();
		const tiltX = displacement.x.div(displacementLength.add(.001));
		const tiltY = displacement.y.div(displacementLength.add(.001));
		const lightDir3D = vec2(.3, .6).normalize();
		const normalDot = tiltX.mul(lightDir3D.x).add(tiltY.mul(lightDir3D.y));
		const lightingFactor = float(1).add(normalDot.mul(uniforms.shardLighting.uniform));
		const lightingIntensity = smoothstep(float(0), float(.02), displacementLength);
		const finalLighting = float(1).add(lightingFactor.sub(1).mul(lightingIntensity));
		return vec4(shadedRGB.mul(finalLighting), normalColor.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Shatter.js
function computeEffectiveProps$17(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$18 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$17 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$17 && componentDefinition$17.props) Object.entries(componentDefinition$17.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$17[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$17 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$17.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$17(props, defaultProps$17);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$18,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$17, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$17.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$17);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Shatter_default = OmbreComponent$17;

//#endregion
//#region node_modules/shaders/dist/core/SimplexNoise-Ce79jgYM.js
var componentDefinition$16 = {
	name: "SimplexNoise",
	category: "Base Layers",
	description: "Organic noise with animated movement",
	props: {
		colorA: {
			default: "#ffffff",
			description: "First color",
			transform: transformColor,
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "transparent",
			description: "Second color",
			transform: transformColor,
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		scale: {
			default: 2,
			description: "Pattern scale (higher = larger patterns)",
			ui: {
				type: "range",
				min: -2,
				max: 5,
				step: .1,
				label: "Scale"
			}
		},
		balance: {
			default: 0,
			description: "Balance between colors (negative = more colorB, positive = more colorA)",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Balance"
			}
		},
		contrast: {
			default: 0,
			description: "Pattern contrast (higher = sharper transitions)",
			ui: {
				type: "range",
				min: -2,
				max: 5,
				step: .1,
				label: "Contrast"
			}
		},
		seed: {
			default: 0,
			description: "Random seed for pattern variation",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Seed"
			}
		},
		speed: {
			default: 1,
			description: "Animation speed",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Speed"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const uv$1$2 = screenUV;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(uv$1$2.x.mul(aspect$1), uv$1$2.y);
		const animTime = createAnimatedTime(params, uniforms.speed);
		const pos = aspectCorrectedUV.mul(exp(uniforms.scale.uniform)).add(uniforms.seed.uniform);
		const noise = mx_noise_float(vec3(pos.x, pos.y, animTime.mul(.5)));
		const contrastMultiplier = uniforms.contrast.uniform.add(1);
		const k = clamp(noise.mul(contrastMultiplier).add(uniforms.balance.uniform).mul(.5).add(.5), 0, 1);
		return mixColors(uniforms.colorB.uniform, uniforms.colorA.uniform, k, float(0));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/SimplexNoise.js
function computeEffectiveProps$16(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$17 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$16 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$16 && componentDefinition$16.props) Object.entries(componentDefinition$16.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$16[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$16 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$16.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$16(props, defaultProps$16);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$17,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$16, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$16.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$16);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var SimplexNoise_default = OmbreComponent$16;

//#endregion
//#region node_modules/shaders/dist/core/SineWave-Cv2gOU8a.js
var componentDefinition$15 = {
	name: "SineWave",
	category: "Base Layers",
	description: "Animated wave with thickness and softness",
	props: {
		color: {
			default: "#ffffff",
			transform: transformColor,
			description: "The color of the sine wave",
			ui: {
				type: "color",
				label: "Color"
			}
		},
		amplitude: {
			default: .15,
			description: "The height/amplitude of the sine wave",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Amplitude"
			}
		},
		frequency: {
			default: 1,
			description: "The frequency/number of wave cycles",
			ui: {
				type: "range",
				min: .1,
				max: 20,
				step: .1,
				label: "Frequency"
			}
		},
		speed: {
			default: 1,
			description: "The animation speed of the wave",
			ui: {
				type: "range",
				min: -5,
				max: 5,
				step: .1,
				label: "Speed"
			}
		},
		angle: {
			default: 0,
			transform: transformAngle,
			description: "The rotation angle of the wave (in degrees)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		position: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center position of the wave",
			ui: {
				type: "position",
				label: "Position"
			}
		},
		thickness: {
			default: .2,
			description: "The thickness of the wave line",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Thickness"
			}
		},
		softness: {
			default: .4,
			description: "Edge softness of the wave line",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Softness"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const uv$1$2 = screenUV;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(uv$1$2.x.mul(aspect$1), uv$1$2.y);
		const centerPos = vec2(uniforms.position.uniform.x.mul(aspect$1), uniforms.position.uniform.y.oneMinus());
		const centeredUV = aspectCorrectedUV.sub(centerPos);
		const angleRad = radians(uniforms.angle.uniform);
		const cosAngle = cos(angleRad);
		const sinAngle = sin(angleRad);
		const rotatedX = centeredUV.x.mul(cosAngle).sub(centeredUV.y.mul(sinAngle));
		const rotatedY = centeredUV.x.mul(sinAngle).add(centeredUV.y.mul(cosAngle));
		const animatedTime = createAnimatedTime(params, uniforms.speed);
		const sineWave = sin(rotatedX.mul(uniforms.frequency.uniform).mul(PI.mul(2)).add(animatedTime)).mul(uniforms.amplitude.uniform);
		const distanceFromWave = abs(rotatedY.sub(sineWave));
		const halfThickness = uniforms.thickness.uniform.mul(.5);
		const halfSoftness = uniforms.softness.uniform.mul(.5);
		const waveMask = smoothstep(halfThickness.add(halfSoftness), halfThickness.sub(halfSoftness), distanceFromWave);
		return vec4(uniforms.color.uniform.rgb, uniforms.color.uniform.a.mul(waveMask));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/SineWave.js
function computeEffectiveProps$15(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$16 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$15 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$15 && componentDefinition$15.props) Object.entries(componentDefinition$15.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$15[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$15 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$15.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$15(props, defaultProps$15);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$16,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$15, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$15.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$15);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var SineWave_default = OmbreComponent$15;

//#endregion
//#region node_modules/shaders/dist/core/SolidColor-DFkDBFq3.js
var componentDefinition$14 = {
	name: "SolidColor",
	category: "Base Layers",
	description: "Fill the canvas with a single solid color",
	props: { color: {
		default: "#5b18ca",
		transform: transformColor,
		description: "The solid color to display",
		ui: {
			type: "color",
			label: "Color"
		}
	} },
	fragmentNode: ({ uniforms }) => {
		return uniforms.color.uniform;
	}
};

//#endregion
//#region node_modules/shaders/dist/react/SolidColor.js
function computeEffectiveProps$14(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$15 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$14 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$14 && componentDefinition$14.props) Object.entries(componentDefinition$14.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$14[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$14 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$14.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$14(props, defaultProps$14);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$15,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$14, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$14.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$14);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var SolidColor_default = OmbreComponent$14;

//#endregion
//#region node_modules/shaders/dist/core/Spherize-R-s4pX9t.js
var componentDefinition$13 = {
	name: "Spherize",
	category: "Distortions",
	description: "Map content onto a 3D sphere surface with depth distortion",
	requiresRTT: true,
	requiresChild: true,
	props: {
		radius: {
			default: 1,
			description: "Radius of the sphere (1 = half viewport height)",
			ui: {
				type: "range",
				min: .1,
				max: 3,
				step: .01,
				label: "Radius"
			}
		},
		depth: {
			default: 1,
			description: "How much the sphere bulges toward viewer (0 = flat, higher = more bulge)",
			ui: {
				type: "range",
				min: 0,
				max: 3,
				step: .01,
				label: "Depth"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the sphere",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		lightPosition: {
			default: {
				x: .3,
				y: .3
			},
			transform: transformPosition,
			description: "Position of the specular light source",
			ui: {
				type: "position",
				label: "Light Position"
			}
		},
		lightIntensity: {
			default: .5,
			description: "Intensity of the rim light (0 = off)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Light Intensity"
			}
		},
		lightSoftness: {
			default: .5,
			description: "Softness of the rim light falloff (0 = hard edge, 1 = soft glow)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Light Softness"
			}
		},
		lightColor: {
			default: "#ffffff",
			transform: transformColor,
			description: "Color of the specular highlight",
			ui: {
				type: "color",
				label: "Light Color"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const uv$1$2 = screenUV;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const centerPos = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const radius = uniforms.radius.uniform;
		const sphereUV = vec2(uv$1$2.x.sub(centerPos.x).mul(aspect$1), uv$1$2.y.sub(centerPos.y)).mul(2).div(radius);
		const radiusSq = sphereUV.x.mul(sphereUV.x).add(sphereUV.y.mul(sphereUV.y));
		const sphereAlpha = float(1).sub(smoothstep(float(.98), float(1), radiusSq));
		const z = sqrt(max(float(0), float(1).sub(radiusSq)));
		const depthFactor = float(1).add(z.mul(uniforms.depth.uniform));
		const finalUV = sphereUV.div(depthFactor).mul(radius).div(2);
		const transformedUV = vec2(finalUV.x.div(aspect$1).add(centerPos.x), finalUV.y.add(centerPos.y));
		const sampledColor = childTexture.sample(transformedUV);
		const lightPos = vec2(uniforms.lightPosition.uniform.x, uniforms.lightPosition.uniform.y.oneMinus());
		const lightIntensity = uniforms.lightIntensity.uniform;
		const lightSoftness = uniforms.lightSoftness.uniform;
		const lightColor = vec3(uniforms.lightColor.uniform.x, uniforms.lightColor.uniform.y, uniforms.lightColor.uniform.z);
		const normal$1 = normalize(vec3(sphereUV.x, sphereUV.y, z));
		const viewDir = vec3(0, 0, 1);
		const fresnelPower = float(1).add(float(4).mul(float(1).sub(lightSoftness)));
		const fresnel = pow(float(1).sub(max(dot(normal$1, viewDir), float(0))), fresnelPower);
		const lightDir2D = vec2(lightPos.x.sub(float(.5)).mul(2), lightPos.y.sub(float(.5)).mul(2));
		const normalDir = normalize(vec2(normal$1.x, normal$1.y).add(vec2(1e-4, 1e-4)));
		const lightDirNorm = normalize(lightDir2D.add(vec2(1e-4, 1e-4)));
		const directionalBias = pow(max(float(0), dot(normalDir, lightDirNorm)), float(2));
		const rimLight = fresnel.mul(directionalBias).mul(lightIntensity).mul(float(2));
		const finalR = sampledColor.x.add(lightColor.x.mul(rimLight));
		const finalG = sampledColor.y.add(lightColor.y.mul(rimLight));
		const finalB = sampledColor.z.add(lightColor.z.mul(rimLight));
		const finalA = sampledColor.w.mul(sphereAlpha);
		return vec4(finalR.mul(finalA), finalG.mul(finalA), finalB.mul(finalA), finalA);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Spherize.js
function computeEffectiveProps$13(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$14 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$13 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$13 && componentDefinition$13.props) Object.entries(componentDefinition$13.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$13[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$13 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$13.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$13(props, defaultProps$13);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$14,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$13, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$13.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$13);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Spherize_default = OmbreComponent$13;

//#endregion
//#region node_modules/shaders/dist/core/Spiral-W4dALX1z.js
var componentDefinition$12 = {
	name: "Spiral",
	category: "Base Layers",
	description: "Rotating spiral pattern with animated movement",
	props: {
		colorA: {
			default: "#000000",
			transform: transformColor,
			description: "Background color",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#ffffff",
			transform: transformColor,
			description: "Spiral stroke color",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		strokeWidth: {
			default: .5,
			description: "Thickness of spiral stroke",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Stroke Width"
			}
		},
		strokeFalloff: {
			default: 0,
			description: "Stroke losing width further from center",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Stroke Falloff"
			}
		},
		softness: {
			default: 0,
			description: "Color transition sharpness (0 = hard edge, 1 = smooth fade)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Softness"
			}
		},
		speed: {
			default: 1,
			description: "Animation speed (negative values reverse direction)",
			ui: {
				type: "range",
				min: -3,
				max: 3,
				step: .1,
				label: "Speed"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the spiral",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		scale: {
			default: 1,
			description: "Scale factor for spiral bands (higher = more bands, lower = fewer bands)",
			ui: {
				type: "range",
				min: .1,
				max: 5,
				step: .1,
				label: "Scale"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const baseUV = screenUV;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(baseUV.x.mul(aspect$1), baseUV.y);
		const centerPos = vec2(uniforms.center.uniform.x.mul(aspect$1), uniforms.center.uniform.y.oneMinus());
		const uv$1$2 = aspectCorrectedUV.sub(centerPos);
		const t = createAnimatedTime(params, uniforms.speed);
		const l = length(uv$1$2);
		const adjustedLength = l;
		const angle = atan(uv$1$2.y, uv$1$2.x).sub(t);
		const TWO_PI$2 = float(6.283185307);
		const angleNormalised = angle.div(TWO_PI$2);
		const offset = adjustedLength.mul(uniforms.scale.uniform).add(angleNormalised);
		const shape = abs(fract(offset).sub(.5)).mul(2);
		const baseWidth = clamp(uniforms.strokeWidth.uniform, uniforms.strokeFalloff.uniform.mul(.005), 1);
		const falloffAmount = clamp(uniforms.strokeFalloff.uniform, 0, 1).mul(l).oneMinus();
		const width = baseWidth.mul(falloffAmount);
		const fw = fwidth(offset);
		const pixelSize = mix(float(4).sub(smoothstep(.05, .4, uniforms.strokeWidth.uniform.mul(2)).mul(smoothstep(.05, .4, uniforms.strokeWidth.uniform.oneMinus().mul(2))).mul(3)).mul(fw), fwidth(shape), clamp(fw, 0, 1));
		const res = smoothstep(width.sub(pixelSize).sub(uniforms.softness.uniform), width.add(pixelSize).add(uniforms.softness.uniform), shape);
		const mixedColor = mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, res, uniforms.colorSpace.uniform);
		return vec4(mixedColor.rgb, mixedColor.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Spiral.js
function computeEffectiveProps$12(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$13 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$12 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$12 && componentDefinition$12.props) Object.entries(componentDefinition$12.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$12[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$12 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$12.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$12(props, defaultProps$12);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$13,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$12, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$12.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$12);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Spiral_default = OmbreComponent$12;

//#endregion
//#region node_modules/shaders/dist/core/Strands-DtN5POfO.js
var componentDefinition$11 = {
	name: "Strands",
	category: "Base Layers",
	description: "Procedural wavy strands with layered animation",
	requiresRTT: false,
	requiresChild: false,
	props: {
		speed: {
			default: .5,
			description: "Overall animation speed",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Speed"
			}
		},
		amplitude: {
			default: 1,
			description: "Wave height amplitude",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Amplitude"
			}
		},
		frequency: {
			default: 1,
			description: "Wave frequency",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .01,
				label: "Frequency"
			}
		},
		lineCount: {
			default: 12,
			description: "Number of wave lines",
			ui: {
				type: "range",
				min: 4,
				max: 32,
				step: 1,
				label: "Line Count"
			}
		},
		lineWidth: {
			default: .1,
			description: "Width of wave lines",
			ui: {
				type: "range",
				min: .01,
				max: .5,
				step: .01,
				label: "Line Width"
			}
		},
		waveColor: {
			default: "#f1c907",
			transform: transformColor,
			description: "Color of the waves",
			ui: {
				type: "color",
				label: "Wave Color"
			}
		},
		pinEdges: {
			default: true,
			description: "Pin waves at edges (fade effect)",
			ui: {
				type: "checkbox",
				label: "Pin Edges"
			}
		},
		start: {
			default: {
				x: 0,
				y: .5
			},
			transform: transformPosition,
			description: "Starting point of the waves",
			ui: {
				type: "position",
				label: "Start"
			}
		},
		end: {
			default: {
				x: 1,
				y: .5
			},
			transform: transformPosition,
			description: "Ending point of the waves",
			ui: {
				type: "position",
				label: "End"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const baseUV = screenUV;
		const t = createAnimatedTime(params, uniforms.speed);
		const random = Fn(([time$1$1]) => {
			return cos(time$1$1).add(cos(time$1$1.mul(1.2).add(1.6))).add(cos(time$1$1.mul(1.4).add(1.5))).div(3);
		});
		return Fn(([uv$1$2]) => {
			const aspectRatio = viewportSize.x.div(viewportSize.y);
			const startPos = vec2(uniforms.start.uniform.x.mul(aspectRatio), uniforms.start.uniform.y.oneMinus());
			const endPos = vec2(uniforms.end.uniform.x.mul(aspectRatio), uniforms.end.uniform.y.oneMinus());
			const aspectUV = vec2(uv$1$2.x.mul(aspectRatio), uv$1$2.y);
			const direction = endPos.sub(startPos);
			const length$1$1 = direction.length();
			const normalizedDir = direction.div(length$1$1);
			const perpDir = vec2(normalizedDir.y.negate(), normalizedDir.x);
			const relativePos = aspectUV.sub(startPos);
			const progress = relativePos.dot(normalizedDir).div(length$1$1);
			const distFromLine = relativePos.dot(perpDir);
			const waveCoord = progress.mul(10);
			const perpCoord = distFromLine.mul(10);
			const edgeFade = uniforms.pinEdges.uniform.select(smoothstep(float(0), float(.1), progress).mul(smoothstep(float(1), float(.9), progress)), float(1));
			const horizontalFade = uniforms.pinEdges.uniform.select(cos(progress.mul(6.28)).mul(.5).add(.5).oneMinus(), float(1));
			const verticalFade = cos(progress.mul(6.28)).mul(.5).add(.5).oneMinus();
			const linesColor = vec4(0, 0, 0, 0).toVar();
			const maxLines = uniforms.lineCount.uniform;
			for (let i = 0; i < 32; i++) {
				const lineActive = float(i).lessThan(maxLines);
				const lineIndex = float(i);
				const normalizedIndex = lineIndex.div(maxLines);
				const offsetFreq = float(.5);
				const offsetSpeed = float(1.33);
				const offsetTime = t.mul(offsetSpeed);
				const offsetPosition = lineIndex.add(waveCoord.mul(offsetFreq));
				const rand$2 = random(offsetPosition.add(offsetTime)).mul(.5).add(.5);
				const halfWidth = mix(float(.01), uniforms.lineWidth.uniform, rand$2.mul(horizontalFade)).mul(.5);
				const minSpread = float(.6);
				const maxSpread = float(2);
				const offset = random(offsetPosition.add(offsetTime.mul(normalizedIndex.add(1)))).mul(mix(minSpread, maxSpread, horizontalFade)).mul(uniforms.amplitude.uniform);
				const linePosition = random(waveCoord.mul(uniforms.frequency.uniform).add(t)).mul(horizontalFade).mul(uniforms.amplitude.uniform).add(offset);
				const dist = abs(perpCoord.sub(linePosition));
				const lineEdgeSoftness = float(.01);
				const line = smoothstep(halfWidth.add(lineEdgeSoftness), halfWidth.sub(lineEdgeSoftness), dist);
				const lineContribution = vec4(uniforms.waveColor.uniform.r, uniforms.waveColor.uniform.g, uniforms.waveColor.uniform.b, line).mul(rand$2);
				linesColor.assign(max(linesColor, lineActive.select(lineContribution, vec4(0, 0, 0, 0))));
			}
			return linesColor.mul(vec4(1, 1, 1, verticalFade.mul(edgeFade)));
		})(baseUV);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Strands.js
function computeEffectiveProps$11(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$12 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$11 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$11 && componentDefinition$11.props) Object.entries(componentDefinition$11.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$11[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$11 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$11.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$11(props, defaultProps$11);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$12,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$11, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$11.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$11);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Strands_default = OmbreComponent$11;

//#endregion
//#region node_modules/shaders/dist/core/Stretch-BzvP_hdu.js
var componentDefinition$10 = {
	name: "Stretch",
	category: "Distortions",
	description: "Stretch content towards a direction from a center point",
	requiresRTT: true,
	requiresChild: true,
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the stretch effect",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		strength: {
			default: 1,
			description: "The intensity of the stretch effect",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Strength"
			}
		},
		angle: {
			default: 0,
			description: "The direction of the stretch in degrees",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		falloff: {
			default: 0,
			description: "Controls the sharpness of the transition (0 = sharp edge, 1 = gradual transition)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Falloff"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(screenUV.x.mul(aspect$1), screenUV.y);
		const centerPos = vec2(uniforms.center.uniform.x.mul(aspect$1), uniforms.center.uniform.y.oneMinus());
		const delta = aspectCorrectedUV.sub(centerPos);
		const angleRad = uniforms.angle.uniform.mul(Math.PI / 180);
		const directionVector = vec2(cos(angleRad), sin(angleRad));
		const projection = delta.dot(directionVector);
		const parallel = directionVector.mul(projection);
		const perpendicular = delta.sub(parallel);
		const falloffAmount = uniforms.falloff.uniform;
		const transitionWidth = mix(float(.001), float(75), falloffAmount);
		const effectMask = clamp(projection.div(transitionWidth), float(0), float(1));
		const scaledStrength = uniforms.strength.uniform.mul(float(100));
		const stretchFactor = float(1).add(scaledStrength.mul(effectMask));
		const finalProjection = projection.div(stretchFactor);
		const stretchedDelta = directionVector.mul(finalProjection).add(perpendicular);
		const stretchedUV = centerPos.add(stretchedDelta);
		const finalUV = vec2(stretchedUV.x.div(aspect$1), stretchedUV.y);
		return applyEdgeHandling(finalUV, childTexture.sample(finalUV), childTexture, uniforms.edges.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Stretch.js
function computeEffectiveProps$10(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$11 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$10 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$10 && componentDefinition$10.props) Object.entries(componentDefinition$10.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$10[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$10 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$10.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$10(props, defaultProps$10);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$11,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$10, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$10.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$10);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Stretch_default = OmbreComponent$10;

//#endregion
//#region node_modules/shaders/dist/core/Stripes-BbNFX05u.js
var componentDefinition$9 = {
	name: "Stripes",
	category: "Base Layers",
	description: "Alternating colored stripes with animation",
	props: {
		colorA: {
			default: "#000000",
			transform: transformColor,
			description: "First stripe color",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#ffffff",
			transform: transformColor,
			description: "Second stripe color",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		angle: {
			default: 45,
			transform: transformAngle,
			description: "Angle of stripes in degrees",
			ui: {
				type: "range",
				min: -180,
				max: 180,
				step: 1,
				label: "Angle"
			}
		},
		density: {
			default: 5,
			description: "Number of stripe pairs visible",
			ui: {
				type: "range",
				min: 1,
				max: 30,
				step: 1,
				label: "Density"
			}
		},
		balance: {
			default: .5,
			description: "Ratio of the two colors",
			ui: {
				type: "range",
				min: .01,
				max: .99,
				step: .01,
				label: "Balance"
			}
		},
		softness: {
			default: 0,
			description: "Edge softness",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Softness"
			}
		},
		speed: {
			default: .2,
			description: "Animation speed",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .1,
				label: "Speed"
			}
		},
		offset: {
			default: 0,
			description: "Phase offset for pattern positioning",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Offset"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const uv$1$2 = screenUV;
		const aspect$1 = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(uv$1$2.x.mul(aspect$1), uv$1$2.y);
		const angleRad = uniforms.angle.uniform.mul(.0174533);
		const cosA = cos(angleRad);
		const sinA = sin(angleRad);
		const rotatedCoord = aspectCorrectedUV.x.mul(cosA).add(aspectCorrectedUV.y.mul(sinA));
		const t = createAnimatedTime(params, uniforms.speed);
		const pattern = rotatedCoord.mul(uniforms.density.uniform).add(t).add(uniforms.offset.uniform);
		const stripe = fract(pattern);
		const fw = fwidth(pattern);
		const balance = uniforms.balance.uniform;
		const soft = uniforms.softness.uniform;
		const mask = smoothstep(balance.sub(soft).sub(fw), balance.add(soft).add(fw), stripe);
		const mixedColor = mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, mask, uniforms.colorSpace.uniform);
		return vec4(mixedColor.rgb, mixedColor.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Stripes.js
function computeEffectiveProps$9(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$10 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$9 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$9 && componentDefinition$9.props) Object.entries(componentDefinition$9.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$9[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$9 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$9.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$9(props, defaultProps$9);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$10,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$9, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$9.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$9);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Stripes_default = OmbreComponent$9;

//#endregion
//#region node_modules/shaders/dist/core/Swirl-CfsYsr4X.js
var componentDefinition$8 = {
	name: "Swirl",
	category: "Base Layers",
	description: "Flowing swirl pattern with multi-layered noise",
	props: {
		colorA: {
			default: "#1275d8",
			description: "Primary gradient color",
			transform: transformColor,
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#e19136",
			description: "Secondary gradient color",
			transform: transformColor,
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		speed: {
			default: 1,
			description: "Flow animation speed",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Speed"
			}
		},
		detail: {
			default: 1,
			description: "Level of detail and intricacy in the swirl patterns",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Detail"
			}
		},
		blend: {
			default: 50,
			description: "Skew color balance toward A (lower values) or B (higher values)",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Blend"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const uvCoords = screenUV;
		const t = createAnimatedTime(params, uniforms.speed);
		const detail = uniforms.detail.uniform;
		const freq1 = detail;
		const distort1 = vec2(uvCoords.x.add(sin(uvCoords.y.mul(freq1.mul(1.7)).add(t.mul(.8))).mul(.12).add(cos(uvCoords.x.mul(freq1.mul(.9)).sub(t.mul(.5))).mul(.05))), uvCoords.y.add(cos(uvCoords.x.mul(freq1.mul(1.3)).sub(t.mul(.6))).mul(.12).add(sin(uvCoords.y.mul(freq1.mul(1.1)).add(t.mul(.7))).mul(.05))));
		const pattern1 = sin(distort1.x.mul(freq1.mul(2.1)).add(distort1.y.mul(freq1.mul(1.8))).add(t.mul(.4)));
		const freq2 = detail.mul(2.1);
		const distort2 = vec2(distort1.x.add(cos(distort1.y.mul(freq2.mul(2.7)).sub(t.mul(.45))).mul(.07).add(sin(distort1.x.mul(freq2.mul(1.9)).add(t.mul(.6))).mul(.04))), distort1.y.add(sin(distort1.x.mul(freq2.mul(2.3)).add(t.mul(.65))).mul(.07).add(cos(distort1.y.mul(freq2.mul(1.6)).sub(t.mul(.4))).mul(.04))));
		const pattern2 = cos(distort2.x.mul(freq2.mul(1.4)).sub(distort2.y.mul(freq2.mul(1.9))).add(t.mul(.35)));
		const freq3 = detail.mul(3.7);
		const distort3 = vec2(distort2.x.add(sin(distort2.y.mul(freq3.mul(1.8)).add(t.mul(.85))).mul(.04).add(cos(distort2.x.mul(freq3.mul(1.3)).sub(t.mul(.55))).mul(.025)).add(sin(distort2.x.add(distort2.y).mul(freq3.mul(.7)).add(t.mul(.9))).mul(.02))), distort2.y.add(cos(distort2.x.mul(freq3.mul(1.6)).sub(t.mul(.75))).mul(.04).add(sin(distort2.y.mul(freq3.mul(1.1)).add(t.mul(.5))).mul(.025)).add(cos(distort2.x.add(distort2.y).mul(freq3.mul(.8)).sub(t.mul(.95))).mul(.02))));
		const pattern3 = sin(distort3.x.mul(freq3.mul(1.1)).add(distort3.y.mul(freq3.mul(1.5))).sub(t.mul(.55)));
		const combinedPattern = pattern1.mul(.45).add(pattern2.mul(.35)).add(pattern3.mul(.2));
		const blendBias = uniforms.blend.uniform.sub(50).mul(.006);
		const blendFactor = smoothstep(.3, .7, combinedPattern.mul(.5).add(.5).add(blendBias));
		const colorMix = mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, blendFactor, uniforms.colorSpace.uniform);
		const shimmer = sin(t.mul(2.5).add(combinedPattern.mul(8))).mul(.015).add(1);
		const finalColor = colorMix.mul(shimmer);
		return vec4(finalColor.rgb, finalColor.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Swirl.js
function computeEffectiveProps$8(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$9 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$8 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$8 && componentDefinition$8.props) Object.entries(componentDefinition$8.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$8[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$8 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$8.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$8(props, defaultProps$8);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$9,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$8, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$8.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$8);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Swirl_default = OmbreComponent$8;

//#endregion
//#region node_modules/shaders/dist/core/TiltShift-B6gbm7Z8.js
var componentDefinition$7 = {
	name: "TiltShift",
	category: "Blurs",
	description: "Selective focus blur mimicking tilt-shift photography",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 50,
			description: "Maximum blur intensity at edges",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Intensity"
			}
		},
		width: {
			default: .3,
			description: "Width of the sharp focus area",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Width"
			}
		},
		falloff: {
			default: .3,
			description: "Distance over which blur transitions to full strength",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Falloff"
			}
		},
		angle: {
			default: 0,
			transform: transformAngle,
			description: "Rotation angle of the focus line (in degrees)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "Center point of the focus line",
			ui: {
				type: "position",
				label: "Center"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const angleRad = radians(uniforms.angle.uniform);
		const cosAngle = cos(angleRad);
		const perpVector = vec2(sin(angleRad).negate(), cosAngle);
		const centerPosition = vec2(uniforms.center.uniform[0], uniforms.center.uniform[1].oneMinus());
		const distFromLine = abs(dot(screenUV.sub(centerPosition), perpVector));
		const focusWidth = uniforms.width.uniform.mul(.5);
		const falloff = uniforms.falloff.uniform;
		const blurAmount = smoothstep(focusWidth, focusWidth.add(falloff), distFromLine);
		const scaledIntensity = uniforms.intensity.uniform.mul(.06);
		const blurRadius = blurAmount.mul(scaledIntensity);
		const weights = [
			.056,
			.135,
			.278,
			.487,
			.726,
			.923,
			1,
			.923,
			.726,
			.487,
			.278,
			.135,
			.056
		];
		const weightSum = 6.214;
		const horizontalTexture = convertToTexture(Fn(() => {
			const uv$1$2 = screenUV;
			const pixelSize = vec2(1).div(viewportSize);
			const total = vec4(0).toVar();
			for (let x = -6; x <= 6; x++) {
				const weight = float(weights[x + 6] / weightSum);
				const offset = vec2(float(x), float(0)).mul(blurRadius).mul(pixelSize);
				const sampleCoord = uv$1$2.add(offset);
				const sample$2 = childTexture.sample(sampleCoord).mul(weight);
				total.assign(total.add(sample$2));
			}
			return total;
		})());
		onCleanup(() => {
			if (horizontalTexture?.renderTarget?.dispose) horizontalTexture.renderTarget.dispose();
		});
		return Fn(() => {
			const uv$1$2 = screenUV;
			const pixelSize = vec2(1).div(viewportSize);
			const total = vec4(0).toVar();
			for (let y = -6; y <= 6; y++) {
				const weight = float(weights[y + 6] / weightSum);
				const offset = vec2(float(0), float(y)).mul(blurRadius).mul(pixelSize);
				const sampleCoord = uv$1$2.add(offset);
				const sample$2 = horizontalTexture.sample(sampleCoord).mul(weight);
				total.assign(total.add(sample$2));
			}
			const blurred = total;
			return mix(childTexture.sample(uv$1$2), blurred, blurAmount);
		})();
	}
};

//#endregion
//#region node_modules/shaders/dist/react/TiltShift.js
function computeEffectiveProps$7(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$8 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$7 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$7 && componentDefinition$7.props) Object.entries(componentDefinition$7.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$7[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$7 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$7.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$7(props, defaultProps$7);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$8,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$7, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$7.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$7);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var TiltShift_default = OmbreComponent$7;

//#endregion
//#region node_modules/shaders/dist/core/Tint-CpnitsHw.js
var componentDefinition$6 = {
	name: "Tint",
	category: "Adjustments",
	description: "Apply a color tint to the image",
	requiresChild: true,
	props: {
		color: {
			default: "#ff8800",
			transform: transformColor,
			description: "Tint color",
			ui: {
				type: "color",
				label: "Tint Color"
			}
		},
		amount: {
			default: .5,
			description: "Tint amount (0 = no tint, 1 = full tint)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Amount"
			}
		},
		preserveLuminosity: {
			default: true,
			description: "Preserve original brightness",
			ui: {
				type: "checkbox",
				label: "Preserve Luminosity"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Tint shader.");
			return vec4(0);
		}
		const tintColor = uniforms.color.uniform;
		const amount = uniforms.amount.uniform;
		const preserveLum = uniforms.preserveLuminosity.uniform;
		const rgb = vec3(childNode.r, childNode.g, childNode.b);
		const luminanceWeights = vec3(.299, .587, .114);
		const originalLum = dot(rgb, luminanceWeights);
		const tinted = mix(rgb, tintColor.rgb, amount);
		const tintedLum = dot(tinted, luminanceWeights);
		const lumPreserved = tinted.mul(originalLum.div(max(tintedLum, 1e-4)));
		return vec4(preserveLum.select(lumPreserved, tinted), childNode.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Tint.js
function computeEffectiveProps$6(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$7 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$6 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$6 && componentDefinition$6.props) Object.entries(componentDefinition$6.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$6[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$6 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$6.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$6(props, defaultProps$6);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$7,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$6, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$6.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$6);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Tint_default = OmbreComponent$6;

//#endregion
//#region node_modules/shaders/dist/core/Tritone-DzvSKVfR.js
var componentDefinition$5 = {
	name: "Tritone",
	category: "Adjustments",
	description: "Map colors to three tones: shadows, midtones, highlights",
	requiresRTT: true,
	requiresChild: true,
	props: {
		colorA: {
			default: "#ce1bea",
			transform: transformColor,
			description: "First color (used for shadows/darkest areas)",
			ui: {
				type: "color",
				label: "Color A (Shadows)"
			}
		},
		colorB: {
			default: "#2fff00",
			transform: transformColor,
			description: "Second color (used for midtones)",
			ui: {
				type: "color",
				label: "Color B (Midtones)"
			}
		},
		colorC: {
			default: "#ffff00",
			transform: transformColor,
			description: "Third color (used for highlights/brightest areas)",
			ui: {
				type: "color",
				label: "Color C (Highlights)"
			}
		},
		blendMid: {
			default: .5,
			description: "Midpoint position between the three colors",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Midpoint"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const inputColor = childTexture.sample(screenUV);
		const luminance$3 = dot(inputColor.rgb, vec3(.299, .587, .114));
		const shadowToMid = smoothstep(uniforms.blendMid.uniform.sub(.25), uniforms.blendMid.uniform, luminance$3);
		const lowerBlend = mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, shadowToMid, uniforms.colorSpace.uniform);
		const midToHighlight = smoothstep(uniforms.blendMid.uniform, uniforms.blendMid.uniform.add(.25), luminance$3);
		return vec4(mixColors(lowerBlend, mixColors(uniforms.colorB.uniform, uniforms.colorC.uniform, midToHighlight, uniforms.colorSpace.uniform), smoothstep(uniforms.blendMid.uniform.sub(.1), uniforms.blendMid.uniform.add(.1), luminance$3), uniforms.colorSpace.uniform).rgb, inputColor.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Tritone.js
function computeEffectiveProps$5(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$6 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$5 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$5 && componentDefinition$5.props) Object.entries(componentDefinition$5.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$5[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$5 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$5.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$5(props, defaultProps$5);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$6,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$5, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$5.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$5);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Tritone_default = OmbreComponent$5;

//#endregion
//#region node_modules/shaders/dist/core/Twirl-BXH4uAd6.js
var componentDefinition$4 = {
	name: "Twirl",
	category: "Distortions",
	description: "Rotate and twist content around a center point",
	requiresRTT: true,
	requiresChild: true,
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the twirl effect",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		intensity: {
			default: 1,
			description: "The strength of the twirl effect",
			ui: {
				type: "range",
				min: -5,
				max: 5,
				step: .1,
				label: "Intensity"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Twirl shader.");
			return vec4(0);
		}
		const texture$1$1 = convertToTexture(childNode);
		onCleanup(() => {
			if (texture$1$1?.renderTarget?.dispose) texture$1$1.renderTarget.dispose();
		});
		const uvNode = screenUV;
		const centerPos = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const delta = uvNode.sub(centerPos);
		const angle = uniforms.intensity.uniform.mul(length(delta));
		const cosAngle = cos(angle);
		const sinAngle = sin(angle);
		const rotatedX = cosAngle.mul(delta.x).sub(sinAngle.mul(delta.y));
		const rotatedY = sinAngle.mul(delta.x).add(cosAngle.mul(delta.y));
		const twistedUV = vec2(rotatedX.add(centerPos.x), rotatedY.add(centerPos.y));
		return applyEdgeHandling(twistedUV, texture$1$1.sample(twistedUV), texture$1$1, uniforms.edges.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Twirl.js
function computeEffectiveProps$4(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$5 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$4 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$4 && componentDefinition$4.props) Object.entries(componentDefinition$4.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$4[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$4 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$4.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$4(props, defaultProps$4);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$5,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$4, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$4.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$4);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Twirl_default = OmbreComponent$4;

//#endregion
//#region node_modules/shaders/dist/core/Vibrance-ByN9bRgU.js
var componentDefinition$3 = {
	name: "Vibrance",
	category: "Adjustments",
	description: "Selective saturation adjustment protecting skin tones",
	requiresChild: true,
	props: { intensity: {
		default: 0,
		description: "The intensity of the vibrance effect",
		ui: {
			type: "range",
			min: -2,
			max: 2,
			step: .01,
			label: "Intensity"
		}
	} },
	fragmentNode: ({ uniforms, childNode }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Vibrance shader.");
			return vec4(0);
		}
		const color$2 = childNode.rgb;
		const adjustment = uniforms.intensity.uniform;
		const average = add(color$2.r, add(color$2.g, color$2.b)).div(3);
		const mx = max(color$2.r, max(color$2.g, color$2.b));
		const amt = mx.sub(average).mul(adjustment).mul(-3);
		return vec4(mix(color$2, vec3(mx, mx, mx), amt), childNode.a);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/Vibrance.js
function computeEffectiveProps$3(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$4 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$3 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$3 && componentDefinition$3.props) Object.entries(componentDefinition$3.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$3[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$3 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$3.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$3(props, defaultProps$3);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$4,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$3, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$3.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$3);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var Vibrance_default = OmbreComponent$3;

//#endregion
//#region node_modules/shaders/dist/core/WaveDistortion-BA1PyqYH.js
var componentDefinition$2 = {
	name: "WaveDistortion",
	category: "Distortions",
	description: "Wave-based distortion with multiple waveform types",
	requiresRTT: true,
	requiresChild: true,
	props: {
		strength: {
			default: .3,
			description: "Distortion intensity",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Strength"
			}
		},
		frequency: {
			default: 1,
			description: "Number of bends/waves",
			ui: {
				type: "range",
				min: .1,
				max: 10,
				step: .1,
				label: "Frequency"
			}
		},
		speed: {
			default: 1,
			description: "Animation speed",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Speed"
			}
		},
		angle: {
			default: 0,
			description: "Direction of wave distortion in degrees",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		waveType: {
			default: "sine",
			description: "Shape of the distortion wave",
			transform: (value) => {
				return {
					"sine": 0,
					"triangle": 1,
					"square": 2,
					"sawtooth": 3
				}[value] ?? 0;
			},
			ui: {
				type: "select",
				options: [
					{
						label: "Sine",
						value: "sine"
					},
					{
						label: "Triangle",
						value: "triangle"
					},
					{
						label: "Square",
						value: "square"
					},
					{
						label: "Sawtooth",
						value: "sawtooth"
					}
				],
				label: "Wave Type"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms, childNode, onCleanup } = params;
		if (!childNode) return vec4(0, 0, 0, 0);
		const uvCoord = screenUV;
		const t = createAnimatedTime(params, uniforms.speed).mul(.5);
		const angleRad = uniforms.angle.uniform.mul(PI).div(180);
		const cosAngle = cos(angleRad);
		const sinAngle = sin(angleRad);
		const centeredUV = uvCoord.sub(vec2(.5, .5));
		const phase = vec2(centeredUV.x.mul(cosAngle).sub(centeredUV.y.mul(sinAngle)), centeredUV.x.mul(sinAngle).add(centeredUV.y.mul(cosAngle))).add(vec2(.5, .5)).y.mul(uniforms.frequency.uniform).mul(PI.mul(2)).add(t);
		const normalizedPhase = fract(phase.div(PI.mul(2)));
		const sineWave = sin(phase);
		const triangleWave = abs(normalizedPhase.mul(2).sub(1)).mul(2).sub(1);
		const squareWave = step(float(.5), normalizedPhase).mul(2).sub(1);
		const sawtoothWave = normalizedPhase.mul(2).sub(1);
		const waveTypeValue = uniforms.waveType.uniform;
		const isSine = step(waveTypeValue, float(.5));
		const isTriangle = step(float(.5), waveTypeValue).mul(step(waveTypeValue, float(1.5)));
		const isSquare = step(float(1.5), waveTypeValue).mul(step(waveTypeValue, float(2.5)));
		const isSawtooth = step(float(2.5), waveTypeValue);
		const displacement = sineWave.mul(isSine).add(triangleWave.mul(isTriangle)).add(squareWave.mul(isSquare)).add(sawtoothWave.mul(isSawtooth)).mul(uniforms.strength.uniform).mul(.5);
		const displacementX = displacement.mul(cosAngle);
		const displacementY = displacement.mul(sinAngle);
		const distortedUV = vec2(uvCoord.x.add(displacementX), uvCoord.y.add(displacementY));
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		return applyEdgeHandling(distortedUV, childTexture.sample(distortedUV), childTexture, uniforms.edges.uniform);
	}
};

//#endregion
//#region node_modules/shaders/dist/react/WaveDistortion.js
function computeEffectiveProps$2(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$3 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$2 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$2 && componentDefinition$2.props) Object.entries(componentDefinition$2.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$2[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$2 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$2.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$2(props, defaultProps$2);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$3,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$2, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$2.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$2);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var WaveDistortion_default = OmbreComponent$2;

//#endregion
//#region node_modules/shaders/dist/core/WebcamTexture-D4Uv7Plz.js
var componentDefinition$1 = {
	name: "WebcamTexture",
	category: "Base Layers",
	description: "Display a live webcam feed with customizable object-fit modes",
	props: {
		objectFit: {
			default: "cover",
			description: "How the webcam feed should be sized within the viewport",
			transform: (value) => {
				return {
					"cover": 0,
					"contain": 1,
					"fill": 2,
					"scale-down": 3,
					"none": 4
				}[value] ?? 0;
			},
			ui: {
				type: "select",
				options: [
					{
						label: "Cover",
						value: "cover"
					},
					{
						label: "Contain",
						value: "contain"
					},
					{
						label: "Fill",
						value: "fill"
					},
					{
						label: "Scale Down",
						value: "scale-down"
					},
					{
						label: "None",
						value: "none"
					}
				],
				label: "Object Fit"
			}
		},
		mirror: {
			default: true,
			description: "Mirror the webcam feed horizontally (selfie mode)",
			ui: {
				type: "checkbox",
				label: "Mirror"
			}
		}
	},
	fragmentNode: ({ uniforms, onCleanup }) => {
		const baseUV = screenUV;
		let mediaStream = null;
		let videoElement = null;
		let videoTexture = null;
		let isInitialized = false;
		let isDisposed = false;
		const videoAspectUniform = uniform(1);
		const videoWidthUniform = uniform(640);
		const videoHeightUniform = uniform(480);
		const placeholderVideo = document.createElement("video");
		placeholderVideo.playsInline = true;
		placeholderVideo.muted = true;
		videoTexture = new VideoTexture(placeholderVideo);
		videoTexture.colorSpace = SRGBColorSpace;
		const textureNode = texture(videoTexture);
		const startWebcam = async () => {
			if (isInitialized || isDisposed) return;
			try {
				mediaStream = await navigator.mediaDevices.getUserMedia({
					video: {
						width: { ideal: 1280 },
						height: { ideal: 720 },
						facingMode: "user"
					},
					audio: false
				});
				if (isDisposed) {
					mediaStream.getTracks().forEach((track) => track.stop());
					mediaStream = null;
					return;
				}
				videoElement = document.createElement("video");
				videoElement.srcObject = mediaStream;
				videoElement.playsInline = true;
				videoElement.muted = true;
				await new Promise((resolve, reject) => {
					if (!videoElement) return reject(/* @__PURE__ */ new Error("Video element not created"));
					videoElement.onloadedmetadata = () => {
						resolve();
					};
					videoElement.onerror = () => {
						reject(/* @__PURE__ */ new Error("Failed to load video metadata"));
					};
				});
				if (isDisposed) return;
				await videoElement.play();
				if (isDisposed) return;
				const width = videoElement.videoWidth || 640;
				const height = videoElement.videoHeight || 480;
				videoAspectUniform.value = width / height;
				videoWidthUniform.value = width;
				videoHeightUniform.value = height;
				if (videoTexture) videoTexture.dispose();
				videoTexture = new VideoTexture(videoElement);
				videoTexture.colorSpace = SRGBColorSpace;
				textureNode.value = videoTexture;
				isInitialized = true;
				console.log(`[WebcamTexture] Webcam started: ${width}x${height}`);
			} catch (error$1) {
				if (error$1 instanceof DOMException) if (error$1.name === "NotAllowedError") console.error("[WebcamTexture] Camera permission denied by user");
				else if (error$1.name === "NotFoundError") console.error("[WebcamTexture] No camera found on this device");
				else if (error$1.name === "NotReadableError") console.error("[WebcamTexture] Camera is already in use by another application");
				else console.error("[WebcamTexture] Camera error:", error$1.message);
				else console.error("[WebcamTexture] Failed to start webcam:", error$1);
			}
		};
		startWebcam();
		onCleanup(() => {
			isDisposed = true;
			if (mediaStream) {
				mediaStream.getTracks().forEach((track) => track.stop());
				mediaStream = null;
			}
			if (videoTexture) {
				videoTexture.dispose();
				videoTexture = null;
			}
			if (videoElement) {
				videoElement.srcObject = null;
				videoElement = null;
			}
			placeholderVideo.srcObject = null;
			isInitialized = false;
		});
		const uv$1$2 = baseUV;
		const viewportAspect = viewportSize.x.div(viewportSize.y);
		const objectFitMode = uniforms.objectFit.uniform;
		const coverScale = max(viewportAspect.div(videoAspectUniform), float(1));
		const coverUVScale = vec2(videoAspectUniform.div(viewportAspect).mul(coverScale), coverScale);
		const containScale = min(viewportAspect.div(videoAspectUniform), float(1));
		const containUVScale = vec2(videoAspectUniform.div(viewportAspect).mul(containScale), containScale);
		const fillUVScale = vec2(1, 1);
		const scaleDownScale = min(min(viewportAspect.div(videoAspectUniform), float(1)), min(viewportSize.x.div(videoWidthUniform), viewportSize.y.div(videoHeightUniform)));
		const scaleDownUVScale = vec2(videoAspectUniform.div(viewportAspect).mul(scaleDownScale), scaleDownScale);
		const noneScale = min(viewportSize.x.div(videoWidthUniform), viewportSize.y.div(videoHeightUniform));
		const noneUVScale = vec2(videoAspectUniform.div(viewportAspect).mul(noneScale), noneScale);
		const isCover = step(objectFitMode, float(.5));
		const isContain = step(float(.5), objectFitMode).mul(step(objectFitMode, float(1.5)));
		const isFill = step(float(1.5), objectFitMode).mul(step(objectFitMode, float(2.5)));
		const isScaleDown = step(float(2.5), objectFitMode).mul(step(objectFitMode, float(3.5)));
		const isNone$1 = step(float(3.5), objectFitMode);
		const uvScale = vec2(0).add(coverUVScale.mul(isCover)).add(containUVScale.mul(isContain)).add(fillUVScale.mul(isFill)).add(scaleDownUVScale.mul(isScaleDown)).add(noneUVScale.mul(isNone$1));
		const adjustedUV = uv$1$2.sub(vec2(.5)).div(uvScale).add(vec2(.5));
		const mirrorMode = uniforms.mirror.uniform;
		const finalUV = vec2(select(mirrorMode, float(1).sub(adjustedUV.x), adjustedUV.x), float(1).sub(adjustedUV.y));
		const sampledColor = textureNode.sample(finalUV);
		const isOutOfBounds = or(or(finalUV.x.lessThan(0), finalUV.x.greaterThan(1)), or(finalUV.y.lessThan(0), finalUV.y.greaterThan(1)));
		return vec4(sampledColor.rgb, select(isOutOfBounds, float(0), sampledColor.a));
	}
};

//#endregion
//#region node_modules/shaders/dist/react/WebcamTexture.js
function computeEffectiveProps$1(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$2 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps$1 = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition$1 && componentDefinition$1.props) Object.entries(componentDefinition$1.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps$1[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent$1 = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition$1.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps$1(props, defaultProps$1);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$2,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition$1, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition$1.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition$1);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var WebcamTexture_default = OmbreComponent$1;

//#endregion
//#region node_modules/shaders/dist/core/ZoomBlur-CIkkDBIo.js
var componentDefinition = {
	name: "ZoomBlur",
	category: "Blurs",
	description: "Radial zoom blur expanding from a center point",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 30,
			description: "Intensity of the zoom blur effect",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Intensity"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "Center point of the zoom blur",
			ui: {
				type: "position",
				label: "Center"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const center = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const radius = uniforms.intensity.uniform.mul(.01);
		return Fn(() => {
			const uv$1$2 = screenUV;
			const total = vec4(0).toVar();
			const totalWeight = float(0).toVar();
			for (let i = 0; i < 32; i++) {
				const t = float(i).div(float(31));
				const weightT = t.sub(.5).mul(2);
				const weight = float(1).div(float(2.506628)).mul(float(-.5).mul(weightT).mul(weightT).div(float(.64)).exp());
				const scale$3 = float(1).add(radius.mul(t));
				const scaledCoord = uv$1$2.sub(center).div(scale$3).add(center);
				const sample$2 = childTexture.sample(scaledCoord).mul(weight);
				total.assign(total.add(sample$2));
				totalWeight.assign(totalWeight.add(weight));
			}
			return total.div(totalWeight);
		})();
	}
};

//#endregion
//#region node_modules/shaders/dist/react/ZoomBlur.js
function computeEffectiveProps(props, defaultProps$1$1) {
	let baseProps = { ...defaultProps$1$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM$1 = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition && componentDefinition.props) Object.entries(componentDefinition.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
var OmbreComponent = (props) => {
	const context$2 = (0, import_react.useContext)(OmbreContext);
	if (!context$2) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context$2;
	const instanceId = (0, import_react.useMemo)(() => {
		return props.id || `${componentDefinition.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = (0, import_react.useMemo)(() => {
		return computeEffectiveProps(props, defaultProps);
	}, [props]);
	const effectiveTransform = (0, import_react.useMemo)(() => ({
		...DEFAULT_TRANSFORM$1,
		...props.transform
	}), [props.transform]);
	const uniformsRef = (0, import_react.useRef)(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition, effectiveProps, instanceId);
	const childContextValue = (0, import_react.useMemo)(() => {
		return {
			...context$2,
			ombreParentId: instanceId
		};
	}, [context$2, instanceId]);
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error$1) {
			console.error("Error registering shader node:", error$1);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = (0, import_react.useRef)({});
	(0, import_react.useEffect)(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform: uniform$2, transform } = uniformData;
				if (uniform$2?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error$1) {
			console.error("Error updating uniforms:", error$1);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	(0, import_react.useEffect)(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error$1) {
			console.error("Error updating metadata:", error$1);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var ZoomBlur_default = OmbreComponent;

//#endregion
//#region node_modules/shaders/dist/react/utils/generatePresetCode.js
var DEFAULT_TRANSFORM = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
function toObjectLiteral(obj) {
	return `{ ${Object.entries(obj).map(([key, value]) => {
		return `${key}: ${typeof value === "string" ? `"${value}"` : value}`;
	}).join(", ")} }`;
}
var shaderMetadata = {
	"AngularBlur": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Ascii": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Beam": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Blob": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Blur": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"BrightnessContrast": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Bulge": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"CRTScreen": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"ChannelBlur": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Checkerboard": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"ChromaFlow": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"ChromaticAberration": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Circle": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"CursorTrail": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"DiffuseBlur": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Dither": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"DotGrid": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Duotone": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"FilmGrain": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"FloatingParticles": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"GlassTiles": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Glow": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Godrays": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Grayscale": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Grid": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"GridDistortion": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Group": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Halftone": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"HueShift": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"ImageTexture": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Invert": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"LinearBlur": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"LinearGradient": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Liquify": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Perspective": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Pixelate": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"PolarCoordinates": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Posterize": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"ProgressiveBlur": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"RadialGradient": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"RectangularCoordinates": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Ripples": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Saturation": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Sharpness": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Shatter": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"SimplexNoise": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"SineWave": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"SolidColor": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Spherize": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Spiral": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Strands": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Stretch": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Stripes": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Swirl": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"TiltShift": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Tint": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Tritone": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Twirl": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"Vibrance": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"WaveDistortion": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"WebcamTexture": {
		"opacity": 1,
		"blendMode": "normal"
	},
	"ZoomBlur": {
		"opacity": 1,
		"blendMode": "normal"
	}
};
function generatePropString(props, componentType, indent = "  ") {
	return Object.entries(props).sort(([a$1], [b$2]) => a$1.localeCompare(b$2)).filter(([key, value]) => {
		if (key === "maskType" && value === "alpha") return false;
		if (key === "transform" && typeof value === "object") {
			if (Object.keys(DEFAULT_TRANSFORM).every((k) => value[k] === DEFAULT_TRANSFORM[k])) return false;
		}
		const componentDefaults = shaderMetadata[componentType] || {};
		if (componentDefaults.hasOwnProperty(key)) {
			const defaultValue = componentDefaults[key];
			if (value != null && defaultValue != null && typeof value === "object" && typeof defaultValue === "object") return JSON.stringify(value) !== JSON.stringify(defaultValue);
			return value !== defaultValue;
		}
		if (key === "opacity" && value === 1) return false;
		if (key === "blendMode" && value === "normal") return false;
		return true;
	}).map(([key, value]) => {
		if (key === "transform" && typeof value === "object") {
			const nonDefaultKeys = {};
			for (const k in value) if (value[k] !== DEFAULT_TRANSFORM[k]) nonDefaultKeys[k] = value[k];
			const keys = Object.keys(nonDefaultKeys).sort();
			if (keys.length > 1) return `${key}={{\n${indent}    ${keys.map((k) => `${k}: ${typeof nonDefaultKeys[k] === "string" ? `"${nonDefaultKeys[k]}"` : nonDefaultKeys[k]}`).join(`,\n${indent}    `)}\n${indent}  }}`;
			else if (keys.length === 1) {
				const k = keys[0];
				const v = nonDefaultKeys[k];
				return `${key}={{ ${k}: ${typeof v === "string" ? `"${v}"` : v} }}`;
			}
		}
		if (typeof value === "string") return `${key}="${value}"`;
		else if (value !== null && typeof value === "object") {
			const roundedValue = { ...value };
			if ("x" in roundedValue && typeof roundedValue.x === "number") roundedValue.x = Math.round(roundedValue.x * 100) / 100;
			if ("y" in roundedValue && typeof roundedValue.y === "number") roundedValue.y = Math.round(roundedValue.y * 100) / 100;
			return `${key}={${toObjectLiteral(roundedValue)}}`;
		} else return `${key}={${value}}`;
	}).join("\n" + indent + "  ");
}
function isIdUsedAsMaskSource(id, allComponents) {
	const flatComponents = [];
	function flattenComponents(components) {
		for (const component of components) {
			flatComponents.push(component);
			if (component.children) flattenComponents(component.children);
		}
	}
	flattenComponents(allComponents);
	return flatComponents.some((component) => component.props?.maskSource === id);
}
function generatePresetCode(preset) {
	const generateComponentString = (config, indent = "  ") => {
		const propString = config.props ? generatePropString(config.props, config.type, indent) : "";
		let idString = "";
		if (config.id) {
			if (isIdUsedAsMaskSource(config.id, preset.components)) idString = `id="${config.id}"`;
		}
		const attributes = [idString, propString].filter(Boolean).join("\n" + indent + "  ");
		if (config.children && config.children.length > 0) {
			const childrenString = config.children.map((child) => generateComponentString(child, indent + "  ")).join("\n");
			if (attributes) return `${indent}<${config.type}\n${indent}  ${attributes}>\n${childrenString}\n${indent}</${config.type}>`;
			else return `${indent}<${config.type}>\n${childrenString}\n${indent}</${config.type}>`;
		} else if (attributes) return `${indent}<${config.type}\n${indent}  ${attributes} />`;
		else return `${indent}<${config.type} />`;
	};
	return `<Shader>\n${preset.components.map((config) => generateComponentString(config)).join("\n")}\n</Shader>`;
}

//#endregion
export { AngularBlur_default as AngularBlur, Ascii_default as Ascii, Beam_default as Beam, Blob_default as Blob, Blur_default as Blur, BrightnessContrast_default as BrightnessContrast, Bulge_default as Bulge, CRTScreen_default as CRTScreen, ChannelBlur_default as ChannelBlur, Checkerboard_default as Checkerboard, ChromaFlow_default as ChromaFlow, ChromaticAberration_default as ChromaticAberration, Circle_default as Circle, CursorTrail_default as CursorTrail, DiffuseBlur_default as DiffuseBlur, Dither_default as Dither, DotGrid_default as DotGrid, Duotone_default as Duotone, FilmGrain_default as FilmGrain, FloatingParticles_default as FloatingParticles, GlassTiles_default as GlassTiles, Glow_default as Glow, Godrays_default as Godrays, Grayscale_default as Grayscale, Grid_default as Grid, GridDistortion_default as GridDistortion, Group_default as Group, Halftone_default as Halftone, HueShift_default as HueShift, ImageTexture_default as ImageTexture, Invert_default as Invert, LinearBlur_default as LinearBlur, LinearGradient_default as LinearGradient, Liquify_default as Liquify, Perspective_default as Perspective, Pixelate_default as Pixelate, PolarCoordinates_default as PolarCoordinates, Posterize_default as Posterize, ProgressiveBlur_default as ProgressiveBlur, RadialGradient_default as RadialGradient, RectangularCoordinates_default as RectangularCoordinates, Ripples_default as Ripples, Saturation_default as Saturation, Shader_default as Shader, Sharpness_default as Sharpness, Shatter_default as Shatter, SimplexNoise_default as SimplexNoise, SineWave_default as SineWave, SolidColor_default as SolidColor, Spherize_default as Spherize, Spiral_default as Spiral, Strands_default as Strands, Stretch_default as Stretch, Stripes_default as Stripes, Swirl_default as Swirl, TiltShift_default as TiltShift, Tint_default as Tint, Tritone_default as Tritone, Twirl_default as Twirl, Vibrance_default as Vibrance, WaveDistortion_default as WaveDistortion, WebcamTexture_default as WebcamTexture, ZoomBlur_default as ZoomBlur, generatePresetCode };
//# sourceMappingURL=shaders_react.js.map