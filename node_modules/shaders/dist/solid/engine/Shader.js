import { createComponent, template, spread, mergeProps, insert, use } from "solid-js/web";
import { createContext, splitProps, createMemo, onMount, onCleanup, useContext } from "solid-js";
import { shaderRenderer } from "../../core/index.js";
import { vec4 } from "three/tsl";
import { isExternalUser, shouldCollectTelemetry, TelemetryCollector } from "../../core/telemetry/index.js";
var _tmpl$ = /* @__PURE__ */ template(`<div><canvas data-renderer=shaders style=width:100%;height:100%;display:block>`);
const ShaderContext = createContext();
function Shader(allProps) {
  const [props, domProps] = splitProps(allProps, ["children", "hideNotice", "style", "class"]);
  let containerRef;
  let canvasRef;
  const rootId = "shader-root-" + Math.random().toString(36).substring(7);
  const rendererInstance = shaderRenderer();
  let telemetryCollector = null;
  let wasVisible = false;
  let visibilityObserver = null;
  let isInitialized = false;
  let isInitializing = false;
  const nodeRegister = (id, fragmentNodeFunc, parentId, metadata, uniforms = null, componentDefinition = null) => {
    if (fragmentNodeFunc === null) {
      try {
        rendererInstance.removeNode(id);
      } catch (err) {
        console.warn("Error removing node:", err);
      }
      return;
    }
    try {
      rendererInstance.registerNode(id, fragmentNodeFunc, parentId, metadata, uniforms, componentDefinition);
    } catch (err) {
      console.error("Error registering node:", err, {
        id,
        parentId,
        metadata
      });
    }
  };
  const uniformUpdate = (nodeId, uniformName, value) => {
    try {
      rendererInstance.updateUniformValue(nodeId, uniformName, value);
    } catch (err) {
      console.warn("Error updating uniform:", err);
    }
  };
  const metadataUpdate = (nodeId, metadata) => {
    try {
      rendererInstance.updateNodeMetadata(nodeId, metadata);
    } catch (err) {
      console.warn("Error updating metadata:", err);
    }
  };
  const contextValue = createMemo(() => ({
    shaderParentId: rootId,
    shaderNodeRegister: nodeRegister,
    shaderUniformUpdate: uniformUpdate,
    shaderMetadataUpdate: metadataUpdate
  }));
  const initializeRenderer = async () => {
    const canvas = canvasRef;
    if (!canvas || isInitialized || isInitializing) {
      return;
    }
    isInitializing = true;
    try {
      if (!rendererInstance.isInitialized()) {
        await rendererInstance.initialize({
          canvas
        });
      }
      rendererInstance.registerNode(
        rootId,
        // @ts-ignore
        ({
          childNode
        }) => childNode || vec4(0, 0, 0, 0),
        // Root node that passes through children
        null,
        // No parent (this is the root)
        null,
        // No metadata to pass
        {}
      );
      isInitialized = true;
      isInitializing = false;
      if (!props.hideNotice) {
        rendererInstance.showLicenseWarning();
      }
      if (isExternalUser() && shouldCollectTelemetry()) {
        telemetryCollector = new TelemetryCollector(rendererInstance);
        telemetryCollector.start();
      }
    } catch (err) {
      console.error("[Shader] Initialization failed:", err);
      isInitializing = false;
      throw err;
    }
  };
  const setupVisibilityObserver = () => {
    const container = containerRef;
    if (!container || visibilityObserver) return;
    visibilityObserver = new IntersectionObserver((entries) => {
      const entry = entries[0];
      if (!entry) return;
      const rect = container.getBoundingClientRect();
      const isCurrentlyVisible = entry.isIntersecting && rect && rect.width > 0 && rect.height > 0;
      if (isCurrentlyVisible && !wasVisible) {
        if (rendererInstance.isInitialized()) {
          rendererInstance.startAnimation();
        } else {
          initializeRenderer().catch(console.error);
        }
        wasVisible = true;
      } else if (!isCurrentlyVisible && wasVisible) {
        rendererInstance.stopAnimation();
        wasVisible = false;
      }
    }, {
      threshold: 0
    });
    visibilityObserver.observe(container);
  };
  onMount(async () => {
    const container = containerRef;
    if (!container) {
      console.error("Container ref is null in Shader onMount");
      return;
    }
    const rect = container.getBoundingClientRect();
    const isVisible = rect.width > 0 && rect.height > 0;
    if (isVisible) {
      await initializeRenderer();
      wasVisible = true;
    } else {
      wasVisible = false;
    }
    setupVisibilityObserver();
  });
  onCleanup(() => {
    if (telemetryCollector) {
      telemetryCollector.stop();
      telemetryCollector = null;
    }
    if (visibilityObserver) {
      visibilityObserver.disconnect();
      visibilityObserver = null;
    }
    if (rendererInstance && isInitialized) {
      try {
        rendererInstance.cleanup();
      } catch (err) {
        console.warn("[Shader] Error during cleanup:", err);
      }
    }
  });
  return createComponent(ShaderContext.Provider, {
    get value() {
      return contextValue();
    },
    get children() {
      var _el$ = _tmpl$(), _el$2 = _el$.firstChild;
      var _ref$ = containerRef;
      typeof _ref$ === "function" ? use(_ref$, _el$) : containerRef = _el$;
      spread(_el$, mergeProps({
        get ["class"]() {
          return "shader" + (props.class ? " " + props.class : "");
        },
        get style() {
          return props.style;
        }
      }, domProps), false, true);
      var _ref$2 = canvasRef;
      typeof _ref$2 === "function" ? use(_ref$2, _el$2) : canvasRef = _el$2;
      insert(_el$, () => props.children, null);
      return _el$;
    }
  });
}
function useShaderContext() {
  const ctx = useContext(ShaderContext);
  if (!ctx) {
    throw new Error("Shader components must be used inside a <Shader> component");
  }
  return ctx;
}
export {
  ShaderContext,
  Shader as default,
  useShaderContext
};
