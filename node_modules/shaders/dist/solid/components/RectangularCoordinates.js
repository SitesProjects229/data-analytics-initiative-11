import { createComponent } from "solid-js/web";
import { splitProps, createMemo, onMount, onCleanup, createEffect } from "solid-js";
import { createUniformsMap } from "../../core/index.js";
import { componentDefinition } from "../../core/shaders/RectangularCoordinates/index.js";
import { useShaderContext, ShaderContext } from "../engine/Shader.js";
const DEFAULT_TRANSFORM = {
  offsetX: 0,
  offsetY: 0,
  rotation: 0,
  scale: 1,
  anchorX: 0.5,
  anchorY: 0.5,
  edges: "transparent"
};
const defaultProps = {
  blendMode: "normal",
  renderOrder: 0,
  visible: true
  // opacity intentionally has no default - handled by renderer
  // transform intentionally has no default - handled by effectiveTransform
};
try {
  if (componentDefinition && componentDefinition.props) {
    Object.entries(componentDefinition.props).forEach(([key, config]) => {
      const propConfig = config;
      if (propConfig && typeof propConfig === "object" && "default" in propConfig) {
        defaultProps[key] = propConfig.default;
      }
    });
  }
} catch (e) {
  console.warn("Error extracting default props:", e);
}
function ShaderComponent(props) {
  const [local, otherProps] = splitProps(props, ["children"]);
  const context = useShaderContext();
  const {
    shaderParentId: parentId,
    shaderNodeRegister: parentRegister,
    shaderUniformUpdate: parentUniformUpdate,
    shaderMetadataUpdate: parentMetadataUpdate
  } = context;
  const instanceId = props.id || `${componentDefinition.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
  const effectiveProps = createMemo(() => {
    let baseProps = {
      ...defaultProps
    };
    for (const [key, value] of Object.entries(otherProps)) {
      if (value !== void 0) {
        baseProps[key] = value;
      }
    }
    return baseProps;
  });
  const effectiveTransform = createMemo(() => ({
    ...DEFAULT_TRANSFORM,
    ...props.transform
  }));
  let uniformsMap = null;
  const getUniformsMap = () => {
    if (!uniformsMap) {
      uniformsMap = createUniformsMap(componentDefinition, effectiveProps(), instanceId);
    }
    return uniformsMap;
  };
  const childContextValue = createMemo(() => ({
    ...context,
    shaderParentId: instanceId
  }));
  let isRegistered = false;
  onMount(() => {
    const uniforms = getUniformsMap();
    if (!uniforms) return;
    try {
      const metadata = {
        blendMode: props.blendMode || "normal",
        opacity: props.opacity,
        visible: props.visible === false ? false : true,
        id: props.id,
        mask: props.maskSource ? {
          source: props.maskSource,
          type: props.maskType || "alpha"
        } : void 0,
        renderOrder: props.renderOrder || 0,
        transform: effectiveTransform()
      };
      parentRegister(instanceId, componentDefinition.fragmentNode, parentId, metadata, uniforms, componentDefinition);
      isRegistered = true;
    } catch (error) {
      console.error("Error registering shader node:", error);
    }
  });
  onCleanup(() => {
    isRegistered = false;
    parentRegister(instanceId, null, null, null, null);
  });
  createEffect(() => {
    if (!isRegistered) return;
    const uniforms = getUniformsMap();
    if (!uniforms) return;
    try {
      const props_snapshot = effectiveProps();
      Object.entries(uniforms).forEach(([propName, uniformData]) => {
        if (!uniformData || typeof uniformData !== "object") return;
        const {
          uniform
        } = uniformData;
        if ((uniform == null ? void 0 : uniform.value) !== void 0 && propName in props_snapshot) {
          const newValue = props_snapshot[propName];
          parentUniformUpdate(instanceId, propName, newValue);
        }
      });
    } catch (error) {
      console.error("Error updating uniforms:", error);
    }
  });
  createEffect(() => {
    if (!isRegistered) return;
    try {
      const metadata = {
        blendMode: props.blendMode || "normal",
        opacity: props.opacity,
        visible: props.visible === false ? false : true,
        id: props.id,
        mask: props.maskSource ? {
          source: props.maskSource,
          type: props.maskType || "alpha"
        } : void 0,
        renderOrder: props.renderOrder || 0,
        transform: effectiveTransform()
      };
      parentMetadataUpdate(instanceId, metadata);
    } catch (error) {
      console.error("Error updating metadata:", error);
    }
  });
  return createComponent(ShaderContext.Provider, {
    get value() {
      return childContextValue();
    },
    get children() {
      return local.children;
    }
  });
}
export {
  ShaderComponent as default
};
