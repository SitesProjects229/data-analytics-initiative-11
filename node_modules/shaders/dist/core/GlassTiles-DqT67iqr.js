import { add, convertToTexture, cos, div, floor, mul, screenUV, sin, sub, uniform, vec2, vec4 } from "three/tsl";
const componentDefinition = {
	name: "GlassTiles",
	category: "Distortions",
	description: "Refraction-like distortion in a tile grid pattern",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 2,
			description: "The intensity of the glass tiles effect",
			ui: {
				type: "range",
				min: 0,
				max: 10,
				step: .1,
				label: "Intensity"
			}
		},
		tileCount: {
			default: 20,
			description: "Number of tiles across the shortest dimension",
			ui: {
				type: "range",
				min: 5,
				max: 50,
				step: 1,
				label: "Tile Count"
			}
		},
		rotation: {
			default: 0,
			description: "Rotation angle of the tile grid in degrees",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Rotation"
			}
		},
		roundness: {
			default: 0,
			description: "Makes tiles more circular instead of square",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Roundness"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, dimensions, onCleanup }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Glass Tiles shader.");
			return vec4(0);
		}
		const texture$1 = convertToTexture(childNode);
		onCleanup(() => {
			if (texture$1?.renderTarget?.dispose) texture$1.renderTarget.dispose();
		});
		const aspectRatioUniform = uniform(dimensions.width / dimensions.height);
		const baseUV = screenUV;
		const intensity = uniforms.intensity.uniform;
		const baseTileCount = uniforms.tileCount.uniform;
		const rotationDegrees = uniforms.rotation.uniform;
		const roundnessAmount = uniforms.roundness.uniform;
		const tileCount = vec2(aspectRatioUniform.greaterThanEqual(1).select(mul(baseTileCount, aspectRatioUniform), baseTileCount), aspectRatioUniform.lessThan(1).select(div(baseTileCount, aspectRatioUniform), baseTileCount));
		const aspectCorrectedUV = vec2(mul(baseUV.x, aspectRatioUniform), baseUV.y);
		const rotationRadians = mul(rotationDegrees, Math.PI / 180);
		const cosAngle = cos(rotationRadians);
		const sinAngle = sin(rotationRadians);
		const centered = sub(aspectCorrectedUV, vec2(mul(.5, aspectRatioUniform), .5));
		const rotatedUV = add(vec2(sub(mul(centered.x, cosAngle), mul(centered.y, sinAngle)), add(mul(centered.x, sinAngle), mul(centered.y, cosAngle))), vec2(mul(.5, aspectRatioUniform), .5));
		const gridUV = vec2(div(rotatedUV.x, aspectRatioUniform), rotatedUV.y);
		const fromCenter = sub(div(sub(gridUV, div(floor(mul(gridUV, tileCount)), tileCount)), div(vec2(1), tileCount)), vec2(.5, .5));
		const clampedRoundness = sub(1, mul(mul(fromCenter.x, fromCenter.x).add(mul(fromCenter.y, fromCenter.y)), mul(roundnessAmount, 4))).max(0);
		const distortedUV = add(baseUV, mul(fromCenter, mul(mul(intensity, .025), clampedRoundness)));
		return vec4(texture$1.sample(distortedUV));
	}
};
var GlassTiles_default = componentDefinition;
export { componentDefinition as n, GlassTiles_default as t };
