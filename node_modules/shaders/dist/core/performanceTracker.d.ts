/**
 * Performance tracking for shader rendering
 * Tracks frame times, memory usage, complexity, and more
 */
export interface PerformanceStats {
    fps: number;
    avgFrameTime: number;
    minFrameTime: number;
    maxFrameTime: number;
    p99FrameTime: number;
    stdDevFrameTime: number;
    jankCount: number;
    jankPercent: number;
    nodeCount: number;
    rttNodeCount: number;
    complexityScore: number;
    memoryUsedMB: number | null;
    memoryGrowthRate: number | null;
    cpuTime: number | null;
    gpuTime: number | null;
    budgetUsed: number;
    drawCalls: number | null;
    shaderPrograms: number | null;
    textureCount: number | null;
    intensityScore: number;
    intensityLabel: string;
    isRendering: boolean;
}
export declare class PerformanceTracker {
    private frameTimesMs;
    private readonly maxSamples;
    private readonly targetFrameTime;
    private jankFrameCount;
    private totalFrameCount;
    private memorySnapshots;
    private memorySnapshotIndex;
    private readonly maxMemorySnapshots;
    private nodeCount;
    private rttNodeCount;
    private lastCpuTime;
    private lastGpuTime;
    private isRendering;
    private lastFrameTimestamp;
    private frameIntervals;
    /**
     * Records a frame's render time
     */
    recordFrame(frameTimeMs: number): void;
    /**
     * Records CPU time for the last frame
     */
    recordCpuTime(timeMs: number): void;
    /**
     * Records GPU time for the last frame
     */
    recordGpuTime(timeMs: number): void;
    /**
     * Updates node counts for complexity calculation
     */
    updateNodeCounts(nodeCount: number, rttNodeCount: number): void;
    /**
     * Sets rendering state
     */
    setRendering(rendering: boolean): void;
    /**
     * Records a memory snapshot for growth rate calculation
     * Uses circular buffer to avoid GC pressure from allocations
     */
    private recordMemorySnapshot;
    /**
     * Calculates memory growth rate in MB/sec
     * Works with circular buffer - oldest is at write index, newest is before it
     */
    private calculateMemoryGrowthRate;
    /**
     * Calculates standard deviation of frame times
     * Optimized to avoid array allocations
     */
    private calculateStdDev;
    private sortBuffer;
    /**
     * Calculates 99th percentile frame time
     * Uses pre-allocated buffer and in-place sorting to avoid allocations
     */
    private calculateP99;
    /**
     * Calculates complexity score based on node structure
     * RTT nodes are 10x more expensive than regular nodes
     */
    private calculateComplexityScore;
    /**
     * Calculates normalized intensity score (0-100) for "average machine" estimation
     * Combines frame time, complexity, and GPU time into single metric
     *
     * Scoring:
     * - 0-20: Very Light (simple effects, <5ms)
     * - 21-40: Light (basic effects, 5-8ms)
     * - 41-60: Medium (moderate effects, 8-12ms)
     * - 61-80: Heavy (complex effects, 12-15ms)
     * - 81-100: Very Heavy (intensive effects, >15ms)
     */
    private calculateIntensityScore;
    /**
     * Gets current performance statistics
     */
    getStats(rendererInfo?: any): PerformanceStats;
    /**
     * Resets all statistics
     */
    reset(): void;
}
//# sourceMappingURL=performanceTracker.d.ts.map