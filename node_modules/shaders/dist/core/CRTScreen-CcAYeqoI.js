import { convertToTexture, float, fract, length, screenUV, sin, smoothstep, vec2, vec3, vec4 } from "three/tsl";
const componentDefinition = {
	name: "CRTScreen",
	category: "Stylize",
	description: "Retro CRT monitor simulation with scanlines",
	requiresRTT: true,
	requiresChild: true,
	props: {
		pixelSize: {
			default: 128,
			description: "Size of individual TV pixels (lower = more pixels)",
			ui: {
				type: "range",
				min: 8,
				max: 128,
				step: 1,
				label: "Pixel Size"
			}
		},
		colorShift: {
			default: 1,
			description: "Chromatic aberration amount",
			ui: {
				type: "range",
				min: 0,
				max: 10,
				step: .1,
				label: "Color Shift"
			}
		},
		scanlineIntensity: {
			default: .3,
			description: "Strength of horizontal scanlines",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Scanline Intensity"
			}
		},
		scanlineFrequency: {
			default: 200,
			description: "Number of scanlines across screen",
			ui: {
				type: "range",
				min: 100,
				max: 800,
				step: 10,
				label: "Scanline Frequency"
			}
		},
		brightness: {
			default: 1.1,
			description: "Screen brightness boost",
			ui: {
				type: "range",
				min: .5,
				max: 2,
				step: .01,
				label: "Brightness"
			}
		},
		contrast: {
			default: 1.2,
			description: "Screen contrast enhancement",
			ui: {
				type: "range",
				min: .5,
				max: 2,
				step: .01,
				label: "Contrast"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const pixelSize = uniforms.pixelSize.uniform;
		const colorShift = uniforms.colorShift.uniform;
		const scanlineIntensity = uniforms.scanlineIntensity.uniform;
		const scanlineFrequency = uniforms.scanlineFrequency.uniform;
		const brightness = uniforms.brightness.uniform;
		const contrast = uniforms.contrast.uniform;
		const scaledColorShift = colorShift.mul(float(.002));
		const redUV = screenUV.add(vec2(scaledColorShift, float(0)));
		const greenUV = screenUV;
		const blueUV = screenUV.sub(vec2(scaledColorShift, float(0)));
		const redSample = childTexture.sample(redUV).r;
		const greenSample = childTexture.sample(greenUV).g;
		const blueSample = childTexture.sample(blueUV).b;
		const adjustedColor = vec3(redSample, greenSample, blueSample).sub(float(.5)).mul(contrast).add(float(.5)).mul(brightness);
		const scanlineWave = sin(screenUV.y.mul(scanlineFrequency).mul(float(3.14159 * 2)));
		const scanlineEffect = float(1).sub(scanlineIntensity.mul(scanlineWave.mul(float(.5)).add(float(.5))));
		const scanlinedColor = adjustedColor.mul(scanlineEffect);
		const phosphorScale = pixelSize.mul(float(.5));
		const pixelPhase = fract(screenUV.mul(phosphorScale));
		const redMask = sin(pixelPhase.x.mul(float(6.28318))).mul(float(.1)).add(float(.95));
		const greenMask = sin(pixelPhase.x.mul(float(6.28318)).add(float(2.09))).mul(float(.1)).add(float(.95));
		const blueMask = sin(pixelPhase.x.mul(float(6.28318)).add(float(4.18))).mul(float(.1)).add(float(.95));
		const phosphorColor = vec3(scanlinedColor.r.mul(redMask), scanlinedColor.g.mul(greenMask), scanlinedColor.b.mul(blueMask));
		const vignetteDistance = length(screenUV.sub(vec2(.5, .5)));
		const vignette = smoothstep(float(.8), float(.3), vignetteDistance);
		return vec4(phosphorColor.mul(vignette), float(1));
	}
};
var CRTScreen_default = componentDefinition;
export { componentDefinition as n, CRTScreen_default as t };
