import { r as transformColor, s as transformPosition } from "./transformations-YbhRK-rd.js";
import { convertToTexture, dot, float, max, normalize, pow, screenUV, smoothstep, sqrt, vec2, vec3, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "Spherize",
	category: "Distortions",
	description: "Map content onto a 3D sphere surface with depth distortion",
	requiresRTT: true,
	requiresChild: true,
	props: {
		radius: {
			default: 1,
			description: "Radius of the sphere (1 = half viewport height)",
			ui: {
				type: "range",
				min: .1,
				max: 3,
				step: .01,
				label: "Radius"
			}
		},
		depth: {
			default: 1,
			description: "How much the sphere bulges toward viewer (0 = flat, higher = more bulge)",
			ui: {
				type: "range",
				min: 0,
				max: 3,
				step: .01,
				label: "Depth"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the sphere",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		lightPosition: {
			default: {
				x: .3,
				y: .3
			},
			transform: transformPosition,
			description: "Position of the specular light source",
			ui: {
				type: "position",
				label: "Light Position"
			}
		},
		lightIntensity: {
			default: .5,
			description: "Intensity of the rim light (0 = off)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Light Intensity"
			}
		},
		lightSoftness: {
			default: .5,
			description: "Softness of the rim light falloff (0 = hard edge, 1 = soft glow)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Light Softness"
			}
		},
		lightColor: {
			default: "#ffffff",
			transform: transformColor,
			description: "Color of the specular highlight",
			ui: {
				type: "color",
				label: "Light Color"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const uv$1 = screenUV;
		const aspect = viewportSize.x.div(viewportSize.y);
		const centerPos = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const radius = uniforms.radius.uniform;
		const sphereUV = vec2(uv$1.x.sub(centerPos.x).mul(aspect), uv$1.y.sub(centerPos.y)).mul(2).div(radius);
		const radiusSq = sphereUV.x.mul(sphereUV.x).add(sphereUV.y.mul(sphereUV.y));
		const sphereAlpha = float(1).sub(smoothstep(float(.98), float(1), radiusSq));
		const z = sqrt(max(float(0), float(1).sub(radiusSq)));
		const depthFactor = float(1).add(z.mul(uniforms.depth.uniform));
		const finalUV = sphereUV.div(depthFactor).mul(radius).div(2);
		const transformedUV = vec2(finalUV.x.div(aspect).add(centerPos.x), finalUV.y.add(centerPos.y));
		const sampledColor = childTexture.sample(transformedUV);
		const lightPos = vec2(uniforms.lightPosition.uniform.x, uniforms.lightPosition.uniform.y.oneMinus());
		const lightIntensity = uniforms.lightIntensity.uniform;
		const lightSoftness = uniforms.lightSoftness.uniform;
		const lightColor = vec3(uniforms.lightColor.uniform.x, uniforms.lightColor.uniform.y, uniforms.lightColor.uniform.z);
		const normal = normalize(vec3(sphereUV.x, sphereUV.y, z));
		const viewDir = vec3(0, 0, 1);
		const fresnelPower = float(1).add(float(4).mul(float(1).sub(lightSoftness)));
		const fresnel = pow(float(1).sub(max(dot(normal, viewDir), float(0))), fresnelPower);
		const lightDir2D = vec2(lightPos.x.sub(float(.5)).mul(2), lightPos.y.sub(float(.5)).mul(2));
		const normalDir = normalize(vec2(normal.x, normal.y).add(vec2(1e-4, 1e-4)));
		const lightDirNorm = normalize(lightDir2D.add(vec2(1e-4, 1e-4)));
		const directionalBias = pow(max(float(0), dot(normalDir, lightDirNorm)), float(2));
		const rimLight = fresnel.mul(directionalBias).mul(lightIntensity).mul(float(2));
		const finalR = sampledColor.x.add(lightColor.x.mul(rimLight));
		const finalG = sampledColor.y.add(lightColor.y.mul(rimLight));
		const finalB = sampledColor.z.add(lightColor.z.mul(rimLight));
		const finalA = sampledColor.w.mul(sphereAlpha);
		return vec4(finalR.mul(finalA), finalG.mul(finalA), finalB.mul(finalA), finalA);
	}
};
var Spherize_default = componentDefinition;
export { componentDefinition as n, Spherize_default as t };
