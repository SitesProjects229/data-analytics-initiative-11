import { r as transformColor, s as transformPosition } from "./transformations-YbhRK-rd.js";
import { t as createAnimatedTime } from "./time-BZqyVJXt.js";
import { t as mixColors } from "./colorMixing-CZPFmiT4.js";
import { distance, float, screenUV, sin, smoothstep, vec2, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "Ripples",
	category: "Base Layers",
	description: "Concentric animated ripples emanating from a point",
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point where ripples emanate from",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		colorA: {
			default: "#ffffff",
			transform: transformColor,
			description: "Color of the ripple waves",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#000000",
			transform: transformColor,
			description: "Background color between ripples",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		speed: {
			default: 1,
			description: "Speed of ripple animation",
			ui: {
				type: "range",
				min: -5,
				max: 5,
				step: .1,
				label: "Speed"
			}
		},
		frequency: {
			default: 20,
			description: "Number of ripples/spacing between them",
			ui: {
				type: "range",
				min: 1,
				max: 80,
				step: .1,
				label: "Frequency"
			}
		},
		softness: {
			default: 0,
			description: "Softness of ripple edges",
			ui: {
				type: "range",
				min: 0,
				max: 3,
				step: .01,
				label: "Softness"
			}
		},
		thickness: {
			default: .5,
			description: "Thickness of each ripple band",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Thickness"
			}
		},
		phase: {
			default: 0,
			description: "Phase offset for ripple animation",
			ui: {
				type: "range",
				min: 0,
				max: 6.28,
				step: .01,
				label: "Phase"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const uv$1 = screenUV;
		const center = uniforms.center.uniform;
		const colorA = uniforms.colorA.uniform;
		const colorB = uniforms.colorB.uniform;
		const frequency = uniforms.frequency.uniform;
		const softness = uniforms.softness.uniform;
		const thickness = uniforms.thickness.uniform;
		const phase = uniforms.phase.uniform;
		const aspect = viewportSize.x.div(viewportSize.y);
		const dist = distance(vec2(uv$1.x.mul(aspect), uv$1.y), vec2(center.x.mul(aspect), center.y.oneMinus()));
		const animTime = createAnimatedTime(params, uniforms.speed);
		const baseWave = sin(dist.mul(frequency).sub(animTime).add(phase));
		const thicknessThreshold = thickness.mul(float(2)).sub(float(1));
		return mixColors(colorB, colorA, smoothstep(thicknessThreshold.add(softness), thicknessThreshold.sub(softness), baseWave), float(0));
	}
};
var Ripples_default = componentDefinition;
export { componentDefinition as n, Ripples_default as t };
