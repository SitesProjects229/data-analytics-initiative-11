import { Fn, clamp, convertToTexture, float, screenUV, vec2, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "Sharpness",
	category: "Adjustments",
	description: "Adjust image sharpness using a convolution kernel",
	requiresRTT: true,
	requiresChild: true,
	props: { sharpness: {
		default: 0,
		description: "How sharp to make the underlying image",
		ui: {
			type: "range",
			min: 0,
			max: 5,
			step: .01,
			label: "Sharpness"
		}
	} },
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		return Fn(() => {
			const uv$1 = screenUV;
			const amount = uniforms.sharpness.uniform;
			const pixelSize = vec2(1).div(viewportSize);
			const center = childTexture.sample(uv$1);
			const top = childTexture.sample(uv$1.add(vec2(0, pixelSize.y)));
			const bottom = childTexture.sample(uv$1.sub(vec2(0, pixelSize.y)));
			const left = childTexture.sample(uv$1.sub(vec2(pixelSize.x, 0)));
			const right = childTexture.sample(uv$1.add(vec2(pixelSize.x, 0)));
			const centerWeight = float(1).add(amount.mul(4));
			const neighborWeight = amount.negate();
			return vec4(clamp(center.mul(centerWeight).add(top.mul(neighborWeight)).add(bottom.mul(neighborWeight)).add(left.mul(neighborWeight)).add(right.mul(neighborWeight)).rgb, 0, 1), center.a);
		})();
	}
};
var Sharpness_default = componentDefinition;
export { componentDefinition as n, Sharpness_default as t };
