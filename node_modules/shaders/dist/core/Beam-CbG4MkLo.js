import { i as transformColorSpace, r as transformColor, s as transformPosition, t as colorSpaceOptions } from "./transformations-YbhRK-rd.js";
import { t as mixColors } from "./colorMixing-CZPFmiT4.js";
import { clamp, float, max, mix, pow, screenUV, smoothstep, sqrt, vec2, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "Beam",
	category: "Base Layers",
	description: "A beam of light from one point to another.",
	props: {
		startPosition: {
			default: {
				x: .2,
				y: .5
			},
			transform: transformPosition,
			description: "Starting point of the beam",
			ui: {
				type: "position",
				label: "Start Position"
			}
		},
		endPosition: {
			default: {
				x: .8,
				y: .5
			},
			transform: transformPosition,
			description: "Ending point of the beam",
			ui: {
				type: "position",
				label: "End Position"
			}
		},
		startThickness: {
			default: .2,
			description: "Thickness at the start of the beam",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Start Thickness"
			}
		},
		endThickness: {
			default: .2,
			description: "Thickness at the end of the beam",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "End Thickness"
			}
		},
		startSoftness: {
			default: .5,
			description: "Edge softness at the start of the beam",
			ui: {
				type: "range",
				min: 0,
				max: 50,
				step: .01,
				label: "Start Softness"
			}
		},
		endSoftness: {
			default: .5,
			description: "Edge softness at the end of the beam",
			ui: {
				type: "range",
				min: 0,
				max: 20,
				step: .01,
				label: "End Softness"
			}
		},
		insideColor: {
			default: "#FF0000",
			transform: transformColor,
			description: "Color at the center of the beam",
			ui: {
				type: "color",
				label: "Inside Color"
			}
		},
		outsideColor: {
			default: "#0000FF",
			transform: transformColor,
			description: "Color at the edges of the beam",
			ui: {
				type: "color",
				label: "Outside Color"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms }) => {
		const baseUV = screenUV;
		const aspect = viewportSize.x.div(viewportSize.y);
		const startPos = vec2(uniforms.startPosition.uniform.x, uniforms.startPosition.uniform.y.oneMinus());
		const endPos = vec2(uniforms.endPosition.uniform.x, uniforms.endPosition.uniform.y.oneMinus());
		const aspectCorrectedStart = vec2(startPos.x.mul(aspect), startPos.y);
		const aspectCorrectedEnd = vec2(endPos.x.mul(aspect), endPos.y);
		const aspectCorrectedUV = vec2(baseUV.x.mul(aspect), baseUV.y);
		const lineVec = vec2(aspectCorrectedEnd.x.sub(aspectCorrectedStart.x), aspectCorrectedEnd.y.sub(aspectCorrectedStart.y));
		const toPoint = vec2(aspectCorrectedUV.x.sub(aspectCorrectedStart.x), aspectCorrectedUV.y.sub(aspectCorrectedStart.y));
		const dotProduct = toPoint.x.mul(lineVec.x).add(toPoint.y.mul(lineVec.y));
		const lineLengthSq = lineVec.x.mul(lineVec.x).add(lineVec.y.mul(lineVec.y));
		const t = clamp(dotProduct.div(max(lineLengthSq, float(1e-4))), float(0), float(1));
		const closestPoint = vec2(aspectCorrectedStart.x.add(lineVec.x.mul(t)), aspectCorrectedStart.y.add(lineVec.y.mul(t)));
		const distVec = vec2(aspectCorrectedUV.x.sub(closestPoint.x), aspectCorrectedUV.y.sub(closestPoint.y));
		const distance$1 = sqrt(distVec.x.mul(distVec.x).add(distVec.y.mul(distVec.y)));
		const thickness = mix(uniforms.startThickness.uniform.mul(.25), uniforms.endThickness.uniform.mul(.25), t);
		const startSoft = uniforms.startSoftness.uniform;
		const endSoft = uniforms.endSoftness.uniform;
		const softness = mix(startSoft, endSoft, t);
		const normalizedDist = distance$1.div(max(thickness, float(1e-4)));
		const edgeEnd = float(1).add(softness);
		const alpha = pow(float(1).sub(smoothstep(float(1), edgeEnd, normalizedDist)), float(1).add(softness.mul(1.5)));
		const colorT = smoothstep(float(1).sub(softness), float(1).add(softness), normalizedDist);
		const insideCol = uniforms.insideColor.uniform;
		const outsideCol = uniforms.outsideColor.uniform;
		const beamColorRGB = mixColors(insideCol, outsideCol, colorT, uniforms.colorSpace.uniform).rgb;
		return vec4(beamColorRGB, insideCol.a.add(outsideCol.a).div(float(2)).mul(alpha));
	}
};
var Beam_default = componentDefinition;
export { componentDefinition as n, Beam_default as t };
