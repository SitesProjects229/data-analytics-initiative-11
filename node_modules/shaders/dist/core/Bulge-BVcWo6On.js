import { t as applyEdgeHandling } from "./edges-Bd7GP4s2.js";
import { o as transformEdges, s as transformPosition } from "./transformations-YbhRK-rd.js";
import { convertToTexture, float, length, max, screenUV, smoothstep, vec2, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "Bulge",
	category: "Distortions",
	description: "Magnify or pinch content around a center point",
	requiresRTT: true,
	requiresChild: true,
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the bulge effect",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		strength: {
			default: 1,
			description: "The intensity of the bulge effect (positive = bulge out, negative = pinch in)",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Strength"
			}
		},
		radius: {
			default: 1,
			description: "The radius of the bulge effect area",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .01,
				label: "Radius"
			}
		},
		falloff: {
			default: .5,
			description: "Controls the smoothness of the transition (0 = hard edge, 1 = very smooth)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Falloff"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const aspect = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(screenUV.x.mul(aspect), screenUV.y);
		const centerPos = vec2(uniforms.center.uniform.x.mul(aspect), uniforms.center.uniform.y.oneMinus());
		const delta = aspectCorrectedUV.sub(centerPos);
		const distance$1 = length(delta);
		const effectRadius = uniforms.radius.uniform.mul(.5);
		const falloffAmount = uniforms.falloff.uniform;
		const smoothFalloff = smoothstep(effectRadius.mul(float(1).sub(falloffAmount).sub(float(.001)).max(float(0))), effectRadius, distance$1).oneMinus();
		const normalizedDist = distance$1.div(effectRadius);
		const distSq = normalizedDist.mul(normalizedDist);
		const quadraticFalloff = max(float(0), float(1).sub(distSq));
		const falloff = smoothFalloff.mul(quadraticFalloff);
		const displacementAmount = uniforms.strength.uniform.negate().mul(falloff);
		const scaleFactor = float(1).add(displacementAmount);
		const bulgedDelta = delta.mul(scaleFactor);
		const bulgedUV = centerPos.add(bulgedDelta);
		const finalUV = vec2(bulgedUV.x.div(aspect), bulgedUV.y);
		return applyEdgeHandling(finalUV, childTexture.sample(finalUV), childTexture, uniforms.edges.uniform);
	}
};
var Bulge_default = componentDefinition;
export { componentDefinition as n, Bulge_default as t };
