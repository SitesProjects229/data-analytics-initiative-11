import { r as transformColor, s as transformPosition } from "./transformations-YbhRK-rd.js";
import { t as createAnimatedTime } from "./time-BZqyVJXt.js";
import { Fn, abs, cos, float, max, mix, screenUV, smoothstep, vec2, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "Strands",
	category: "Base Layers",
	description: "Procedural wavy strands with layered animation",
	requiresRTT: false,
	requiresChild: false,
	props: {
		speed: {
			default: .5,
			description: "Overall animation speed",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Speed"
			}
		},
		amplitude: {
			default: 1,
			description: "Wave height amplitude",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Amplitude"
			}
		},
		frequency: {
			default: 1,
			description: "Wave frequency",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .01,
				label: "Frequency"
			}
		},
		lineCount: {
			default: 12,
			description: "Number of wave lines",
			ui: {
				type: "range",
				min: 4,
				max: 32,
				step: 1,
				label: "Line Count"
			}
		},
		lineWidth: {
			default: .1,
			description: "Width of wave lines",
			ui: {
				type: "range",
				min: .01,
				max: .5,
				step: .01,
				label: "Line Width"
			}
		},
		waveColor: {
			default: "#f1c907",
			transform: transformColor,
			description: "Color of the waves",
			ui: {
				type: "color",
				label: "Wave Color"
			}
		},
		pinEdges: {
			default: true,
			description: "Pin waves at edges (fade effect)",
			ui: {
				type: "checkbox",
				label: "Pin Edges"
			}
		},
		start: {
			default: {
				x: 0,
				y: .5
			},
			transform: transformPosition,
			description: "Starting point of the waves",
			ui: {
				type: "position",
				label: "Start"
			}
		},
		end: {
			default: {
				x: 1,
				y: .5
			},
			transform: transformPosition,
			description: "Ending point of the waves",
			ui: {
				type: "position",
				label: "End"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const baseUV = screenUV;
		const t = createAnimatedTime(params, uniforms.speed);
		const random = Fn(([time$1]) => {
			return cos(time$1).add(cos(time$1.mul(1.2).add(1.6))).add(cos(time$1.mul(1.4).add(1.5))).div(3);
		});
		return Fn(([uv$1]) => {
			const aspectRatio = viewportSize.x.div(viewportSize.y);
			const startPos = vec2(uniforms.start.uniform.x.mul(aspectRatio), uniforms.start.uniform.y.oneMinus());
			const endPos = vec2(uniforms.end.uniform.x.mul(aspectRatio), uniforms.end.uniform.y.oneMinus());
			const aspectUV = vec2(uv$1.x.mul(aspectRatio), uv$1.y);
			const direction = endPos.sub(startPos);
			const length$1 = direction.length();
			const normalizedDir = direction.div(length$1);
			const perpDir = vec2(normalizedDir.y.negate(), normalizedDir.x);
			const relativePos = aspectUV.sub(startPos);
			const progress = relativePos.dot(normalizedDir).div(length$1);
			const distFromLine = relativePos.dot(perpDir);
			const waveCoord = progress.mul(10);
			const perpCoord = distFromLine.mul(10);
			const edgeFade = uniforms.pinEdges.uniform.select(smoothstep(float(0), float(.1), progress).mul(smoothstep(float(1), float(.9), progress)), float(1));
			const horizontalFade = uniforms.pinEdges.uniform.select(cos(progress.mul(6.28)).mul(.5).add(.5).oneMinus(), float(1));
			const verticalFade = cos(progress.mul(6.28)).mul(.5).add(.5).oneMinus();
			const linesColor = vec4(0, 0, 0, 0).toVar();
			const maxLines = uniforms.lineCount.uniform;
			for (let i = 0; i < 32; i++) {
				const lineActive = float(i).lessThan(maxLines);
				const lineIndex = float(i);
				const normalizedIndex = lineIndex.div(maxLines);
				const offsetFreq = float(.5);
				const offsetSpeed = float(1.33);
				const offsetTime = t.mul(offsetSpeed);
				const offsetPosition = lineIndex.add(waveCoord.mul(offsetFreq));
				const rand = random(offsetPosition.add(offsetTime)).mul(.5).add(.5);
				const halfWidth = mix(float(.01), uniforms.lineWidth.uniform, rand.mul(horizontalFade)).mul(.5);
				const minSpread = float(.6);
				const maxSpread = float(2);
				const offset = random(offsetPosition.add(offsetTime.mul(normalizedIndex.add(1)))).mul(mix(minSpread, maxSpread, horizontalFade)).mul(uniforms.amplitude.uniform);
				const linePosition = random(waveCoord.mul(uniforms.frequency.uniform).add(t)).mul(horizontalFade).mul(uniforms.amplitude.uniform).add(offset);
				const dist = abs(perpCoord.sub(linePosition));
				const lineEdgeSoftness = float(.01);
				const line = smoothstep(halfWidth.add(lineEdgeSoftness), halfWidth.sub(lineEdgeSoftness), dist);
				const lineContribution = vec4(uniforms.waveColor.uniform.r, uniforms.waveColor.uniform.g, uniforms.waveColor.uniform.b, line).mul(rand);
				linesColor.assign(max(linesColor, lineActive.select(lineContribution, vec4(0, 0, 0, 0))));
			}
			return linesColor.mul(vec4(1, 1, 1, verticalFade.mul(edgeFade)));
		})(baseUV);
	}
};
var Strands_default = componentDefinition;
export { componentDefinition as n, Strands_default as t };
