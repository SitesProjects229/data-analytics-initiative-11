import { t as applyEdgeHandling } from "./edges-Bd7GP4s2.js";
import { o as transformEdges } from "./transformations-YbhRK-rd.js";
import { convertToTexture, dot, fract, screenUV, sin, vec2, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "DiffuseBlur",
	category: "Blurs",
	description: "Grain-like pixel displacement at random",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 30,
			description: "Intensity of the diffuse blur effect",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Intensity"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const hash = (p) => {
			return fract(sin(dot(p, vec2(12.9898, 78.233).mul(2))).mul(43758.5453));
		};
		const uv$1 = screenUV;
		const pixelSize = vec2(1).div(viewportSize);
		const seed = uv$1.mul(1e3);
		const rand1 = hash(seed);
		const rand2 = hash(seed.add(vec2(73.2, 41.9)));
		const offset = vec2(rand1.mul(2).sub(1), rand2.mul(2).sub(1)).mul(uniforms.intensity.uniform).mul(pixelSize);
		const displacedUV = uv$1.add(offset);
		return applyEdgeHandling(displacedUV, childTexture.sample(displacedUV), childTexture, uniforms.edges.uniform);
	}
};
var DiffuseBlur_default = componentDefinition;
export { componentDefinition as n, DiffuseBlur_default as t };
