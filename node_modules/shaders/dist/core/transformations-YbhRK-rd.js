import { Vector2, Vector4 } from "three";
import { vec2, vec4 } from "three/tsl";
function multiplyMatrices(A, B) {
	let m$1 = A.length;
	if (!Array.isArray(A[0])) A = [A];
	if (!Array.isArray(B[0])) B = B.map((x) => [x]);
	let p$1 = B[0].length;
	let B_cols = B[0].map((_, i) => B.map((x) => x[i]));
	let product = A.map((row) => B_cols.map((col) => {
		let ret = 0;
		if (!Array.isArray(row)) {
			for (let c$1 of col) ret += row * c$1;
			return ret;
		}
		for (let i = 0; i < row.length; i++) ret += row[i] * (col[i] || 0);
		return ret;
	}));
	if (m$1 === 1) product = product[0];
	if (p$1 === 1) return product.map((x) => x[0]);
	return product;
}
function isString(str) {
	return type(str) === "string";
}
function type(o) {
	return (Object.prototype.toString.call(o).match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
}
function serializeNumber(n$2, { precision, unit }) {
	if (isNone(n$2)) return "none";
	return toPrecision(n$2, precision) + (unit ?? "");
}
function isNone(n$2) {
	return Number.isNaN(n$2) || n$2 instanceof Number && n$2?.none;
}
function skipNone(n$2) {
	return isNone(n$2) ? 0 : n$2;
}
function toPrecision(n$2, precision) {
	if (n$2 === 0) return 0;
	let integer = ~~n$2;
	let digits = 0;
	if (integer && precision) digits = ~~Math.log10(Math.abs(integer)) + 1;
	const multiplier = 10 ** (precision - digits);
	return Math.floor(n$2 * multiplier + .5) / multiplier;
}
var angleFactor = {
	deg: 1,
	grad: .9,
	rad: 180 / Math.PI,
	turn: 360
};
function parseFunction(str) {
	if (!str) return;
	str = str.trim();
	const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
	const isNumberRegex = /^-?[\d.]+$/;
	const unitValueRegex = /%|deg|g?rad|turn$/;
	const singleArgument = /\/?\s*(none|[-\w.]+(?:%|deg|g?rad|turn)?)/g;
	let parts = str.match(isFunctionRegex);
	if (parts) {
		let args = [];
		parts[2].replace(singleArgument, ($0, rawArg) => {
			let match = rawArg.match(unitValueRegex);
			let arg = rawArg;
			if (match) {
				let unit = match[0];
				let unitlessArg = arg.slice(0, -unit.length);
				if (unit === "%") {
					arg = /* @__PURE__ */ new Number(unitlessArg / 100);
					arg.type = "<percentage>";
				} else {
					arg = new Number(unitlessArg * angleFactor[unit]);
					arg.type = "<angle>";
					arg.unit = unit;
				}
			} else if (isNumberRegex.test(arg)) {
				arg = new Number(arg);
				arg.type = "<number>";
			} else if (arg === "none") {
				arg = /* @__PURE__ */ new Number(NaN);
				arg.none = true;
			}
			if ($0.startsWith("/")) {
				arg = arg instanceof Number ? arg : new Number(arg);
				arg.alpha = true;
			}
			if (typeof arg === "object" && arg instanceof Number) arg.raw = rawArg;
			args.push(arg);
		});
		return {
			name: parts[1].toLowerCase(),
			rawName: parts[1],
			rawArgs: parts[2],
			args
		};
	}
}
function last(arr) {
	return arr[arr.length - 1];
}
function interpolate(start, end, p$1) {
	if (isNaN(start)) return end;
	if (isNaN(end)) return start;
	return start + (end - start) * p$1;
}
function interpolateInv(start, end, value) {
	return (value - start) / (end - start);
}
function mapRange(from, to$1, value) {
	return interpolate(to$1[0], to$1[1], interpolateInv(from[0], from[1], value));
}
function parseCoordGrammar(coordGrammars) {
	return coordGrammars.map((coordGrammar$1) => {
		return coordGrammar$1.split("|").map((type$1) => {
			type$1 = type$1.trim();
			let range$1 = type$1.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
			if (range$1) {
				let ret = new String(range$1[1]);
				ret.range = [+range$1[2], +range$1[3]];
				return ret;
			}
			return type$1;
		});
	});
}
function clamp$1(min$1, val, max$2) {
	return Math.max(Math.min(max$2, val), min$1);
}
function copySign(to$1, from) {
	return Math.sign(to$1) === Math.sign(from) ? to$1 : -to$1;
}
function spow(base, exp$1) {
	return copySign(Math.abs(base) ** exp$1, base);
}
function zdiv(n$2, d$1) {
	return d$1 === 0 ? 0 : n$2 / d$1;
}
function bisectLeft(arr, value, lo = 0, hi = arr.length) {
	while (lo < hi) {
		const mid = lo + hi >> 1;
		if (arr[mid] < value) lo = mid + 1;
		else hi = mid;
	}
	return lo;
}
var util = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	bisectLeft,
	clamp: clamp$1,
	copySign,
	interpolate,
	interpolateInv,
	isNone,
	isString,
	last,
	mapRange,
	multiplyMatrices,
	parseCoordGrammar,
	parseFunction,
	serializeNumber,
	skipNone,
	spow,
	toPrecision,
	type,
	zdiv
});
var Hooks = class {
	add(name, callback, first) {
		if (typeof arguments[0] != "string") {
			for (var name in arguments[0]) this.add(name, arguments[0][name], arguments[1]);
			return;
		}
		(Array.isArray(name) ? name : [name]).forEach(function(name$1) {
			this[name$1] = this[name$1] || [];
			if (callback) this[name$1][first ? "unshift" : "push"](callback);
		}, this);
	}
	run(name, env) {
		this[name] = this[name] || [];
		this[name].forEach(function(callback) {
			callback.call(env && env.context ? env.context : env, env);
		});
	}
};
var hooks = new Hooks();
var defaults = {
	gamut_mapping: "css",
	precision: 5,
	deltaE: "76",
	verbose: globalThis?.process?.env?.NODE_ENV?.toLowerCase() !== "test",
	warn: function warn(msg) {
		if (this.verbose) globalThis?.console?.warn?.(msg);
	}
};
var WHITES = {
	D50: [
		.3457 / .3585,
		1,
		.2958 / .3585
	],
	D65: [
		.3127 / .329,
		1,
		.3583 / .329
	]
};
function getWhite(name) {
	if (Array.isArray(name)) return name;
	return WHITES[name];
}
function adapt$2(W1, W2, XYZ, options = {}) {
	W1 = getWhite(W1);
	W2 = getWhite(W2);
	if (!W1 || !W2) throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
	if (W1 === W2) return XYZ;
	let env = {
		W1,
		W2,
		XYZ,
		options
	};
	hooks.run("chromatic-adaptation-start", env);
	if (!env.M) {
		if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) env.M = [
			[
				1.0479297925449969,
				.022946870601609652,
				-.05019226628920524
			],
			[
				.02962780877005599,
				.9904344267538799,
				-.017073799063418826
			],
			[
				-.009243040646204504,
				.015055191490298152,
				.7518742814281371
			]
		];
		else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) env.M = [
			[
				.955473421488075,
				-.02309845494876471,
				.06325924320057072
			],
			[
				-.0283697093338637,
				1.0099953980813041,
				.021041441191917323
			],
			[
				.012314014864481998,
				-.020507649298898964,
				1.330365926242124
			]
		];
	}
	hooks.run("chromatic-adaptation-end", env);
	if (env.M) return multiplyMatrices(env.M, env.XYZ);
	else throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
}
var noneTypes = new Set([
	"<number>",
	"<percentage>",
	"<angle>"
]);
function coerceCoords(space, format, name, coords) {
	return Object.entries(space.coords).map(([id, coordMeta], i) => {
		let coordGrammar$1 = format.coordGrammar[i];
		let arg = coords[i];
		let providedType = arg?.type;
		let type$1;
		if (arg.none) type$1 = coordGrammar$1.find((c$1) => noneTypes.has(c$1));
		else type$1 = coordGrammar$1.find((c$1) => c$1 == providedType);
		if (!type$1) {
			let coordName = coordMeta.name || id;
			throw new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);
		}
		let fromRange = type$1.range;
		if (providedType === "<percentage>") fromRange ||= [0, 1];
		let toRange = coordMeta.range || coordMeta.refRange;
		if (fromRange && toRange) coords[i] = mapRange(fromRange, toRange, coords[i]);
		return type$1;
	});
}
function parse(str, { meta } = {}) {
	let env = { "str": String(str)?.trim() };
	hooks.run("parse-start", env);
	if (env.color) return env.color;
	env.parsed = parseFunction(env.str);
	if (env.parsed) {
		let name = env.parsed.name;
		if (name === "color") {
			let id = env.parsed.args.shift();
			let alternateId = id.startsWith("--") ? id.substring(2) : `--${id}`;
			let ids = [id, alternateId];
			let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
			for (let space of ColorSpace.all) {
				let colorSpec = space.getFormat("color");
				if (colorSpec) {
					if (ids.includes(colorSpec.id) || colorSpec.ids?.filter((specId) => ids.includes(specId)).length) {
						const coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);
						let types;
						if (colorSpec.coordGrammar) types = coerceCoords(space, colorSpec, "color", coords);
						if (meta) Object.assign(meta, {
							formatId: "color",
							types
						});
						if (colorSpec.id.startsWith("--") && !id.startsWith("--")) defaults.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. Use prefixed color(${colorSpec.id}) instead of color(${id}).`);
						if (id.startsWith("--") && !colorSpec.id.startsWith("--")) defaults.warn(`${space.name} is a standard space and supported in the CSS spec. Use color(${colorSpec.id}) instead of prefixed color(${id}).`);
						return {
							spaceId: space.id,
							coords,
							alpha
						};
					}
				}
			}
			let didYouMean = "";
			let registryId = id in ColorSpace.registry ? id : alternateId;
			if (registryId in ColorSpace.registry) {
				let cssId = ColorSpace.registry[registryId].formats?.color?.id;
				if (cssId) didYouMean = `Did you mean color(${cssId})?`;
			}
			throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
		} else for (let space of ColorSpace.all) {
			let format = space.getFormat(name);
			if (format && format.type === "function") {
				let alpha = 1;
				if (format.lastAlpha || last(env.parsed.args).alpha) alpha = env.parsed.args.pop();
				let coords = env.parsed.args;
				let types;
				if (format.coordGrammar) types = coerceCoords(space, format, name, coords);
				if (meta) Object.assign(meta, {
					formatId: format.name,
					types
				});
				return {
					spaceId: space.id,
					coords,
					alpha
				};
			}
		}
	} else for (let space of ColorSpace.all) for (let formatId in space.formats) {
		let format = space.formats[formatId];
		if (format.type !== "custom") continue;
		if (format.test && !format.test(env.str)) continue;
		let color = format.parse(env.str);
		if (color) {
			color.alpha ??= 1;
			if (meta) meta.formatId = formatId;
			return color;
		}
	}
	throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
}
function getColor(color) {
	if (Array.isArray(color)) return color.map(getColor);
	if (!color) throw new TypeError("Empty color reference");
	if (isString(color)) color = parse(color);
	let space = color.space || color.spaceId;
	if (!(space instanceof ColorSpace)) color.space = ColorSpace.get(space);
	if (color.alpha === void 0) color.alpha = 1;
	return color;
}
var ε$7 = 75e-6;
var ColorSpace = class ColorSpace {
	constructor(options) {
		this.id = options.id;
		this.name = options.name;
		this.base = options.base ? ColorSpace.get(options.base) : null;
		this.aliases = options.aliases;
		if (this.base) {
			this.fromBase = options.fromBase;
			this.toBase = options.toBase;
		}
		let coords = options.coords ?? this.base.coords;
		for (let name in coords) if (!("name" in coords[name])) coords[name].name = name;
		this.coords = coords;
		this.white = getWhite(options.white ?? this.base.white ?? "D65");
		this.formats = options.formats ?? {};
		for (let name in this.formats) {
			let format = this.formats[name];
			format.type ||= "function";
			format.name ||= name;
		}
		if (!this.formats.color?.id) this.formats.color = {
			...this.formats.color ?? {},
			id: options.cssId || this.id
		};
		if (options.gamutSpace) this.gamutSpace = options.gamutSpace === "self" ? this : ColorSpace.get(options.gamutSpace);
		else if (this.isPolar) this.gamutSpace = this.base;
		else this.gamutSpace = this;
		if (this.gamutSpace.isUnbounded) this.inGamut = (coords$1, options$1) => {
			return true;
		};
		this.referred = options.referred;
		Object.defineProperty(this, "path", {
			value: getPath(this).reverse(),
			writable: false,
			enumerable: true,
			configurable: true
		});
		hooks.run("colorspace-init-end", this);
	}
	inGamut(coords, { epsilon = ε$7 } = {}) {
		if (!this.equals(this.gamutSpace)) {
			coords = this.to(this.gamutSpace, coords);
			return this.gamutSpace.inGamut(coords, { epsilon });
		}
		let coordMeta = Object.values(this.coords);
		return coords.every((c$1, i) => {
			let meta = coordMeta[i];
			if (meta.type !== "angle" && meta.range) {
				if (Number.isNaN(c$1)) return true;
				let [min$1, max$2] = meta.range;
				return (min$1 === void 0 || c$1 >= min$1 - epsilon) && (max$2 === void 0 || c$1 <= max$2 + epsilon);
			}
			return true;
		});
	}
	get isUnbounded() {
		return Object.values(this.coords).every((coord) => !("range" in coord));
	}
	get cssId() {
		return this.formats?.color?.id || this.id;
	}
	get isPolar() {
		for (let id in this.coords) if (this.coords[id].type === "angle") return true;
		return false;
	}
	getFormat(format) {
		if (typeof format === "object") {
			format = processFormat(format, this);
			return format;
		}
		let ret;
		if (format === "default") ret = Object.values(this.formats)[0];
		else ret = this.formats[format];
		if (ret) {
			ret = processFormat(ret, this);
			return ret;
		}
		return null;
	}
	equals(space) {
		if (!space) return false;
		return this === space || this.id === space || this.id === space.id;
	}
	to(space, coords) {
		if (arguments.length === 1) {
			const color = getColor(space);
			[space, coords] = [color.space, color.coords];
		}
		space = ColorSpace.get(space);
		if (this.equals(space)) return coords;
		coords = coords.map((c$1) => Number.isNaN(c$1) ? 0 : c$1);
		let myPath = this.path;
		let otherPath = space.path;
		let connectionSpace, connectionSpaceIndex;
		for (let i = 0; i < myPath.length; i++) if (myPath[i].equals(otherPath[i])) {
			connectionSpace = myPath[i];
			connectionSpaceIndex = i;
		} else break;
		if (!connectionSpace) throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
		for (let i = myPath.length - 1; i > connectionSpaceIndex; i--) coords = myPath[i].toBase(coords);
		for (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) coords = otherPath[i].fromBase(coords);
		return coords;
	}
	from(space, coords) {
		if (arguments.length === 1) {
			const color = getColor(space);
			[space, coords] = [color.space, color.coords];
		}
		space = ColorSpace.get(space);
		return space.to(this, coords);
	}
	toString() {
		return `${this.name} (${this.id})`;
	}
	getMinCoords() {
		let ret = [];
		for (let id in this.coords) {
			let meta = this.coords[id];
			let range$1 = meta.range || meta.refRange;
			ret.push(range$1?.min ?? 0);
		}
		return ret;
	}
	static registry = {};
	static get all() {
		return [...new Set(Object.values(ColorSpace.registry))];
	}
	static register(id, space) {
		if (arguments.length === 1) {
			space = arguments[0];
			id = space.id;
		}
		space = this.get(space);
		if (this.registry[id] && this.registry[id] !== space) throw new Error(`Duplicate color space registration: '${id}'`);
		this.registry[id] = space;
		if (arguments.length === 1 && space.aliases) for (let alias of space.aliases) this.register(alias, space);
		return space;
	}
	static get(space, ...alternatives) {
		if (!space || space instanceof ColorSpace) return space;
		if (type(space) === "string") {
			let ret = ColorSpace.registry[space.toLowerCase()];
			if (!ret) throw new TypeError(`No color space found with id = "${space}"`);
			return ret;
		}
		if (alternatives.length) return ColorSpace.get(...alternatives);
		throw new TypeError(`${space} is not a valid color space`);
	}
	static resolveCoord(ref, workingSpace) {
		let coordType = type(ref);
		let space, coord;
		if (coordType === "string") if (ref.includes(".")) [space, coord] = ref.split(".");
		else [space, coord] = [, ref];
		else if (Array.isArray(ref)) [space, coord] = ref;
		else {
			space = ref.space;
			coord = ref.coordId;
		}
		space = ColorSpace.get(space);
		if (!space) space = workingSpace;
		if (!space) throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);
		coordType = type(coord);
		if (coordType === "number" || coordType === "string" && coord >= 0) {
			let meta = Object.entries(space.coords)[coord];
			if (meta) return {
				space,
				id: meta[0],
				index: coord,
				...meta[1]
			};
		}
		space = ColorSpace.get(space);
		let normalizedCoord = coord.toLowerCase();
		let i = 0;
		for (let id in space.coords) {
			let meta = space.coords[id];
			if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) return {
				space,
				id,
				index: i,
				...meta
			};
			i++;
		}
		throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
	}
	static DEFAULT_FORMAT = {
		type: "functions",
		name: "color"
	};
};
function getPath(space) {
	let ret = [space];
	for (let s = space; s = s.base;) ret.push(s);
	return ret;
}
function processFormat(format, { coords } = {}) {
	if (format.coords && !format.coordGrammar) {
		format.type ||= "function";
		format.name ||= "color";
		format.coordGrammar = parseCoordGrammar(format.coords);
		let coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {
			let outputType = format.coordGrammar[i][0];
			let fromRange = coordMeta.range || coordMeta.refRange;
			let toRange = outputType.range, suffix = "";
			if (outputType == "<percentage>") {
				toRange = [0, 100];
				suffix = "%";
			} else if (outputType == "<angle>") suffix = "deg";
			return {
				fromRange,
				toRange,
				suffix
			};
		});
		format.serializeCoords = (coords$1, precision) => {
			return coords$1.map((c$1, i) => {
				let { fromRange, toRange, suffix } = coordFormats[i];
				if (fromRange && toRange) c$1 = mapRange(fromRange, toRange, c$1);
				c$1 = serializeNumber(c$1, {
					precision,
					unit: suffix
				});
				return c$1;
			});
		};
	}
	return format;
}
var xyz_d65 = new ColorSpace({
	id: "xyz-d65",
	name: "XYZ D65",
	coords: {
		x: { name: "X" },
		y: { name: "Y" },
		z: { name: "Z" }
	},
	white: "D65",
	formats: { color: { ids: ["xyz-d65", "xyz"] } },
	aliases: ["xyz"]
});
var RGBColorSpace = class extends ColorSpace {
	constructor(options) {
		if (!options.coords) options.coords = {
			r: {
				range: [0, 1],
				name: "Red"
			},
			g: {
				range: [0, 1],
				name: "Green"
			},
			b: {
				range: [0, 1],
				name: "Blue"
			}
		};
		if (!options.base) options.base = xyz_d65;
		if (options.toXYZ_M && options.fromXYZ_M) {
			options.toBase ??= (rgb) => {
				let xyz = multiplyMatrices(options.toXYZ_M, rgb);
				if (this.white !== this.base.white) xyz = adapt$2(this.white, this.base.white, xyz);
				return xyz;
			};
			options.fromBase ??= (xyz) => {
				xyz = adapt$2(this.base.white, this.white, xyz);
				return multiplyMatrices(options.fromXYZ_M, xyz);
			};
		}
		options.referred ??= "display";
		super(options);
	}
};
function getAll(color, space) {
	color = getColor(color);
	if (!space || color.space.equals(space)) return color.coords.slice();
	space = ColorSpace.get(space);
	return space.from(color);
}
function get(color, prop) {
	color = getColor(color);
	let { space, index } = ColorSpace.resolveCoord(prop, color.space);
	return getAll(color, space)[index];
}
function setAll(color, space, coords) {
	color = getColor(color);
	space = ColorSpace.get(space);
	color.coords = space.to(color.space, coords);
	return color;
}
setAll.returns = "color";
function set(color, prop, value) {
	color = getColor(color);
	if (arguments.length === 2 && type(arguments[1]) === "object") {
		let object = arguments[1];
		for (let p$1 in object) set(color, p$1, object[p$1]);
	} else {
		if (typeof value === "function") value = value(get(color, prop));
		let { space, index } = ColorSpace.resolveCoord(prop, color.space);
		let coords = getAll(color, space);
		coords[index] = value;
		setAll(color, space, coords);
	}
	return color;
}
set.returns = "color";
var XYZ_D50 = new ColorSpace({
	id: "xyz-d50",
	name: "XYZ D50",
	white: "D50",
	base: xyz_d65,
	fromBase: (coords) => adapt$2(xyz_d65.white, "D50", coords),
	toBase: (coords) => adapt$2("D50", xyz_d65.white, coords)
});
var ε$6 = 216 / 24389;
var ε3$1 = 24 / 116;
var κ$4 = 24389 / 27;
var white$4 = WHITES.D50;
var lab = new ColorSpace({
	id: "lab",
	name: "Lab",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		a: { refRange: [-125, 125] },
		b: { refRange: [-125, 125] }
	},
	white: white$4,
	base: XYZ_D50,
	fromBase(XYZ) {
		let f = XYZ.map((value, i) => value / white$4[i]).map((value) => value > ε$6 ? Math.cbrt(value) : (κ$4 * value + 16) / 116);
		return [
			116 * f[1] - 16,
			500 * (f[0] - f[1]),
			200 * (f[1] - f[2])
		];
	},
	toBase(Lab) {
		let f = [];
		f[1] = (Lab[0] + 16) / 116;
		f[0] = Lab[1] / 500 + f[1];
		f[2] = f[1] - Lab[2] / 200;
		return [
			f[0] > ε3$1 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ$4,
			Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ$4,
			f[2] > ε3$1 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ$4
		].map((value, i) => value * white$4[i]);
	},
	formats: { "lab": { coords: [
		"<number> | <percentage>",
		"<number> | <percentage>[-1,1]",
		"<number> | <percentage>[-1,1]"
	] } }
});
function constrain(angle) {
	return (angle % 360 + 360) % 360;
}
function adjust(arc, angles) {
	if (arc === "raw") return angles;
	let [a1, a2] = angles.map(constrain);
	let angleDiff = a2 - a1;
	if (arc === "increasing") {
		if (angleDiff < 0) a2 += 360;
	} else if (arc === "decreasing") {
		if (angleDiff > 0) a1 += 360;
	} else if (arc === "longer") {
		if (-180 < angleDiff && angleDiff < 180) if (angleDiff > 0) a1 += 360;
		else a2 += 360;
	} else if (arc === "shorter") {
		if (angleDiff > 180) a1 += 360;
		else if (angleDiff < -180) a2 += 360;
	}
	return [a1, a2];
}
var lch = new ColorSpace({
	id: "lch",
	name: "LCH",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		c: {
			refRange: [0, 150],
			name: "Chroma"
		},
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	base: lab,
	fromBase(Lab) {
		let [L, a$1, b$2] = Lab;
		let hue;
		const ε$8 = .02;
		if (Math.abs(a$1) < ε$8 && Math.abs(b$2) < ε$8) hue = NaN;
		else hue = Math.atan2(b$2, a$1) * 180 / Math.PI;
		return [
			L,
			Math.sqrt(a$1 ** 2 + b$2 ** 2),
			constrain(hue)
		];
	},
	toBase(LCH) {
		let [Lightness, Chroma, Hue] = LCH;
		if (Chroma < 0) Chroma = 0;
		if (isNaN(Hue)) Hue = 0;
		return [
			Lightness,
			Chroma * Math.cos(Hue * Math.PI / 180),
			Chroma * Math.sin(Hue * Math.PI / 180)
		];
	},
	formats: { "lch": { coords: [
		"<number> | <percentage>",
		"<number> | <percentage>",
		"<number> | <angle>"
	] } }
});
var Gfactor = 25 ** 7;
var π$1 = Math.PI;
var r2d = 180 / π$1;
var d2r$1 = π$1 / 180;
function pow7(x) {
	const x2 = x * x;
	return x2 * x2 * x2 * x;
}
function deltaE2000(color, sample, { kL = 1, kC = 1, kH = 1 } = {}) {
	[color, sample] = getColor([color, sample]);
	let [L1, a1, b1] = lab.from(color);
	let C1 = lch.from(lab, [
		L1,
		a1,
		b1
	])[1];
	let [L2, a2, b2] = lab.from(sample);
	let C2 = lch.from(lab, [
		L2,
		a2,
		b2
	])[1];
	if (C1 < 0) C1 = 0;
	if (C2 < 0) C2 = 0;
	let C7 = pow7((C1 + C2) / 2);
	let G = .5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
	let adash1 = (1 + G) * a1;
	let adash2 = (1 + G) * a2;
	let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
	let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);
	let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
	let h2 = adash2 === 0 && b2 === 0 ? 0 : Math.atan2(b2, adash2);
	if (h1 < 0) h1 += 2 * π$1;
	if (h2 < 0) h2 += 2 * π$1;
	h1 *= r2d;
	h2 *= r2d;
	let ΔL = L2 - L1;
	let ΔC = Cdash2 - Cdash1;
	let hdiff = h2 - h1;
	let hsum = h1 + h2;
	let habs = Math.abs(hdiff);
	let Δh;
	if (Cdash1 * Cdash2 === 0) Δh = 0;
	else if (habs <= 180) Δh = hdiff;
	else if (hdiff > 180) Δh = hdiff - 360;
	else if (hdiff < -180) Δh = hdiff + 360;
	else defaults.warn("the unthinkable has happened");
	let ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r$1 / 2);
	let Ldash = (L1 + L2) / 2;
	let Cdash = (Cdash1 + Cdash2) / 2;
	let Cdash7 = pow7(Cdash);
	let hdash;
	if (Cdash1 * Cdash2 === 0) hdash = hsum;
	else if (habs <= 180) hdash = hsum / 2;
	else if (hsum < 360) hdash = (hsum + 360) / 2;
	else hdash = (hsum - 360) / 2;
	let lsq = (Ldash - 50) ** 2;
	let SL = 1 + .015 * lsq / Math.sqrt(20 + lsq);
	let SC = 1 + .045 * Cdash;
	let T = 1;
	T -= .17 * Math.cos((hdash - 30) * d2r$1);
	T += .24 * Math.cos(2 * hdash * d2r$1);
	T += .32 * Math.cos((3 * hdash + 6) * d2r$1);
	T -= .2 * Math.cos((4 * hdash - 63) * d2r$1);
	let SH = 1 + .015 * Cdash * T;
	let Δθ = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
	let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
	let RT = -1 * Math.sin(2 * Δθ * d2r$1) * RC;
	let dE = (ΔL / (kL * SL)) ** 2;
	dE += (ΔC / (kC * SC)) ** 2;
	dE += (ΔH / (kH * SH)) ** 2;
	dE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));
	return Math.sqrt(dE);
}
var XYZtoLMS_M$1 = [
	[
		.819022437996703,
		.3619062600528904,
		-.1288737815209879
	],
	[
		.0329836539323885,
		.9292868615863434,
		.0361446663506424
	],
	[
		.0481771893596242,
		.2642395317527308,
		.6335478284694309
	]
];
var LMStoXYZ_M$1 = [
	[
		1.2268798758459243,
		-.5578149944602171,
		.2813910456659647
	],
	[
		-.0405757452148008,
		1.112286803280317,
		-.0717110580655164
	],
	[
		-.0763729366746601,
		-.4214933324022432,
		1.5869240198367816
	]
];
var LMStoLab_M = [
	[
		.210454268309314,
		.7936177747023054,
		-.0040720430116193
	],
	[
		1.9779985324311684,
		-2.42859224204858,
		.450593709617411
	],
	[
		.0259040424655478,
		.7827717124575296,
		-.8086757549230774
	]
];
var LabtoLMS_M = [
	[
		1,
		.3963377773761749,
		.2158037573099136
	],
	[
		1,
		-.1055613458156586,
		-.0638541728258133
	],
	[
		1,
		-.0894841775298119,
		-1.2914855480194092
	]
];
var OKLab = new ColorSpace({
	id: "oklab",
	name: "Oklab",
	coords: {
		l: {
			refRange: [0, 1],
			name: "Lightness"
		},
		a: { refRange: [-.4, .4] },
		b: { refRange: [-.4, .4] }
	},
	white: "D65",
	base: xyz_d65,
	fromBase(XYZ) {
		return multiplyMatrices(LMStoLab_M, multiplyMatrices(XYZtoLMS_M$1, XYZ).map((val) => Math.cbrt(val)));
	},
	toBase(OKLab$1) {
		return multiplyMatrices(LMStoXYZ_M$1, multiplyMatrices(LabtoLMS_M, OKLab$1).map((val) => val ** 3));
	},
	formats: { "oklab": { coords: [
		"<percentage> | <number>",
		"<number> | <percentage>[-1,1]",
		"<number> | <percentage>[-1,1]"
	] } }
});
function deltaEOK(color, sample) {
	[color, sample] = getColor([color, sample]);
	let [L1, a1, b1] = OKLab.from(color);
	let [L2, a2, b2] = OKLab.from(sample);
	let ΔL = L1 - L2;
	let Δa = a1 - a2;
	let Δb = b1 - b2;
	return Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);
}
var ε$5 = 75e-6;
function inGamut(color, space, { epsilon = ε$5 } = {}) {
	color = getColor(color);
	if (!space) space = color.space;
	space = ColorSpace.get(space);
	let coords = color.coords;
	if (space !== color.space) coords = space.from(color);
	return space.inGamut(coords, { epsilon });
}
function clone(color) {
	return {
		space: color.space,
		coords: color.coords.slice(),
		alpha: color.alpha
	};
}
function distance$1(color1, color2, space = "lab") {
	space = ColorSpace.get(space);
	let coords1 = space.from(color1);
	let coords2 = space.from(color2);
	return Math.sqrt(coords1.reduce((acc, c1$3, i) => {
		let c2$3 = coords2[i];
		if (isNaN(c1$3) || isNaN(c2$3)) return acc;
		return acc + (c2$3 - c1$3) ** 2;
	}, 0));
}
function deltaE76(color, sample) {
	return distance$1(color, sample, "lab");
}
var d2r = Math.PI / 180;
function deltaECMC(color, sample, { l = 2, c: c$1 = 1 } = {}) {
	[color, sample] = getColor([color, sample]);
	let [L1, a1, b1] = lab.from(color);
	let [, C1, H1] = lch.from(lab, [
		L1,
		a1,
		b1
	]);
	let [L2, a2, b2] = lab.from(sample);
	let C2 = lch.from(lab, [
		L2,
		a2,
		b2
	])[1];
	if (C1 < 0) C1 = 0;
	if (C2 < 0) C2 = 0;
	let ΔL = L1 - L2;
	let ΔC = C1 - C2;
	let Δa = a1 - a2;
	let Δb = b1 - b2;
	let H2 = Δa ** 2 + Δb ** 2 - ΔC ** 2;
	let SL = .511;
	if (L1 >= 16) SL = .040975 * L1 / (1 + .01765 * L1);
	let SC = .0638 * C1 / (1 + .0131 * C1) + .638;
	let T;
	if (Number.isNaN(H1)) H1 = 0;
	if (H1 >= 164 && H1 <= 345) T = .56 + Math.abs(.2 * Math.cos((H1 + 168) * d2r));
	else T = .36 + Math.abs(.4 * Math.cos((H1 + 35) * d2r));
	let C4 = Math.pow(C1, 4);
	let F = Math.sqrt(C4 / (C4 + 1900));
	let SH = SC * (F * T + 1 - F);
	let dE = (ΔL / (l * SL)) ** 2;
	dE += (ΔC / (c$1 * SC)) ** 2;
	dE += H2 / SH ** 2;
	return Math.sqrt(dE);
}
var Yw$1 = 203;
var XYZ_Abs_D65 = new ColorSpace({
	id: "xyz-abs-d65",
	cssId: "--xyz-abs-d65",
	name: "Absolute XYZ D65",
	coords: {
		x: {
			refRange: [0, 9504.7],
			name: "Xa"
		},
		y: {
			refRange: [0, 1e4],
			name: "Ya"
		},
		z: {
			refRange: [0, 10888.3],
			name: "Za"
		}
	},
	base: xyz_d65,
	fromBase(XYZ) {
		return XYZ.map((v) => Math.max(v * Yw$1, 0));
	},
	toBase(AbsXYZ) {
		return AbsXYZ.map((v) => Math.max(v / Yw$1, 0));
	}
});
var b$1 = 1.15;
var g = .66;
var n$1 = 2610 / 2 ** 14;
var ninv$1 = 2 ** 14 / 2610;
var c1$2 = 3424 / 2 ** 12;
var c2$2 = 2413 / 2 ** 7;
var c3$2 = 2392 / 2 ** 7;
var p = 1.7 * 2523 / 2 ** 5;
var pinv = 2 ** 5 / (1.7 * 2523);
var d = -.56;
var d0 = 16295499532821565e-27;
var XYZtoCone_M = [
	[
		.41478972,
		.579999,
		.014648
	],
	[
		-.20151,
		1.120649,
		.0531008
	],
	[
		-.0166008,
		.2648,
		.6684799
	]
];
var ConetoXYZ_M = [
	[
		1.9242264357876067,
		-1.0047923125953657,
		.037651404030618
	],
	[
		.35031676209499907,
		.7264811939316552,
		-.06538442294808501
	],
	[
		-.09098281098284752,
		-.3127282905230739,
		1.5227665613052603
	]
];
var ConetoIab_M = [
	[
		.5,
		.5,
		0
	],
	[
		3.524,
		-4.066708,
		.542708
	],
	[
		.199076,
		1.096799,
		-1.295875
	]
];
var IabtoCone_M = [
	[
		1,
		.1386050432715393,
		.05804731615611886
	],
	[
		.9999999999999999,
		-.1386050432715393,
		-.05804731615611886
	],
	[
		.9999999999999998,
		-.09601924202631895,
		-.8118918960560388
	]
];
var Jzazbz = new ColorSpace({
	id: "jzazbz",
	name: "Jzazbz",
	coords: {
		jz: {
			refRange: [0, 1],
			name: "Jz"
		},
		az: { refRange: [-.5, .5] },
		bz: { refRange: [-.5, .5] }
	},
	base: XYZ_Abs_D65,
	fromBase(XYZ) {
		let [Xa, Ya, Za] = XYZ;
		let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, multiplyMatrices(XYZtoCone_M, [
			b$1 * Xa - (b$1 - 1) * Za,
			g * Ya - (g - 1) * Xa,
			Za
		]).map(function(val) {
			return ((c1$2 + c2$2 * (val / 1e4) ** n$1) / (1 + c3$2 * (val / 1e4) ** n$1)) ** p;
		}));
		return [
			(1 + d) * Iz / (1 + d * Iz) - d0,
			az,
			bz
		];
	},
	toBase(Jzazbz$1) {
		let [Jz, az, bz] = Jzazbz$1;
		let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, multiplyMatrices(IabtoCone_M, [
			(Jz + d0) / (1 + d - d * (Jz + d0)),
			az,
			bz
		]).map(function(val) {
			return 1e4 * ((c1$2 - val ** pinv) / (c3$2 * val ** pinv - c2$2)) ** ninv$1;
		}));
		let Xa = (Xm + (b$1 - 1) * Za) / b$1;
		return [
			Xa,
			(Ym + (g - 1) * Xa) / g,
			Za
		];
	},
	formats: { "color": { coords: [
		"<number> | <percentage>",
		"<number> | <percentage>[-1,1]",
		"<number> | <percentage>[-1,1]"
	] } }
});
var jzczhz = new ColorSpace({
	id: "jzczhz",
	name: "JzCzHz",
	coords: {
		jz: {
			refRange: [0, 1],
			name: "Jz"
		},
		cz: {
			refRange: [0, 1],
			name: "Chroma"
		},
		hz: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	base: Jzazbz,
	fromBase(jzazbz) {
		let [Jz, az, bz] = jzazbz;
		let hue;
		const ε$8 = 2e-4;
		if (Math.abs(az) < ε$8 && Math.abs(bz) < ε$8) hue = NaN;
		else hue = Math.atan2(bz, az) * 180 / Math.PI;
		return [
			Jz,
			Math.sqrt(az ** 2 + bz ** 2),
			constrain(hue)
		];
	},
	toBase(jzczhz$1) {
		return [
			jzczhz$1[0],
			jzczhz$1[1] * Math.cos(jzczhz$1[2] * Math.PI / 180),
			jzczhz$1[1] * Math.sin(jzczhz$1[2] * Math.PI / 180)
		];
	}
});
function deltaEJz(color, sample) {
	[color, sample] = getColor([color, sample]);
	let [Jz1, Cz1, Hz1] = jzczhz.from(color);
	let [Jz2, Cz2, Hz2] = jzczhz.from(sample);
	let ΔJ = Jz1 - Jz2;
	let ΔC = Cz1 - Cz2;
	if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
		Hz1 = 0;
		Hz2 = 0;
	} else if (Number.isNaN(Hz1)) Hz1 = Hz2;
	else if (Number.isNaN(Hz2)) Hz2 = Hz1;
	let Δh = Hz1 - Hz2;
	let ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(Δh / 2 * (Math.PI / 180));
	return Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);
}
var c1$1 = 3424 / 4096;
var c2$1 = 2413 / 128;
var c3$1 = 2392 / 128;
var m1$1 = 2610 / 16384;
var m2 = 2523 / 32;
var im1 = 16384 / 2610;
var im2 = 32 / 2523;
var XYZtoLMS_M = [
	[
		.3592832590121217,
		.6976051147779502,
		-.035891593232029
	],
	[
		-.1920808463704993,
		1.100476797037432,
		.0753748658519118
	],
	[
		.0070797844607479,
		.0748396662186362,
		.8433265453898765
	]
];
var LMStoIPT_M = [
	[
		2048 / 4096,
		2048 / 4096,
		0
	],
	[
		6610 / 4096,
		-13613 / 4096,
		7003 / 4096
	],
	[
		17933 / 4096,
		-17390 / 4096,
		-543 / 4096
	]
];
var IPTtoLMS_M = [
	[
		.9999999999999998,
		.0086090370379328,
		.111029625003026
	],
	[
		.9999999999999998,
		-.0086090370379328,
		-.1110296250030259
	],
	[
		.9999999999999998,
		.5600313357106791,
		-.3206271749873188
	]
];
var LMStoXYZ_M = [
	[
		2.0701522183894223,
		-1.3263473389671563,
		.2066510476294053
	],
	[
		.3647385209748072,
		.6805660249472273,
		-.0453045459220347
	],
	[
		-.0497472075358123,
		-.0492609666966131,
		1.1880659249923042
	]
];
var ictcp = new ColorSpace({
	id: "ictcp",
	name: "ICTCP",
	coords: {
		i: {
			refRange: [0, 1],
			name: "I"
		},
		ct: {
			refRange: [-.5, .5],
			name: "CT"
		},
		cp: {
			refRange: [-.5, .5],
			name: "CP"
		}
	},
	base: XYZ_Abs_D65,
	fromBase(XYZ) {
		return LMStoICtCp(multiplyMatrices(XYZtoLMS_M, XYZ));
	},
	toBase(ICtCp) {
		return multiplyMatrices(LMStoXYZ_M, ICtCptoLMS(ICtCp));
	}
});
function LMStoICtCp(LMS) {
	return multiplyMatrices(LMStoIPT_M, LMS.map(function(val) {
		return ((c1$1 + c2$1 * (val / 1e4) ** m1$1) / (1 + c3$1 * (val / 1e4) ** m1$1)) ** m2;
	}));
}
function ICtCptoLMS(ICtCp) {
	return multiplyMatrices(IPTtoLMS_M, ICtCp).map(function(val) {
		return 1e4 * (Math.max(val ** im2 - c1$1, 0) / (c2$1 - c3$1 * val ** im2)) ** im1;
	});
}
function deltaEITP(color, sample) {
	[color, sample] = getColor([color, sample]);
	let [I1, T1, P1] = ictcp.from(color);
	let [I2, T2, P2] = ictcp.from(sample);
	return 720 * Math.sqrt((I1 - I2) ** 2 + .25 * (T1 - T2) ** 2 + (P1 - P2) ** 2);
}
var white$3 = WHITES.D65;
var adaptedCoef = .42;
var adaptedCoefInv = 1 / adaptedCoef;
var tau = 2 * Math.PI;
var cat16 = [
	[
		.401288,
		.650173,
		-.051461
	],
	[
		-.250268,
		1.204414,
		.045854
	],
	[
		-.002079,
		.048952,
		.953127
	]
];
var cat16Inv = [
	[
		1.8620678550872327,
		-1.0112546305316843,
		.14918677544445175
	],
	[
		.38752654323613717,
		.6214474419314753,
		-.008973985167612518
	],
	[
		-.015841498849333856,
		-.03412293802851557,
		1.0499644368778496
	]
];
var m1 = [
	[
		460,
		451,
		288
	],
	[
		460,
		-891,
		-261
	],
	[
		460,
		-220,
		-6300
	]
];
var surroundMap = {
	dark: [
		.8,
		.525,
		.8
	],
	dim: [
		.9,
		.59,
		.9
	],
	average: [
		1,
		.69,
		1
	]
};
var hueQuadMap = {
	h: [
		20.14,
		90,
		164.25,
		237.53,
		380.14
	],
	e: [
		.8,
		.7,
		1,
		1.2,
		.8
	],
	H: [
		0,
		100,
		200,
		300,
		400
	]
};
var rad2deg = 180 / Math.PI;
var deg2rad$1 = Math.PI / 180;
function adapt$1(coords, fl) {
	return coords.map((c$1) => {
		const x = spow(fl * Math.abs(c$1) * .01, adaptedCoef);
		return 400 * copySign(x, c$1) / (x + 27.13);
	});
}
function unadapt(adapted, fl) {
	const constant = 100 / fl * 27.13 ** adaptedCoefInv;
	return adapted.map((c$1) => {
		const cabs = Math.abs(c$1);
		return copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c$1);
	});
}
function hueQuadrature(h) {
	let hp = constrain(h);
	if (hp <= hueQuadMap.h[0]) hp += 360;
	const i = bisectLeft(hueQuadMap.h, hp) - 1;
	const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
	const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
	const Hi = hueQuadMap.H[i];
	const t = (hp - hi) / ei;
	return Hi + 100 * t / (t + (hii - hp) / eii);
}
function invHueQuadrature(H) {
	let Hp = (H % 400 + 400) % 400;
	const i = Math.floor(.01 * Hp);
	Hp = Hp % 100;
	const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
	const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
	return constrain((Hp * (eii * hi - ei * hii) - 100 * hi * eii) / (Hp * (eii - ei) - 100 * eii));
}
function environment(refWhite, adaptingLuminance, backgroundLuminance, surround, discounting) {
	const env = {};
	env.discounting = discounting;
	env.refWhite = refWhite;
	env.surround = surround;
	const xyzW = refWhite.map((c$1) => {
		return c$1 * 100;
	});
	env.la = adaptingLuminance;
	env.yb = backgroundLuminance;
	const yw = xyzW[1];
	const rgbW = multiplyMatrices(cat16, xyzW);
	surround = surroundMap[env.surround];
	const f = surround[0];
	env.c = surround[1];
	env.nc = surround[2];
	const k4 = (1 / (5 * env.la + 1)) ** 4;
	env.fl = k4 * env.la + .1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la);
	env.flRoot = env.fl ** .25;
	env.n = env.yb / yw;
	env.z = 1.48 + Math.sqrt(env.n);
	env.nbb = .725 * env.n ** -.2;
	env.ncb = env.nbb;
	const d$1 = discounting ? 1 : Math.max(Math.min(f * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1), 0);
	env.dRgb = rgbW.map((c$1) => {
		return interpolate(1, yw / c$1, d$1);
	});
	env.dRgbInv = env.dRgb.map((c$1) => {
		return 1 / c$1;
	});
	const rgbAW = adapt$1(rgbW.map((c$1, i) => {
		return c$1 * env.dRgb[i];
	}), env.fl);
	env.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + .05 * rgbAW[2]);
	return env;
}
var viewingConditions$1 = environment(white$3, 64 / Math.PI * .2, 20, "average", false);
function fromCam16(cam16$1, env) {
	if (!(cam16$1.J !== void 0 ^ cam16$1.Q !== void 0)) throw new Error("Conversion requires one and only one: 'J' or 'Q'");
	if (!(cam16$1.C !== void 0 ^ cam16$1.M !== void 0 ^ cam16$1.s !== void 0)) throw new Error("Conversion requires one and only one: 'C', 'M' or 's'");
	if (!(cam16$1.h !== void 0 ^ cam16$1.H !== void 0)) throw new Error("Conversion requires one and only one: 'h' or 'H'");
	if (cam16$1.J === 0 || cam16$1.Q === 0) return [
		0,
		0,
		0
	];
	let hRad = 0;
	if (cam16$1.h !== void 0) hRad = constrain(cam16$1.h) * deg2rad$1;
	else hRad = invHueQuadrature(cam16$1.H) * deg2rad$1;
	const cosh = Math.cos(hRad);
	const sinh = Math.sin(hRad);
	let Jroot = 0;
	if (cam16$1.J !== void 0) Jroot = spow(cam16$1.J, 1 / 2) * .1;
	else if (cam16$1.Q !== void 0) Jroot = .25 * env.c * cam16$1.Q / ((env.aW + 4) * env.flRoot);
	let alpha = 0;
	if (cam16$1.C !== void 0) alpha = cam16$1.C / Jroot;
	else if (cam16$1.M !== void 0) alpha = cam16$1.M / env.flRoot / Jroot;
	else if (cam16$1.s !== void 0) alpha = 4e-4 * cam16$1.s ** 2 * (env.aW + 4) / env.c;
	const t = spow(alpha * Math.pow(1.64 - Math.pow(.29, env.n), -.73), 10 / 9);
	const et = .25 * (Math.cos(hRad + 2) + 3.8);
	const A = env.aW * spow(Jroot, 2 / env.c / env.z);
	const p1 = 5e4 / 13 * env.nc * env.ncb * et;
	const p2 = A / env.nbb;
	const r = 23 * (p2 + .305) * zdiv(t, 23 * p1 + t * (11 * cosh + 108 * sinh));
	return multiplyMatrices(cat16Inv, unadapt(multiplyMatrices(m1, [
		p2,
		r * cosh,
		r * sinh
	]).map((c$1) => {
		return c$1 * 1 / 1403;
	}), env.fl).map((c$1, i) => {
		return c$1 * env.dRgbInv[i];
	})).map((c$1) => {
		return c$1 / 100;
	});
}
function toCam16(xyzd65, env) {
	const rgbA = adapt$1(multiplyMatrices(cat16, xyzd65.map((c$1) => {
		return c$1 * 100;
	})).map((c$1, i) => {
		return c$1 * env.dRgb[i];
	}), env.fl);
	const a$1 = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;
	const b$2 = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;
	const hRad = (Math.atan2(b$2, a$1) % tau + tau) % tau;
	const et = .25 * (Math.cos(hRad + 2) + 3.8);
	const alpha = spow(5e4 / 13 * env.nc * env.ncb * zdiv(et * Math.sqrt(a$1 ** 2 + b$2 ** 2), rgbA[0] + rgbA[1] + 1.05 * rgbA[2] + .305), .9) * Math.pow(1.64 - Math.pow(.29, env.n), .73);
	const Jroot = spow(env.nbb * (2 * rgbA[0] + rgbA[1] + .05 * rgbA[2]) / env.aW, .5 * env.c * env.z);
	const J = 100 * spow(Jroot, 2);
	const Q = 4 / env.c * Jroot * (env.aW + 4) * env.flRoot;
	const C = alpha * Jroot;
	const M = C * env.flRoot;
	const h = constrain(hRad * rad2deg);
	const H = hueQuadrature(h);
	return {
		J,
		C,
		h,
		s: 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2),
		Q,
		M,
		H
	};
}
var cam16 = new ColorSpace({
	id: "cam16-jmh",
	cssId: "--cam16-jmh",
	name: "CAM16-JMh",
	coords: {
		j: {
			refRange: [0, 100],
			name: "J"
		},
		m: {
			refRange: [0, 105],
			name: "Colorfulness"
		},
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	base: xyz_d65,
	fromBase(xyz) {
		const cam16$1 = toCam16(xyz, viewingConditions$1);
		return [
			cam16$1.J,
			cam16$1.M,
			cam16$1.h
		];
	},
	toBase(cam16$1) {
		return fromCam16({
			J: cam16$1[0],
			M: cam16$1[1],
			h: cam16$1[2]
		}, viewingConditions$1);
	}
});
var white$2 = WHITES.D65;
var ε$4 = 216 / 24389;
var κ$3 = 24389 / 27;
function toLstar(y) {
	return 116 * (y > ε$4 ? Math.cbrt(y) : (κ$3 * y + 16) / 116) - 16;
}
function fromLstar(lstar) {
	return lstar > 8 ? Math.pow((lstar + 16) / 116, 3) : lstar / κ$3;
}
function fromHct(coords, env) {
	let [h, c$1, t] = coords;
	let xyz = [];
	let j = 0;
	if (t === 0) return [
		0,
		0,
		0
	];
	let y = fromLstar(t);
	if (t > 0) j = .00379058511492914 * t ** 2 + .608983189401032 * t + .9155088574762233;
	else j = 9514440756550361e-21 * t ** 2 + .08693057439788597 * t - 21.928975842194614;
	const threshold = 2e-12;
	const max_attempts = 15;
	let attempt = 0;
	let last$1 = Infinity;
	while (attempt <= max_attempts) {
		xyz = fromCam16({
			J: j,
			C: c$1,
			h
		}, env);
		const delta = Math.abs(xyz[1] - y);
		if (delta < last$1) {
			if (delta <= threshold) return xyz;
			last$1 = delta;
		}
		j = j - (xyz[1] - y) * j / (2 * xyz[1]);
		attempt += 1;
	}
	return fromCam16({
		J: j,
		C: c$1,
		h
	}, env);
}
function toHct(xyz, env) {
	const t = toLstar(xyz[1]);
	if (t === 0) return [
		0,
		0,
		0
	];
	const cam16$1 = toCam16(xyz, viewingConditions);
	return [
		constrain(cam16$1.h),
		cam16$1.C,
		t
	];
}
var viewingConditions = environment(white$2, 200 / Math.PI * fromLstar(50), fromLstar(50) * 100, "average", false);
var hct = new ColorSpace({
	id: "hct",
	name: "HCT",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		c: {
			refRange: [0, 145],
			name: "Colorfulness"
		},
		t: {
			refRange: [0, 100],
			name: "Tone"
		}
	},
	base: xyz_d65,
	fromBase(xyz) {
		return toHct(xyz);
	},
	toBase(hct$1) {
		return fromHct(hct$1, viewingConditions);
	},
	formats: { color: {
		id: "--hct",
		coords: [
			"<number> | <angle>",
			"<percentage> | <number>",
			"<percentage> | <number>"
		]
	} }
});
var deg2rad = Math.PI / 180;
var ucsCoeff = [
	1,
	.007,
	.0228
];
function convertUcsAb(coords) {
	if (coords[1] < 0) coords = hct.fromBase(hct.toBase(coords));
	const M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1)) / ucsCoeff[2];
	const hrad = coords[0] * deg2rad;
	const a$1 = M * Math.cos(hrad);
	const b$2 = M * Math.sin(hrad);
	return [
		coords[2],
		a$1,
		b$2
	];
}
function deltaEHCT(color, sample) {
	[color, sample] = getColor([color, sample]);
	let [t1, a1, b1] = convertUcsAb(hct.from(color));
	let [t2, a2, b2] = convertUcsAb(hct.from(sample));
	return Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);
}
var deltaEMethods = {
	deltaE76,
	deltaECMC,
	deltaE2000,
	deltaEJz,
	deltaEITP,
	deltaEOK,
	deltaEHCT
};
function calcEpsilon(jnd) {
	const order = !jnd ? 0 : Math.floor(Math.log10(Math.abs(jnd)));
	return Math.max(parseFloat(`1e${order - 2}`), 1e-6);
}
var GMAPPRESET = {
	"hct": {
		method: "hct.c",
		jnd: 2,
		deltaEMethod: "hct",
		blackWhiteClamp: {}
	},
	"hct-tonal": {
		method: "hct.c",
		jnd: 0,
		deltaEMethod: "hct",
		blackWhiteClamp: {
			channel: "hct.t",
			min: 0,
			max: 100
		}
	}
};
function toGamut(color, { method = defaults.gamut_mapping, space = void 0, deltaEMethod = "", jnd = 2, blackWhiteClamp = {} } = {}) {
	color = getColor(color);
	if (isString(arguments[1])) space = arguments[1];
	else if (!space) space = color.space;
	space = ColorSpace.get(space);
	if (inGamut(color, space, { epsilon: 0 })) return color;
	let spaceColor;
	if (method === "css") spaceColor = toGamutCSS(color, { space });
	else {
		if (method !== "clip" && !inGamut(color, space)) {
			if (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) ({method, jnd, deltaEMethod, blackWhiteClamp} = GMAPPRESET[method]);
			let de = deltaE2000;
			if (deltaEMethod !== "") {
				for (let m$1 in deltaEMethods) if ("deltae" + deltaEMethod.toLowerCase() === m$1.toLowerCase()) {
					de = deltaEMethods[m$1];
					break;
				}
			}
			let clipped = toGamut(to(color, space), {
				method: "clip",
				space
			});
			if (de(color, clipped) > jnd) {
				if (Object.keys(blackWhiteClamp).length === 3) {
					let channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);
					let channel = get(to(color, channelMeta.space), channelMeta.id);
					if (isNone(channel)) channel = 0;
					if (channel >= blackWhiteClamp.max) return to({
						space: "xyz-d65",
						coords: WHITES["D65"]
					}, color.space);
					else if (channel <= blackWhiteClamp.min) return to({
						space: "xyz-d65",
						coords: [
							0,
							0,
							0
						]
					}, color.space);
				}
				let coordMeta = ColorSpace.resolveCoord(method);
				let mapSpace = coordMeta.space;
				let coordId = coordMeta.id;
				let mappedColor = to(color, mapSpace);
				mappedColor.coords.forEach((c$1, i) => {
					if (isNone(c$1)) mappedColor.coords[i] = 0;
				});
				let min$1 = (coordMeta.range || coordMeta.refRange)[0];
				let ε$8 = calcEpsilon(jnd);
				let low = min$1;
				let high = get(mappedColor, coordId);
				while (high - low > ε$8) {
					let clipped$1 = clone(mappedColor);
					clipped$1 = toGamut(clipped$1, {
						space,
						method: "clip"
					});
					if (de(mappedColor, clipped$1) - jnd < ε$8) low = get(mappedColor, coordId);
					else high = get(mappedColor, coordId);
					set(mappedColor, coordId, (low + high) / 2);
				}
				spaceColor = to(mappedColor, space);
			} else spaceColor = clipped;
		} else spaceColor = to(color, space);
		if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
			let bounds = Object.values(space.coords).map((c$1) => c$1.range || []);
			spaceColor.coords = spaceColor.coords.map((c$1, i) => {
				let [min$1, max$2] = bounds[i];
				if (min$1 !== void 0) c$1 = Math.max(min$1, c$1);
				if (max$2 !== void 0) c$1 = Math.min(c$1, max$2);
				return c$1;
			});
		}
	}
	if (space !== color.space) spaceColor = to(spaceColor, color.space);
	color.coords = spaceColor.coords;
	return color;
}
toGamut.returns = "color";
var COLORS = {
	WHITE: {
		space: OKLab,
		coords: [
			1,
			0,
			0
		]
	},
	BLACK: {
		space: OKLab,
		coords: [
			0,
			0,
			0
		]
	}
};
function toGamutCSS(origin, { space } = {}) {
	const JND = .02;
	const ε$8 = 1e-4;
	origin = getColor(origin);
	if (!space) space = origin.space;
	space = ColorSpace.get(space);
	const oklchSpace = ColorSpace.get("oklch");
	if (space.isUnbounded) return to(origin, space);
	const origin_OKLCH = to(origin, oklchSpace);
	let L = origin_OKLCH.coords[0];
	if (L >= 1) {
		const white$5 = to(COLORS.WHITE, space);
		white$5.alpha = origin.alpha;
		return to(white$5, space);
	}
	if (L <= 0) {
		const black = to(COLORS.BLACK, space);
		black.alpha = origin.alpha;
		return to(black, space);
	}
	if (inGamut(origin_OKLCH, space, { epsilon: 0 })) return to(origin_OKLCH, space);
	function clip(_color) {
		const destColor = to(_color, space);
		const spaceCoords = Object.values(space.coords);
		destColor.coords = destColor.coords.map((coord, index) => {
			if ("range" in spaceCoords[index]) {
				const [min$2, max$3] = spaceCoords[index].range;
				return clamp$1(min$2, coord, max$3);
			}
			return coord;
		});
		return destColor;
	}
	let min$1 = 0;
	let max$2 = origin_OKLCH.coords[1];
	let min_inGamut = true;
	let current = clone(origin_OKLCH);
	let clipped = clip(current);
	let E = deltaEOK(clipped, current);
	if (E < JND) return clipped;
	while (max$2 - min$1 > ε$8) {
		const chroma = (min$1 + max$2) / 2;
		current.coords[1] = chroma;
		if (min_inGamut && inGamut(current, space, { epsilon: 0 })) min$1 = chroma;
		else {
			clipped = clip(current);
			E = deltaEOK(clipped, current);
			if (E < JND) if (JND - E < ε$8) break;
			else {
				min_inGamut = false;
				min$1 = chroma;
			}
			else max$2 = chroma;
		}
	}
	return clipped;
}
function to(color, space, { inGamut: inGamut$1 } = {}) {
	color = getColor(color);
	space = ColorSpace.get(space);
	let coords = space.from(color);
	let ret = {
		space,
		coords,
		alpha: color.alpha
	};
	if (inGamut$1) ret = toGamut(ret, inGamut$1 === true ? void 0 : inGamut$1);
	return ret;
}
to.returns = "color";
function serialize(color, { precision = defaults.precision, format = "default", inGamut: inGamut$1 = true,...customOptions } = {}) {
	let ret;
	color = getColor(color);
	let formatId = format;
	format = color.space.getFormat(format) ?? color.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
	let coords = color.coords.slice();
	inGamut$1 ||= format.toGamut;
	if (inGamut$1 && !inGamut(color)) coords = toGamut(clone(color), inGamut$1 === true ? void 0 : inGamut$1).coords;
	if (format.type === "custom") {
		customOptions.precision = precision;
		if (format.serialize) ret = format.serialize(coords, color.alpha, customOptions);
		else throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
	} else {
		let name = format.name || "color";
		if (format.serializeCoords) coords = format.serializeCoords(coords, precision);
		else if (precision !== null) coords = coords.map((c$1) => {
			return serializeNumber(c$1, { precision });
		});
		let args = [...coords];
		if (name === "color") {
			let cssId = format.id || format.ids?.[0] || color.space.id;
			args.unshift(cssId);
		}
		let alpha = color.alpha;
		if (precision !== null) alpha = serializeNumber(alpha, { precision });
		let strAlpha = color.alpha >= 1 || format.noAlpha ? "" : `${format.commas ? "," : " /"} ${alpha}`;
		ret = `${name}(${args.join(format.commas ? ", " : " ")}${strAlpha})`;
	}
	return ret;
}
var REC2020Linear = new RGBColorSpace({
	id: "rec2020-linear",
	cssId: "--rec2020-linear",
	name: "Linear REC.2020",
	white: "D65",
	toXYZ_M: [
		[
			.6369580483012914,
			.14461690358620832,
			.1688809751641721
		],
		[
			.2627002120112671,
			.6779980715188708,
			.05930171646986196
		],
		[
			0,
			.028072693049087428,
			1.060985057710791
		]
	],
	fromXYZ_M: [
		[
			1.716651187971268,
			-.355670783776392,
			-.25336628137366
		],
		[
			-.666684351832489,
			1.616481236634939,
			.0157685458139111
		],
		[
			.017639857445311,
			-.042770613257809,
			.942103121235474
		]
	]
});
var α = 1.09929682680944;
var β = .018053968510807;
var REC2020 = new RGBColorSpace({
	id: "rec2020",
	name: "REC.2020",
	base: REC2020Linear,
	toBase(RGB) {
		return RGB.map(function(val) {
			if (val < β * 4.5) return val / 4.5;
			return Math.pow((val + α - 1) / α, 1 / .45);
		});
	},
	fromBase(RGB) {
		return RGB.map(function(val) {
			if (val >= β) return α * Math.pow(val, .45) - (α - 1);
			return 4.5 * val;
		});
	}
});
var P3Linear = new RGBColorSpace({
	id: "p3-linear",
	cssId: "--display-p3-linear",
	name: "Linear P3",
	white: "D65",
	toXYZ_M: [
		[
			.4865709486482162,
			.26566769316909306,
			.1982172852343625
		],
		[
			.2289745640697488,
			.6917385218365064,
			.079286914093745
		],
		[
			0,
			.04511338185890264,
			1.043944368900976
		]
	],
	fromXYZ_M: [
		[
			2.493496911941425,
			-.9313836179191239,
			-.40271078445071684
		],
		[
			-.8294889695615747,
			1.7626640603183463,
			.023624685841943577
		],
		[
			.03584583024378447,
			-.07617238926804182,
			.9568845240076872
		]
	]
});
var toXYZ_M$3 = [
	[
		.41239079926595934,
		.357584339383878,
		.1804807884018343
	],
	[
		.21263900587151027,
		.715168678767756,
		.07219231536073371
	],
	[
		.01933081871559182,
		.11919477979462598,
		.9505321522496607
	]
];
var fromXYZ_M$3 = [
	[
		3.2409699419045226,
		-1.537383177570094,
		-.4986107602930034
	],
	[
		-.9692436362808796,
		1.8759675015077202,
		.04155505740717559
	],
	[
		.05563007969699366,
		-.20397695888897652,
		1.0569715142428786
	]
];
var sRGBLinear = new RGBColorSpace({
	id: "srgb-linear",
	name: "Linear sRGB",
	white: "D65",
	toXYZ_M: toXYZ_M$3,
	fromXYZ_M: fromXYZ_M$3
});
var KEYWORDS = {
	"aliceblue": [
		240 / 255,
		248 / 255,
		1
	],
	"antiquewhite": [
		250 / 255,
		235 / 255,
		215 / 255
	],
	"aqua": [
		0,
		1,
		1
	],
	"aquamarine": [
		127 / 255,
		1,
		212 / 255
	],
	"azure": [
		240 / 255,
		1,
		1
	],
	"beige": [
		245 / 255,
		245 / 255,
		220 / 255
	],
	"bisque": [
		1,
		228 / 255,
		196 / 255
	],
	"black": [
		0,
		0,
		0
	],
	"blanchedalmond": [
		1,
		235 / 255,
		205 / 255
	],
	"blue": [
		0,
		0,
		1
	],
	"blueviolet": [
		138 / 255,
		43 / 255,
		226 / 255
	],
	"brown": [
		165 / 255,
		42 / 255,
		42 / 255
	],
	"burlywood": [
		222 / 255,
		184 / 255,
		135 / 255
	],
	"cadetblue": [
		95 / 255,
		158 / 255,
		160 / 255
	],
	"chartreuse": [
		127 / 255,
		1,
		0
	],
	"chocolate": [
		210 / 255,
		105 / 255,
		30 / 255
	],
	"coral": [
		1,
		127 / 255,
		80 / 255
	],
	"cornflowerblue": [
		100 / 255,
		149 / 255,
		237 / 255
	],
	"cornsilk": [
		1,
		248 / 255,
		220 / 255
	],
	"crimson": [
		220 / 255,
		20 / 255,
		60 / 255
	],
	"cyan": [
		0,
		1,
		1
	],
	"darkblue": [
		0,
		0,
		139 / 255
	],
	"darkcyan": [
		0,
		139 / 255,
		139 / 255
	],
	"darkgoldenrod": [
		184 / 255,
		134 / 255,
		11 / 255
	],
	"darkgray": [
		169 / 255,
		169 / 255,
		169 / 255
	],
	"darkgreen": [
		0,
		100 / 255,
		0
	],
	"darkgrey": [
		169 / 255,
		169 / 255,
		169 / 255
	],
	"darkkhaki": [
		189 / 255,
		183 / 255,
		107 / 255
	],
	"darkmagenta": [
		139 / 255,
		0,
		139 / 255
	],
	"darkolivegreen": [
		85 / 255,
		107 / 255,
		47 / 255
	],
	"darkorange": [
		1,
		140 / 255,
		0
	],
	"darkorchid": [
		153 / 255,
		50 / 255,
		204 / 255
	],
	"darkred": [
		139 / 255,
		0,
		0
	],
	"darksalmon": [
		233 / 255,
		150 / 255,
		122 / 255
	],
	"darkseagreen": [
		143 / 255,
		188 / 255,
		143 / 255
	],
	"darkslateblue": [
		72 / 255,
		61 / 255,
		139 / 255
	],
	"darkslategray": [
		47 / 255,
		79 / 255,
		79 / 255
	],
	"darkslategrey": [
		47 / 255,
		79 / 255,
		79 / 255
	],
	"darkturquoise": [
		0,
		206 / 255,
		209 / 255
	],
	"darkviolet": [
		148 / 255,
		0,
		211 / 255
	],
	"deeppink": [
		1,
		20 / 255,
		147 / 255
	],
	"deepskyblue": [
		0,
		191 / 255,
		1
	],
	"dimgray": [
		105 / 255,
		105 / 255,
		105 / 255
	],
	"dimgrey": [
		105 / 255,
		105 / 255,
		105 / 255
	],
	"dodgerblue": [
		30 / 255,
		144 / 255,
		1
	],
	"firebrick": [
		178 / 255,
		34 / 255,
		34 / 255
	],
	"floralwhite": [
		1,
		250 / 255,
		240 / 255
	],
	"forestgreen": [
		34 / 255,
		139 / 255,
		34 / 255
	],
	"fuchsia": [
		1,
		0,
		1
	],
	"gainsboro": [
		220 / 255,
		220 / 255,
		220 / 255
	],
	"ghostwhite": [
		248 / 255,
		248 / 255,
		1
	],
	"gold": [
		1,
		215 / 255,
		0
	],
	"goldenrod": [
		218 / 255,
		165 / 255,
		32 / 255
	],
	"gray": [
		128 / 255,
		128 / 255,
		128 / 255
	],
	"green": [
		0,
		128 / 255,
		0
	],
	"greenyellow": [
		173 / 255,
		1,
		47 / 255
	],
	"grey": [
		128 / 255,
		128 / 255,
		128 / 255
	],
	"honeydew": [
		240 / 255,
		1,
		240 / 255
	],
	"hotpink": [
		1,
		105 / 255,
		180 / 255
	],
	"indianred": [
		205 / 255,
		92 / 255,
		92 / 255
	],
	"indigo": [
		75 / 255,
		0,
		130 / 255
	],
	"ivory": [
		1,
		1,
		240 / 255
	],
	"khaki": [
		240 / 255,
		230 / 255,
		140 / 255
	],
	"lavender": [
		230 / 255,
		230 / 255,
		250 / 255
	],
	"lavenderblush": [
		1,
		240 / 255,
		245 / 255
	],
	"lawngreen": [
		124 / 255,
		252 / 255,
		0
	],
	"lemonchiffon": [
		1,
		250 / 255,
		205 / 255
	],
	"lightblue": [
		173 / 255,
		216 / 255,
		230 / 255
	],
	"lightcoral": [
		240 / 255,
		128 / 255,
		128 / 255
	],
	"lightcyan": [
		224 / 255,
		1,
		1
	],
	"lightgoldenrodyellow": [
		250 / 255,
		250 / 255,
		210 / 255
	],
	"lightgray": [
		211 / 255,
		211 / 255,
		211 / 255
	],
	"lightgreen": [
		144 / 255,
		238 / 255,
		144 / 255
	],
	"lightgrey": [
		211 / 255,
		211 / 255,
		211 / 255
	],
	"lightpink": [
		1,
		182 / 255,
		193 / 255
	],
	"lightsalmon": [
		1,
		160 / 255,
		122 / 255
	],
	"lightseagreen": [
		32 / 255,
		178 / 255,
		170 / 255
	],
	"lightskyblue": [
		135 / 255,
		206 / 255,
		250 / 255
	],
	"lightslategray": [
		119 / 255,
		136 / 255,
		153 / 255
	],
	"lightslategrey": [
		119 / 255,
		136 / 255,
		153 / 255
	],
	"lightsteelblue": [
		176 / 255,
		196 / 255,
		222 / 255
	],
	"lightyellow": [
		1,
		1,
		224 / 255
	],
	"lime": [
		0,
		1,
		0
	],
	"limegreen": [
		50 / 255,
		205 / 255,
		50 / 255
	],
	"linen": [
		250 / 255,
		240 / 255,
		230 / 255
	],
	"magenta": [
		1,
		0,
		1
	],
	"maroon": [
		128 / 255,
		0,
		0
	],
	"mediumaquamarine": [
		102 / 255,
		205 / 255,
		170 / 255
	],
	"mediumblue": [
		0,
		0,
		205 / 255
	],
	"mediumorchid": [
		186 / 255,
		85 / 255,
		211 / 255
	],
	"mediumpurple": [
		147 / 255,
		112 / 255,
		219 / 255
	],
	"mediumseagreen": [
		60 / 255,
		179 / 255,
		113 / 255
	],
	"mediumslateblue": [
		123 / 255,
		104 / 255,
		238 / 255
	],
	"mediumspringgreen": [
		0,
		250 / 255,
		154 / 255
	],
	"mediumturquoise": [
		72 / 255,
		209 / 255,
		204 / 255
	],
	"mediumvioletred": [
		199 / 255,
		21 / 255,
		133 / 255
	],
	"midnightblue": [
		25 / 255,
		25 / 255,
		112 / 255
	],
	"mintcream": [
		245 / 255,
		1,
		250 / 255
	],
	"mistyrose": [
		1,
		228 / 255,
		225 / 255
	],
	"moccasin": [
		1,
		228 / 255,
		181 / 255
	],
	"navajowhite": [
		1,
		222 / 255,
		173 / 255
	],
	"navy": [
		0,
		0,
		128 / 255
	],
	"oldlace": [
		253 / 255,
		245 / 255,
		230 / 255
	],
	"olive": [
		128 / 255,
		128 / 255,
		0
	],
	"olivedrab": [
		107 / 255,
		142 / 255,
		35 / 255
	],
	"orange": [
		1,
		165 / 255,
		0
	],
	"orangered": [
		1,
		69 / 255,
		0
	],
	"orchid": [
		218 / 255,
		112 / 255,
		214 / 255
	],
	"palegoldenrod": [
		238 / 255,
		232 / 255,
		170 / 255
	],
	"palegreen": [
		152 / 255,
		251 / 255,
		152 / 255
	],
	"paleturquoise": [
		175 / 255,
		238 / 255,
		238 / 255
	],
	"palevioletred": [
		219 / 255,
		112 / 255,
		147 / 255
	],
	"papayawhip": [
		1,
		239 / 255,
		213 / 255
	],
	"peachpuff": [
		1,
		218 / 255,
		185 / 255
	],
	"peru": [
		205 / 255,
		133 / 255,
		63 / 255
	],
	"pink": [
		1,
		192 / 255,
		203 / 255
	],
	"plum": [
		221 / 255,
		160 / 255,
		221 / 255
	],
	"powderblue": [
		176 / 255,
		224 / 255,
		230 / 255
	],
	"purple": [
		128 / 255,
		0,
		128 / 255
	],
	"rebeccapurple": [
		102 / 255,
		51 / 255,
		153 / 255
	],
	"red": [
		1,
		0,
		0
	],
	"rosybrown": [
		188 / 255,
		143 / 255,
		143 / 255
	],
	"royalblue": [
		65 / 255,
		105 / 255,
		225 / 255
	],
	"saddlebrown": [
		139 / 255,
		69 / 255,
		19 / 255
	],
	"salmon": [
		250 / 255,
		128 / 255,
		114 / 255
	],
	"sandybrown": [
		244 / 255,
		164 / 255,
		96 / 255
	],
	"seagreen": [
		46 / 255,
		139 / 255,
		87 / 255
	],
	"seashell": [
		1,
		245 / 255,
		238 / 255
	],
	"sienna": [
		160 / 255,
		82 / 255,
		45 / 255
	],
	"silver": [
		192 / 255,
		192 / 255,
		192 / 255
	],
	"skyblue": [
		135 / 255,
		206 / 255,
		235 / 255
	],
	"slateblue": [
		106 / 255,
		90 / 255,
		205 / 255
	],
	"slategray": [
		112 / 255,
		128 / 255,
		144 / 255
	],
	"slategrey": [
		112 / 255,
		128 / 255,
		144 / 255
	],
	"snow": [
		1,
		250 / 255,
		250 / 255
	],
	"springgreen": [
		0,
		1,
		127 / 255
	],
	"steelblue": [
		70 / 255,
		130 / 255,
		180 / 255
	],
	"tan": [
		210 / 255,
		180 / 255,
		140 / 255
	],
	"teal": [
		0,
		128 / 255,
		128 / 255
	],
	"thistle": [
		216 / 255,
		191 / 255,
		216 / 255
	],
	"tomato": [
		1,
		99 / 255,
		71 / 255
	],
	"turquoise": [
		64 / 255,
		224 / 255,
		208 / 255
	],
	"violet": [
		238 / 255,
		130 / 255,
		238 / 255
	],
	"wheat": [
		245 / 255,
		222 / 255,
		179 / 255
	],
	"white": [
		1,
		1,
		1
	],
	"whitesmoke": [
		245 / 255,
		245 / 255,
		245 / 255
	],
	"yellow": [
		1,
		1,
		0
	],
	"yellowgreen": [
		154 / 255,
		205 / 255,
		50 / 255
	]
};
var coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
var coordGrammarNumber = Array(3).fill("<number>[0, 255]");
var sRGB = new RGBColorSpace({
	id: "srgb",
	name: "sRGB",
	base: sRGBLinear,
	fromBase: (rgb) => {
		return rgb.map((val) => {
			let sign = val < 0 ? -1 : 1;
			let abs$1 = val * sign;
			if (abs$1 > .0031308) return sign * (1.055 * abs$1 ** (1 / 2.4) - .055);
			return 12.92 * val;
		});
	},
	toBase: (rgb) => {
		return rgb.map((val) => {
			let sign = val < 0 ? -1 : 1;
			let abs$1 = val * sign;
			if (abs$1 <= .04045) return val / 12.92;
			return sign * ((abs$1 + .055) / 1.055) ** 2.4;
		});
	},
	formats: {
		"rgb": { coords: coordGrammar },
		"rgb_number": {
			name: "rgb",
			commas: true,
			coords: coordGrammarNumber,
			noAlpha: true
		},
		"color": {},
		"rgba": {
			coords: coordGrammar,
			commas: true,
			lastAlpha: true
		},
		"rgba_number": {
			name: "rgba",
			commas: true,
			coords: coordGrammarNumber
		},
		"hex": {
			type: "custom",
			toGamut: true,
			test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
			parse(str) {
				if (str.length <= 5) str = str.replace(/[a-f0-9]/gi, "$&$&");
				let rgba = [];
				str.replace(/[a-f0-9]{2}/gi, (component) => {
					rgba.push(parseInt(component, 16) / 255);
				});
				return {
					spaceId: "srgb",
					coords: rgba.slice(0, 3),
					alpha: rgba.slice(3)[0]
				};
			},
			serialize: (coords, alpha, { collapse = true } = {}) => {
				if (alpha < 1) coords.push(alpha);
				coords = coords.map((c$1) => Math.round(c$1 * 255));
				let collapsible = collapse && coords.every((c$1) => c$1 % 17 === 0);
				return "#" + coords.map((c$1) => {
					if (collapsible) return (c$1 / 17).toString(16);
					return c$1.toString(16).padStart(2, "0");
				}).join("");
			}
		},
		"keyword": {
			type: "custom",
			test: (str) => /^[a-z]+$/i.test(str),
			parse(str) {
				str = str.toLowerCase();
				let ret = {
					spaceId: "srgb",
					coords: null,
					alpha: 1
				};
				if (str === "transparent") {
					ret.coords = KEYWORDS.black;
					ret.alpha = 0;
				} else ret.coords = KEYWORDS[str];
				if (ret.coords) return ret;
			}
		}
	}
});
var P3 = new RGBColorSpace({
	id: "p3",
	cssId: "display-p3",
	name: "P3",
	base: P3Linear,
	fromBase: sRGB.fromBase,
	toBase: sRGB.toBase
});
defaults.display_space = sRGB;
var supportsNone;
if (typeof CSS !== "undefined" && CSS.supports) for (let space of [
	lab,
	REC2020,
	P3
]) {
	let str = serialize({
		space,
		coords: space.getMinCoords(),
		alpha: 1
	});
	if (CSS.supports("color", str)) {
		defaults.display_space = space;
		break;
	}
}
function display(color, { space = defaults.display_space,...options } = {}) {
	let ret = serialize(color, options);
	if (typeof CSS === "undefined" || CSS.supports("color", ret) || !defaults.display_space) {
		ret = new String(ret);
		ret.color = color;
	} else {
		let fallbackColor = color;
		if (color.coords.some(isNone) || isNone(color.alpha)) {
			if (!(supportsNone ??= CSS.supports("color", "hsl(none 50% 50%)"))) {
				fallbackColor = clone(color);
				fallbackColor.coords = fallbackColor.coords.map(skipNone);
				fallbackColor.alpha = skipNone(fallbackColor.alpha);
				ret = serialize(fallbackColor, options);
				if (CSS.supports("color", ret)) {
					ret = new String(ret);
					ret.color = fallbackColor;
					return ret;
				}
			}
		}
		fallbackColor = to(fallbackColor, space);
		ret = new String(serialize(fallbackColor, options));
		ret.color = fallbackColor;
	}
	return ret;
}
function equals(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	return color1.space === color2.space && color1.alpha === color2.alpha && color1.coords.every((c$1, i) => c$1 === color2.coords[i]);
}
function getLuminance(color) {
	return get(color, [xyz_d65, "y"]);
}
function setLuminance(color, value) {
	set(color, [xyz_d65, "y"], value);
}
function register$2(Color$1) {
	Object.defineProperty(Color$1.prototype, "luminance", {
		get() {
			return getLuminance(this);
		},
		set(value) {
			setLuminance(this, value);
		}
	});
}
var luminance = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	getLuminance,
	register: register$2,
	setLuminance
});
function contrastWCAG21(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	let Y1 = Math.max(getLuminance(color1), 0);
	let Y2 = Math.max(getLuminance(color2), 0);
	if (Y2 > Y1) [Y1, Y2] = [Y2, Y1];
	return (Y1 + .05) / (Y2 + .05);
}
var normBG = .56;
var normTXT = .57;
var revTXT = .62;
var revBG = .65;
var blkThrs = .022;
var blkClmp = 1.414;
var loClip = .1;
var deltaYmin = 5e-4;
var scaleBoW = 1.14;
var loBoWoffset = .027;
var scaleWoB = 1.14;
function fclamp(Y) {
	if (Y >= blkThrs) return Y;
	return Y + (blkThrs - Y) ** blkClmp;
}
function linearize(val) {
	let sign = val < 0 ? -1 : 1;
	let abs$1 = Math.abs(val);
	return sign * Math.pow(abs$1, 2.4);
}
function contrastAPCA(background, foreground) {
	foreground = getColor(foreground);
	background = getColor(background);
	let S;
	let C;
	let Sapc;
	let R, G, B;
	foreground = to(foreground, "srgb");
	[R, G, B] = foreground.coords;
	let lumTxt = linearize(R) * .2126729 + linearize(G) * .7151522 + linearize(B) * .072175;
	background = to(background, "srgb");
	[R, G, B] = background.coords;
	let lumBg = linearize(R) * .2126729 + linearize(G) * .7151522 + linearize(B) * .072175;
	let Ytxt = fclamp(lumTxt);
	let Ybg = fclamp(lumBg);
	let BoW = Ybg > Ytxt;
	if (Math.abs(Ybg - Ytxt) < deltaYmin) C = 0;
	else if (BoW) {
		S = Ybg ** normBG - Ytxt ** normTXT;
		C = S * scaleBoW;
	} else {
		S = Ybg ** revBG - Ytxt ** revTXT;
		C = S * scaleWoB;
	}
	if (Math.abs(C) < loClip) Sapc = 0;
	else if (C > 0) Sapc = C - loBoWoffset;
	else Sapc = C + loBoWoffset;
	return Sapc * 100;
}
function contrastMichelson(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	let Y1 = Math.max(getLuminance(color1), 0);
	let Y2 = Math.max(getLuminance(color2), 0);
	if (Y2 > Y1) [Y1, Y2] = [Y2, Y1];
	let denom = Y1 + Y2;
	return denom === 0 ? 0 : (Y1 - Y2) / denom;
}
var max$1 = 5e4;
function contrastWeber(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	let Y1 = Math.max(getLuminance(color1), 0);
	let Y2 = Math.max(getLuminance(color2), 0);
	if (Y2 > Y1) [Y1, Y2] = [Y2, Y1];
	return Y2 === 0 ? max$1 : (Y1 - Y2) / Y2;
}
function contrastLstar(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	let L1 = get(color1, [lab, "l"]);
	let L2 = get(color2, [lab, "l"]);
	return Math.abs(L1 - L2);
}
var ε$3 = 216 / 24389;
var ε3 = 24 / 116;
var κ$2 = 24389 / 27;
var white$1 = WHITES.D65;
var lab_d65 = new ColorSpace({
	id: "lab-d65",
	name: "Lab D65",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		a: { refRange: [-125, 125] },
		b: { refRange: [-125, 125] }
	},
	white: white$1,
	base: xyz_d65,
	fromBase(XYZ) {
		let f = XYZ.map((value, i) => value / white$1[i]).map((value) => value > ε$3 ? Math.cbrt(value) : (κ$2 * value + 16) / 116);
		return [
			116 * f[1] - 16,
			500 * (f[0] - f[1]),
			200 * (f[1] - f[2])
		];
	},
	toBase(Lab) {
		let f = [];
		f[1] = (Lab[0] + 16) / 116;
		f[0] = Lab[1] / 500 + f[1];
		f[2] = f[1] - Lab[2] / 200;
		return [
			f[0] > ε3 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ$2,
			Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ$2,
			f[2] > ε3 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ$2
		].map((value, i) => value * white$1[i]);
	},
	formats: { "lab-d65": { coords: [
		"<number> | <percentage>",
		"<number> | <percentage>[-1,1]",
		"<number> | <percentage>[-1,1]"
	] } }
});
var phi = Math.pow(5, .5) * .5 + .5;
function contrastDeltaPhi(color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);
	let Lstr1 = get(color1, [lab_d65, "l"]);
	let Lstr2 = get(color2, [lab_d65, "l"]);
	let deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));
	let contrast$1 = Math.pow(deltaPhiStar, 1 / phi) * Math.SQRT2 - 40;
	return contrast$1 < 7.5 ? 0 : contrast$1;
}
var contrastMethods = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	contrastAPCA,
	contrastDeltaPhi,
	contrastLstar,
	contrastMichelson,
	contrastWCAG21,
	contrastWeber
});
function contrast(background, foreground, o = {}) {
	if (isString(o)) o = { algorithm: o };
	let { algorithm,...rest } = o;
	if (!algorithm) {
		let algorithms = Object.keys(contrastMethods).map((a$1) => a$1.replace(/^contrast/, "")).join(", ");
		throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);
	}
	background = getColor(background);
	foreground = getColor(foreground);
	for (let a$1 in contrastMethods) if ("contrast" + algorithm.toLowerCase() === a$1.toLowerCase()) return contrastMethods[a$1](background, foreground, rest);
	throw new TypeError(`Unknown contrast algorithm: ${algorithm}`);
}
function uv$1(color) {
	let [X, Y, Z] = getAll(color, xyz_d65);
	let denom = X + 15 * Y + 3 * Z;
	return [4 * X / denom, 9 * Y / denom];
}
function xy(color) {
	let [X, Y, Z] = getAll(color, xyz_d65);
	let sum = X + Y + Z;
	return [X / sum, Y / sum];
}
function register$1(Color$1) {
	Object.defineProperty(Color$1.prototype, "uv", { get() {
		return uv$1(this);
	} });
	Object.defineProperty(Color$1.prototype, "xy", { get() {
		return xy(this);
	} });
}
var chromaticity = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	register: register$1,
	uv: uv$1,
	xy
});
function deltaE(c1$3, c2$3, o = {}) {
	if (isString(o)) o = { method: o };
	let { method = defaults.deltaE,...rest } = o;
	for (let m$1 in deltaEMethods) if ("deltae" + method.toLowerCase() === m$1.toLowerCase()) return deltaEMethods[m$1](c1$3, c2$3, rest);
	throw new TypeError(`Unknown deltaE method: ${method}`);
}
function lighten(color, amount = .25) {
	return set(color, [ColorSpace.get("oklch", "lch"), "l"], (l) => l * (1 + amount));
}
function darken(color, amount = .25) {
	return set(color, [ColorSpace.get("oklch", "lch"), "l"], (l) => l * (1 - amount));
}
var variations = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	darken,
	lighten
});
function mix$1(c1$3, c2$3, p$1 = .5, o = {}) {
	[c1$3, c2$3] = [getColor(c1$3), getColor(c2$3)];
	if (type(p$1) === "object") [p$1, o] = [.5, p$1];
	return range(c1$3, c2$3, o)(p$1);
}
function steps(c1$3, c2$3, options = {}) {
	let colorRange;
	if (isRange(c1$3)) {
		[colorRange, options] = [c1$3, c2$3];
		[c1$3, c2$3] = colorRange.rangeArgs.colors;
	}
	let { maxDeltaE, deltaEMethod, steps: steps$1 = 2, maxSteps = 1e3,...rangeOptions } = options;
	if (!colorRange) {
		[c1$3, c2$3] = [getColor(c1$3), getColor(c2$3)];
		colorRange = range(c1$3, c2$3, rangeOptions);
	}
	let totalDelta = deltaE(c1$3, c2$3);
	let actualSteps = maxDeltaE > 0 ? Math.max(steps$1, Math.ceil(totalDelta / maxDeltaE) + 1) : steps$1;
	let ret = [];
	if (maxSteps !== void 0) actualSteps = Math.min(actualSteps, maxSteps);
	if (actualSteps === 1) ret = [{
		p: .5,
		color: colorRange(.5)
	}];
	else {
		let step$1 = 1 / (actualSteps - 1);
		ret = Array.from({ length: actualSteps }, (_, i) => {
			let p$1 = i * step$1;
			return {
				p: p$1,
				color: colorRange(p$1)
			};
		});
	}
	if (maxDeltaE > 0) {
		let maxDelta = ret.reduce((acc, cur, i) => {
			if (i === 0) return 0;
			let ΔΕ = deltaE(cur.color, ret[i - 1].color, deltaEMethod);
			return Math.max(acc, ΔΕ);
		}, 0);
		while (maxDelta > maxDeltaE) {
			maxDelta = 0;
			for (let i = 1; i < ret.length && ret.length < maxSteps; i++) {
				let prev = ret[i - 1];
				let cur = ret[i];
				let p$1 = (cur.p + prev.p) / 2;
				let color = colorRange(p$1);
				maxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));
				ret.splice(i, 0, {
					p: p$1,
					color: colorRange(p$1)
				});
				i++;
			}
		}
	}
	ret = ret.map((a$1) => a$1.color);
	return ret;
}
function range(color1, color2, options = {}) {
	if (isRange(color1)) {
		let [r, options$1] = [color1, color2];
		return range(...r.rangeArgs.colors, {
			...r.rangeArgs.options,
			...options$1
		});
	}
	let { space, outputSpace, progression, premultiplied } = options;
	color1 = getColor(color1);
	color2 = getColor(color2);
	color1 = clone(color1);
	color2 = clone(color2);
	let rangeArgs = {
		colors: [color1, color2],
		options
	};
	if (space) space = ColorSpace.get(space);
	else space = ColorSpace.registry[defaults.interpolationSpace] || color1.space;
	outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
	color1 = to(color1, space);
	color2 = to(color2, space);
	color1 = toGamut(color1);
	color2 = toGamut(color2);
	if (space.coords.h && space.coords.h.type === "angle") {
		let arc = options.hue = options.hue || "shorter";
		let hue = [space, "h"];
		let [θ1, θ2] = [get(color1, hue), get(color2, hue)];
		if (isNaN(θ1) && !isNaN(θ2)) θ1 = θ2;
		else if (isNaN(θ2) && !isNaN(θ1)) θ2 = θ1;
		[θ1, θ2] = adjust(arc, [θ1, θ2]);
		set(color1, hue, θ1);
		set(color2, hue, θ2);
	}
	if (premultiplied) {
		color1.coords = color1.coords.map((c$1) => c$1 * color1.alpha);
		color2.coords = color2.coords.map((c$1) => c$1 * color2.alpha);
	}
	return Object.assign((p$1) => {
		p$1 = progression ? progression(p$1) : p$1;
		let coords = color1.coords.map((start, i) => {
			let end = color2.coords[i];
			return interpolate(start, end, p$1);
		});
		let alpha = interpolate(color1.alpha, color2.alpha, p$1);
		let ret = {
			space,
			coords,
			alpha
		};
		if (premultiplied) ret.coords = ret.coords.map((c$1) => c$1 / alpha);
		if (outputSpace !== space) ret = to(ret, outputSpace);
		return ret;
	}, { rangeArgs });
}
function isRange(val) {
	return type(val) === "function" && !!val.rangeArgs;
}
defaults.interpolationSpace = "lab";
function register(Color$1) {
	Color$1.defineFunction("mix", mix$1, { returns: "color" });
	Color$1.defineFunction("range", range, { returns: "function<color>" });
	Color$1.defineFunction("steps", steps, { returns: "array<color>" });
}
var interpolation = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	isRange,
	mix: mix$1,
	range,
	register,
	steps
});
var HSL = new ColorSpace({
	id: "hsl",
	name: "HSL",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		s: {
			range: [0, 100],
			name: "Saturation"
		},
		l: {
			range: [0, 100],
			name: "Lightness"
		}
	},
	base: sRGB,
	fromBase: (rgb) => {
		let max$2 = Math.max(...rgb);
		let min$1 = Math.min(...rgb);
		let [r, g$1, b$2] = rgb;
		let [h, s, l] = [
			NaN,
			0,
			(min$1 + max$2) / 2
		];
		let d$1 = max$2 - min$1;
		if (d$1 !== 0) {
			s = l === 0 || l === 1 ? 0 : (max$2 - l) / Math.min(l, 1 - l);
			switch (max$2) {
				case r:
					h = (g$1 - b$2) / d$1 + (g$1 < b$2 ? 6 : 0);
					break;
				case g$1:
					h = (b$2 - r) / d$1 + 2;
					break;
				case b$2: h = (r - g$1) / d$1 + 4;
			}
			h = h * 60;
		}
		if (s < 0) {
			h += 180;
			s = Math.abs(s);
		}
		if (h >= 360) h -= 360;
		return [
			h,
			s * 100,
			l * 100
		];
	},
	toBase: (hsl) => {
		let [h, s, l] = hsl;
		h = h % 360;
		if (h < 0) h += 360;
		s /= 100;
		l /= 100;
		function f(n$2) {
			let k = (n$2 + h / 30) % 12;
			let a$1 = s * Math.min(l, 1 - l);
			return l - a$1 * Math.max(-1, Math.min(k - 3, 9 - k, 1));
		}
		return [
			f(0),
			f(8),
			f(4)
		];
	},
	formats: {
		"hsl": { coords: [
			"<number> | <angle>",
			"<percentage>",
			"<percentage>"
		] },
		"hsla": {
			coords: [
				"<number> | <angle>",
				"<percentage>",
				"<percentage>"
			],
			commas: true,
			lastAlpha: true
		}
	}
});
var HSV = new ColorSpace({
	id: "hsv",
	name: "HSV",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		s: {
			range: [0, 100],
			name: "Saturation"
		},
		v: {
			range: [0, 100],
			name: "Value"
		}
	},
	base: HSL,
	fromBase(hsl) {
		let [h, s, l] = hsl;
		s /= 100;
		l /= 100;
		let v = l + s * Math.min(l, 1 - l);
		return [
			h,
			v === 0 ? 0 : 200 * (1 - l / v),
			100 * v
		];
	},
	toBase(hsv) {
		let [h, s, v] = hsv;
		s /= 100;
		v /= 100;
		let l = v * (1 - s / 2);
		return [
			h,
			l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l) * 100,
			l * 100
		];
	},
	formats: { color: {
		id: "--hsv",
		coords: [
			"<number> | <angle>",
			"<percentage> | <number>",
			"<percentage> | <number>"
		]
	} }
});
var hwb = new ColorSpace({
	id: "hwb",
	name: "HWB",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		w: {
			range: [0, 100],
			name: "Whiteness"
		},
		b: {
			range: [0, 100],
			name: "Blackness"
		}
	},
	base: HSV,
	fromBase(hsv) {
		let [h, s, v] = hsv;
		return [
			h,
			v * (100 - s) / 100,
			100 - v
		];
	},
	toBase(hwb$1) {
		let [h, w, b$2] = hwb$1;
		w /= 100;
		b$2 /= 100;
		let sum = w + b$2;
		if (sum >= 1) return [
			h,
			0,
			w / sum * 100
		];
		let v = 1 - b$2;
		return [
			h,
			(v === 0 ? 0 : 1 - w / v) * 100,
			v * 100
		];
	},
	formats: { "hwb": { coords: [
		"<number> | <angle>",
		"<percentage> | <number>",
		"<percentage> | <number>"
	] } }
});
var A98Linear = new RGBColorSpace({
	id: "a98rgb-linear",
	cssId: "--a98-rgb-linear",
	name: "Linear Adobe® 98 RGB compatible",
	white: "D65",
	toXYZ_M: [
		[
			.5766690429101305,
			.1855582379065463,
			.1882286462349947
		],
		[
			.29734497525053605,
			.6273635662554661,
			.07529145849399788
		],
		[
			.02703136138641234,
			.07068885253582723,
			.9913375368376388
		]
	],
	fromXYZ_M: [
		[
			2.0415879038107465,
			-.5650069742788596,
			-.34473135077832956
		],
		[
			-.9692436362808795,
			1.8759675015077202,
			.04155505740717557
		],
		[
			.013444280632031142,
			-.11836239223101838,
			1.0151749943912054
		]
	]
});
var a98rgb = new RGBColorSpace({
	id: "a98rgb",
	cssId: "a98-rgb",
	name: "Adobe® 98 RGB compatible",
	base: A98Linear,
	toBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),
	fromBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val))
});
var ProPhotoLinear = new RGBColorSpace({
	id: "prophoto-linear",
	cssId: "--prophoto-rgb-linear",
	name: "Linear ProPhoto",
	white: "D50",
	base: XYZ_D50,
	toXYZ_M: [
		[
			.7977666449006423,
			.13518129740053308,
			.0313477341283922
		],
		[
			.2880748288194013,
			.711835234241873,
			8993693872564e-17
		],
		[
			0,
			0,
			.8251046025104602
		]
	],
	fromXYZ_M: [
		[
			1.3457868816471583,
			-.25557208737979464,
			-.05110186497554526
		],
		[
			-.5446307051249019,
			1.5082477428451468,
			.02052744743642139
		],
		[
			0,
			0,
			1.2119675456389452
		]
	]
});
var Et = 1 / 512;
var Et2 = 16 / 512;
var prophoto = new RGBColorSpace({
	id: "prophoto",
	cssId: "prophoto-rgb",
	name: "ProPhoto",
	base: ProPhotoLinear,
	toBase(RGB) {
		return RGB.map((v) => v < Et2 ? v / 16 : v ** 1.8);
	},
	fromBase(RGB) {
		return RGB.map((v) => v >= Et ? v ** (1 / 1.8) : 16 * v);
	}
});
var oklch = new ColorSpace({
	id: "oklch",
	name: "Oklch",
	coords: {
		l: {
			refRange: [0, 1],
			name: "Lightness"
		},
		c: {
			refRange: [0, .4],
			name: "Chroma"
		},
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	white: "D65",
	base: OKLab,
	fromBase(oklab) {
		let [L, a$1, b$2] = oklab;
		let h;
		const ε$8 = 2e-4;
		if (Math.abs(a$1) < ε$8 && Math.abs(b$2) < ε$8) h = NaN;
		else h = Math.atan2(b$2, a$1) * 180 / Math.PI;
		return [
			L,
			Math.sqrt(a$1 ** 2 + b$2 ** 2),
			constrain(h)
		];
	},
	toBase(oklch$1) {
		let [L, C, h] = oklch$1;
		let a$1, b$2;
		if (isNaN(h)) {
			a$1 = 0;
			b$2 = 0;
		} else {
			a$1 = C * Math.cos(h * Math.PI / 180);
			b$2 = C * Math.sin(h * Math.PI / 180);
		}
		return [
			L,
			a$1,
			b$2
		];
	},
	formats: { "oklch": { coords: [
		"<percentage> | <number>",
		"<number> | <percentage>[0,1]",
		"<number> | <angle>"
	] } }
});
var white = WHITES.D65;
var ε$2 = 216 / 24389;
var κ$1 = 24389 / 27;
var [U_PRIME_WHITE, V_PRIME_WHITE] = uv$1({
	space: xyz_d65,
	coords: white
});
var Luv = new ColorSpace({
	id: "luv",
	name: "Luv",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		u: { refRange: [-215, 215] },
		v: { refRange: [-215, 215] }
	},
	white,
	base: xyz_d65,
	fromBase(XYZ) {
		let xyz = [
			skipNone(XYZ[0]),
			skipNone(XYZ[1]),
			skipNone(XYZ[2])
		];
		let y = xyz[1];
		let [up, vp] = uv$1({
			space: xyz_d65,
			coords: xyz
		});
		if (!Number.isFinite(up) || !Number.isFinite(vp)) return [
			0,
			0,
			0
		];
		let L = y <= ε$2 ? κ$1 * y : 116 * Math.cbrt(y) - 16;
		return [
			L,
			13 * L * (up - U_PRIME_WHITE),
			13 * L * (vp - V_PRIME_WHITE)
		];
	},
	toBase(Luv$1) {
		let [L, u, v] = Luv$1;
		if (L === 0 || isNone(L)) return [
			0,
			0,
			0
		];
		u = skipNone(u);
		v = skipNone(v);
		let up = u / (13 * L) + U_PRIME_WHITE;
		let vp = v / (13 * L) + V_PRIME_WHITE;
		let y = L <= 8 ? L / κ$1 : Math.pow((L + 16) / 116, 3);
		return [
			y * (9 * up / (4 * vp)),
			y,
			y * ((12 - 3 * up - 20 * vp) / (4 * vp))
		];
	},
	formats: { color: {
		id: "--luv",
		coords: [
			"<number> | <percentage>",
			"<number> | <percentage>[-1,1]",
			"<number> | <percentage>[-1,1]"
		]
	} }
});
var LCHuv = new ColorSpace({
	id: "lchuv",
	name: "LChuv",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		c: {
			refRange: [0, 220],
			name: "Chroma"
		},
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	base: Luv,
	fromBase(Luv$1) {
		let [L, u, v] = Luv$1;
		let hue;
		const ε$8 = .02;
		if (Math.abs(u) < ε$8 && Math.abs(v) < ε$8) hue = NaN;
		else hue = Math.atan2(v, u) * 180 / Math.PI;
		return [
			L,
			Math.sqrt(u ** 2 + v ** 2),
			constrain(hue)
		];
	},
	toBase(LCH) {
		let [Lightness, Chroma, Hue] = LCH;
		if (Chroma < 0) Chroma = 0;
		if (isNaN(Hue)) Hue = 0;
		return [
			Lightness,
			Chroma * Math.cos(Hue * Math.PI / 180),
			Chroma * Math.sin(Hue * Math.PI / 180)
		];
	},
	formats: { color: {
		id: "--lchuv",
		coords: [
			"<number> | <percentage>",
			"<number> | <percentage>",
			"<number> | <angle>"
		]
	} }
});
var ε$1 = 216 / 24389;
var κ = 24389 / 27;
var m_r0 = fromXYZ_M$3[0][0];
var m_r1 = fromXYZ_M$3[0][1];
var m_r2 = fromXYZ_M$3[0][2];
var m_g0 = fromXYZ_M$3[1][0];
var m_g1 = fromXYZ_M$3[1][1];
var m_g2 = fromXYZ_M$3[1][2];
var m_b0 = fromXYZ_M$3[2][0];
var m_b1 = fromXYZ_M$3[2][1];
var m_b2 = fromXYZ_M$3[2][2];
function distanceFromOriginAngle(slope, intercept, angle) {
	const d$1 = intercept / (Math.sin(angle) - slope * Math.cos(angle));
	return d$1 < 0 ? Infinity : d$1;
}
function calculateBoundingLines(l) {
	const sub1 = Math.pow(l + 16, 3) / 1560896;
	const sub2 = sub1 > ε$1 ? sub1 : l / κ;
	const s1r = sub2 * (284517 * m_r0 - 94839 * m_r2);
	const s2r = sub2 * (838422 * m_r2 + 769860 * m_r1 + 731718 * m_r0);
	const s3r = sub2 * (632260 * m_r2 - 126452 * m_r1);
	const s1g = sub2 * (284517 * m_g0 - 94839 * m_g2);
	const s2g = sub2 * (838422 * m_g2 + 769860 * m_g1 + 731718 * m_g0);
	const s3g = sub2 * (632260 * m_g2 - 126452 * m_g1);
	const s1b = sub2 * (284517 * m_b0 - 94839 * m_b2);
	const s2b = sub2 * (838422 * m_b2 + 769860 * m_b1 + 731718 * m_b0);
	const s3b = sub2 * (632260 * m_b2 - 126452 * m_b1);
	return {
		r0s: s1r / s3r,
		r0i: s2r * l / s3r,
		r1s: s1r / (s3r + 126452),
		r1i: (s2r - 769860) * l / (s3r + 126452),
		g0s: s1g / s3g,
		g0i: s2g * l / s3g,
		g1s: s1g / (s3g + 126452),
		g1i: (s2g - 769860) * l / (s3g + 126452),
		b0s: s1b / s3b,
		b0i: s2b * l / s3b,
		b1s: s1b / (s3b + 126452),
		b1i: (s2b - 769860) * l / (s3b + 126452)
	};
}
function calcMaxChromaHsluv(lines, h) {
	const hueRad = h / 360 * Math.PI * 2;
	const r0 = distanceFromOriginAngle(lines.r0s, lines.r0i, hueRad);
	const r1 = distanceFromOriginAngle(lines.r1s, lines.r1i, hueRad);
	const g0 = distanceFromOriginAngle(lines.g0s, lines.g0i, hueRad);
	const g1 = distanceFromOriginAngle(lines.g1s, lines.g1i, hueRad);
	const b0 = distanceFromOriginAngle(lines.b0s, lines.b0i, hueRad);
	const b1 = distanceFromOriginAngle(lines.b1s, lines.b1i, hueRad);
	return Math.min(r0, r1, g0, g1, b0, b1);
}
var hsluv = new ColorSpace({
	id: "hsluv",
	name: "HSLuv",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		s: {
			range: [0, 100],
			name: "Saturation"
		},
		l: {
			range: [0, 100],
			name: "Lightness"
		}
	},
	base: LCHuv,
	gamutSpace: sRGB,
	fromBase(lch$1) {
		let [l, c$1, h] = [
			skipNone(lch$1[0]),
			skipNone(lch$1[1]),
			skipNone(lch$1[2])
		];
		let s;
		if (l > 99.9999999) {
			s = 0;
			l = 100;
		} else if (l < 1e-8) {
			s = 0;
			l = 0;
		} else s = c$1 / calcMaxChromaHsluv(calculateBoundingLines(l), h) * 100;
		return [
			h,
			s,
			l
		];
	},
	toBase(hsl) {
		let [h, s, l] = [
			skipNone(hsl[0]),
			skipNone(hsl[1]),
			skipNone(hsl[2])
		];
		let c$1;
		if (l > 99.9999999) {
			l = 100;
			c$1 = 0;
		} else if (l < 1e-8) {
			l = 0;
			c$1 = 0;
		} else c$1 = calcMaxChromaHsluv(calculateBoundingLines(l), h) / 100 * s;
		return [
			l,
			c$1,
			h
		];
	},
	formats: { color: {
		id: "--hsluv",
		coords: [
			"<number> | <angle>",
			"<percentage> | <number>",
			"<percentage> | <number>"
		]
	} }
});
fromXYZ_M$3[0][0];
fromXYZ_M$3[0][1];
fromXYZ_M$3[0][2];
fromXYZ_M$3[1][0];
fromXYZ_M$3[1][1];
fromXYZ_M$3[1][2];
fromXYZ_M$3[2][0];
fromXYZ_M$3[2][1];
fromXYZ_M$3[2][2];
function distanceFromOrigin(slope, intercept) {
	return Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
}
function calcMaxChromaHpluv(lines) {
	let r0 = distanceFromOrigin(lines.r0s, lines.r0i);
	let r1 = distanceFromOrigin(lines.r1s, lines.r1i);
	let g0 = distanceFromOrigin(lines.g0s, lines.g0i);
	let g1 = distanceFromOrigin(lines.g1s, lines.g1i);
	let b0 = distanceFromOrigin(lines.b0s, lines.b0i);
	let b1 = distanceFromOrigin(lines.b1s, lines.b1i);
	return Math.min(r0, r1, g0, g1, b0, b1);
}
var hpluv = new ColorSpace({
	id: "hpluv",
	name: "HPLuv",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		s: {
			range: [0, 100],
			name: "Saturation"
		},
		l: {
			range: [0, 100],
			name: "Lightness"
		}
	},
	base: LCHuv,
	gamutSpace: "self",
	fromBase(lch$1) {
		let [l, c$1, h] = [
			skipNone(lch$1[0]),
			skipNone(lch$1[1]),
			skipNone(lch$1[2])
		];
		let s;
		if (l > 99.9999999) {
			s = 0;
			l = 100;
		} else if (l < 1e-8) {
			s = 0;
			l = 0;
		} else s = c$1 / calcMaxChromaHpluv(calculateBoundingLines(l)) * 100;
		return [
			h,
			s,
			l
		];
	},
	toBase(hsl) {
		let [h, s, l] = [
			skipNone(hsl[0]),
			skipNone(hsl[1]),
			skipNone(hsl[2])
		];
		let c$1;
		if (l > 99.9999999) {
			l = 100;
			c$1 = 0;
		} else if (l < 1e-8) {
			l = 0;
			c$1 = 0;
		} else c$1 = calcMaxChromaHpluv(calculateBoundingLines(l)) / 100 * s;
		return [
			l,
			c$1,
			h
		];
	},
	formats: { color: {
		id: "--hpluv",
		coords: [
			"<number> | <angle>",
			"<percentage> | <number>",
			"<percentage> | <number>"
		]
	} }
});
var Yw = 203;
var n = 2610 / 2 ** 14;
var ninv = 2 ** 14 / 2610;
var m = 2523 / 2 ** 5;
var minv = 2 ** 5 / 2523;
var c1 = 3424 / 2 ** 12;
var c2 = 2413 / 2 ** 7;
var c3 = 2392 / 2 ** 7;
var rec2100Pq = new RGBColorSpace({
	id: "rec2100pq",
	cssId: "rec2100-pq",
	name: "REC.2100-PQ",
	base: REC2020Linear,
	toBase(RGB) {
		return RGB.map(function(val) {
			return (Math.max(val ** minv - c1, 0) / (c2 - c3 * val ** minv)) ** ninv * 1e4 / Yw;
		});
	},
	fromBase(RGB) {
		return RGB.map(function(val) {
			let x = Math.max(val * Yw / 1e4, 0);
			return ((c1 + c2 * x ** n) / (1 + c3 * x ** n)) ** m;
		});
	}
});
var a = .17883277;
var b = .28466892;
var c = .55991073;
var scale = 3.7743;
var rec2100Hlg = new RGBColorSpace({
	id: "rec2100hlg",
	cssId: "rec2100-hlg",
	name: "REC.2100-HLG",
	referred: "scene",
	base: REC2020Linear,
	toBase(RGB) {
		return RGB.map(function(val) {
			if (val <= .5) return val ** 2 / 3 * scale;
			return (Math.exp((val - c) / a) + b) / 12 * scale;
		});
	},
	fromBase(RGB) {
		return RGB.map(function(val) {
			val /= scale;
			if (val <= 1 / 12) return Math.sqrt(3 * val);
			return a * Math.log(12 * val - b) + c;
		});
	}
});
var CATs = {};
hooks.add("chromatic-adaptation-start", (env) => {
	if (env.options.method) env.M = adapt(env.W1, env.W2, env.options.method);
});
hooks.add("chromatic-adaptation-end", (env) => {
	if (!env.M) env.M = adapt(env.W1, env.W2, env.options.method);
});
function defineCAT({ id, toCone_M, fromCone_M }) {
	CATs[id] = arguments[0];
}
function adapt(W1, W2, id = "Bradford") {
	let method = CATs[id];
	let [ρs, γs, βs] = multiplyMatrices(method.toCone_M, W1);
	let [ρd, γd, βd] = multiplyMatrices(method.toCone_M, W2);
	let scaled_cone_M = multiplyMatrices([
		[
			ρd / ρs,
			0,
			0
		],
		[
			0,
			γd / γs,
			0
		],
		[
			0,
			0,
			βd / βs
		]
	], method.toCone_M);
	return multiplyMatrices(method.fromCone_M, scaled_cone_M);
}
defineCAT({
	id: "von Kries",
	toCone_M: [
		[
			.40024,
			.7076,
			-.08081
		],
		[
			-.2263,
			1.16532,
			.0457
		],
		[
			0,
			0,
			.91822
		]
	],
	fromCone_M: [
		[
			1.8599363874558397,
			-1.1293816185800916,
			.21989740959619328
		],
		[
			.3611914362417676,
			.6388124632850422,
			-6370596838649899e-21
		],
		[
			0,
			0,
			1.0890636230968613
		]
	]
});
defineCAT({
	id: "Bradford",
	toCone_M: [
		[
			.8951,
			.2664,
			-.1614
		],
		[
			-.7502,
			1.7135,
			.0367
		],
		[
			.0389,
			-.0685,
			1.0296
		]
	],
	fromCone_M: [
		[
			.9869929054667121,
			-.14705425642099013,
			.15996265166373122
		],
		[
			.4323052697233945,
			.5183602715367774,
			.049291228212855594
		],
		[
			-.00852866457517732,
			.04004282165408486,
			.96848669578755
		]
	]
});
defineCAT({
	id: "CAT02",
	toCone_M: [
		[
			.7328,
			.4296,
			-.1624
		],
		[
			-.7036,
			1.6975,
			.0061
		],
		[
			.003,
			.0136,
			.9834
		]
	],
	fromCone_M: [
		[
			1.0961238208355142,
			-.27886900021828726,
			.18274517938277307
		],
		[
			.4543690419753592,
			.4735331543074117,
			.07209780371722911
		],
		[
			-.009627608738429355,
			-.00569803121611342,
			1.0153256399545427
		]
	]
});
defineCAT({
	id: "CAT16",
	toCone_M: [
		[
			.401288,
			.650173,
			-.051461
		],
		[
			-.250268,
			1.204414,
			.045854
		],
		[
			-.002079,
			.048952,
			.953127
		]
	],
	fromCone_M: [
		[
			1.862067855087233,
			-1.0112546305316845,
			.14918677544445172
		],
		[
			.3875265432361372,
			.6214474419314753,
			-.008973985167612521
		],
		[
			-.01584149884933386,
			-.03412293802851557,
			1.0499644368778496
		]
	]
});
Object.assign(WHITES, {
	A: [
		1.0985,
		1,
		.35585
	],
	C: [
		.98074,
		1,
		1.18232
	],
	D55: [
		.95682,
		1,
		.92149
	],
	D75: [
		.94972,
		1,
		1.22638
	],
	E: [
		1,
		1,
		1
	],
	F2: [
		.99186,
		1,
		.67393
	],
	F7: [
		.95041,
		1,
		1.08747
	],
	F11: [
		1.00962,
		1,
		.6435
	]
});
WHITES.ACES = [
	.32168 / .33767,
	1,
	.34065 / .33767
];
var ACEScg = new RGBColorSpace({
	id: "acescg",
	cssId: "--acescg",
	name: "ACEScg",
	coords: {
		r: {
			range: [0, 65504],
			name: "Red"
		},
		g: {
			range: [0, 65504],
			name: "Green"
		},
		b: {
			range: [0, 65504],
			name: "Blue"
		}
	},
	referred: "scene",
	white: WHITES.ACES,
	toXYZ_M: [
		[
			.6624541811085053,
			.13400420645643313,
			.1561876870049078
		],
		[
			.27222871678091454,
			.6740817658111484,
			.05368951740793705
		],
		[
			-.005574649490394108,
			.004060733528982826,
			1.0103391003129971
		]
	],
	fromXYZ_M: [
		[
			1.6410233796943257,
			-.32480329418479,
			-.23642469523761225
		],
		[
			-.6636628587229829,
			1.6153315916573379,
			.016756347685530137
		],
		[
			.011721894328375376,
			-.008284441996237409,
			.9883948585390215
		]
	]
});
var ε = 2 ** -16;
var ACES_min_nonzero = -.35828683;
var ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52;
var acescc = new RGBColorSpace({
	id: "acescc",
	cssId: "--acescc",
	name: "ACEScc",
	coords: {
		r: {
			range: [ACES_min_nonzero, ACES_cc_max],
			name: "Red"
		},
		g: {
			range: [ACES_min_nonzero, ACES_cc_max],
			name: "Green"
		},
		b: {
			range: [ACES_min_nonzero, ACES_cc_max],
			name: "Blue"
		}
	},
	referred: "scene",
	base: ACEScg,
	toBase(RGB) {
		const low = -5.279999999999999 / 17.52;
		return RGB.map(function(val) {
			if (val <= low) return (2 ** (val * 17.52 - 9.72) - ε) * 2;
			else if (val < ACES_cc_max) return 2 ** (val * 17.52 - 9.72);
			else return 65504;
		});
	},
	fromBase(RGB) {
		return RGB.map(function(val) {
			if (val <= 0) return (Math.log2(ε) + 9.72) / 17.52;
			else if (val < ε) return (Math.log2(ε + val * .5) + 9.72) / 17.52;
			else return (Math.log2(val) + 9.72) / 17.52;
		});
	}
});
var spaces = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	A98RGB: a98rgb,
	A98RGB_Linear: A98Linear,
	ACEScc: acescc,
	ACEScg,
	CAM16_JMh: cam16,
	HCT: hct,
	HPLuv: hpluv,
	HSL,
	HSLuv: hsluv,
	HSV,
	HWB: hwb,
	ICTCP: ictcp,
	JzCzHz: jzczhz,
	Jzazbz,
	LCH: lch,
	LCHuv,
	Lab: lab,
	Lab_D65: lab_d65,
	Luv,
	OKLCH: oklch,
	OKLab,
	P3,
	P3_Linear: P3Linear,
	ProPhoto: prophoto,
	ProPhoto_Linear: ProPhotoLinear,
	REC_2020: REC2020,
	REC_2020_Linear: REC2020Linear,
	REC_2100_HLG: rec2100Hlg,
	REC_2100_PQ: rec2100Pq,
	XYZ_ABS_D65: XYZ_Abs_D65,
	XYZ_D50,
	XYZ_D65: xyz_d65,
	sRGB,
	sRGB_Linear: sRGBLinear
});
var Color = class Color {
	constructor(...args) {
		let color;
		if (args.length === 1) color = getColor(args[0]);
		let space, coords, alpha;
		if (color) {
			space = color.space || color.spaceId;
			coords = color.coords;
			alpha = color.alpha;
		} else [space, coords, alpha] = args;
		Object.defineProperty(this, "space", {
			value: ColorSpace.get(space),
			writable: false,
			enumerable: true,
			configurable: true
		});
		this.coords = coords ? coords.slice() : [
			0,
			0,
			0
		];
		this.alpha = alpha > 1 || alpha === void 0 ? 1 : alpha < 0 ? 0 : alpha;
		for (let i = 0; i < this.coords.length; i++) if (this.coords[i] === "NaN") this.coords[i] = NaN;
		for (let id in this.space.coords) Object.defineProperty(this, id, {
			get: () => this.get(id),
			set: (value) => this.set(id, value)
		});
	}
	get spaceId() {
		return this.space.id;
	}
	clone() {
		return new Color(this.space, this.coords, this.alpha);
	}
	toJSON() {
		return {
			spaceId: this.spaceId,
			coords: this.coords,
			alpha: this.alpha
		};
	}
	display(...args) {
		let ret = display(this, ...args);
		ret.color = new Color(ret.color);
		return ret;
	}
	static get(color, ...args) {
		if (color instanceof Color) return color;
		return new Color(color, ...args);
	}
	static defineFunction(name, code, o = code) {
		let { instance = true, returns } = o;
		let func = function(...args) {
			let ret = code(...args);
			if (returns === "color") ret = Color.get(ret);
			else if (returns === "function<color>") {
				let f = ret;
				ret = function(...args$1) {
					let ret$1 = f(...args$1);
					return Color.get(ret$1);
				};
				Object.assign(ret, f);
			} else if (returns === "array<color>") ret = ret.map((c$1) => Color.get(c$1));
			return ret;
		};
		if (!(name in Color)) Color[name] = func;
		if (instance) Color.prototype[name] = function(...args) {
			return func(this, ...args);
		};
	}
	static defineFunctions(o) {
		for (let name in o) Color.defineFunction(name, o[name], o[name]);
	}
	static extend(exports) {
		if (exports.register) exports.register(Color);
		else for (let name in exports) Color.defineFunction(name, exports[name]);
	}
};
Color.defineFunctions({
	get,
	getAll,
	set,
	setAll,
	to,
	equals,
	inGamut,
	toGamut,
	distance: distance$1,
	toString: serialize
});
Object.assign(Color, {
	util,
	hooks,
	WHITES,
	Space: ColorSpace,
	spaces: ColorSpace.registry,
	parse,
	defaults
});
for (let key of Object.keys(spaces)) ColorSpace.register(spaces[key]);
for (let id in ColorSpace.registry) addSpaceAccessors(id, ColorSpace.registry[id]);
hooks.add("colorspace-init-end", (space) => {
	addSpaceAccessors(space.id, space);
	space.aliases?.forEach((alias) => {
		addSpaceAccessors(alias, space);
	});
});
function addSpaceAccessors(id, space) {
	let propId = id.replace(/-/g, "_");
	Object.defineProperty(Color.prototype, propId, {
		get() {
			let ret = this.getAll(id);
			if (typeof Proxy === "undefined") return ret;
			return new Proxy(ret, {
				has: (obj, property) => {
					try {
						ColorSpace.resolveCoord([space, property]);
						return true;
					} catch (e) {}
					return Reflect.has(obj, property);
				},
				get: (obj, property, receiver) => {
					if (property && typeof property !== "symbol" && !(property in obj)) {
						let { index } = ColorSpace.resolveCoord([space, property]);
						if (index >= 0) return obj[index];
					}
					return Reflect.get(obj, property, receiver);
				},
				set: (obj, property, value, receiver) => {
					if (property && typeof property !== "symbol" && !(property in obj) || property >= 0) {
						let { index } = ColorSpace.resolveCoord([space, property]);
						if (index >= 0) {
							obj[index] = value;
							this.setAll(id, obj);
							return true;
						}
					}
					return Reflect.set(obj, property, value, receiver);
				}
			});
		},
		set(coords) {
			this.setAll(id, coords);
		},
		configurable: true,
		enumerable: true
	});
}
Color.extend(deltaEMethods);
Color.extend({ deltaE });
Object.assign(Color, { deltaEMethods });
Color.extend(variations);
Color.extend({ contrast });
Color.extend(chromaticity);
Color.extend(luminance);
Color.extend(interpolation);
Color.extend(contrastMethods);
var reusableVector4 = null;
var reusableVector2 = null;
var getReusableVector4 = () => {
	if (!reusableVector4) reusableVector4 = new Vector4();
	return reusableVector4;
};
var getReusableVector2 = () => {
	if (!reusableVector2) reusableVector2 = new Vector2();
	return reusableVector2;
};
const transformColor = (value) => {
	const threeColor = new Color(value);
	const coords = threeColor.to("p3-linear").coords;
	const r = coords[0], g$1 = coords[1], b$2 = coords[2], a$1 = threeColor.alpha;
	return {
		node: vec4(r, g$1, b$2, a$1),
		data: new Vector4(r, g$1, b$2, a$1)
	};
};
const transformColorUpdate = (value) => {
	const threeColor = new Color(value);
	const coords = threeColor.to("p3-linear").coords;
	return getReusableVector4().set(coords[0], coords[1], coords[2], threeColor.alpha);
};
const transformPosition = (value) => {
	let x = .5;
	let y = .5;
	const parsePositionValue = (val, isVertical = false) => {
		if (typeof val === "number") return val;
		const str = val.toLowerCase().trim();
		if (isVertical) {
			if (str === "top") return 0;
			if (str === "bottom") return 1;
			if (str === "center") return .5;
		} else {
			if (str === "left") return 0;
			if (str === "right") return 1;
			if (str === "center") return .5;
		}
		console.warn(`Invalid position value: ${val}. Defaulting to center.`);
		return .5;
	};
	if (typeof value === "string") {
		const parts = value.toLowerCase().trim().split(/\s+/);
		if (parts.includes("left")) x = 0;
		else if (parts.includes("right")) x = 1;
		else if (parts.includes("center") || parts.length === 1 && (parts[0] === "top" || parts[0] === "bottom")) x = .5;
		if (parts.includes("top")) y = 0;
		else if (parts.includes("bottom")) y = 1;
		else if (parts.includes("center") || parts.length === 1 && (parts[0] === "left" || parts[0] === "right")) y = .5;
		if (parts.length === 1 && parts[0] === "center") {
			x = .5;
			y = .5;
		}
	} else if (typeof value === "object" && value !== null) {
		x = parsePositionValue(value.x, false);
		y = parsePositionValue(value.y, true);
	} else console.warn(`Invalid position value provided: ${value}. Defaulting to center.`);
	const finalY = 1 - y;
	return {
		node: vec2(x, finalY),
		data: new Vector2(x, finalY)
	};
};
const transformPositionUpdate = (value) => {
	let x = .5;
	let y = .5;
	const parsePositionValue = (val, isVertical = false) => {
		if (typeof val === "number") return val;
		const str = val.toLowerCase().trim();
		if (isVertical) {
			if (str === "top") return 0;
			if (str === "bottom") return 1;
			if (str === "center") return .5;
		} else {
			if (str === "left") return 0;
			if (str === "right") return 1;
			if (str === "center") return .5;
		}
		return .5;
	};
	if (typeof value === "string") {
		const parts = value.toLowerCase().trim().split(/\s+/);
		if (parts.includes("left")) x = 0;
		else if (parts.includes("right")) x = 1;
		else if (parts.includes("center") || parts.length === 1 && (parts[0] === "top" || parts[0] === "bottom")) x = .5;
		if (parts.includes("top")) y = 0;
		else if (parts.includes("bottom")) y = 1;
		else if (parts.includes("center") || parts.length === 1 && (parts[0] === "left" || parts[0] === "right")) y = .5;
		if (parts.length === 1 && parts[0] === "center") {
			x = .5;
			y = .5;
		}
	} else if (typeof value === "object" && value !== null) {
		x = parsePositionValue(value.x, false);
		y = parsePositionValue(value.y, true);
	}
	return getReusableVector2().set(x, 1 - y);
};
const transformAngle = (value) => {
	if (typeof value === "number") return (value % 360 + 360) % 360;
	const str = value.toLowerCase().trim();
	switch (str) {
		case "to right": return 0;
		case "to bottom": return 90;
		case "to left": return 180;
		case "to top": return 270;
		case "to bottom right":
		case "to right bottom": return 45;
		case "to bottom left":
		case "to left bottom": return 135;
		case "to top left":
		case "to left top": return 225;
		case "to top right":
		case "to right top": return 315;
		case "from left": return 0;
		case "from top": return 90;
		case "from right": return 180;
		case "from bottom": return 270;
		case "from top left": return 45;
		case "from top right": return 135;
		case "from bottom right": return 225;
		case "from bottom left": return 315;
		default:
			const numMatch = str.match(/^(-?\d*\.?\d+)(deg|rad|turn)?$/);
			if (numMatch) {
				const [, valueStr, unit = "deg"] = numMatch;
				const numValue = parseFloat(valueStr);
				switch (unit) {
					case "deg": return (numValue % 360 + 360) % 360;
					case "rad": return (numValue * 180 / Math.PI % 360 + 360) % 360;
					case "turn": return (numValue * 360 % 360 + 360) % 360;
					default: return (numValue % 360 + 360) % 360;
				}
			}
			console.warn(`Invalid angle value: ${value}. Defaulting to 0 degrees.`);
			return 0;
	}
};
const transformEdges = (value) => {
	const mode = {
		"stretch": 0,
		"transparent": 1,
		"mirror": 2,
		"wrap": 3
	}[value.toLowerCase()];
	if (mode === void 0) {
		console.warn(`Invalid edge mode: ${value}. Defaulting to 'stretch'.`);
		return 0;
	}
	return mode;
};
const colorSpaceOptions = [
	{
		label: "Linear RGB",
		value: "linear"
	},
	{
		label: "OKLCh",
		value: "oklch"
	},
	{
		label: "OKLAB",
		value: "oklab"
	}
];
const transformColorSpace = (value) => {
	const mode = {
		"linear": 0,
		"oklch": 1,
		"oklab": 2
	}[value.toLowerCase()];
	if (mode === void 0) {
		console.warn(`Invalid color space mode: ${value}. Defaulting to 'linear'.`);
		return 0;
	}
	return mode;
};
export { transformColorUpdate as a, transformPositionUpdate as c, transformColorSpace as i, transformAngle as n, transformEdges as o, transformColor as r, transformPosition as s, colorSpaceOptions as t };
