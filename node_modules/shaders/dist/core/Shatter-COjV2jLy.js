import { t as applyEdgeHandling } from "./edges-Bd7GP4s2.js";
import { o as transformEdges } from "./transformations-YbhRK-rd.js";
import { DataTexture, FloatType, LinearFilter, RGBAFormat } from "three";
import { convertToTexture, float, screenUV, smoothstep, texture, vec2, vec4 } from "three/tsl";
var seededRandom = (seed) => {
	const x = Math.sin(seed) * 1e4;
	return x - Math.floor(x);
};
const componentDefinition = {
	name: "Shatter",
	category: "Interactive",
	description: "Broken glass effect with tectonic plate displacement",
	requiresRTT: true,
	requiresChild: true,
	props: {
		crackWidth: {
			default: 1,
			description: "Thickness of crack lines",
			ui: {
				type: "range",
				min: .5,
				max: 5,
				step: .1,
				label: "Crack Width"
			}
		},
		intensity: {
			default: 4,
			description: "How much shards shift",
			ui: {
				type: "range",
				min: 0,
				max: 20,
				step: 1,
				label: "Intensity"
			}
		},
		radius: {
			default: .4,
			description: "Cursor influence radius",
			ui: {
				type: "range",
				min: .1,
				max: 1,
				step: .1,
				label: "Radius"
			}
		},
		decay: {
			default: 1,
			description: "How fast shards return to rest",
			ui: {
				type: "range",
				min: .1,
				max: 10,
				step: .1,
				label: "Decay"
			}
		},
		seed: {
			default: 2,
			description: "Random seed for pattern",
			ui: {
				type: "range",
				min: 0,
				max: 50,
				step: 1,
				label: "Seed"
			}
		},
		chromaticSplit: {
			default: 1,
			description: "RGB separation for prismatic glass effect",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Chromatic Split"
			}
		},
		refractionStrength: {
			default: 5,
			description: "How much cracks bend/distort the underlying image",
			ui: {
				type: "range",
				min: 0,
				max: 10,
				step: .1,
				label: "Refraction"
			}
		},
		shardLighting: {
			default: .1,
			description: "Subtle lighting on tilted shards for 3D depth",
			ui: {
				type: "range",
				min: 0,
				max: .5,
				step: .1,
				label: "Shard Lighting"
			}
		},
		edges: {
			default: "mirror",
			description: "How to handle edges when displacement pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, onBeforeRender, childNode, onCleanup }) => {
		const SHARD_COUNT = 16;
		const FRICTION = 1;
		const cellData = new Float32Array(SHARD_COUNT * 4);
		const cellTexture = new DataTexture(cellData, 4, 4, RGBAFormat, FloatType);
		cellTexture.magFilter = LinearFilter;
		cellTexture.minFilter = LinearFilter;
		const displacementData = new Float32Array(SHARD_COUNT * 4);
		const displacementTexture = new DataTexture(displacementData, 4, 4, RGBAFormat, FloatType);
		displacementTexture.magFilter = LinearFilter;
		displacementTexture.minFilter = LinearFilter;
		const generateCells = (seed) => {
			for (let i = 0; i < SHARD_COUNT; i++) {
				cellData[i * 4] = seededRandom(seed + i * 2);
				cellData[i * 4 + 1] = seededRandom(seed + i * 2 + 1);
				cellData[i * 4 + 2] = seededRandom(seed + i * 3);
				cellData[i * 4 + 3] = seededRandom(seed + i * 3 + 1);
			}
			cellTexture.needsUpdate = true;
		};
		let currentSeed = uniforms.seed.uniform.value;
		generateCells(currentSeed);
		displacementData.fill(0);
		displacementTexture.needsUpdate = true;
		let prevX = .5;
		let prevY = .5;
		let lastTime = Date.now();
		onBeforeRender(({ pointer }) => {
			const currentTime = Date.now();
			const dt = Math.min((currentTime - lastTime) / 1e3, .016);
			lastTime = currentTime;
			const newSeed = uniforms.seed.uniform.value;
			if (newSeed !== currentSeed) {
				currentSeed = newSeed;
				generateCells(currentSeed);
				displacementData.fill(0);
			}
			const intensity = uniforms.intensity.uniform.value;
			const radius = uniforms.radius.uniform.value;
			const decay = uniforms.decay.uniform.value;
			const friction = FRICTION;
			let velX = dt > 0 ? (pointer.x - prevX) / dt : 0;
			let velY = dt > 0 ? (pointer.y - prevY) / dt : 0;
			let speed = Math.sqrt(velX * velX + velY * velY);
			const maxVelocity = 5 + intensity * 2;
			if (speed > maxVelocity) {
				const scale = maxVelocity / speed;
				velX *= scale;
				velY *= scale;
				speed = maxVelocity;
			}
			for (let i = 0; i < SHARD_COUNT; i++) {
				const cellX = cellData[i * 4];
				const cellY = cellData[i * 4 + 1];
				const randomDirX = cellData[i * 4 + 2] - .5;
				const randomDirY = cellData[i * 4 + 3] - .5;
				const dx = cellX - pointer.x;
				const dy = cellY - pointer.y;
				const dist = Math.sqrt(dx * dx + dy * dy);
				let currentDx = displacementData[i * 4];
				let currentDy = displacementData[i * 4 + 1];
				const decayTime = Math.max(.01, decay);
				const decayFactor = Math.exp(-dt / decayTime);
				currentDx *= decayFactor;
				currentDy *= decayFactor;
				let velocityDx = 0;
				let velocityDy = 0;
				if (dist < radius && speed > .01) {
					const influence = Math.max(0, 1 - dist / radius);
					const influenceCurve = influence * influence;
					const pushForce = influenceCurve * speed * intensity * dt * .5;
					velocityDx = velX * pushForce;
					velocityDy = velY * pushForce;
					const jitterForce = influenceCurve * speed * intensity * dt * .1;
					velocityDx += randomDirX * jitterForce;
					velocityDy += randomDirY * jitterForce;
				}
				const lerpFactor = Math.min(1, friction * dt);
				displacementData[i * 4] = currentDx + velocityDx * lerpFactor;
				displacementData[i * 4 + 1] = currentDy + velocityDy * lerpFactor;
				displacementData[i * 4 + 2] = 0;
				displacementData[i * 4 + 3] = 0;
			}
			displacementTexture.needsUpdate = true;
			prevX = pointer.x;
			prevY = pointer.y;
		});
		onCleanup(() => {
			cellTexture.dispose();
			displacementTexture.dispose();
		});
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const cellField = texture(cellTexture);
		const dispField = texture(displacementTexture);
		const cells = [];
		for (let i = 0; i < SHARD_COUNT; i++) {
			const u = (i % 4 + .5) / 4;
			const v = (Math.floor(i / 4) + .5) / 4;
			const cellPos = cellField.sample(vec2(u, v)).xy;
			const dist = screenUV.sub(cellPos).length();
			cells.push({
				dist,
				index: float(i)
			});
		}
		let minDist1 = cells[0].dist;
		let minDist2 = float(1e3);
		let nearestIdx = cells[0].index;
		for (let i = 1; i < SHARD_COUNT; i++) {
			const dist = cells[i].dist;
			const isNewNearest = dist.lessThan(minDist1);
			const isNewSecond = dist.lessThan(minDist2).and(isNewNearest.not());
			const nextMin2 = isNewNearest.select(minDist1, isNewSecond.select(dist, minDist2));
			const nextMin1 = isNewNearest.select(dist, minDist1);
			const nextIdx = isNewNearest.select(cells[i].index, nearestIdx);
			minDist2 = nextMin2;
			minDist1 = nextMin1;
			nearestIdx = nextIdx;
		}
		const dispU = nearestIdx.mod(float(4)).add(.5).div(4);
		const dispV = nearestIdx.div(float(4)).floor().add(.5).div(4);
		const displacement = dispField.sample(vec2(dispU, dispV)).xy;
		const displacementMag = displacement.length();
		const edgeDiff = minDist2.sub(minDist1);
		const crackThreshold = uniforms.crackWidth.uniform.mul(.005);
		const baseCrackIntensity = float(1).sub(smoothstep(float(0), crackThreshold, edgeDiff));
		const displacementFactor = smoothstep(float(0), float(.01), displacementMag);
		const crackIntensity = baseCrackIntensity.mul(displacementFactor);
		const nearestCellU = nearestIdx.mod(float(4)).add(.5).div(4);
		const nearestCellV = nearestIdx.div(float(4)).floor().add(.5).div(4);
		const nearestCellPos = cellField.sample(vec2(nearestCellU, nearestCellV)).xy;
		const toNearest = screenUV.sub(nearestCellPos).normalize();
		const edgeNormal = vec2(toNearest.y.negate(), toNearest.x);
		const displacedUV = screenUV.sub(displacement);
		const refractionOffset = edgeNormal.mul(uniforms.refractionStrength.uniform).mul(.01);
		const chromaticOffset = uniforms.chromaticSplit.uniform.mul(.005);
		const rOffset = refractionOffset.add(edgeNormal.mul(chromaticOffset));
		const gOffset = refractionOffset;
		const bOffset = refractionOffset.sub(edgeNormal.mul(chromaticOffset));
		const rUV = displacedUV.add(rOffset.mul(crackIntensity));
		const gUV = displacedUV.add(gOffset.mul(crackIntensity));
		const bUV = displacedUV.add(bOffset.mul(crackIntensity));
		const rSample = childTexture.sample(rUV);
		const gSample = childTexture.sample(gUV);
		const bSample = childTexture.sample(bUV);
		const rFinal = applyEdgeHandling(rUV, rSample, childTexture, uniforms.edges.uniform);
		const gFinal = applyEdgeHandling(gUV, gSample, childTexture, uniforms.edges.uniform);
		const bFinal = applyEdgeHandling(bUV, bSample, childTexture, uniforms.edges.uniform);
		const refractedColor = vec4(rFinal.r, gFinal.g, bFinal.b, gFinal.a);
		const normalColor = applyEdgeHandling(displacedUV, childTexture.sample(displacedUV), childTexture, uniforms.edges.uniform);
		let shadedRGB = normalColor.rgb.mul(float(1).sub(crackIntensity)).add(refractedColor.rgb.mul(crackIntensity));
		const displacementLength = displacement.length();
		const tiltX = displacement.x.div(displacementLength.add(.001));
		const tiltY = displacement.y.div(displacementLength.add(.001));
		const lightDir3D = vec2(.3, .6).normalize();
		const normalDot = tiltX.mul(lightDir3D.x).add(tiltY.mul(lightDir3D.y));
		const lightingFactor = float(1).add(normalDot.mul(uniforms.shardLighting.uniform));
		const lightingIntensity = smoothstep(float(0), float(.02), displacementLength);
		const finalLighting = float(1).add(lightingFactor.sub(1).mul(lightingIntensity));
		return vec4(shadedRGB.mul(finalLighting), normalColor.a);
	}
};
var Shatter_default = componentDefinition;
export { componentDefinition as n, Shatter_default as t };
