const TELEMETRY_CONFIG = {
	samplingRate: .05,
	collectionDuration: 1e4,
	warmupDuration: 1e3,
	sampleInterval: 100,
	apiEndpoint: "https://shaders.com/api/telemetry"
};
function collectEnvironment() {
	if (typeof window === "undefined" || typeof navigator === "undefined") return {
		domain: "unknown",
		url: "unknown",
		userAgent: "unknown",
		viewport: {
			width: 0,
			height: 0
		},
		devicePixelRatio: 1,
		locale: "en-US"
	};
	return {
		domain: window.location.hostname,
		url: window.location.pathname,
		userAgent: navigator.userAgent,
		viewport: {
			width: window.innerWidth,
			height: window.innerHeight
		},
		devicePixelRatio: window.devicePixelRatio,
		locale: navigator.language
	};
}
var TelemetryCollector = class {
	renderer;
	sessionId;
	frameSamples = [];
	sampleInterval = null;
	stopped = false;
	constructor(renderer) {
		this.renderer = renderer;
		this.sessionId = `tel_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
	}
	stop() {
		this.stopped = true;
		if (this.sampleInterval) {
			clearInterval(this.sampleInterval);
			this.sampleInterval = null;
		}
	}
	async start() {
		try {
			await this.sleep(TELEMETRY_CONFIG.warmupDuration);
			if (this.stopped) return;
			this.sampleInterval = setInterval(() => {
				if (this.stopped) return;
				try {
					const stats = this.renderer.getPerformanceStats();
					this.frameSamples.push(stats);
				} catch (error) {
					console.error("Telemetry sampling error:", error);
				}
			}, TELEMETRY_CONFIG.sampleInterval);
			await this.sleep(TELEMETRY_CONFIG.collectionDuration - TELEMETRY_CONFIG.warmupDuration);
			if (this.stopped) return;
			if (this.sampleInterval) {
				clearInterval(this.sampleInterval);
				this.sampleInterval = null;
			}
			if (!this.stopped && this.frameSamples.length >= 10) {
				const payload = this.aggregateData();
				await this.sendTelemetry(payload);
			} else if (this.frameSamples.length < 10) console.log("[Telemetry] Insufficient samples collected, skipping send");
		} catch (error) {
			console.error("Telemetry collection error:", error);
		}
	}
	sleep(ms) {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}
	aggregateData() {
		const performance = this.aggregatePerformance();
		const renderer = this.detectRendererType();
		const components = this.extractComponents();
		const environment = collectEnvironment();
		return {
			sessionId: this.sessionId,
			timestamp: Date.now(),
			collectionDuration: TELEMETRY_CONFIG.collectionDuration,
			performance,
			renderer,
			components,
			environment
		};
	}
	aggregatePerformance() {
		if (this.frameSamples.length === 0) return {
			fps: 0,
			frameTime: {
				avg: 0,
				min: 0,
				max: 0,
				p99: 0
			},
			jankPercent: 0,
			budgetUsed: 0
		};
		const frameTimes = this.frameSamples.map((s) => s.avgFrameTime);
		const jankPercents = this.frameSamples.map((s) => s.jankPercent);
		const budgetUseds = this.frameSamples.map((s) => s.budgetUsed);
		const fpsValues = this.frameSamples.map((s) => s.fps);
		const fps = this.calculateMedian(fpsValues);
		const avgFrameTime = this.calculateMean(frameTimes);
		const minFrameTime = Math.min(...frameTimes);
		const maxFrameTime = Math.max(...frameTimes);
		const p99FrameTime = this.calculatePercentile(frameTimes, 99);
		const jankPercent = this.calculateMean(jankPercents);
		const budgetUsed = this.calculateMean(budgetUseds);
		return {
			fps: Math.round(fps * 10) / 10,
			frameTime: {
				avg: Math.round(avgFrameTime * 10) / 10,
				min: Math.round(minFrameTime * 10) / 10,
				max: Math.round(maxFrameTime * 10) / 10,
				p99: Math.round(p99FrameTime * 10) / 10
			},
			jankPercent: Math.round(jankPercent * 10) / 10,
			budgetUsed: Math.round(budgetUsed * 10) / 10
		};
	}
	detectRendererType() {
		const latestSample = this.frameSamples[this.frameSamples.length - 1];
		return {
			type: this.renderer.getRendererType?.() || "webgl",
			drawCalls: latestSample?.drawCalls ?? null,
			textureCount: latestSample?.textureCount ?? null
		};
	}
	extractComponents() {
		try {
			const nodeRegistry = this.renderer.getNodeRegistry();
			const components = [];
			for (const [_, nodeInfo] of nodeRegistry.nodes) {
				if (nodeInfo.parentId === null) continue;
				components.push({
					name: nodeInfo.componentName,
					requiresRTT: nodeInfo.requiresRTT,
					renderOrder: nodeInfo.metadata.renderOrder
				});
			}
			return components.sort((a, b) => a.renderOrder - b.renderOrder);
		} catch (error) {
			console.error("Failed to extract components:", error);
			return [];
		}
	}
	async sendTelemetry(payload) {
		try {
			const response = await fetch(TELEMETRY_CONFIG.apiEndpoint, {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify(payload)
			});
			if (!response.ok) console.warn("Telemetry send failed:", response.status, response.statusText);
		} catch (error) {
			console.error("Telemetry send error:", error);
		}
	}
	calculateMean(values) {
		if (values.length === 0) return 0;
		return values.reduce((a, b) => a + b, 0) / values.length;
	}
	calculateMedian(values) {
		if (values.length === 0) return 0;
		const sorted = [...values].sort((a, b) => a - b);
		const mid = Math.floor(sorted.length / 2);
		if (sorted.length % 2 === 0) return (sorted[mid - 1] + sorted[mid]) / 2;
		else return sorted[mid];
	}
	calculatePercentile(values, percentile) {
		if (values.length === 0) return 0;
		const sorted = [...values].sort((a, b) => a - b);
		const index = Math.ceil(percentile / 100 * sorted.length) - 1;
		return sorted[Math.max(0, index)];
	}
};
function shouldCollectTelemetry() {
	if (typeof window !== "undefined" && window.location?.search?.includes("telemetry=true")) return true;
	return Math.random() < TELEMETRY_CONFIG.samplingRate;
}
function isExternalUser() {
	if (typeof window === "undefined" || !window.location) return false;
	const hostname = window.location.hostname;
	return !hostname.includes("shaders.com") && hostname !== "localhost" && hostname !== "127.0.0.1";
}
export { TelemetryCollector, isExternalUser, shouldCollectTelemetry };
