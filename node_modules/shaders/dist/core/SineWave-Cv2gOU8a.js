import { n as transformAngle, r as transformColor, s as transformPosition } from "./transformations-YbhRK-rd.js";
import { t as createAnimatedTime } from "./time-BZqyVJXt.js";
import { PI, abs, cos, radians, screenUV, sin, smoothstep, vec2, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "SineWave",
	category: "Base Layers",
	description: "Animated wave with thickness and softness",
	props: {
		color: {
			default: "#ffffff",
			transform: transformColor,
			description: "The color of the sine wave",
			ui: {
				type: "color",
				label: "Color"
			}
		},
		amplitude: {
			default: .15,
			description: "The height/amplitude of the sine wave",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Amplitude"
			}
		},
		frequency: {
			default: 1,
			description: "The frequency/number of wave cycles",
			ui: {
				type: "range",
				min: .1,
				max: 20,
				step: .1,
				label: "Frequency"
			}
		},
		speed: {
			default: 1,
			description: "The animation speed of the wave",
			ui: {
				type: "range",
				min: -5,
				max: 5,
				step: .1,
				label: "Speed"
			}
		},
		angle: {
			default: 0,
			transform: transformAngle,
			description: "The rotation angle of the wave (in degrees)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		position: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center position of the wave",
			ui: {
				type: "position",
				label: "Position"
			}
		},
		thickness: {
			default: .2,
			description: "The thickness of the wave line",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Thickness"
			}
		},
		softness: {
			default: .4,
			description: "Edge softness of the wave line",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Softness"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const uv$1 = screenUV;
		const aspect = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(uv$1.x.mul(aspect), uv$1.y);
		const centerPos = vec2(uniforms.position.uniform.x.mul(aspect), uniforms.position.uniform.y.oneMinus());
		const centeredUV = aspectCorrectedUV.sub(centerPos);
		const angleRad = radians(uniforms.angle.uniform);
		const cosAngle = cos(angleRad);
		const sinAngle = sin(angleRad);
		const rotatedX = centeredUV.x.mul(cosAngle).sub(centeredUV.y.mul(sinAngle));
		const rotatedY = centeredUV.x.mul(sinAngle).add(centeredUV.y.mul(cosAngle));
		const animatedTime = createAnimatedTime(params, uniforms.speed);
		const sineWave = sin(rotatedX.mul(uniforms.frequency.uniform).mul(PI.mul(2)).add(animatedTime)).mul(uniforms.amplitude.uniform);
		const distanceFromWave = abs(rotatedY.sub(sineWave));
		const halfThickness = uniforms.thickness.uniform.mul(.5);
		const halfSoftness = uniforms.softness.uniform.mul(.5);
		const waveMask = smoothstep(halfThickness.add(halfSoftness), halfThickness.sub(halfSoftness), distanceFromWave);
		return vec4(uniforms.color.uniform.rgb, uniforms.color.uniform.a.mul(waveMask));
	}
};
var SineWave_default = componentDefinition;
export { componentDefinition as n, SineWave_default as t };
