import { t as applyEdgeHandling } from "./edges-Bd7GP4s2.js";
import { o as transformEdges } from "./transformations-YbhRK-rd.js";
import { DataTexture, FloatType, LinearFilter, RGFormat } from "three";
import { convertToTexture, float, screenUV, texture, uniform, vec2, vec4 } from "three/tsl";
var DEFAULT_GRID_SIZE = 20;
var displacementStateCache = /* @__PURE__ */ new WeakMap();
var getOrCreateDisplacementState = (uniforms) => {
	let state = displacementStateCache.get(uniforms);
	const gridSize = uniforms?.gridSize?.uniform?.value ? Math.max(8, Math.min(128, Math.floor(uniforms.gridSize.uniform.value))) : DEFAULT_GRID_SIZE;
	if (state && state.gridSize !== gridSize) {
		state.dataTexture.dispose();
		state = void 0;
		displacementStateCache.delete(uniforms);
	}
	if (!state) {
		const data = new Float32Array(gridSize * gridSize * 2);
		const dataTexture = new DataTexture(data, gridSize, gridSize, RGFormat, FloatType);
		dataTexture.magFilter = LinearFilter;
		dataTexture.minFilter = LinearFilter;
		dataTexture.needsUpdate = true;
		state = {
			dataTexture,
			data,
			tslNode: texture(dataTexture),
			gridSize
		};
		displacementStateCache.set(uniforms, state);
	}
	return state;
};
const componentDefinition = {
	name: "GridDistortion",
	category: "Interactive",
	description: "Interactive grid distortion controlled by mouse position",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 1,
			description: "Strength of the distortion effect",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .1,
				label: "Intensity"
			}
		},
		swirl: {
			default: 0,
			description: "Amount of swirl motion",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .1,
				label: "Swirl"
			}
		},
		decay: {
			default: 3,
			description: "Rate of distortion decay (higher = faster)",
			ui: {
				type: "range",
				min: 0,
				max: 10,
				step: .1,
				label: "Decay"
			}
		},
		radius: {
			default: 1,
			description: "Radius of the distortion effect",
			ui: {
				type: "range",
				min: 0,
				max: 3,
				step: .01,
				label: "Radius"
			}
		},
		gridSize: {
			default: 20,
			description: "Resolution of the distortion grid (higher = more detailed)",
			ui: {
				type: "range",
				min: 8,
				max: 128,
				step: 1,
				label: "Grid Size"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, onBeforeRender, childNode, onCleanup }) => {
		const { dataTexture: displacementTexture, data: displacementData, tslNode: displacementField, gridSize: GRID_SIZE } = getOrCreateDisplacementState(uniforms);
		const mouseVelX = uniform(0);
		const mouseVelY = uniform(0);
		let prevX = .5;
		let prevY = .5;
		let lastTime = Date.now();
		onBeforeRender(({ pointer }) => {
			const currentTime = Date.now();
			const dt = Math.min((currentTime - lastTime) / 1e3, .016);
			lastTime = currentTime;
			const velX = dt > 0 ? (pointer.x - prevX) / dt : 0;
			const velY = dt > 0 ? (pointer.y - prevY) / dt : 0;
			mouseVelX.value = mouseVelX.value * .85 + velX * .15;
			mouseVelY.value = mouseVelY.value * .85 + velY * .15;
			const decay = uniforms.decay.uniform.value;
			const intensity = uniforms.intensity.uniform.value;
			const radius = uniforms.radius.uniform.value * .05;
			const swirl = uniforms.swirl.uniform.value;
			for (let i = 0; i < GRID_SIZE; i++) for (let j = 0; j < GRID_SIZE; j++) {
				const idx = (i * GRID_SIZE + j) * 2;
				displacementData[idx] *= 1 - decay * dt;
				displacementData[idx + 1] *= 1 - decay * dt;
				const cellX = (j + .5) / GRID_SIZE;
				const cellY = (i + .5) / GRID_SIZE;
				const dx = cellX - pointer.x;
				const dy = cellY - pointer.y;
				const dist = Math.sqrt(dx * dx + dy * dy);
				if (dist < radius * 2 && Math.abs(velX) + Math.abs(velY) > .01) {
					const influence = Math.exp(-dist * dist / (radius * radius));
					displacementData[idx] += mouseVelX.value * influence * intensity * dt * .5;
					displacementData[idx + 1] += mouseVelY.value * influence * intensity * dt * .5;
					if (swirl > 0) {
						const angle = Math.atan2(dy, dx) + Math.PI * .5;
						displacementData[idx] += Math.cos(angle) * swirl * influence * dt * 2;
						displacementData[idx + 1] += Math.sin(angle) * swirl * influence * dt * 2;
					}
				}
				displacementData[idx] = Math.max(-1, Math.min(1, displacementData[idx]));
				displacementData[idx + 1] = Math.max(-1, Math.min(1, displacementData[idx + 1]));
			}
			displacementTexture.needsUpdate = true;
			prevX = pointer.x;
			prevY = pointer.y;
		});
		onCleanup(() => {
			displacementTexture.dispose();
			displacementStateCache.delete(uniforms);
		});
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const gridSizeUniform = uniforms.gridSize.uniform;
		const gridScale = float(1).div(gridSizeUniform);
		const gridCellUV = screenUV.div(gridScale).floor().mul(gridScale).add(gridScale.mul(.5));
		const displacement = displacementField.sample(gridCellUV).xy;
		const maxDisplacement = float(.1);
		const negMaxDisplacement = float(-.1);
		const clampedDisplacement = displacement.clamp(vec2(negMaxDisplacement, negMaxDisplacement), vec2(maxDisplacement, maxDisplacement));
		const distortedUV = screenUV.sub(clampedDisplacement);
		return applyEdgeHandling(distortedUV, childTexture.sample(distortedUV), childTexture, uniforms.edges.uniform);
	}
};
var GridDistortion_default = componentDefinition;
export { componentDefinition as n, GridDistortion_default as t };
