import { DataTexture, NearestFilter, RGBAFormat, UnsignedByteType } from "three";
import { abs, any, ceil, convertToTexture, dot, float, floor, fract, greaterThan, or, screenUV, select, sqrt, texture, uniform, vec2, vec3, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "Ascii",
	category: "Stylize",
	description: "Convert imagery to ASCII character art",
	requiresRTT: true,
	requiresChild: true,
	props: {
		characters: {
			default: "@%#*+=-:.",
			description: "Characters to use for ASCII effect (light to dark)",
			ui: {
				type: "text",
				label: "Characters"
			}
		},
		cellSize: {
			default: 30,
			description: "Size of each ASCII character cell in pixels",
			ui: {
				type: "range",
				min: 8,
				max: 100,
				step: 1,
				label: "Cell Size"
			}
		},
		fontFamily: {
			default: "JetBrains Mono",
			description: "Font family for characters",
			ui: {
				type: "select",
				options: [
					{
						label: "JetBrains Mono",
						value: "JetBrains Mono"
					},
					{
						label: "Fira Code",
						value: "Fira Code"
					},
					{
						label: "Source Code Pro",
						value: "Source Code Pro"
					},
					{
						label: "IBM Plex Mono",
						value: "IBM Plex Mono"
					},
					{
						label: "Space Mono",
						value: "Space Mono"
					},
					{
						label: "Roboto Mono",
						value: "Roboto Mono"
					},
					{
						label: "Courier Prime",
						value: "Courier Prime"
					}
				],
				label: "Font Family"
			}
		},
		spacing: {
			default: 1,
			description: "Character size within each cell (1.0 = optimal size, 0.0 = smallest)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .05,
				label: "Character Size"
			},
			transform: (value) => .1 + value * 1.4
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup, onBeforeRender }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const ATLAS_TEXTURE_SIZE = 2048;
		const GOOGLE_FONTS_MAP = {
			"JetBrains Mono": "JetBrains+Mono",
			"Fira Code": "Fira+Code",
			"Source Code Pro": "Source+Code+Pro",
			"IBM Plex Mono": "IBM+Plex+Mono",
			"Space Mono": "Space+Mono",
			"Roboto Mono": "Roboto+Mono",
			"Courier Prime": "Courier+Prime"
		};
		const loadedFonts = /* @__PURE__ */ new Set();
		async function loadGoogleFont(fontFamily) {
			if (loadedFonts.has(fontFamily)) return;
			if (!GOOGLE_FONTS_MAP[fontFamily]) return;
			const googleFontName = GOOGLE_FONTS_MAP[fontFamily];
			if (!document.querySelector(`link[href*="${googleFontName}"]`)) {
				const link = document.createElement("link");
				link.rel = "stylesheet";
				link.href = `https://fonts.googleapis.com/css2?family=${googleFontName}:wght@400&display=swap`;
				document.head.appendChild(link);
			}
			try {
				if (document.fonts && document.fonts.load) {
					const specs = [
						`400 12px "${fontFamily}"`,
						`12px "${fontFamily}"`,
						`400 12px ${fontFamily}`,
						`12px ${fontFamily}`
					];
					for (const spec of specs) try {
						await document.fonts.load(spec);
						break;
					} catch (e) {}
					await new Promise((resolve) => setTimeout(resolve, 500));
					loadedFonts.add(fontFamily);
				} else {
					await new Promise((resolve) => setTimeout(resolve, 1e3));
					loadedFonts.add(fontFamily);
				}
			} catch (error) {}
		}
		let reusableCanvas = null;
		let reusableCtx = null;
		let reusableDataBuffer = null;
		const createCharacterAtlas = async (characters, cellSize, fontFamily, spacing) => {
			if (!characters || characters.length === 0) throw new Error("Characters string cannot be empty");
			const charCount$1 = characters.length;
			const atlasSize$1 = Math.max(2, Math.ceil(Math.sqrt(charCount$1)));
			const baseAtlasCellSize = 128;
			const spacingMultiplier = Math.max(1, 2 / spacing);
			const actualCellSize = Math.min(baseAtlasCellSize * spacingMultiplier, ATLAS_TEXTURE_SIZE / atlasSize$1);
			const fontSize = actualCellSize * .75;
			if (!reusableCanvas) {
				reusableCanvas = document.createElement("canvas");
				reusableCanvas.width = ATLAS_TEXTURE_SIZE;
				reusableCanvas.height = ATLAS_TEXTURE_SIZE;
				reusableCtx = reusableCanvas.getContext("2d");
				if (!reusableCtx) {
					console.error("[Ascii] Failed to create 2D canvas context for character atlas");
					throw new Error("Ascii shader: Canvas 2D context unavailable");
				}
			}
			if (!reusableCtx) {
				console.error("[Ascii] Canvas context unexpectedly null during atlas creation");
				throw new Error("Ascii shader: Canvas 2D context unavailable");
			}
			const ctx = reusableCtx;
			ctx.clearRect(0, 0, ATLAS_TEXTURE_SIZE, ATLAS_TEXTURE_SIZE);
			ctx.fillStyle = "#ffffff";
			ctx.font = `${fontSize}px "${fontFamily}", ${fontFamily}, monospace`;
			if (!ctx.font.includes(fontFamily) && !ctx.font.includes("IBM") && !ctx.font.includes("Plex")) ctx.font = `${fontSize}px ${fontFamily}, monospace`;
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			for (let i = 0; i < charCount$1; i++) {
				const char = characters[i];
				const row = Math.floor(i / atlasSize$1);
				const x = i % atlasSize$1 * actualCellSize + actualCellSize / 2;
				const y = row * actualCellSize + actualCellSize / 2;
				ctx.fillText(char, x, y);
			}
			const imageData = ctx.getImageData(0, 0, ATLAS_TEXTURE_SIZE, ATLAS_TEXTURE_SIZE);
			if (!reusableDataBuffer) reusableDataBuffer = new Uint8Array(ATLAS_TEXTURE_SIZE * ATLAS_TEXTURE_SIZE * 4);
			reusableDataBuffer.set(imageData.data);
			return {
				data: reusableDataBuffer,
				width: ATLAS_TEXTURE_SIZE,
				height: ATLAS_TEXTURE_SIZE,
				atlasSize: atlasSize$1,
				cellSize,
				charCount: charCount$1,
				characters,
				fontFamily,
				uvScale: atlasSize$1 * actualCellSize / ATLAS_TEXTURE_SIZE
			};
		};
		const defaultCharacters = componentDefinition.props.characters.default;
		const defaultCellSize = componentDefinition.props.cellSize.default;
		const defaultFontFamily = componentDefinition.props.fontFamily.default;
		const defaultSpacing = componentDefinition.props.spacing.transform ? componentDefinition.props.spacing.transform(componentDefinition.props.spacing.default) : componentDefinition.props.spacing.default;
		const initialCharacters = uniforms?.characters?.uniform?.value ?? defaultCharacters;
		const initialCellSize = uniforms?.cellSize?.uniform?.value ?? defaultCellSize;
		const initialFontFamily = uniforms?.fontFamily?.uniform?.value ?? defaultFontFamily;
		const initialSpacing = uniforms?.spacing?.uniform?.value ?? defaultSpacing;
		let atlasData = {
			data: new Uint8Array(ATLAS_TEXTURE_SIZE * ATLAS_TEXTURE_SIZE * 4),
			width: ATLAS_TEXTURE_SIZE,
			height: ATLAS_TEXTURE_SIZE,
			atlasSize: 3,
			cellSize: initialCellSize,
			charCount: initialCharacters.length,
			characters: initialCharacters,
			fontFamily: initialFontFamily,
			uvScale: 1
		};
		const atlasTexture = new DataTexture(atlasData.data, ATLAS_TEXTURE_SIZE, ATLAS_TEXTURE_SIZE, RGBAFormat, UnsignedByteType);
		atlasTexture.minFilter = NearestFilter;
		atlasTexture.magFilter = NearestFilter;
		atlasTexture.generateMipmaps = false;
		atlasTexture.needsUpdate = true;
		const atlasField = texture(atlasTexture);
		const charCountUniform = uniform(atlasData.charCount);
		const cellSizeUniform = uniform(atlasData.cellSize);
		const atlasScaleUniform = uniform(atlasData.uvScale);
		let lastCharacters = initialCharacters;
		let lastCellSize = initialCellSize;
		let lastFontFamily = initialFontFamily;
		let lastSpacing = initialSpacing;
		const initializeAtlas = async () => {
			const currentCharacters = uniforms?.characters?.uniform?.value ?? lastCharacters;
			const currentCellSize = uniforms?.cellSize?.uniform?.value ?? lastCellSize;
			const currentFontFamily = uniforms?.fontFamily?.uniform?.value ?? lastFontFamily;
			const currentSpacing = uniforms?.spacing?.uniform?.value ?? lastSpacing;
			atlasData = await createCharacterAtlas(currentCharacters, currentCellSize, currentFontFamily, currentSpacing);
			atlasTexture.image.data = atlasData.data;
			atlasTexture.needsUpdate = true;
			charCountUniform.value = atlasData.charCount;
			cellSizeUniform.value = atlasData.cellSize;
			atlasScaleUniform.value = atlasData.uvScale;
			lastCharacters = currentCharacters;
			lastCellSize = currentCellSize;
			lastFontFamily = currentFontFamily;
			lastSpacing = currentSpacing;
		};
		setTimeout(() => {
			initializeAtlas().catch((error) => {
				console.error("Failed to initialize atlas:", error);
			});
			loadGoogleFont(uniforms?.fontFamily?.uniform?.value ?? initialFontFamily).then(() => {
				initializeAtlas().catch((error) => {
					console.error("Failed to update atlas with custom font:", error);
				});
			}).catch((error) => {
				console.error("Failed to load font:", error);
			});
		}, 0);
		let lastUpdateTime = 0;
		let isUpdating = false;
		onBeforeRender(() => {
			const now = Date.now();
			if (now - lastUpdateTime < 16 || isUpdating) return;
			const currentCharacters = uniforms.characters?.uniform?.value ?? lastCharacters;
			const currentCellSize = uniforms.cellSize?.uniform?.value ?? lastCellSize;
			const currentFontFamily = uniforms.fontFamily?.uniform?.value ?? lastFontFamily;
			const currentSpacing = uniforms.spacing?.uniform?.value ?? lastSpacing;
			if (!currentCharacters || currentCharacters.length === 0) return;
			if (currentCharacters !== lastCharacters || currentCellSize !== lastCellSize || currentFontFamily !== lastFontFamily || currentSpacing !== lastSpacing) {
				lastUpdateTime = now;
				isUpdating = true;
				createCharacterAtlas(currentCharacters, currentCellSize, currentFontFamily, currentSpacing).then((newAtlasData) => {
					atlasData = newAtlasData;
					atlasTexture.image.data = atlasData.data;
					atlasTexture.needsUpdate = true;
					charCountUniform.value = atlasData.charCount;
					cellSizeUniform.value = atlasData.cellSize;
					atlasScaleUniform.value = atlasData.uvScale;
					lastCharacters = currentCharacters;
					lastCellSize = currentCellSize;
					lastFontFamily = currentFontFamily;
					lastSpacing = currentSpacing;
					isUpdating = false;
				}).catch((error) => {
					console.error("Failed to update atlas:", error);
					isUpdating = false;
				});
			}
		});
		onCleanup(() => {
			atlasTexture.dispose();
			if (reusableCanvas) {
				reusableCanvas.width = 0;
				reusableCanvas.height = 0;
				reusableCanvas = null;
				reusableCtx = null;
			}
			reusableDataBuffer = null;
		});
		const effectiveCellSize = cellSizeUniform.mul(1.5);
		const mainGridSize = viewportSize.div(effectiveCellSize);
		const gridCoords = screenUV.mul(mainGridSize);
		const cellCoords = floor(gridCoords);
		const rawCellUV = fract(gridCoords);
		const characterSize = uniforms.spacing?.uniform ?? uniform(initialSpacing);
		const center = vec2(.5);
		const centeredUV = rawCellUV.sub(center);
		const cellUV = centeredUV.div(characterSize).add(center);
		const isOutsideBounds = any(greaterThan(abs(centeredUV), vec2(characterSize.mul(.5))));
		const cellCenter = cellCoords.add(vec2(.5)).div(mainGridSize);
		const cellColor = childTexture.sample(cellCenter);
		const rawBrightness = dot(cellColor.rgb, vec3(.299, .587, .114));
		const charCount = charCountUniform;
		const charIndex = floor(rawBrightness.mul(.8).add(.1).mul(charCount).min(charCount.sub(1e-4)));
		const atlasSize = ceil(sqrt(charCount));
		const atlasCol = charIndex.mod(atlasSize);
		const atlasRow = floor(charIndex.div(atlasSize));
		const atlasCellSize = float(1).div(atlasSize).mul(atlasScaleUniform);
		const atlasSampleUV = vec2(atlasCol, atlasRow).mul(atlasCellSize).add(cellUV.mul(atlasCellSize));
		const asciiChar = atlasField.sample(atlasSampleUV);
		const isBackground = dot(asciiChar.rgb, vec3(.299, .587, .114)).lessThan(.1);
		return vec4(asciiChar.rgb.mul(cellColor.rgb), select(or(isBackground, isOutsideBounds), float(0), cellColor.a));
	}
};
var Ascii_default = componentDefinition;
export { componentDefinition as n, Ascii_default as t };
