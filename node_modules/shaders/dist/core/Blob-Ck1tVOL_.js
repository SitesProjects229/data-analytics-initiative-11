import { i as transformColorSpace, r as transformColor, s as transformPosition, t as colorSpaceOptions } from "./transformations-YbhRK-rd.js";
import { t as createAnimatedTime } from "./time-BZqyVJXt.js";
import { t as mixColors } from "./colorMixing-CZPFmiT4.js";
import { dot, float, length, max, normalize, pow, reflect, screenUV, sin, smoothstep, vec2, vec3, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "Blob",
	category: "Base Layers",
	description: "Organic animated blob with 3D lighting and gradients",
	props: {
		colorA: {
			default: "#ff6b35",
			transform: transformColor,
			description: "Primary color of the blob",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#e91e63",
			transform: transformColor,
			description: "Secondary color of the blob",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		size: {
			default: .5,
			description: "Size of the blob",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Size"
			}
		},
		deformation: {
			default: .5,
			description: "How organic and blobby the shape is (0 = circle, 1 = very blobby)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Deformation"
			}
		},
		softness: {
			default: .5,
			description: "Softness of the blob edges (combines edge width and transition curve)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Softness"
			}
		},
		highlightIntensity: {
			default: .5,
			description: "Intensity of specular highlight effect",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Highlight Intensity"
			}
		},
		highlightX: {
			default: .3,
			description: "Light direction X component",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Highlight X"
			}
		},
		highlightY: {
			default: -.3,
			description: "Light direction Y component",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Highlight Y"
			}
		},
		highlightZ: {
			default: .4,
			description: "Light direction Z component",
			ui: {
				type: "range",
				min: -1,
				max: 1,
				step: .01,
				label: "Highlight Z"
			}
		},
		highlightColor: {
			default: "#ffe11a",
			transform: transformColor,
			description: "Color of the specular highlight",
			ui: {
				type: "color",
				label: "Highlight Color"
			}
		},
		speed: {
			default: .5,
			description: "Animation speed",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .1,
				label: "Speed"
			}
		},
		seed: {
			default: 1,
			description: "Adjusts the starting state, useful for variation",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Seed"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the blob",
			ui: {
				type: "position",
				label: "Center Position"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const baseUV = screenUV;
		const animTime = createAnimatedTime(params, uniforms.speed, uniforms.seed);
		const colorA = uniforms.colorA.uniform;
		const colorB = uniforms.colorB.uniform;
		const size = uniforms.size.uniform;
		const deformation = uniforms.deformation.uniform;
		const softness = uniforms.softness.uniform;
		const highlightIntensity = uniforms.highlightIntensity.uniform;
		const highlightX = uniforms.highlightX.uniform;
		const highlightY = uniforms.highlightY.uniform;
		const highlightZ = uniforms.highlightZ.uniform;
		const highlightColor = uniforms.highlightColor.uniform;
		const edgeWidth = softness.mul(float(.3));
		const edgeCurve = softness.mul(float(2)).add(float(.5));
		const edgeComplexity = float(.5);
		const aspect = viewportSize.x.div(viewportSize.y);
		const aspectCorrectedUV = vec2(baseUV.x.mul(aspect), baseUV.y);
		const centerPos = vec2(uniforms.center.uniform.x.mul(aspect), uniforms.center.uniform.y.oneMinus());
		const uv$1 = aspectCorrectedUV.sub(centerPos);
		const dist = length(uv$1);
		const baseRadius = size;
		const noiseScale = float(4);
		const noise1 = sin(uv$1.x.mul(noiseScale.mul(float(.8))).add(animTime.mul(float(.8)))).mul(sin(uv$1.y.mul(noiseScale.mul(float(.7))).add(animTime.mul(float(.6))))).add(sin(uv$1.x.mul(noiseScale.mul(float(1.2))).sub(uv$1.y.mul(noiseScale.mul(float(.9))).add(animTime.mul(float(.4)))))).mul(float(.15)).mul(deformation);
		const noise2 = sin(uv$1.x.mul(noiseScale.mul(float(1.4))).sub(animTime.mul(float(.5)))).mul(sin(uv$1.y.mul(noiseScale.mul(float(1.1))).add(animTime.mul(float(.7))))).mul(float(.12)).mul(deformation).mul(smoothstep(float(.15), float(.25), edgeComplexity));
		const noise3 = sin(uv$1.x.mul(noiseScale.mul(float(1.8))).add(uv$1.y.mul(noiseScale.mul(float(1.6))).add(animTime.mul(float(.3))))).add(sin(uv$1.x.mul(noiseScale.mul(float(.6))).sub(animTime.mul(float(.9))))).mul(float(.1)).mul(deformation).mul(smoothstep(float(.3), float(.4), edgeComplexity));
		const noise4 = sin(uv$1.x.mul(noiseScale.mul(float(2.2))).add(animTime.mul(float(.2)))).mul(sin(uv$1.y.mul(noiseScale.mul(float(1.9))).sub(animTime.mul(float(.8))))).mul(float(.08)).mul(deformation).mul(smoothstep(float(.45), float(.55), edgeComplexity));
		const noise5 = sin(uv$1.x.mul(noiseScale.mul(float(2.8))).sub(uv$1.y.mul(noiseScale.mul(float(2.4))).add(animTime.mul(float(.6))))).mul(float(.06)).mul(deformation).mul(smoothstep(float(.6), float(.7), edgeComplexity));
		const noise6 = sin(uv$1.x.mul(noiseScale.mul(float(3.2))).add(animTime.mul(float(1.1)))).add(sin(uv$1.y.mul(noiseScale.mul(float(3.5))).sub(animTime.mul(float(.4))))).mul(float(.04)).mul(deformation).mul(smoothstep(float(.75), float(.85), edgeComplexity));
		const noiseAmount = noise1.add(noise2).add(noise3).add(noise4).add(noise5).add(noise6);
		const organicRadius = baseRadius.add(noiseAmount);
		const blobMask = pow(smoothstep(organicRadius.add(edgeWidth), organicRadius.sub(edgeWidth), dist), edgeCurve);
		const distFromCenter = length(uv$1);
		const sphereRadius = organicRadius;
		const normalTilt = smoothstep(float(0), sphereRadius, distFromCenter);
		const fakeZ = float(1).sub(normalTilt.mul(float(.1)));
		const surfaceNormal = normalize(vec3(uv$1.x.mul(normalTilt.add(float(.2))), uv$1.y.mul(normalTilt.add(float(.2))), fakeZ));
		const lightDir = normalize(vec3(highlightX, highlightY, highlightZ));
		const viewDir = vec3(float(0), float(0), float(1));
		const reflectDir = reflect(lightDir.negate(), surfaceNormal);
		const specularPower = float(32);
		const specular = pow(max(float(0), dot(reflectDir, viewDir)), specularPower);
		const curvatureBoost = normalTilt.mul(float(.5)).add(float(.5));
		const finalHighlight = specular.mul(curvatureBoost).mul(highlightIntensity).mul(blobMask);
		const posX = uv$1.x.mul(float(3));
		const posY = uv$1.y.mul(float(3));
		const colorNoise1 = sin(posX.add(animTime.mul(float(.4)))).mul(sin(posY.add(animTime.mul(float(.3))))).add(sin(posX.mul(float(.7)).add(posY.mul(float(.8))).add(animTime.mul(float(.2))))).mul(float(.5)).add(float(.5));
		const colorNoise2 = sin(posX.mul(float(1.3)).sub(animTime.mul(float(.5)))).mul(sin(posY.mul(float(1.1)).add(animTime.mul(float(.6))))).add(sin(posX.mul(float(.5)).sub(posY.mul(float(.6)).sub(animTime.mul(float(.3)))))).mul(float(.5)).add(float(.5));
		const combinedNoise = colorNoise1.mul(float(.6)).add(colorNoise2.mul(float(.4)));
		const finalColorRGB = mixColors(colorA, colorB, smoothstep(float(.1), float(.9), combinedNoise), uniforms.colorSpace.uniform).rgb;
		const avgAlpha = colorA.a.add(colorB.a).div(float(2));
		const highlightContribution = highlightColor.rgb.mul(finalHighlight);
		return vec4(finalColorRGB.add(highlightContribution), avgAlpha.mul(blobMask));
	}
};
var Blob_default = componentDefinition;
export { componentDefinition as n, Blob_default as t };
