import { r as transformColor, s as transformPosition } from "./transformations-YbhRK-rd.js";
import { t as createAnimatedTime } from "./time-BZqyVJXt.js";
import { Fn, PI, abs, atan, clamp, float, length, mix, pow, screenUV, sin, smoothstep, vec2, vec4 } from "three/tsl";
const componentDefinition = {
	name: "Godrays",
	category: "Base Layers",
	description: "Volumetric light rays emanating from a point",
	requiresRTT: false,
	props: {
		center: {
			default: {
				x: 0,
				y: 0
			},
			transform: transformPosition,
			description: "The center point of the god rays",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		density: {
			default: .3,
			description: "Frequency of ray sectors",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Density"
			}
		},
		intensity: {
			default: .8,
			description: "Ray visibility within sectors",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Intensity"
			}
		},
		spotty: {
			default: 1,
			description: "Density of spots on rays (higher = more spots)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Spotty"
			}
		},
		speed: {
			default: .5,
			description: "Animation speed of the rays",
			ui: {
				type: "range",
				min: 0,
				max: 2,
				step: .01,
				label: "Speed"
			}
		},
		rayColor: {
			default: "#4283fb",
			transform: transformColor,
			description: "Color of the light rays",
			ui: {
				type: "color",
				label: "Ray Color"
			}
		},
		backgroundColor: {
			default: "transparent",
			transform: transformColor,
			description: "Background color",
			ui: {
				type: "color",
				label: "Background Color"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms } = params;
		const uv$1 = screenUV;
		const centerPos = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const shapeUV = uv$1.sub(centerPos);
		const valueNoise = Fn(([st]) => {
			const i = st.floor();
			const f = st.fract();
			const hash = (p) => {
				return sin(p.x.mul(127.1).add(p.y.mul(311.7))).mul(43758.5453).fract();
			};
			const a = hash(i);
			const b = hash(i.add(vec2(1, 0)));
			const c = hash(i.add(vec2(0, 1)));
			const d = hash(i.add(vec2(1, 1)));
			const u = f.mul(f).mul(f.mul(-2).add(3));
			return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
		});
		const raysShape = Fn(([uv$2, r, freq, intensity]) => {
			const a = atan(uv$2.y, uv$2.x);
			const left = vec2(a.mul(freq), r);
			const right = vec2(a.mod(PI.mul(2)).mul(freq), r);
			const nLeft = pow(valueNoise(left), intensity);
			return mix(pow(valueNoise(right), intensity), nLeft, smoothstep(-.15, .15, uv$2.x));
		});
		const animTime = createAnimatedTime(params, uniforms.speed).mul(.2);
		const rayEffect = Fn(() => {
			const radius = length(shapeUV);
			const spots = float(6.5).mul(abs(uniforms.spotty.uniform));
			const intensityCalc = float(4).sub(float(3).mul(clamp(uniforms.intensity.uniform, 0, 1)));
			const density = float(6).mul(uniforms.density.uniform);
			const accumRay = float(0).toVar();
			const r1 = radius.mul(1).sub(animTime.mul(3));
			const r2 = radius.mul(.5).mul(float(1).add(spots)).sub(animTime.mul(2));
			const f1 = density.mul(5);
			const ray = raysShape(shapeUV, r1, f1, intensityCalc).toVar();
			ray.assign(ray.mul(raysShape(shapeUV, r2, f1.mul(4), intensityCalc)));
			accumRay.assign(accumRay.add(ray));
			const r3 = radius.mul(1.4).sub(animTime.mul(2.5));
			const r4 = radius.mul(.7).mul(float(1).add(spots)).sub(animTime.mul(1.8));
			const f2 = density.mul(4.5);
			const ray2 = raysShape(shapeUV, r3, f2, intensityCalc).toVar();
			ray2.assign(ray2.mul(raysShape(shapeUV, r4, f2.mul(3.5), intensityCalc)));
			accumRay.assign(accumRay.add(ray2.mul(.7)));
			return clamp(accumRay, 0, 1);
		})();
		const rayColorRGB = uniforms.rayColor.uniform.rgb;
		const rayColorA = uniforms.rayColor.uniform.a;
		const bgColorRGB = uniforms.backgroundColor.uniform.rgb;
		const bgColorA = uniforms.backgroundColor.uniform.a;
		const rayAlpha = rayEffect.mul(rayColorA);
		const finalAlpha = rayAlpha.add(bgColorA.mul(float(1).sub(rayAlpha)));
		const safeAlpha = clamp(finalAlpha, .001, 1);
		const rayContribution = rayColorRGB.mul(rayAlpha);
		const bgContribution = bgColorRGB.mul(bgColorA).mul(float(1).sub(rayAlpha));
		return vec4(rayContribution.add(bgContribution).div(safeAlpha), finalAlpha);
	}
};
var Godrays_default = componentDefinition;
export { componentDefinition as n, Godrays_default as t };
