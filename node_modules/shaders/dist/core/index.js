import { t as applyEdgeHandling } from "./edges-Bd7GP4s2.js";
import { a as transformColorUpdate, c as transformPositionUpdate, r as transformColor, s as transformPosition } from "./transformations-YbhRK-rd.js";
import { t as createAnimatedTime } from "./time-BZqyVJXt.js";
import { Material, Mesh, MeshBasicNodeMaterial, OrthographicCamera, PlaneGeometry, SRGBColorSpace, Scene, WebGPURenderer } from "three/webgpu";
import { WebGLRenderer } from "three";
import { PI, abs, add, atan, convertToTexture, cos, div, dot, float, fract, max, min, mix, mul, pow, screenUV, sin, smoothstep, sqrt, step, sub, time, uniform, uv, vec2, vec3, vec4 } from "three/tsl";
function normal_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(overlay.rgb, overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
var p3ToSRGB$1 = (p3) => {
	return vec3(p3.x.mul(1.2249401).sub(p3.y.mul(.2249404)).sub(p3.z.mul(0)), p3.x.mul(-.0420569).add(p3.y.mul(1.0420571)).add(p3.z.mul(0)), p3.x.mul(-.0196376).sub(p3.y.mul(.0786361)).add(p3.z.mul(1.0982735)));
};
var sRGBToP3$1 = (srgb) => {
	return vec3(srgb.x.mul(.8224621).add(srgb.y.mul(.177538)).add(srgb.z.mul(0)), srgb.x.mul(.0331941).add(srgb.y.mul(.9668058)).add(srgb.z.mul(0)), srgb.x.mul(.0170826).add(srgb.y.mul(.0723974)).add(srgb.z.mul(.9105199)));
};
var rgbToOklab$1 = (rgb) => {
	const r = rgb.x;
	const g = rgb.y;
	const b = rgb.z;
	const l = r.mul(.4122214708).add(g.mul(.5363325363)).add(b.mul(.0514459929));
	const m = r.mul(.2119034982).add(g.mul(.6806995451).add(b.mul(.1073969566)));
	const s = r.mul(.0883024619).add(g.mul(.2817188376)).add(b.mul(.6299787005));
	const l_ = pow(l, float(1 / 3));
	const m_ = pow(m, float(1 / 3));
	const s_ = pow(s, float(1 / 3));
	return vec3(l_.mul(.2104542553).add(m_.mul(.793617785)).sub(s_.mul(.0040720468)), l_.mul(1.9779984951).sub(m_.mul(2.428592205)).add(s_.mul(.4505937099)), l_.mul(.0259040371).add(m_.mul(.7827717662)).sub(s_.mul(.808675766)));
};
var oklabToRgb$1 = (lab) => {
	const L = lab.x;
	const a = lab.y;
	const b = lab.z;
	const l_ = L.add(a.mul(.3963377774)).add(b.mul(.2158037573));
	const m_ = L.sub(a.mul(.1055613458)).sub(b.mul(.0638541728));
	const s_ = L.sub(a.mul(.0894841775)).sub(b.mul(1.291485548));
	const l = pow(l_, float(3));
	const m = pow(m_, float(3));
	const s = pow(s_, float(3));
	return vec3(l.mul(4.0767416621).sub(m.mul(3.3077115913)).add(s.mul(.2309699292)), l.mul(-1.2684380046).add(m.mul(2.6097574011)).sub(s.mul(.3413193965)), l.mul(-.0041960863).sub(m.mul(.7034186147)).add(s.mul(1.707614701)));
};
var oklabToOklch = (lab) => {
	const L = lab.x;
	const a = lab.y;
	const b = lab.z;
	return vec3(L, sqrt(a.mul(a).add(b.mul(b))), atan(b, a));
};
var oklchToOklab = (lch) => {
	const L = lch.x;
	const C = lch.y;
	const h = lch.z;
	return vec3(L, C.mul(cos(h)), C.mul(sin(h)));
};
function normal_oklch_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const baseSRGB = p3ToSRGB$1(vec3(base.r, base.g, base.b));
	const overlaySRGB = p3ToSRGB$1(vec3(overlay.r, overlay.g, overlay.b));
	const baseOklab = rgbToOklab$1(baseSRGB);
	const overlayOklab = rgbToOklab$1(overlaySRGB);
	const baseOklch = oklabToOklch(baseOklab);
	return vec4(sRGBToP3$1(oklabToRgb$1(oklchToOklab(add(mul(oklabToOklch(overlayOklab), overlayAlpha), mul(baseOklch, mul(base.a, sub(1, overlayAlpha))))))), finalAlpha);
}
var p3ToSRGB = (p3) => {
	return vec3(p3.x.mul(1.2249401).sub(p3.y.mul(.2249404)).sub(p3.z.mul(0)), p3.x.mul(-.0420569).add(p3.y.mul(1.0420571)).add(p3.z.mul(0)), p3.x.mul(-.0196376).sub(p3.y.mul(.0786361)).add(p3.z.mul(1.0982735)));
};
var sRGBToP3 = (srgb) => {
	return vec3(srgb.x.mul(.8224621).add(srgb.y.mul(.177538)).add(srgb.z.mul(0)), srgb.x.mul(.0331941).add(srgb.y.mul(.9668058)).add(srgb.z.mul(0)), srgb.x.mul(.0170826).add(srgb.y.mul(.0723974)).add(srgb.z.mul(.9105199)));
};
var rgbToOklab = (rgb) => {
	const r = rgb.x;
	const g = rgb.y;
	const b = rgb.z;
	const l = r.mul(.4122214708).add(g.mul(.5363325363)).add(b.mul(.0514459929));
	const m = r.mul(.2119034982).add(g.mul(.6806995451).add(b.mul(.1073969566)));
	const s = r.mul(.0883024619).add(g.mul(.2817188376)).add(b.mul(.6299787005));
	const l_ = pow(l, float(1 / 3));
	const m_ = pow(m, float(1 / 3));
	const s_ = pow(s, float(1 / 3));
	return vec3(l_.mul(.2104542553).add(m_.mul(.793617785)).sub(s_.mul(.0040720468)), l_.mul(1.9779984951).sub(m_.mul(2.428592205)).add(s_.mul(.4505937099)), l_.mul(.0259040371).add(m_.mul(.7827717662)).sub(s_.mul(.808675766)));
};
var oklabToRgb = (lab) => {
	const L = lab.x;
	const a = lab.y;
	const b = lab.z;
	const l_ = L.add(a.mul(.3963377774)).add(b.mul(.2158037573));
	const m_ = L.sub(a.mul(.1055613458)).sub(b.mul(.0638541728));
	const s_ = L.sub(a.mul(.0894841775)).sub(b.mul(1.291485548));
	const l = pow(l_, float(3));
	const m = pow(m_, float(3));
	const s = pow(s_, float(3));
	return vec3(l.mul(4.0767416621).sub(m.mul(3.3077115913)).add(s.mul(.2309699292)), l.mul(-1.2684380046).add(m.mul(2.6097574011)).sub(s.mul(.3413193965)), l.mul(-.0041960863).sub(m.mul(.7034186147)).add(s.mul(1.707614701)));
};
function normal_oklab_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const baseSRGB = p3ToSRGB(vec3(base.r, base.g, base.b));
	const overlaySRGB = p3ToSRGB(vec3(overlay.r, overlay.g, overlay.b));
	const baseOklab = rgbToOklab(baseSRGB);
	return vec4(sRGBToP3(oklabToRgb(add(mul(rgbToOklab(overlaySRGB), overlayAlpha), mul(baseOklab, mul(base.a, sub(1, overlayAlpha)))))), finalAlpha);
}
function multiply_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(mul(base.rgb, overlay.rgb), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function screen_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(sub(1, mul(sub(1, base.rgb), sub(1, overlay.rgb))), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function linearDodge_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(min(add(base.rgb, overlay.rgb), 1), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function overlay_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(mix(mul(2, mul(base.rgb, overlay.rgb)), sub(1, mul(2, mul(sub(1, base.rgb), sub(1, overlay.rgb)))), step(.5, base.rgb)), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function difference_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(abs(sub(base.rgb, overlay.rgb)), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function colorDodge_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(mix(base.rgb, min(div(base.rgb, sub(1, overlay.rgb)), 1), step(.001, sub(1, overlay.rgb))), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function exclusion_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(sub(add(base.rgb, overlay.rgb), mul(2, mul(base.rgb, overlay.rgb))), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function getLuminance(rgb) {
	return add(add(mul(rgb.r, .2126), mul(rgb.g, .7152)), mul(rgb.b, .0722));
}
function color_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const lumDiff = sub(getLuminance(base.rgb), getLuminance(overlay.rgb));
	return vec4(add(mul(add(overlay.rgb, lumDiff), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function luminosity_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const baseLum = getLuminance(base.rgb);
	const lumRatio = getLuminance(overlay.rgb).div(add(baseLum, 1e-4));
	return vec4(add(mul(mul(base.rgb, lumRatio), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function darken_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(min(base.rgb, overlay.rgb), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function lighten_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(max(base.rgb, overlay.rgb), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function colorBurn_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(mix(vec4(0, 0, 0, 1).rgb, max(sub(1, sub(1, base.rgb).div(add(overlay.rgb, 1e-4))), 0), step(1e-4, overlay.rgb)), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function linearBurn_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(max(add(add(base.rgb, overlay.rgb), -1), 0), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function softLight_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const softLightDark = add(mul(2, mul(base.rgb, overlay.rgb)), mul(mul(base.rgb, base.rgb), sub(1, mul(2, overlay.rgb))));
	const baseSqrt = sqrt(base.rgb);
	return vec4(add(mul(mix(softLightDark, add(mul(2, mul(base.rgb, sub(1, overlay.rgb))), mul(baseSqrt, sub(mul(2, overlay.rgb), 1))), step(.5, overlay.rgb)), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function hardLight_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	return vec4(add(mul(mix(mul(2, mul(base.rgb, overlay.rgb)), sub(1, mul(2, mul(sub(1, base.rgb), sub(1, overlay.rgb)))), step(.5, overlay.rgb)), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function hue_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const baseLum = getLuminance(base.rgb);
	const overlayLum = getLuminance(overlay.rgb);
	const baseChromaticity = base.rgb.sub(baseLum);
	const overlayChromaticity = overlay.rgb.sub(overlayLum);
	const baseChromaLength = baseChromaticity.length();
	return vec4(add(mul(add(mul(overlayChromaticity.normalize(), baseChromaLength), baseLum), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
function saturation_default(base, overlay, opacity = 1) {
	const overlayAlpha = mul(overlay.a, opacity);
	const finalAlpha = add(overlayAlpha, mul(base.a, sub(1, overlayAlpha)));
	const baseLum = getLuminance(base.rgb);
	const overlayLum = getLuminance(overlay.rgb);
	const baseChromaticity = base.rgb.sub(baseLum);
	const overlayChromaticity = overlay.rgb.sub(overlayLum);
	return vec4(add(mul(add(mul(baseChromaticity.normalize(), overlayChromaticity.length()), baseLum), overlayAlpha), mul(base.rgb, mul(base.a, sub(1, overlayAlpha)))), finalAlpha);
}
var blendModes = {
	normal: normal_default,
	"normal-oklch": normal_oklch_default,
	"normal-oklab": normal_oklab_default,
	multiply: multiply_default,
	screen: screen_default,
	linearDodge: linearDodge_default,
	overlay: overlay_default,
	difference: difference_default,
	colorDodge: colorDodge_default,
	exclusion: exclusion_default,
	color: color_default,
	luminosity: luminosity_default,
	darken: darken_default,
	lighten: lighten_default,
	colorBurn: colorBurn_default,
	linearBurn: linearBurn_default,
	softLight: softLight_default,
	hardLight: hardLight_default,
	hue: hue_default,
	saturation: saturation_default
};
function applyBlendMode(baseNode, overlayNode, blendMode = "normal", opacity = 1) {
	return (blendModes[blendMode] || blendModes.normal)(baseNode, overlayNode, opacity);
}
function alpha_default(target, mask) {
	const maskedAlpha = mul(target.a, mask.a);
	return vec4(target.rgb, maskedAlpha);
}
function alphaInverted_default(target, mask) {
	const invertedMaskAlpha = sub(1, mask.a);
	const maskedAlpha = mul(target.a, invertedMaskAlpha);
	return vec4(target.rgb, maskedAlpha);
}
function luminance_default(target, mask) {
	const luminanceWeights = vec3(.2126, .7152, .0722);
	const luminance = dot(mask.rgb, luminanceWeights);
	const maskedAlpha = mul(target.a, luminance);
	return vec4(target.rgb, maskedAlpha);
}
function luminanceInverted_default(target, mask) {
	const luminanceWeights = vec3(.2126, .7152, .0722);
	const invertedLuminance = sub(1, dot(mask.rgb, luminanceWeights));
	const maskedAlpha = mul(target.a, invertedLuminance);
	return vec4(target.rgb, maskedAlpha);
}
var maskFunctions = {
	"alpha": alpha_default,
	"alphaInverted": alphaInverted_default,
	"luminance": luminance_default,
	"luminanceInverted": luminanceInverted_default
};
function applyMask(target, mask, maskType = "alpha") {
	return (maskFunctions[maskType] || maskFunctions["alpha"])(target, mask);
}
var PerformanceTracker = class {
	frameTimesMs = [];
	maxSamples = 60;
	targetFrameTime = 16.67;
	jankFrameCount = 0;
	totalFrameCount = 0;
	memorySnapshots = [];
	memorySnapshotIndex = 0;
	maxMemorySnapshots = 300;
	nodeCount = 0;
	rttNodeCount = 0;
	lastCpuTime = null;
	lastGpuTime = null;
	isRendering = false;
	lastFrameTimestamp = 0;
	frameIntervals = [];
	recordFrame(frameTimeMs) {
		this.frameTimesMs.push(frameTimeMs);
		if (this.frameTimesMs.length > this.maxSamples) this.frameTimesMs.shift();
		this.totalFrameCount++;
		if (frameTimeMs > this.targetFrameTime) this.jankFrameCount++;
		const now = performance.now();
		if (this.lastFrameTimestamp > 0) {
			const interval = now - this.lastFrameTimestamp;
			this.frameIntervals.push(interval);
			if (this.frameIntervals.length > this.maxSamples) this.frameIntervals.shift();
		}
		this.lastFrameTimestamp = now;
		this.recordMemorySnapshot();
	}
	recordCpuTime(timeMs) {
		this.lastCpuTime = timeMs;
	}
	recordGpuTime(timeMs) {
		this.lastGpuTime = timeMs;
	}
	updateNodeCounts(nodeCount, rttNodeCount) {
		this.nodeCount = nodeCount;
		this.rttNodeCount = rttNodeCount;
	}
	setRendering(rendering) {
		this.isRendering = rendering;
	}
	recordMemorySnapshot() {
		if (!performance.memory) return;
		const now = performance.now();
		const bytes = performance.memory.usedJSHeapSize;
		if (this.memorySnapshots.length < this.maxMemorySnapshots) this.memorySnapshots.push({
			time: now,
			bytes
		});
		else {
			const entry = this.memorySnapshots[this.memorySnapshotIndex];
			entry.time = now;
			entry.bytes = bytes;
			this.memorySnapshotIndex = (this.memorySnapshotIndex + 1) % this.maxMemorySnapshots;
		}
	}
	calculateMemoryGrowthRate() {
		if (this.memorySnapshots.length < 2) return null;
		const len = this.memorySnapshots.length;
		const oldestIdx = len < this.maxMemorySnapshots ? 0 : this.memorySnapshotIndex;
		const newestIdx = len < this.maxMemorySnapshots ? len - 1 : (this.memorySnapshotIndex - 1 + len) % len;
		const oldest = this.memorySnapshots[oldestIdx];
		const newest = this.memorySnapshots[newestIdx];
		const timeDeltaSeconds = (newest.time - oldest.time) / 1e3;
		if (timeDeltaSeconds <= 0) return null;
		return (newest.bytes - oldest.bytes) / (1024 * 1024) / timeDeltaSeconds;
	}
	calculateStdDev(values) {
		if (values.length === 0) return 0;
		const mean = values.reduce((a, b) => a + b, 0) / values.length;
		let sumSquaredDiff = 0;
		for (let i = 0; i < values.length; i++) {
			const diff = values[i] - mean;
			sumSquaredDiff += diff * diff;
		}
		return Math.sqrt(sumSquaredDiff / values.length);
	}
	sortBuffer = [];
	calculateP99(values) {
		const len = values.length;
		if (len === 0) return 0;
		while (this.sortBuffer.length < len) this.sortBuffer.push(0);
		for (let i = 0; i < len; i++) this.sortBuffer[i] = values[i];
		for (let i = 1; i < len; i++) {
			const current = this.sortBuffer[i];
			let j = i - 1;
			while (j >= 0 && this.sortBuffer[j] > current) {
				this.sortBuffer[j + 1] = this.sortBuffer[j];
				j--;
			}
			this.sortBuffer[j + 1] = current;
		}
		const index = Math.floor(len * .99);
		return this.sortBuffer[Math.min(index, len - 1)];
	}
	calculateComplexityScore() {
		return this.nodeCount + this.rttNodeCount * 10;
	}
	calculateIntensityScore() {
		const frameCount = this.frameTimesMs.length;
		if (frameCount === 0) return {
			score: 0,
			label: "N/A"
		};
		const avgFrameTime = this.frameTimesMs.reduce((a, b) => a + b, 0) / frameCount;
		const frameTimeScore = Math.min(avgFrameTime / 16.67 * 100, 100);
		const complexity = this.calculateComplexityScore();
		const complexityScore = Math.min(complexity / 100 * 100, 100);
		let gpuTimeScore = 0;
		if (this.lastGpuTime !== null) gpuTimeScore = Math.min(this.lastGpuTime / 16.67 * 100, 100);
		const weights = this.lastGpuTime !== null ? {
			frame: .4,
			gpu: .4,
			complexity: .2
		} : {
			frame: .7,
			gpu: 0,
			complexity: .3
		};
		const finalScore = Math.round(frameTimeScore * weights.frame + gpuTimeScore * weights.gpu + complexityScore * weights.complexity);
		let label;
		if (finalScore <= 20) label = "Very Light";
		else if (finalScore <= 40) label = "Light";
		else if (finalScore <= 60) label = "Medium";
		else if (finalScore <= 80) label = "Heavy";
		else label = "Very Heavy";
		return {
			score: Math.min(finalScore, 100),
			label
		};
	}
	getStats(rendererInfo) {
		const frameCount = this.frameTimesMs.length;
		const fps = this.frameIntervals.length > 0 ? 1e3 / (this.frameIntervals.reduce((a, b) => a + b, 0) / this.frameIntervals.length) : 0;
		const avgFrameTime = frameCount > 0 ? this.frameTimesMs.reduce((a, b) => a + b, 0) / frameCount : 0;
		const minFrameTime = frameCount > 0 ? Math.min(...this.frameTimesMs) : 0;
		const maxFrameTime = frameCount > 0 ? Math.max(...this.frameTimesMs) : 0;
		const p99FrameTime = this.calculateP99(this.frameTimesMs);
		const stdDevFrameTime = this.calculateStdDev(this.frameTimesMs);
		const jankPercent = this.totalFrameCount > 0 ? this.jankFrameCount / this.totalFrameCount * 100 : 0;
		const memory = performance.memory;
		const memoryUsedMB = memory ? memory.usedJSHeapSize / (1024 * 1024) : null;
		const memoryGrowthRate = this.calculateMemoryGrowthRate();
		const budgetUsed = avgFrameTime > 0 ? avgFrameTime / this.targetFrameTime * 100 : 0;
		const drawCalls = rendererInfo?.render?.calls ?? null;
		const shaderPrograms = rendererInfo?.programs?.length ?? null;
		const textureCount = rendererInfo?.memory?.textures ?? null;
		const intensity = this.calculateIntensityScore();
		return {
			fps: Math.round(fps),
			avgFrameTime: Math.round(avgFrameTime * 100) / 100,
			minFrameTime: Math.round(minFrameTime * 100) / 100,
			maxFrameTime: Math.round(maxFrameTime * 100) / 100,
			p99FrameTime: Math.round(p99FrameTime * 100) / 100,
			stdDevFrameTime: Math.round(stdDevFrameTime * 100) / 100,
			jankCount: this.jankFrameCount,
			jankPercent: Math.round(jankPercent * 10) / 10,
			nodeCount: this.nodeCount,
			rttNodeCount: this.rttNodeCount,
			complexityScore: this.calculateComplexityScore(),
			memoryUsedMB: memoryUsedMB !== null ? Math.round(memoryUsedMB * 100) / 100 : null,
			memoryGrowthRate: memoryGrowthRate !== null ? Math.round(memoryGrowthRate * 1e3) / 1e3 : null,
			cpuTime: this.lastCpuTime !== null ? Math.round(this.lastCpuTime * 100) / 100 : null,
			gpuTime: this.lastGpuTime !== null ? Math.round(this.lastGpuTime * 100) / 100 : null,
			budgetUsed: Math.round(budgetUsed * 10) / 10,
			drawCalls,
			shaderPrograms,
			textureCount,
			intensityScore: intensity.score,
			intensityLabel: intensity.label,
			isRendering: this.isRendering
		};
	}
	reset() {
		this.frameTimesMs.length = 0;
		this.frameIntervals.length = 0;
		this.lastFrameTimestamp = 0;
		this.jankFrameCount = 0;
		this.totalFrameCount = 0;
		this.memorySnapshots.length = 0;
		this.memorySnapshotIndex = 0;
		this.sortBuffer.length = 0;
		this.lastCpuTime = null;
		this.lastGpuTime = null;
	}
};
const needsTransformation = (transform) => {
	if (!transform) return false;
	return transform.offsetX !== 0 || transform.offsetY !== 0 || transform.rotation !== 0 || transform.scale !== 1 || transform.anchorX !== .5 || transform.anchorY !== .5;
};
const applyUVTransform = (uv$1, offsetXUniform, offsetYUniform, rotationUniform, scaleUniform, anchorXUniform, anchorYUniform, aspectRatioUniform) => {
	const rotationRad = rotationUniform.mul(PI).div(float(180));
	const cosAngle = cos(rotationRad);
	const sinAngle = sin(rotationRad);
	const anchor = vec2(anchorXUniform, anchorYUniform);
	const scaledUV = uv$1.sub(anchor).div(scaleUniform);
	const squareUV = vec2(scaledUV.x.mul(aspectRatioUniform), scaledUV.y);
	const rotatedSquareUV = vec2(squareUV.x.mul(cosAngle).sub(squareUV.y.mul(sinAngle)), squareUV.x.mul(sinAngle).add(squareUV.y.mul(cosAngle)));
	return vec2(rotatedSquareUV.x.div(aspectRatioUniform), rotatedSquareUV.y).sub(vec2(offsetXUniform, offsetYUniform)).add(anchor);
};
var updateTransformMap = new Map([[transformColor, transformColorUpdate], [transformPosition, transformPositionUpdate]]);
function createUniformsMap(component, reactiveProps, instanceId) {
	const uniformsMap = {};
	Object.entries(component.props).forEach(([propName, propConfig]) => {
		const initialValue = reactiveProps[propName];
		let uniformValue = initialValue;
		if (propConfig.transform) {
			const transformed = propConfig.transform(initialValue);
			uniformValue = transformed?.node ?? transformed;
		}
		if (uniformValue === null || uniformValue === void 0) {
			uniformValue = propConfig.default;
			if (propConfig.transform && uniformValue !== null && uniformValue !== void 0) {
				const transformed = propConfig.transform(uniformValue);
				uniformValue = transformed?.node ?? transformed;
			}
		}
		if (uniformValue === null || uniformValue === void 0) {
			console.error(`[Shaders] Uniform "${propName}" is null/undefined after fallback. PropConfig:`, {
				propName,
				initialValue,
				default: propConfig.default,
				hasTransform: !!propConfig.transform
			});
			uniformValue = 0;
		}
		const uniformNode = uniform(uniformValue).setName(`${propName}_${instanceId}`);
		if (typeof uniformValue === "string" && uniformNode.value === null) uniformNode.value = uniformValue;
		uniformsMap[propName] = {
			uniform: uniformNode,
			transform: propConfig.transform || void 0
		};
	});
	return uniformsMap;
}
function updateUniformValue(uniform$1, newValue) {
	if (uniform$1?.transform) {
		const updateTransform = updateTransformMap.get(uniform$1.transform);
		if (updateTransform) {
			const newData = updateTransform(newValue);
			if (uniform$1.uniform.value && typeof uniform$1.uniform.value.copy === "function") uniform$1.uniform.value.copy(newData);
			else uniform$1.uniform.value = newData;
		} else {
			const transformed = uniform$1.transform(newValue);
			const dataValue = transformed?.data ?? transformed;
			if (uniform$1.uniform.value && typeof uniform$1.uniform.value.copy === "function" && dataValue && typeof dataValue.copy === "function") uniform$1.uniform.value.copy(dataValue);
			else uniform$1.uniform.value = dataValue;
		}
	} else uniform$1.uniform.value = newValue;
}
var hasLoggedLicenseInfo = false;
var globalEventManager = (() => {
	let instanceCount = 0;
	const callbacks = /* @__PURE__ */ new Set();
	const globalMouseMoveHandler = (e) => {
		callbacks.forEach((cb) => {
			try {
				cb.onMouseMove(e);
			} catch (error) {
				console.error("[Shaders] Error in mouse move handler:", error);
			}
		});
	};
	const globalTouchMoveHandler = (e) => {
		callbacks.forEach((cb) => {
			try {
				cb.onTouchMove(e);
			} catch (error) {
				console.error("[Shaders] Error in touch move handler:", error);
			}
		});
	};
	const globalMouseUpHandler = () => {
		callbacks.forEach((cb) => {
			try {
				cb.onMouseUp();
			} catch (error) {
				console.error("[Shaders] Error in mouse up handler:", error);
			}
		});
	};
	const globalTouchEndHandler = () => {
		callbacks.forEach((cb) => {
			try {
				cb.onTouchEnd();
			} catch (error) {
				console.error("[Shaders] Error in touch end handler:", error);
			}
		});
	};
	return { register(handlers) {
		callbacks.add(handlers);
		instanceCount++;
		if (instanceCount === 1) {
			window.addEventListener("mousemove", globalMouseMoveHandler);
			window.addEventListener("touchmove", globalTouchMoveHandler);
			window.addEventListener("mouseup", globalMouseUpHandler);
			window.addEventListener("touchend", globalTouchEndHandler);
		}
		return () => {
			callbacks.delete(handlers);
			instanceCount--;
			if (instanceCount === 0) {
				window.removeEventListener("mousemove", globalMouseMoveHandler);
				window.removeEventListener("touchmove", globalTouchMoveHandler);
				window.removeEventListener("mouseup", globalMouseUpHandler);
				window.removeEventListener("touchend", globalTouchEndHandler);
			}
		};
	} };
})();
var isDevelopment = () => {
	try {
		{
			const { MODE, DEV } = {
				"DEV": false,
				"MODE": "production"
			};
			return DEV || MODE === "development";
		}
		if (typeof window !== "undefined" && window.location) {
			const hostname = window.location.hostname;
			return hostname === "localhost" || hostname === "127.0.0.1" || hostname.endsWith(".local") || hostname.includes("dev.") || hostname.startsWith("dev-");
		}
		return false;
	} catch (error) {
		return false;
	}
};
function shaderRenderer() {
	let canvasElement = null;
	let renderer;
	let camera;
	let scene;
	let mesh;
	let material;
	const nodeRegistry = {
		nodes: /* @__PURE__ */ new Map(),
		rootId: null,
		idToNodeId: /* @__PURE__ */ new Map()
	};
	const parentToChildren = /* @__PURE__ */ new Map();
	let animationFrameId = null;
	let resizeObserver = null;
	let intersectionObserver = null;
	let isInitialized = false;
	let isInitializing = false;
	let hasInitialDimensions = false;
	let initializationAbortController = null;
	let isVisible = false;
	let shouldAnimate = true;
	let currentWidth = 0;
	let currentHeight = 0;
	let lastRenderTime = 0;
	let needsMaterialRefresh = false;
	let pointerX = .5;
	let pointerY = .5;
	let pointerActive = false;
	let isUpdatingMaterial = false;
	let globalEventUnregister = null;
	let unloadHandler = null;
	let enablePerformanceTracking = false;
	const performanceTracker = new PerformanceTracker();
	let pendingRegistrationQueue = [];
	let isRendererReady = false;
	let materialUpdateBatchRAF = null;
	let lastComposedNodes = /* @__PURE__ */ new Set();
	let activeRTTNodes = /* @__PURE__ */ new Set();
	let actualRTTOperations = 0;
	let currentTextures = /* @__PURE__ */ new Set();
	let previousTextures = /* @__PURE__ */ new Set();
	let pendingResize = null;
	let isResizeScheduled = false;
	const updateRendererDimensions = (width, height) => {
		if (width <= 0 || height <= 0) return;
		if (width === currentWidth && height === currentHeight) return;
		pendingResize = {
			width,
			height
		};
		if (!isResizeScheduled) {
			isResizeScheduled = true;
			requestAnimationFrame(() => {
				isResizeScheduled = false;
				if (!pendingResize) return;
				const { width: width$1, height: height$1 } = pendingResize;
				pendingResize = null;
				currentWidth = width$1;
				currentHeight = height$1;
				if (!hasInitialDimensions) hasInitialDimensions = true;
				renderer.setSize(width$1, height$1, false);
				const aspectRatio = width$1 / height$1;
				const frustumHeight = 2;
				const frustumWidth = frustumHeight * aspectRatio;
				camera.left = -frustumWidth / 2;
				camera.right = frustumWidth / 2;
				camera.top = frustumHeight / 2;
				camera.bottom = -frustumHeight / 2;
				camera.updateProjectionMatrix();
				mesh.scale.set(frustumWidth, frustumHeight, 1);
				nodeRegistry.nodes.forEach((nodeInfo) => {
					if (nodeInfo.transformUniforms?.aspectRatio) nodeInfo.transformUniforms.aspectRatio.value = aspectRatio;
					nodeInfo.resizeCallbacks.forEach((callback) => {
						try {
							callback({
								width: width$1,
								height: height$1
							});
						} catch (error) {
							console.error("Error in resize callback:", error);
						}
					});
				});
				if (!animationFrameId) renderFrame().catch(console.warn);
			});
		}
	};
	const canRender = () => {
		return isInitialized && !!renderer && !!scene && !!camera && !!material && currentWidth > 0 && currentHeight > 0;
	};
	const handleResize = (entries) => {
		if (!renderer || !camera || !mesh) return;
		const entry = entries[0];
		if (!entry) return;
		let width, height;
		if (entry.contentBoxSize) {
			const boxSize = Array.isArray(entry.contentBoxSize) ? entry.contentBoxSize[0] : entry.contentBoxSize;
			if (boxSize) {
				width = Math.round(boxSize.inlineSize);
				height = Math.round(boxSize.blockSize);
			} else {
				width = Math.round(entry.contentRect.width);
				height = Math.round(entry.contentRect.height);
			}
		} else {
			width = Math.round(entry.contentRect.width);
			height = Math.round(entry.contentRect.height);
		}
		if (width === 0 || height === 0) return;
		updateRendererDimensions(width, height);
	};
	const handleVisibilityChange = (entries) => {
		const entry = entries[0];
		if (!entry) return;
		isVisible = entry.isIntersecting;
	};
	const setsAreEqual = (set1, set2) => {
		if (set1.size !== set2.size) return false;
		for (const item of set1) if (!set2.has(item)) return false;
		return true;
	};
	const trackConvertToTexture = (node) => {
		actualRTTOperations++;
		const texture$1 = convertToTexture(node);
		currentTextures.add(texture$1);
		return texture$1;
	};
	const disposePreviousTextures = () => {
		previousTextures.forEach((texture$1) => {
			try {
				if (texture$1?.renderTarget?.dispose) texture$1.renderTarget.dispose();
			} catch (e) {}
		});
		previousTextures.clear();
	};
	let materialUpdatePending = false;
	const updateMaterial = () => {
		if (!nodeRegistry.rootId || !material || isUpdatingMaterial) return;
		if (!nodeRegistry.nodes.get(nodeRegistry.rootId)) return;
		if (currentWidth === 0 || currentHeight === 0) {
			if (!materialUpdatePending) {
				materialUpdatePending = true;
				requestAnimationFrame(() => {
					materialUpdatePending = false;
					if (currentWidth > 0 && currentHeight > 0) updateMaterial();
				});
			}
			return;
		}
		isUpdatingMaterial = true;
		try {
			previousTextures = new Set(currentTextures);
			currentTextures.clear();
			const currentComposedNodes = /* @__PURE__ */ new Set();
			activeRTTNodes.clear();
			nodeRegistry.nodes.forEach((nodeInfo, nodeId) => {
				if (nodeInfo.requiresRTT || nodeInfo.transformRTTActive) activeRTTNodes.add(nodeId);
			});
			actualRTTOperations = 0;
			const composedNode = composeNodeTree(nodeRegistry.rootId, /* @__PURE__ */ new Set(), currentComposedNodes);
			if (composedNode && material) {
				const compositionChanged = !setsAreEqual(lastComposedNodes, currentComposedNodes);
				const nodeChanged = material.fragmentNode !== composedNode;
				if (compositionChanged || needsMaterialRefresh || nodeChanged) {
					disposePreviousTextures();
					try {
						material.dispose();
						if (renderer.renderTarget) renderer.renderTarget.dispose();
					} catch (e) {}
					const newMaterial = new MeshBasicNodeMaterial({ transparent: true });
					newMaterial.fragmentNode = composedNode;
					newMaterial.needsUpdate = true;
					mesh.material = newMaterial;
					material = newMaterial;
					needsMaterialRefresh = false;
					lastComposedNodes = currentComposedNodes;
				}
			}
		} catch (error) {
			console.error("Error composing shader tree:", error);
		} finally {
			isUpdatingMaterial = false;
		}
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const findChildNodes = (parentId) => {
		const childIds = parentToChildren.get(parentId);
		if (!childIds) return [];
		const children = [];
		for (const childId of childIds) {
			const nodeInfo = nodeRegistry.nodes.get(childId);
			if (nodeInfo) children.push(nodeInfo);
		}
		return children;
	};
	const findNodeByCustomId = (customId) => {
		for (const [nodeId, info] of nodeRegistry.nodes.entries()) if (info.metadata.id === customId) return nodeId;
		return null;
	};
	const applyMaskIfNeeded = (result, nodeInfo, nodeId, processedMasks, distortedUV) => {
		if (!nodeInfo.metadata.mask?.source) return result;
		const maskSourceId = nodeInfo.metadata.mask.source;
		const maskNodeId = findNodeByCustomId(maskSourceId);
		if (!maskNodeId) return result;
		if (processedMasks.has(maskNodeId)) {
			console.error(`Uh oh, looks like you've got a circular dependency in your shader masks.`);
			return result;
		}
		const newProcessedMasks = new Set(processedMasks);
		newProcessedMasks.add(nodeId);
		const maskNode = composeNodeTree(maskNodeId, newProcessedMasks);
		let finalMaskNode = maskNode;
		if (distortedUV) finalMaskNode = trackConvertToTexture(maskNode).sample(distortedUV);
		const maskType = nodeInfo.metadata.mask.type || "alpha";
		return applyMask(result, finalMaskNode, maskType);
	};
	const applyNodeTransformation = (result, nodeInfo) => {
		if (!nodeInfo.metadata.transform || !nodeInfo.transformUniforms || !needsTransformation(nodeInfo.metadata.transform) && !nodeInfo.transformRTTActive) return result;
		const texture$1 = trackConvertToTexture(result);
		const transformedUV = applyUVTransform(screenUV, nodeInfo.transformUniforms.offsetX, nodeInfo.transformUniforms.offsetY, nodeInfo.transformUniforms.rotation, nodeInfo.transformUniforms.scale, nodeInfo.transformUniforms.anchorX, nodeInfo.transformUniforms.anchorY, nodeInfo.transformUniforms.aspectRatio);
		return applyEdgeHandling(transformedUV, texture$1.sample(transformedUV), texture$1, nodeInfo.transformUniforms.edges);
	};
	const composeNodeTree = (nodeId, processedMasks = /* @__PURE__ */ new Set(), currentlyComposedNodes) => {
		if (currentWidth === 0 || currentHeight === 0) return vec4(0, 0, 0, 0);
		const nodeInfo = nodeRegistry.nodes.get(nodeId);
		if (!nodeInfo) return vec4(0, 0, 0, 0);
		const nodeSpecificOnCleanup = (callback) => {
			nodeInfo.cleanupCallbacks.push(callback);
		};
		const nodeSpecificOnBeforeRender = (callback) => {
			nodeInfo.beforeRenderCallbacks.push(callback);
		};
		const nodeSpecificOnAfterRender = (callback) => {
			nodeInfo.afterRenderCallbacks.push(callback);
		};
		const nodeSpecificOnResize = (callback) => {
			nodeInfo.resizeCallbacks.push(callback);
		};
		const childNodes = findChildNodes(nodeId);
		if (childNodes.length === 0) {
			nodeInfo.cleanupCallbacks.forEach((callback) => {
				try {
					callback();
				} catch (e) {
					console.error("Error in cleanup callback:", e);
				}
			});
			nodeInfo.cleanupCallbacks = [];
			nodeInfo.beforeRenderCallbacks = [];
			nodeInfo.afterRenderCallbacks = [];
			nodeInfo.resizeCallbacks = [];
			return applyMaskIfNeeded(applyNodeTransformation(nodeInfo.fragmentNodeFunc({
				uniforms: nodeInfo.uniforms ?? {},
				childNode: void 0,
				onCleanup: nodeSpecificOnCleanup,
				onBeforeRender: nodeSpecificOnBeforeRender,
				onAfterRender: nodeSpecificOnAfterRender,
				onResize: nodeSpecificOnResize,
				canvas: canvasElement,
				dimensions: {
					width: currentWidth,
					height: currentHeight
				},
				renderer
			}), nodeInfo), nodeInfo, nodeId, processedMasks);
		} else {
			const sortedChildren = [...childNodes].sort((a, b) => a.metadata.renderOrder - b.metadata.renderOrder);
			if (nodeInfo.parentId === null) {
				let composedChildren = void 0;
				for (let i = 0; i < sortedChildren.length; i++) {
					const childInfo = sortedChildren[i];
					let effectiveOpacity;
					if (childInfo.metadata.opacity === void 0) {
						effectiveOpacity = 1;
						childInfo.opacityUniform.value = effectiveOpacity;
					} else {
						effectiveOpacity = childInfo.metadata.opacity;
						childInfo.opacityUniform.value = effectiveOpacity;
					}
					if (childInfo.metadata.visible === false) continue;
					if (currentlyComposedNodes) currentlyComposedNodes.add(childInfo.id);
					const childHasChildren = findChildNodes(childInfo.id).length > 0;
					let childResult;
					if (childHasChildren) childResult = composeNodeTree(childInfo.id, processedMasks, currentlyComposedNodes);
					else {
						const childSpecificOnCleanup = (callback) => {
							childInfo.cleanupCallbacks.push(callback);
						};
						const childSpecificOnBeforeRender = (callback) => {
							childInfo.beforeRenderCallbacks.push(callback);
						};
						const childSpecificOnAfterRender = (callback) => {
							childInfo.afterRenderCallbacks.push(callback);
						};
						const childSpecificOnResize = (callback) => {
							childInfo.resizeCallbacks.push(callback);
						};
						let effectiveChildNode = composedChildren;
						if (childInfo.requiresRTT && composedChildren !== void 0) effectiveChildNode = applyBlendMode(vec4(0, 0, 0, 0), composedChildren, "normal", 1);
						childInfo.cleanupCallbacks.forEach((callback) => {
							try {
								callback();
							} catch (e) {
								console.error("Error in cleanup callback:", e);
							}
						});
						childInfo.cleanupCallbacks = [];
						childInfo.beforeRenderCallbacks = [];
						childInfo.afterRenderCallbacks = [];
						childInfo.resizeCallbacks = [];
						childResult = applyMaskIfNeeded(applyNodeTransformation(childInfo.fragmentNodeFunc({
							uniforms: childInfo.uniforms ?? {},
							childNode: effectiveChildNode,
							onCleanup: childSpecificOnCleanup,
							onBeforeRender: childSpecificOnBeforeRender,
							onAfterRender: childSpecificOnAfterRender,
							onResize: childSpecificOnResize,
							canvas: canvasElement,
							dimensions: {
								width: currentWidth,
								height: currentHeight
							},
							renderer
						}), childInfo), childInfo, childInfo.id, processedMasks);
					}
					if (childInfo.requiresChild && childInfo.metadata.blendMode === "normal" && !childHasChildren) composedChildren = applyBlendMode(vec4(0, 0, 0, 0), childResult, "normal", childInfo.opacityUniform);
					else if (composedChildren === void 0) if (nodeInfo.requiresRTT || effectiveOpacity !== 1) composedChildren = applyBlendMode(vec4(1, 1, 1, 0), childResult, childInfo.metadata.blendMode, childInfo.opacityUniform);
					else composedChildren = childResult;
					else composedChildren = applyBlendMode(composedChildren, childResult, childInfo.metadata.blendMode, childInfo.opacityUniform);
				}
				nodeInfo.cleanupCallbacks.forEach((callback) => {
					try {
						callback();
					} catch (e) {
						console.error("Error in cleanup callback:", e);
					}
				});
				nodeInfo.cleanupCallbacks = [];
				nodeInfo.beforeRenderCallbacks = [];
				nodeInfo.afterRenderCallbacks = [];
				nodeInfo.resizeCallbacks = [];
				return applyMaskIfNeeded(applyNodeTransformation(nodeInfo.fragmentNodeFunc({
					uniforms: nodeInfo.uniforms ?? {},
					childNode: composedChildren,
					onCleanup: nodeSpecificOnCleanup,
					onBeforeRender: nodeSpecificOnBeforeRender,
					onAfterRender: nodeSpecificOnAfterRender,
					onResize: nodeSpecificOnResize,
					canvas: canvasElement,
					dimensions: {
						width: currentWidth,
						height: currentHeight
					},
					renderer
				}), nodeInfo), nodeInfo, nodeId, processedMasks);
			} else {
				let composedChildrenResult = void 0;
				for (let i = 0; i < sortedChildren.length; i++) {
					const childInfo = sortedChildren[i];
					let effectiveOpacity;
					if (childInfo.metadata.opacity === void 0) {
						effectiveOpacity = 1;
						childInfo.opacityUniform.value = effectiveOpacity;
					} else {
						effectiveOpacity = childInfo.metadata.opacity;
						childInfo.opacityUniform.value = effectiveOpacity;
					}
					if (childInfo.metadata.visible === false) continue;
					if (currentlyComposedNodes) currentlyComposedNodes.add(childInfo.id);
					const childHasChildren = findChildNodes(childInfo.id).length > 0;
					let childResult;
					if (childHasChildren) childResult = composeNodeTree(childInfo.id, processedMasks, currentlyComposedNodes);
					else {
						const childSpecificOnCleanup = (callback) => {
							childInfo.cleanupCallbacks.push(callback);
						};
						const childSpecificOnBeforeRender = (callback) => {
							childInfo.beforeRenderCallbacks.push(callback);
						};
						const childSpecificOnAfterRender = (callback) => {
							childInfo.afterRenderCallbacks.push(callback);
						};
						const childSpecificOnResize = (callback) => {
							childInfo.resizeCallbacks.push(callback);
						};
						let effectiveChildNode = composedChildrenResult;
						if (childInfo.requiresRTT && composedChildrenResult !== void 0) effectiveChildNode = applyBlendMode(vec4(0, 0, 0, 0), composedChildrenResult, "normal", 1);
						childInfo.cleanupCallbacks = [];
						childInfo.beforeRenderCallbacks = [];
						childInfo.afterRenderCallbacks = [];
						childInfo.resizeCallbacks = [];
						childResult = applyMaskIfNeeded(applyNodeTransformation(childInfo.fragmentNodeFunc({
							uniforms: childInfo.uniforms ?? {},
							childNode: effectiveChildNode,
							onCleanup: childSpecificOnCleanup,
							onBeforeRender: childSpecificOnBeforeRender,
							onAfterRender: childSpecificOnAfterRender,
							onResize: childSpecificOnResize,
							canvas: canvasElement,
							dimensions: {
								width: currentWidth,
								height: currentHeight
							},
							renderer
						}), childInfo), childInfo, childInfo.id, processedMasks);
					}
					if (childInfo.requiresChild && childInfo.metadata.blendMode === "normal" && !childHasChildren) composedChildrenResult = applyBlendMode(vec4(0, 0, 0, 0), childResult, "normal", childInfo.opacityUniform);
					else if (composedChildrenResult === void 0) if (nodeInfo.requiresRTT || effectiveOpacity !== 1) composedChildrenResult = applyBlendMode(vec4(1, 1, 1, 0), childResult, childInfo.metadata.blendMode, childInfo.opacityUniform);
					else composedChildrenResult = childResult;
					else composedChildrenResult = applyBlendMode(composedChildrenResult, childResult, childInfo.metadata.blendMode, childInfo.opacityUniform);
				}
				nodeInfo.cleanupCallbacks.forEach((callback) => {
					try {
						callback();
					} catch (e) {
						console.error("Error in cleanup callback:", e);
					}
				});
				nodeInfo.cleanupCallbacks = [];
				nodeInfo.beforeRenderCallbacks = [];
				nodeInfo.afterRenderCallbacks = [];
				nodeInfo.resizeCallbacks = [];
				return applyMaskIfNeeded(applyNodeTransformation(nodeInfo.fragmentNodeFunc({
					uniforms: nodeInfo.uniforms ?? {},
					childNode: composedChildrenResult,
					onCleanup: nodeSpecificOnCleanup,
					onBeforeRender: nodeSpecificOnBeforeRender,
					onAfterRender: nodeSpecificOnAfterRender,
					onResize: nodeSpecificOnResize,
					canvas: canvasElement,
					dimensions: {
						width: currentWidth,
						height: currentHeight
					},
					renderer
				}), nodeInfo), nodeInfo, nodeId, processedMasks);
			}
		}
	};
	const registerNode = (id, fragmentNodeFunc, parentId, metadata, uniforms = {}, componentDefinition) => {
		if (fragmentNodeFunc === null) {
			const queueIndex = pendingRegistrationQueue.findIndex((item) => item.id === id);
			if (queueIndex !== -1) {
				pendingRegistrationQueue.splice(queueIndex, 1);
				return;
			}
			removeNode(id);
			return;
		}
		if (!isRendererReady) {
			const existing = pendingRegistrationQueue.findIndex((item) => item.id === id);
			if (existing !== -1) pendingRegistrationQueue[existing] = {
				id,
				fragmentNodeFunc,
				parentId,
				metadata,
				uniforms,
				componentDefinition
			};
			else pendingRegistrationQueue.push({
				id,
				fragmentNodeFunc,
				parentId,
				metadata,
				uniforms,
				componentDefinition
			});
			return;
		}
		let defaultRenderOrder = 0;
		if (parentId !== null) {
			const siblings = parentToChildren.get(parentId);
			if (siblings && siblings.size > 0) {
				let maxOrder = 0;
				for (const siblingId of siblings) {
					const sibling = nodeRegistry.nodes.get(siblingId);
					if (sibling && sibling.metadata.renderOrder > maxOrder) maxOrder = sibling.metadata.renderOrder;
				}
				defaultRenderOrder = maxOrder + 1;
			}
		}
		const opacityUniform = uniform(metadata?.opacity !== void 0 ? metadata.opacity : 1);
		let transformUniforms = void 0;
		if (metadata?.transform) {
			const aspectRatio = currentWidth / Math.max(1, currentHeight);
			transformUniforms = {
				offsetX: uniform(metadata.transform.offsetX),
				offsetY: uniform(metadata.transform.offsetY),
				rotation: uniform(metadata.transform.rotation),
				scale: uniform(metadata.transform.scale),
				anchorX: uniform(metadata.transform.anchorX),
				anchorY: uniform(metadata.transform.anchorY),
				edges: uniform(metadata.transform.edges === "stretch" ? 0 : metadata.transform.edges === "transparent" ? 1 : metadata.transform.edges === "mirror" ? 2 : 3),
				aspectRatio: uniform(aspectRatio)
			};
		}
		const nodeInfo = {
			id,
			componentName: componentDefinition?.name || "Unknown",
			fragmentNodeFunc,
			parentId,
			requiresRTT: componentDefinition?.requiresRTT || false,
			requiresChild: componentDefinition?.requiresChild || false,
			opacityUniform,
			metadata: {
				blendMode: metadata?.blendMode || "normal",
				opacity: metadata?.opacity,
				visible: metadata?.visible === false ? false : true,
				id: metadata?.id,
				mask: metadata?.mask,
				renderOrder: metadata?.renderOrder !== void 0 ? metadata?.renderOrder : defaultRenderOrder,
				transform: metadata?.transform
			},
			uniforms,
			cleanupCallbacks: [],
			beforeRenderCallbacks: [],
			afterRenderCallbacks: [],
			resizeCallbacks: [],
			transformUniforms,
			transformRTTActive: false
		};
		nodeRegistry.nodes.set(id, nodeInfo);
		if (parentId === null) nodeRegistry.rootId = id;
		const childrenSet = parentToChildren.get(parentId) || /* @__PURE__ */ new Set();
		childrenSet.add(id);
		parentToChildren.set(parentId, childrenSet);
		if (material && isInitialized && currentWidth > 0 && currentHeight > 0) {
			if (materialUpdateBatchRAF === null) materialUpdateBatchRAF = requestAnimationFrame(() => {
				materialUpdateBatchRAF = null;
				updateMaterial();
			});
		} else if (material && isInitialized) {
			if (!materialUpdatePending) {
				materialUpdatePending = true;
				requestAnimationFrame(() => {
					materialUpdatePending = false;
					if (currentWidth > 0 && currentHeight > 0) updateMaterial();
				});
			}
		}
	};
	const updateUniformValue$1 = (nodeId, uniformName, value) => {
		const nodeInfo = nodeRegistry.nodes.get(nodeId);
		if (!nodeInfo || !nodeInfo.uniforms) return;
		const uniformDefinition = nodeInfo.uniforms[uniformName];
		if (!uniformDefinition || !uniformDefinition.uniform) return;
		if (uniformDefinition.transform) updateUniformValue(uniformDefinition, value);
		else uniformDefinition.uniform.value = value;
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const updateNodeMetadata = (nodeId, metadata) => {
		const existingNode = nodeRegistry.nodes.get(nodeId);
		if (!existingNode) return;
		let needsRecompose = false;
		if (metadata.blendMode !== void 0 && existingNode.metadata.blendMode !== metadata.blendMode) {
			existingNode.metadata.blendMode = metadata.blendMode;
			needsRecompose = true;
		}
		if (metadata.opacity !== void 0 && existingNode.metadata.opacity !== metadata.opacity) {
			existingNode.metadata.opacity = metadata.opacity;
			existingNode.opacityUniform.value = metadata.opacity;
		}
		if (metadata.renderOrder !== void 0 && existingNode.metadata.renderOrder !== metadata.renderOrder) {
			existingNode.metadata.renderOrder = metadata.renderOrder;
			needsRecompose = true;
		}
		const newVisible = metadata.visible === false ? false : true;
		if (existingNode.metadata.visible !== newVisible) {
			existingNode.metadata.visible = newVisible;
			needsRecompose = true;
		}
		if (metadata.id !== void 0 && existingNode.metadata.id !== metadata.id) {
			existingNode.metadata.id = metadata.id;
			needsRecompose = true;
		}
		if (metadata.mask !== void 0 && (existingNode.metadata.mask?.source !== metadata.mask?.source || existingNode.metadata.mask?.type !== metadata.mask?.type)) {
			existingNode.metadata.mask = metadata.mask;
			needsRecompose = true;
		}
		if (metadata.transform !== void 0) {
			existingNode.metadata.transform && needsTransformation(existingNode.metadata.transform);
			const newTransformState = needsTransformation(metadata.transform);
			existingNode.metadata.transform = metadata.transform;
			if (!existingNode.transformUniforms && metadata.transform) {
				const aspectRatio = currentWidth / Math.max(1, currentHeight);
				existingNode.transformUniforms = {
					offsetX: uniform(metadata.transform.offsetX),
					offsetY: uniform(metadata.transform.offsetY),
					rotation: uniform(metadata.transform.rotation),
					scale: uniform(metadata.transform.scale),
					anchorX: uniform(metadata.transform.anchorX),
					anchorY: uniform(metadata.transform.anchorY),
					edges: uniform(metadata.transform.edges === "stretch" ? 0 : metadata.transform.edges === "transparent" ? 1 : metadata.transform.edges === "mirror" ? 2 : 3),
					aspectRatio: uniform(aspectRatio)
				};
			} else if (existingNode.transformUniforms) {
				existingNode.transformUniforms.offsetX.value = metadata.transform.offsetX;
				existingNode.transformUniforms.offsetY.value = metadata.transform.offsetY;
				existingNode.transformUniforms.rotation.value = metadata.transform.rotation;
				existingNode.transformUniforms.scale.value = metadata.transform.scale;
				existingNode.transformUniforms.anchorX.value = metadata.transform.anchorX;
				existingNode.transformUniforms.anchorY.value = metadata.transform.anchorY;
				existingNode.transformUniforms.edges.value = metadata.transform.edges === "stretch" ? 0 : metadata.transform.edges === "transparent" ? 1 : metadata.transform.edges === "mirror" ? 2 : 3;
			}
			if (newTransformState && !existingNode.transformRTTActive) {
				existingNode.transformRTTActive = true;
				needsRecompose = true;
			}
		}
		if (needsRecompose && material && isInitialized) {
			if (materialUpdateBatchRAF === null) materialUpdateBatchRAF = requestAnimationFrame(() => {
				materialUpdateBatchRAF = null;
				updateMaterial();
			});
		} else if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const removeNode = (id) => {
		if (!nodeRegistry.nodes.has(id)) return;
		const nodeInfo = nodeRegistry.nodes.get(id);
		if (nodeInfo && nodeInfo.cleanupCallbacks.length > 0) for (const callback of nodeInfo.cleanupCallbacks) try {
			callback();
		} catch (e) {
			console.error(`Error executing cleanup callback for node ${id}:`, e);
		}
		const childNodes = findChildNodes(id);
		for (const child of childNodes) removeNode(child.id);
		if (nodeRegistry.rootId === id) nodeRegistry.rootId = null;
		if (nodeInfo) {
			const childrenSet = parentToChildren.get(nodeInfo.parentId);
			if (childrenSet) {
				childrenSet.delete(id);
				if (childrenSet.size === 0) parentToChildren.delete(nodeInfo.parentId);
			}
		}
		nodeRegistry.nodes.delete(id);
		if (material && isInitialized) updateMaterial();
	};
	const executeBeforeRenderCallbacks = (deltaTime) => {
		const params = {
			deltaTime,
			pointer: {
				x: pointerX,
				y: pointerY
			},
			pointerActive,
			dimensions: {
				width: currentWidth,
				height: currentHeight
			}
		};
		for (const nodeInfo of nodeRegistry.nodes.values()) if (nodeInfo.beforeRenderCallbacks.length > 0) for (const callback of nodeInfo.beforeRenderCallbacks) try {
			callback(params);
		} catch (e) {
			console.error(`Error executing before render callback for node ${nodeInfo.id}:`, e);
		}
	};
	const executeAfterRenderCallbacks = (deltaTime) => {
		const params = {
			deltaTime,
			pointer: {
				x: pointerX,
				y: pointerY
			},
			pointerActive,
			dimensions: {
				width: currentWidth,
				height: currentHeight
			}
		};
		for (const nodeInfo of nodeRegistry.nodes.values()) if (nodeInfo.afterRenderCallbacks.length > 0) for (const callback of nodeInfo.afterRenderCallbacks) try {
			callback(params);
		} catch (e) {
			console.error(`Error executing after render callback for node ${nodeInfo.id}:`, e);
		}
	};
	const renderAndWait = async () => {
		if (!canRender()) throw new Error("Renderer is not ready");
		await renderFrame();
		if (renderer instanceof WebGPURenderer) try {
			const backend = renderer.backend;
			if (backend?.device) await backend.device.queue.onSubmittedWorkDone();
		} catch (e) {
			await new Promise((resolve) => setTimeout(resolve, 16));
		}
	};
	const renderFrame = async () => {
		if (!canRender()) return;
		const frameStartTime = enablePerformanceTracking ? performance.now() : 0;
		const currentTime = frameStartTime || performance.now();
		const deltaTime = lastRenderTime > 0 ? (currentTime - lastRenderTime) / 1e3 : .016;
		const OFF_SCREEN_FPS_INTERVAL = 1e3;
		const MIN_FRAME_INTERVAL = 1e3 / 120;
		if (lastRenderTime > 0) {
			const timeSinceLastRender = currentTime - lastRenderTime;
			if (!isVisible && timeSinceLastRender < OFF_SCREEN_FPS_INTERVAL) return;
			if (isVisible && timeSinceLastRender < MIN_FRAME_INTERVAL) return;
		}
		const cappedDeltaTime = Math.min(deltaTime, .1);
		lastRenderTime = currentTime;
		if (enablePerformanceTracking) performance.mark("shader-cpu-start");
		executeBeforeRenderCallbacks(cappedDeltaTime);
		try {
			if (isUpdatingMaterial) return;
			if (enablePerformanceTracking) performance.mark("shader-gpu-start");
			renderer.render(scene, camera);
			executeAfterRenderCallbacks(cappedDeltaTime);
			if (enablePerformanceTracking) {
				performance.mark("shader-gpu-end");
				if (renderer instanceof WebGPURenderer) try {
					const backend = renderer.backend;
					if (backend && backend.get && backend.get(renderer)) {
						const renderContext = backend.get(renderer);
						if (renderContext?.timestampQuery) {
							const gpuTime = renderContext.timestampQuery.getResult();
							if (gpuTime !== null && gpuTime !== void 0) performanceTracker.recordGpuTime(gpuTime / 1e6);
						}
					}
				} catch (e) {}
				try {
					performance.measure("shader-gpu-time", "shader-gpu-start", "shader-gpu-end");
					const gpuMeasure = performance.getEntriesByName("shader-gpu-time")[0];
					if (gpuMeasure) performanceTracker.recordGpuTime(gpuMeasure.duration);
					performance.clearMarks("shader-gpu-start");
					performance.clearMarks("shader-gpu-end");
					performance.clearMeasures("shader-gpu-time");
				} catch (e) {}
			}
			if (enablePerformanceTracking) {
				performance.mark("shader-cpu-end");
				try {
					performance.measure("shader-cpu-time", "shader-cpu-start", "shader-cpu-end");
					const cpuMeasure = performance.getEntriesByName("shader-cpu-time")[0];
					if (cpuMeasure) performanceTracker.recordCpuTime(cpuMeasure.duration);
					performance.clearMarks("shader-cpu-start");
					performance.clearMarks("shader-cpu-end");
					performance.clearMeasures("shader-cpu-time");
				} catch (e) {}
				const frameTime = performance.now() - frameStartTime;
				performanceTracker.recordFrame(frameTime);
			}
		} catch (error) {
			console.error("Render frame error:", error);
		}
	};
	const updatePerformanceNodeCounts = () => {
		const nodeCount = Math.max(0, nodeRegistry.nodes.size - 1);
		const rttNodeCount = actualRTTOperations;
		performanceTracker.updateNodeCounts(nodeCount, rttNodeCount);
	};
	const getPerformanceStats = () => {
		updatePerformanceNodeCounts();
		const rendererInfo = renderer?.info;
		return performanceTracker.getStats(rendererInfo);
	};
	const startAnimation = () => {
		if (animationFrameId || !shouldAnimate) return;
		performanceTracker.setRendering(true);
		const animate = () => {
			animationFrameId = requestAnimationFrame(animate);
			renderFrame().catch(console.warn);
		};
		animate();
	};
	const stopAnimation = () => {
		if (animationFrameId) {
			cancelAnimationFrame(animationFrameId);
			animationFrameId = null;
		}
		performanceTracker.setRendering(false);
	};
	const updatePointerCoords = (event) => {
		if (!canvasElement) return;
		let clientX;
		let clientY;
		if ("touches" in event) {
			if (event.touches.length === 0) return;
			clientX = event.touches[0].clientX;
			clientY = event.touches[0].clientY;
		} else {
			clientX = event.clientX;
			clientY = event.clientY;
		}
		const rect = canvasElement.getBoundingClientRect();
		const x = (clientX - rect.left) / rect.width;
		const y = (clientY - rect.top) / rect.height;
		pointerX = x;
		pointerY = y;
	};
	const globalMouseMoveHandler = (event) => {
		if (!isInitialized || !canvasElement) return;
		updatePointerCoords(event);
	};
	const globalTouchMoveHandler = (event) => {
		if (!isInitialized || !canvasElement) return;
		updatePointerCoords(event);
	};
	const globalMouseUpHandler = () => {
		if (!isInitialized) return;
		pointerActive = false;
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const globalTouchEndHandler = () => {
		if (!isInitialized) return;
		pointerActive = false;
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const canvasMouseDownHandler = () => {
		pointerActive = true;
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const canvasTouchStartHandler = () => {
		pointerActive = true;
		if (!animationFrameId) renderFrame().catch(console.warn);
	};
	const processQueuedRegistrations = () => {
		if (pendingRegistrationQueue.length === 0) return;
		const queue = [...pendingRegistrationQueue];
		pendingRegistrationQueue = [];
		for (const { id, fragmentNodeFunc, parentId, metadata, uniforms, componentDefinition } of queue) if (fragmentNodeFunc) registerNode(id, fragmentNodeFunc, parentId, metadata, uniforms, componentDefinition);
	};
	const initialize = async ({ canvas, enablePerformanceTracking: enableTracking = false }) => {
		if (isInitialized || isInitializing) return;
		enablePerformanceTracking = enableTracking;
		isInitializing = true;
		initializationAbortController = new AbortController();
		const localAbortController = initializationAbortController;
		try {
			canvasElement = canvas;
			scene = new Scene();
			scene.background = null;
			camera = new OrthographicCamera(-1, 1, 1, -1, .1, 10);
			camera.position.z = 1;
			camera.lookAt(0, 0, 0);
			globalEventUnregister = globalEventManager.register({
				onMouseMove: globalMouseMoveHandler,
				onTouchMove: globalTouchMoveHandler,
				onMouseUp: globalMouseUpHandler,
				onTouchEnd: globalTouchEndHandler
			});
			canvas.addEventListener("mousedown", canvasMouseDownHandler);
			canvas.addEventListener("touchstart", canvasTouchStartHandler);
			unloadHandler = () => {
				cleanup();
			};
			window.addEventListener("beforeunload", unloadHandler);
			if (localAbortController.signal.aborted) return;
			try {
				const rendererOptions = {
					canvas,
					antialias: true,
					alpha: true,
					depth: false,
					powerPreference: "high-performance"
				};
				if (enablePerformanceTracking) {
					rendererOptions.forceWebGL = false;
					rendererOptions.requiredFeatures = ["timestamp-query"];
				}
				renderer = new WebGPURenderer(rendererOptions);
				await renderer.init();
				if (localAbortController.signal.aborted) return;
			} catch (e) {
				if (localAbortController.signal.aborted) return;
				console.warn("[Shaders] WebGPU initialization failed, falling back to WebGL:", e);
				try {
					renderer = new WebGLRenderer({
						canvas,
						antialias: true,
						alpha: true,
						depth: false,
						powerPreference: "high-performance"
					});
					if (localAbortController.signal.aborted) return;
				} catch (webglError) {
					if (localAbortController.signal.aborted) return;
					console.error("[Shaders] Both WebGPU and WebGL initialization failed:", webglError);
					return;
				}
			}
			if (localAbortController.signal.aborted) return;
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			renderer.outputColorSpace = SRGBColorSpace;
			material = new MeshBasicNodeMaterial({ transparent: true });
			material.fragmentNode = vec4(0, 0, 0, 0);
			mesh = new Mesh(new PlaneGeometry(2, 2), material);
			scene.add(mesh);
			const parentElement = canvas.parentElement;
			if (!parentElement) {
				console.warn("[Shaders] Canvas has no parent element for resize observation");
				return;
			}
			resizeObserver = new ResizeObserver(handleResize);
			resizeObserver.observe(parentElement);
			intersectionObserver = new IntersectionObserver(handleVisibilityChange, { threshold: 0 });
			intersectionObserver.observe(canvas);
			const rect = canvas.getBoundingClientRect();
			isVisible = rect.width > 0 && rect.height > 0 && rect.top < window.innerHeight && rect.bottom > 0 && rect.left < window.innerWidth && rect.right > 0;
			shouldAnimate = true;
			const { width, height } = canvas.getBoundingClientRect();
			const roundedWidth = Math.round(width);
			const roundedHeight = Math.round(height);
			if (roundedWidth > 0 && roundedHeight > 0) {
				currentWidth = roundedWidth;
				currentHeight = roundedHeight;
				hasInitialDimensions = true;
				renderer.setSize(roundedWidth, roundedHeight, false);
				const aspectRatio = roundedWidth / roundedHeight;
				const frustumHeight = 2;
				const frustumWidth = frustumHeight * aspectRatio;
				camera.left = -frustumWidth / 2;
				camera.right = frustumWidth / 2;
				camera.top = frustumHeight / 2;
				camera.bottom = -frustumHeight / 2;
				camera.updateProjectionMatrix();
				mesh.scale.set(frustumWidth, frustumHeight, 1);
				await renderFrame();
			} else hasInitialDimensions = false;
			if (shouldAnimate) startAnimation();
			if (!localAbortController.signal.aborted) {
				isInitialized = true;
				isRendererReady = true;
				processQueuedRegistrations();
			}
		} catch (error) {
			console.error("[Shaders] Initialization error:", error);
		} finally {
			isInitializing = false;
			if (initializationAbortController === localAbortController) initializationAbortController = null;
		}
	};
	const showLicenseWarning = () => {
		if (!isDevelopment() || hasLoggedLicenseInfo) return;
		console.warn("Shaders is running in development mode. Please purchase a license at https://shaders.com to use it in production.");
		hasLoggedLicenseInfo = true;
	};
	const cleanup = () => {
		if (initializationAbortController) initializationAbortController.abort();
		if (resizeObserver) {
			resizeObserver.disconnect();
			resizeObserver = null;
		}
		if (intersectionObserver) {
			intersectionObserver.disconnect();
			intersectionObserver = null;
		}
		if (globalEventUnregister) {
			globalEventUnregister();
			globalEventUnregister = null;
		}
		if (canvasElement) {
			canvasElement.removeEventListener("mousedown", canvasMouseDownHandler);
			canvasElement.removeEventListener("touchstart", canvasTouchStartHandler);
		}
		if (unloadHandler) {
			window.removeEventListener("beforeunload", unloadHandler);
			unloadHandler = null;
		}
		stopAnimation();
		disposePreviousTextures();
		currentTextures.forEach((texture$1) => {
			try {
				if (texture$1?.renderTarget?.dispose) texture$1.renderTarget.dispose();
			} catch (e) {}
		});
		currentTextures.clear();
		nodeRegistry.nodes.clear();
		nodeRegistry.rootId = null;
		nodeRegistry.idToNodeId.clear();
		parentToChildren.clear();
		pendingRegistrationQueue = [];
		isRendererReady = false;
		if (materialUpdateBatchRAF !== null) {
			cancelAnimationFrame(materialUpdateBatchRAF);
			materialUpdateBatchRAF = null;
		}
		pendingResize = null;
		isResizeScheduled = false;
		if (mesh) {
			if (scene) scene.remove(mesh);
			try {
				if (mesh.geometry && typeof mesh.geometry.dispose === "function") mesh.geometry.dispose();
			} catch (e) {}
			try {
				if (mesh.material instanceof Material && typeof mesh.material.dispose === "function") mesh.material.dispose();
			} catch (e) {}
		}
		if (renderer && typeof renderer.dispose === "function") try {
			renderer.dispose();
		} catch (e) {}
		canvasElement = null;
		renderer = null;
		camera = null;
		scene = null;
		mesh = null;
		material = null;
		isInitialized = false;
		isInitializing = false;
		hasInitialDimensions = false;
		initializationAbortController = null;
		currentWidth = 0;
		currentHeight = 0;
		isVisible = false;
		shouldAnimate = true;
		pointerX = .5;
		pointerY = .5;
		pointerActive = false;
	};
	const getRendererType = () => {
		if (!renderer) return null;
		return renderer instanceof WebGPURenderer ? "webgpu" : "webgl";
	};
	return {
		initialize,
		cleanup,
		registerNode,
		removeNode,
		updateUniformValue: updateUniformValue$1,
		updateNodeMetadata,
		showLicenseWarning,
		isInitialized: () => isInitialized,
		startAnimation,
		stopAnimation,
		renderAndWait,
		getPerformanceStats,
		getNodeRegistry: () => ({ nodes: new Map(nodeRegistry.nodes) }),
		getRendererType,
		__testing: {
			needsTransformation,
			findChildNodes,
			applyMaskIfNeeded,
			applyNodeTransformation,
			getNodeRegistry: () => nodeRegistry,
			getParentToChildren: () => parentToChildren
		}
	};
}
function resolveMaskDependencies(nodes) {
	const elementIdToNodeId = /* @__PURE__ */ new Map();
	const maskDependencies = /* @__PURE__ */ new Map();
	const result = {
		processingOrder: [],
		maskSources: /* @__PURE__ */ new Map(),
		circularDependencies: []
	};
	nodes.forEach((node) => {
		if (node.elementId) elementIdToNodeId.set(node.elementId, node.id);
	});
	nodes.forEach((node) => {
		if (node.mask?.source) {
			const sourceElementId = node.mask.source.startsWith("#") ? node.mask.source.substring(1) : node.mask.source;
			const sourceNodeId = elementIdToNodeId.get(sourceElementId);
			if (sourceNodeId) {
				if (!maskDependencies.has(node.id)) maskDependencies.set(node.id, []);
				maskDependencies.get(node.id)?.push(sourceNodeId);
				result.maskSources.set(node.id, sourceNodeId);
			} else console.warn(`Mask source "${sourceElementId}" not found for node "${node.id}"`);
		}
	});
	result.processingOrder = topologicalSort(maskDependencies, result.circularDependencies);
	return result;
}
function topologicalSort(dependencies, circularDependencies) {
	const result = [];
	const visited = /* @__PURE__ */ new Set();
	const tempVisited = /* @__PURE__ */ new Set();
	function visit(nodeId, path = []) {
		if (visited.has(nodeId)) return;
		if (tempVisited.has(nodeId)) {
			const cycle = [...path.slice(path.indexOf(nodeId)), nodeId];
			circularDependencies.push(cycle);
			return;
		}
		tempVisited.add(nodeId);
		path.push(nodeId);
		const deps = dependencies.get(nodeId) || [];
		for (const depId of deps) visit(depId, [...path]);
		tempVisited.delete(nodeId);
		visited.add(nodeId);
		result.push(nodeId);
	}
	for (const nodeId of dependencies.keys()) if (!visited.has(nodeId)) visit(nodeId);
	const allSourceNodeIds = new Set([...dependencies.values()].flat());
	for (const sourceId of allSourceNodeIds) if (!visited.has(sourceId) && !dependencies.has(sourceId)) result.push(sourceId);
	return result.reverse();
}
const noise = (st) => fract(sin(dot(st, vec2(12.12345, 78.12345))).mul(40000.12345));
const grain = (intensity = .03) => (st) => noise(st).mul(intensity).mul(.10012345);
const distort = (uv$1 = vec2(0), intensity = .02, frequency = 1, seed = 1) => {
	const phaseX = seed * 1.618033988749895;
	const phaseY = seed * 2.718281828459045;
	const freqMod1 = (Math.sin(seed) + 2) * 5;
	const freqMod2 = (Math.cos(seed) + 2) * 5;
	const flow1 = vec2(sin(uv$1.x.mul(frequency).mul(freqMod1).add(time.mul(.1)).add(phaseX)), cos(uv$1.y.mul(frequency).mul(freqMod1).add(time.mul(.1)).add(phaseY)));
	const flow2 = vec2(sin(uv$1.y.mul(frequency).mul(freqMod2).add(time.mul(.05)).add(phaseY)), cos(uv$1.x.mul(frequency).mul(freqMod2).add(time.mul(.05)).add(phaseX)));
	const offset = flow1.add(flow2).mul(intensity);
	return uv$1.add(offset);
};
const glow = (color, glowColor, threshold = .6, softness = .3, intensity = 1) => {
	const brightness = max(max(color.r, color.g), color.b);
	const glowAmount = smoothstep(threshold, threshold + softness, brightness).mul(intensity).mul(1);
	return vec4(color.rgb.add(glowColor.rgb.mul(glowAmount)), color.a);
};
const edgeMask = (options = {}) => {
	const { inset = .4, softness = .5, offsetX = 0, offsetY = 0 } = options;
	const rawUV = uv();
	const ovalX = rawUV.x.sub(.5).sub(float(offsetX)).mul(2);
	const ovalY = rawUV.y.sub(.5).add(float(offsetY)).mul(2);
	const ovalDistance = ovalX.mul(ovalX).add(ovalY.mul(ovalY)).sqrt();
	return float(1).sub(smoothstep(float(1).sub(float(inset)), float(1).sub(float(inset)).add(float(softness)), ovalDistance.mul(float(1).add(float(softness)))));
};
export { createAnimatedTime, createUniformsMap, distort, edgeMask, glow, grain, resolveMaskDependencies, shaderRenderer, updateUniformValue };
