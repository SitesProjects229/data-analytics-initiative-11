import { atan, cos, float, max, pow, sin, sqrt, vec3, vec4 } from "three/tsl";
var p3ToSRGB = (p3) => {
	return vec3(p3.x.mul(1.2249401).sub(p3.y.mul(.2249404)).sub(p3.z.mul(0)), p3.x.mul(-.0420569).add(p3.y.mul(1.0420571)).add(p3.z.mul(0)), p3.x.mul(-.0196376).sub(p3.y.mul(.0786361)).add(p3.z.mul(1.0982735)));
};
var sRGBToP3 = (srgb) => {
	return vec3(srgb.x.mul(.8224621).add(srgb.y.mul(.177538)).add(srgb.z.mul(0)), srgb.x.mul(.0331941).add(srgb.y.mul(.9668058)).add(srgb.z.mul(0)), srgb.x.mul(.0170826).add(srgb.y.mul(.0723974)).add(srgb.z.mul(.9105199)));
};
var rgbToOklab = (rgb) => {
	const r = rgb.x;
	const g = rgb.y;
	const b = rgb.z;
	const l = r.mul(.4122214708).add(g.mul(.5363325363)).add(b.mul(.0514459929));
	const m = r.mul(.2119034982).add(g.mul(.6806995451).add(b.mul(.1073969566)));
	const s = r.mul(.0883024619).add(g.mul(.2817188376)).add(b.mul(.6299787005));
	const l_ = pow(l, float(1 / 3));
	const m_ = pow(m, float(1 / 3));
	const s_ = pow(s, float(1 / 3));
	return vec3(l_.mul(.2104542553).add(m_.mul(.793617785)).sub(s_.mul(.0040720468)), l_.mul(1.9779984951).sub(m_.mul(2.428592205)).add(s_.mul(.4505937099)), l_.mul(.0259040371).add(m_.mul(.7827717662)).sub(s_.mul(.808675766)));
};
var oklabToRgb = (lab) => {
	const L = lab.x;
	const a = lab.y;
	const b = lab.z;
	const l_ = L.add(a.mul(.3963377774)).add(b.mul(.2158037573));
	const m_ = L.sub(a.mul(.1055613458)).sub(b.mul(.0638541728));
	const s_ = L.sub(a.mul(.0894841775)).sub(b.mul(1.291485548));
	const l = pow(l_, float(3));
	const m = pow(m_, float(3));
	const s = pow(s_, float(3));
	return vec3(l.mul(4.0767416621).sub(m.mul(3.3077115913)).add(s.mul(.2309699292)), l.mul(-1.2684380046).add(m.mul(2.6097574011)).sub(s.mul(.3413193965)), l.mul(-.0041960863).sub(m.mul(.7034186147)).add(s.mul(1.707614701)));
};
var oklabToOklch = (lab) => {
	const L = lab.x;
	const a = lab.y;
	const b = lab.z;
	return vec3(L, sqrt(a.mul(a).add(b.mul(b))), atan(b, a));
};
var oklchToOklab = (lch) => {
	const L = lch.x;
	const C = lch.y;
	const h = lch.z;
	return vec3(L, C.mul(cos(h)), C.mul(sin(h)));
};
const mixColors = (colorA, colorB, t, colorSpaceMode) => {
	const p3A = vec3(colorA.x, colorA.y, colorA.z);
	const p3B = vec3(colorB.x, colorB.y, colorB.z);
	const alphaA = colorA.w;
	const alphaB = colorB.w;
	const weightA = alphaA.mul(float(1).sub(t));
	const weightB = alphaB.mul(t);
	const totalWeight = weightA.add(weightB);
	const safeWeight = max(totalWeight, float(.001));
	const alphaWeightedMix = (rgbA, rgbB) => {
		return rgbA.mul(weightA).add(rgbB.mul(weightB)).div(safeWeight);
	};
	const linearMix = alphaWeightedMix(p3A, p3B);
	const srgbA = p3ToSRGB(p3A);
	const srgbB = p3ToSRGB(p3B);
	const oklabA = rgbToOklab(srgbA);
	const oklabB = rgbToOklab(srgbB);
	const oklchResult = sRGBToP3(oklabToRgb(oklchToOklab(alphaWeightedMix(oklabToOklch(oklabA), oklabToOklch(oklabB)))));
	const oklabResult = sRGBToP3(oklabToRgb(alphaWeightedMix(oklabA, oklabB)));
	const isMode1OrHigher = colorSpaceMode.greaterThanEqual(float(.5));
	const rgb = colorSpaceMode.greaterThanEqual(float(1.5)).select(oklabResult, isMode1OrHigher.select(oklchResult, linearMix));
	const alpha = totalWeight;
	return vec4(rgb.x, rgb.y, rgb.z, alpha);
};
export { mixColors as t };
