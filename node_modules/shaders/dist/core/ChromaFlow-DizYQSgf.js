import { r as transformColor } from "./transformations-YbhRK-rd.js";
import { DataTexture, FloatType, LinearFilter, RGFormat } from "three";
import { float, mix, screenUV, smoothstep, texture, uniform, vec2, vec4 } from "three/tsl";
const componentDefinition = {
	name: "ChromaFlow",
	category: "Interactive",
	description: "Interactive liquid flow effect that follows your cursor",
	props: {
		baseColor: {
			default: "#0066ff",
			transform: transformColor,
			description: "Base liquid color",
			ui: {
				type: "color",
				label: "Base Color"
			}
		},
		upColor: {
			default: "#00ff00",
			transform: transformColor,
			description: "Color for upward movement",
			ui: {
				type: "color",
				label: "Up Color"
			}
		},
		downColor: {
			default: "#ff0000",
			transform: transformColor,
			description: "Color for downward movement",
			ui: {
				type: "color",
				label: "Down Color"
			}
		},
		leftColor: {
			default: "#0000ff",
			transform: transformColor,
			description: "Color for leftward movement",
			ui: {
				type: "color",
				label: "Left Color"
			}
		},
		rightColor: {
			default: "#ffff00",
			transform: transformColor,
			description: "Color for rightward movement",
			ui: {
				type: "color",
				label: "Right Color"
			}
		},
		intensity: {
			default: 1,
			description: "Strength of the liquid effect",
			ui: {
				type: "range",
				min: .5,
				max: 1.5,
				step: .1,
				label: "Intensity"
			}
		},
		radius: {
			default: 2,
			description: "Radius of the liquid effect",
			ui: {
				type: "range",
				min: 0,
				max: 3,
				step: .01,
				label: "Radius"
			}
		},
		momentum: {
			default: 30,
			description: "How much momentum colors retain in their flow direction",
			ui: {
				type: "range",
				min: 10,
				max: 60,
				step: 1,
				label: "Momentum"
			}
		}
	},
	fragmentNode: ({ uniforms, onBeforeRender, onCleanup }) => {
		const GRID_SIZE = 128;
		const displacementData = new Float32Array(GRID_SIZE * GRID_SIZE * 2);
		const liquidData = new Float32Array(GRID_SIZE * GRID_SIZE * 2);
		const tempDisplacementData = new Float32Array(GRID_SIZE * GRID_SIZE * 2);
		const tempLiquidData = new Float32Array(GRID_SIZE * GRID_SIZE * 2);
		const displacementTexture = new DataTexture(displacementData, GRID_SIZE, GRID_SIZE, RGFormat, FloatType);
		displacementTexture.magFilter = LinearFilter;
		displacementTexture.minFilter = LinearFilter;
		displacementTexture.needsUpdate = true;
		const liquidTexture = new DataTexture(liquidData, GRID_SIZE, GRID_SIZE, RGFormat, FloatType);
		liquidTexture.magFilter = LinearFilter;
		liquidTexture.minFilter = LinearFilter;
		liquidTexture.needsUpdate = true;
		const displacementField = texture(displacementTexture);
		const liquidField = texture(liquidTexture);
		const mouseX = uniform(.5);
		const mouseY = uniform(.5);
		const mouseVelX = uniform(0);
		const mouseVelY = uniform(0);
		let prevX = .5;
		let prevY = .5;
		let lastTime = Date.now();
		onBeforeRender(({ pointer }) => {
			const currentTime = Date.now();
			const dt = Math.min((currentTime - lastTime) / 1e3, .016);
			lastTime = currentTime;
			const velX = dt > 0 ? (pointer.x - prevX) / dt : 0;
			const velY = dt > 0 ? (pointer.y - prevY) / dt : 0;
			mouseVelX.value = mouseVelX.value * .85 + velX * .15;
			mouseVelY.value = mouseVelY.value * .85 + velY * .15;
			mouseX.value = pointer.x;
			mouseY.value = pointer.y;
			const intensity = uniforms.intensity.uniform.value;
			const radius = uniforms.radius.uniform.value * .05;
			const momentum = uniforms.momentum.uniform.value;
			tempDisplacementData.set(displacementData);
			tempLiquidData.set(liquidData);
			const flowFadeRate = 1 - dt / Math.max(.1, 1);
			for (let i = 0; i < GRID_SIZE * GRID_SIZE * 2; i++) tempDisplacementData[i] = displacementData[i] * flowFadeRate;
			for (let i = 0; i < GRID_SIZE; i++) for (let j = 0; j < GRID_SIZE; j++) {
				const idx = (i * GRID_SIZE + j) * 2;
				const liquidFadeRate = 1 - dt / Math.max(.4, 1);
				tempLiquidData[idx] = liquidData[idx] * liquidFadeRate;
				tempLiquidData[idx + 1] = liquidData[idx + 1] * liquidFadeRate;
				if (Math.abs(displacementData[idx]) > .001 || Math.abs(displacementData[idx + 1]) > .001) {
					const flowSpeed = momentum * 50 * dt;
					const advectX = j - displacementData[idx] * flowSpeed;
					const advectY = i - displacementData[idx + 1] * flowSpeed;
					const x0 = Math.floor(advectX);
					const y0 = Math.floor(advectY);
					const x1 = x0 + 1;
					const y1 = y0 + 1;
					if (x0 >= 0 && y0 >= 0 && x1 < GRID_SIZE && y1 < GRID_SIZE) {
						const fx = advectX - x0;
						const fy = advectY - y0;
						const idx00 = (y0 * GRID_SIZE + x0) * 2;
						const idx01 = (y0 * GRID_SIZE + x1) * 2;
						const idx10 = (y1 * GRID_SIZE + x0) * 2;
						const idx11 = (y1 * GRID_SIZE + x1) * 2;
						tempLiquidData[idx] = (liquidData[idx00] * (1 - fx) * (1 - fy) + liquidData[idx01] * fx * (1 - fy) + liquidData[idx10] * (1 - fx) * fy + liquidData[idx11] * fx * fy) * liquidFadeRate;
					}
				}
			}
			for (let i = 0; i < GRID_SIZE; i++) for (let j = 0; j < GRID_SIZE; j++) {
				const idx = (i * GRID_SIZE + j) * 2;
				const cellX = (j + .5) / GRID_SIZE;
				const cellY = (i + .5) / GRID_SIZE;
				const dx = cellX - pointer.x;
				const dy = cellY - pointer.y;
				const dist = Math.sqrt(dx * dx + dy * dy);
				const speed = Math.sqrt(mouseVelX.value * mouseVelX.value + mouseVelY.value * mouseVelY.value);
				const effectiveRadius = radius * Math.min(speed * speed * 20, 1);
				if (dist < effectiveRadius * 2 && Math.abs(velX) + Math.abs(velY) > .01) {
					const influence = Math.exp(-dist * dist / (effectiveRadius * effectiveRadius));
					tempDisplacementData[idx] += mouseVelX.value * influence * (intensity * 100) * dt * .01;
					tempDisplacementData[idx + 1] += mouseVelY.value * influence * (intensity * 100) * dt * .01;
					const speedMultiplier = Math.min(speed * 10, 1);
					tempLiquidData[idx] += influence * (intensity * 100) * dt * .01 * speedMultiplier;
					tempLiquidData[idx + 1] = 0;
				}
				tempDisplacementData[idx] = Math.max(-1, Math.min(1, tempDisplacementData[idx]));
				tempDisplacementData[idx + 1] = Math.max(-1, Math.min(1, tempDisplacementData[idx + 1]));
				tempLiquidData[idx] = Math.max(0, Math.min(1, tempLiquidData[idx]));
				tempLiquidData[idx + 1] = 0;
			}
			displacementData.set(tempDisplacementData);
			liquidData.set(tempLiquidData);
			displacementTexture.needsUpdate = true;
			liquidTexture.needsUpdate = true;
			prevX = pointer.x;
			prevY = pointer.y;
		});
		onCleanup(() => {
			displacementTexture.dispose();
			liquidTexture.dispose();
		});
		const liquidDensity = liquidField.sample(screenUV).x;
		const pixelSize = vec2(float(1 / 128), float(1 / 128));
		const sample1 = liquidField.sample(screenUV.add(vec2(pixelSize.x, float(0)))).x;
		const sample2 = liquidField.sample(screenUV.add(vec2(float(0), pixelSize.y))).x;
		const sample3 = liquidField.sample(screenUV.add(vec2(pixelSize.x.negate(), float(0)))).x;
		const sample4 = liquidField.sample(screenUV.add(vec2(float(0), pixelSize.y.negate()))).x;
		const smoothedLiquid = liquidDensity.add(sample1).add(sample2).add(sample3).add(sample4).mul(float(.2));
		const liquidIntensity = smoothstep(float(0), float(.1), smoothedLiquid);
		const flowPixelSize = vec2(float(1 / 128), float(1 / 128));
		const centerFlow = displacementField.sample(screenUV).xy;
		const flowSample1 = displacementField.sample(screenUV.add(vec2(flowPixelSize.x, float(0)))).xy;
		const flowSample2 = displacementField.sample(screenUV.add(vec2(float(0), flowPixelSize.y))).xy;
		const flowSample3 = displacementField.sample(screenUV.add(vec2(flowPixelSize.x.negate(), float(0)))).xy;
		const flowSample4 = displacementField.sample(screenUV.add(vec2(float(0), flowPixelSize.y.negate()))).xy;
		const flowVectors = centerFlow.add(flowSample1).add(flowSample2).add(flowSample3).add(flowSample4).mul(float(.2));
		const baseColor = uniforms.baseColor.uniform;
		const upColor = uniforms.upColor.uniform;
		const downColor = uniforms.downColor.uniform;
		const leftColor = uniforms.leftColor.uniform;
		const rightColor = uniforms.rightColor.uniform;
		const flowMagnitude = flowVectors.x.mul(flowVectors.x).add(flowVectors.y.mul(flowVectors.y)).sqrt();
		const hasFlow = smoothstep(float(.01), float(.1), flowMagnitude);
		const normalizedX = flowVectors.x.div(flowMagnitude.add(float(.001)));
		const normalizedY = flowVectors.y.div(flowMagnitude.add(float(.001)));
		const rightAmount = smoothstep(float(0), float(.7), normalizedX.max(float(0)));
		const leftAmount = smoothstep(float(0), float(.7), normalizedX.negate().max(float(0)));
		const upAmount = smoothstep(float(0), float(.7), normalizedY.max(float(0)));
		const downAmount = smoothstep(float(0), float(.7), normalizedY.negate().max(float(0)));
		const horizontalColor = leftColor.mul(leftAmount).add(rightColor.mul(rightAmount));
		const verticalColor = downColor.mul(downAmount).add(upColor.mul(upAmount));
		const horizontalWeight = leftAmount.add(rightAmount);
		const verticalWeight = upAmount.add(downAmount);
		const totalWeight = horizontalWeight.add(verticalWeight).add(float(.001));
		const finalColor = mix(baseColor, horizontalColor.mul(horizontalWeight.div(totalWeight)).add(verticalColor.mul(verticalWeight.div(totalWeight))), hasFlow);
		return vec4(finalColor.rgb.mul(liquidIntensity), finalColor.a.mul(liquidIntensity));
	}
};
var ChromaFlow_default = componentDefinition;
export { componentDefinition as n, ChromaFlow_default as t };
