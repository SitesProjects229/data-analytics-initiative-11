import { n as transformAngle, s as transformPosition } from "./transformations-YbhRK-rd.js";
import { Fn, abs, convertToTexture, cos, dot, float, mix, radians, screenUV, sin, smoothstep, vec2, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "TiltShift",
	category: "Blurs",
	description: "Selective focus blur mimicking tilt-shift photography",
	requiresRTT: true,
	requiresChild: true,
	props: {
		intensity: {
			default: 50,
			description: "Maximum blur intensity at edges",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Intensity"
			}
		},
		width: {
			default: .3,
			description: "Width of the sharp focus area",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Width"
			}
		},
		falloff: {
			default: .3,
			description: "Distance over which blur transitions to full strength",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Falloff"
			}
		},
		angle: {
			default: 0,
			transform: transformAngle,
			description: "Rotation angle of the focus line (in degrees)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "Center point of the focus line",
			ui: {
				type: "position",
				label: "Center"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const angleRad = radians(uniforms.angle.uniform);
		const cosAngle = cos(angleRad);
		const perpVector = vec2(sin(angleRad).negate(), cosAngle);
		const centerPosition = vec2(uniforms.center.uniform[0], uniforms.center.uniform[1].oneMinus());
		const distFromLine = abs(dot(screenUV.sub(centerPosition), perpVector));
		const focusWidth = uniforms.width.uniform.mul(.5);
		const falloff = uniforms.falloff.uniform;
		const blurAmount = smoothstep(focusWidth, focusWidth.add(falloff), distFromLine);
		const scaledIntensity = uniforms.intensity.uniform.mul(.06);
		const blurRadius = blurAmount.mul(scaledIntensity);
		const weights = [
			.056,
			.135,
			.278,
			.487,
			.726,
			.923,
			1,
			.923,
			.726,
			.487,
			.278,
			.135,
			.056
		];
		const weightSum = 6.214;
		const horizontalTexture = convertToTexture(Fn(() => {
			const uv$1 = screenUV;
			const pixelSize = vec2(1).div(viewportSize);
			const total = vec4(0).toVar();
			for (let x = -6; x <= 6; x++) {
				const weight = float(weights[x + 6] / weightSum);
				const offset = vec2(float(x), float(0)).mul(blurRadius).mul(pixelSize);
				const sampleCoord = uv$1.add(offset);
				const sample = childTexture.sample(sampleCoord).mul(weight);
				total.assign(total.add(sample));
			}
			return total;
		})());
		onCleanup(() => {
			if (horizontalTexture?.renderTarget?.dispose) horizontalTexture.renderTarget.dispose();
		});
		return Fn(() => {
			const uv$1 = screenUV;
			const pixelSize = vec2(1).div(viewportSize);
			const total = vec4(0).toVar();
			for (let y = -6; y <= 6; y++) {
				const weight = float(weights[y + 6] / weightSum);
				const offset = vec2(float(0), float(y)).mul(blurRadius).mul(pixelSize);
				const sampleCoord = uv$1.add(offset);
				const sample = horizontalTexture.sample(sampleCoord).mul(weight);
				total.assign(total.add(sample));
			}
			const blurred = total;
			return mix(childTexture.sample(uv$1), blurred, blurAmount);
		})();
	}
};
var TiltShift_default = componentDefinition;
export { componentDefinition as n, TiltShift_default as t };
