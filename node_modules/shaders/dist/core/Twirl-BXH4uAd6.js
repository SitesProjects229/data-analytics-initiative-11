import { t as applyEdgeHandling } from "./edges-Bd7GP4s2.js";
import { o as transformEdges, s as transformPosition } from "./transformations-YbhRK-rd.js";
import { convertToTexture, cos, length, screenUV, sin, vec2, vec4 } from "three/tsl";
const componentDefinition = {
	name: "Twirl",
	category: "Distortions",
	description: "Rotate and twist content around a center point",
	requiresRTT: true,
	requiresChild: true,
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "The center point of the twirl effect",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		intensity: {
			default: 1,
			description: "The strength of the twirl effect",
			ui: {
				type: "range",
				min: -5,
				max: 5,
				step: .1,
				label: "Intensity"
			}
		},
		edges: {
			default: "stretch",
			description: "How to handle edges when distortion pushes content out of bounds",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) {
			console.error("You must pass a child component into the Twirl shader.");
			return vec4(0);
		}
		const texture$1 = convertToTexture(childNode);
		onCleanup(() => {
			if (texture$1?.renderTarget?.dispose) texture$1.renderTarget.dispose();
		});
		const uvNode = screenUV;
		const centerPos = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const delta = uvNode.sub(centerPos);
		const angle = uniforms.intensity.uniform.mul(length(delta));
		const cosAngle = cos(angle);
		const sinAngle = sin(angle);
		const rotatedX = cosAngle.mul(delta.x).sub(sinAngle.mul(delta.y));
		const rotatedY = sinAngle.mul(delta.x).add(cosAngle.mul(delta.y));
		const twistedUV = vec2(rotatedX.add(centerPos.x), rotatedY.add(centerPos.y));
		return applyEdgeHandling(twistedUV, texture$1.sample(twistedUV), texture$1, uniforms.edges.uniform);
	}
};
var Twirl_default = componentDefinition;
export { componentDefinition as n, Twirl_default as t };
