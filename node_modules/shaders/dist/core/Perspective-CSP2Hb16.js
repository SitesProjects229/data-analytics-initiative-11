import { t as applyEdgeHandling } from "./edges-Bd7GP4s2.js";
import { o as transformEdges, s as transformPosition } from "./transformations-YbhRK-rd.js";
import { convertToTexture, cos, float, max, screenUV, sin, tan, vec2, vec4 } from "three/tsl";
const componentDefinition = {
	name: "Perspective",
	category: "Distortions",
	description: "Rotate the plane in 3D space with pan and tilt",
	requiresRTT: true,
	requiresChild: true,
	props: {
		center: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "Center point of rotation",
			ui: {
				type: "position",
				label: "Center"
			}
		},
		pan: {
			default: 0,
			description: "Horizontal rotation (left/right)",
			ui: {
				type: "range",
				min: -90,
				max: 90,
				step: .1,
				label: "Pan"
			}
		},
		tilt: {
			default: 0,
			description: "Vertical rotation (up/down)",
			ui: {
				type: "range",
				min: -90,
				max: 90,
				step: .1,
				label: "Tilt"
			}
		},
		fov: {
			default: 60,
			description: "Field of view - controls perspective intensity",
			ui: {
				type: "range",
				min: 30,
				max: 120,
				step: 1,
				label: "FOV"
			}
		},
		zoom: {
			default: 1,
			description: "Zoom in to fill the frame after rotation",
			ui: {
				type: "range",
				min: .5,
				max: 3,
				step: .01,
				label: "Zoom"
			}
		},
		offset: {
			default: {
				x: .5,
				y: .5
			},
			transform: transformPosition,
			description: "Shift the result in X/Y",
			ui: {
				type: "position",
				label: "Offset"
			}
		},
		edges: {
			default: "transparent",
			description: "How to handle edges",
			transform: transformEdges,
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const centerPos = vec2(uniforms.center.uniform.x, uniforms.center.uniform.y.oneMinus());
		const zoom = uniforms.zoom.uniform;
		const x = screenUV.x.sub(centerPos.x).div(zoom);
		const y = screenUV.y.sub(centerPos.y).div(zoom);
		const panRad = uniforms.pan.uniform.mul(Math.PI / 180);
		const tiltRad = uniforms.tilt.uniform.mul(Math.PI / 180);
		const fovRad = uniforms.fov.uniform.mul(Math.PI / 180);
		const cosPan = cos(panRad);
		const sinPan = sin(panRad);
		const cosTilt = cos(tiltRad);
		const sinTilt = sin(tiltRad);
		const perspectiveFactor = tan(fovRad.mul(.5)).mul(2);
		const safePanDivisor = max(cosPan.add(sinPan.mul(x).mul(perspectiveFactor)), float(.001));
		const afterPanX = x.div(safePanDivisor);
		const afterPanY = y.mul(cosPan).div(safePanDivisor);
		const safeTiltDivisor = max(cosTilt.add(sinTilt.mul(afterPanY).mul(perspectiveFactor)), float(.001));
		const finalX = afterPanX.mul(cosTilt).div(safeTiltDivisor);
		const finalY = afterPanY.div(safeTiltDivisor);
		const offsetPos = vec2(uniforms.offset.uniform.x, uniforms.offset.uniform.y.oneMinus());
		const finalUV = vec2(finalX, finalY).add(centerPos).sub(offsetPos).add(vec2(.5, .5));
		return applyEdgeHandling(finalUV, childTexture.sample(finalUV), childTexture, uniforms.edges.uniform);
	}
};
var Perspective_default = componentDefinition;
export { componentDefinition as n, Perspective_default as t };
