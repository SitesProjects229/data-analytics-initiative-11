import { i as transformColorSpace, n as transformAngle, o as transformEdges, r as transformColor, s as transformPosition, t as colorSpaceOptions } from "./transformations-YbhRK-rd.js";
import { t as mixColors } from "./colorMixing-CZPFmiT4.js";
import { abs, cos, dot, float, fract, length, mod, normalize, radians, screenUV, sin, vec2, vec4 } from "three/tsl";
const componentDefinition = {
	name: "LinearGradient",
	category: "Base Layers",
	description: "Create smooth linear color gradients",
	props: {
		colorA: {
			default: "#1aff00",
			transform: transformColor,
			description: "The starting color of the gradient",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#0000ff",
			transform: transformColor,
			description: "The ending color of the gradient",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		start: {
			default: {
				x: 0,
				y: .5
			},
			transform: transformPosition,
			description: "The starting point of the gradient",
			ui: {
				type: "position",
				label: "Start"
			}
		},
		end: {
			default: {
				x: 1,
				y: .5
			},
			transform: transformPosition,
			description: "The ending point of the gradient",
			ui: {
				type: "position",
				label: "End"
			}
		},
		angle: {
			default: 0,
			transform: transformAngle,
			description: "Additional rotation angle of the gradient (in degrees)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		edges: {
			default: "stretch",
			transform: transformEdges,
			description: "How to handle areas beyond the gradient endpoints",
			ui: {
				type: "select",
				options: [
					{
						label: "Stretch",
						value: "stretch"
					},
					{
						label: "Transparent",
						value: "transparent"
					},
					{
						label: "Mirror",
						value: "mirror"
					},
					{
						label: "Wrap",
						value: "wrap"
					}
				],
				label: "Edges"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms }) => {
		const uv$1 = screenUV;
		const startPos = vec2(uniforms.start.uniform[0], uniforms.start.uniform[1].oneMinus());
		const endPos = vec2(uniforms.end.uniform[0], uniforms.end.uniform[1].oneMinus());
		const gradientVector = endPos.sub(startPos);
		const gradientLength = length(gradientVector);
		const gradientDir = normalize(gradientVector);
		const angleRad = radians(uniforms.angle.uniform).negate();
		const cosAngle = cos(angleRad);
		const sinAngle = sin(angleRad);
		const midpoint = startPos.add(endPos).mul(.5);
		const centeredUV = uv$1.sub(midpoint);
		const t = dot(vec2(centeredUV.x.mul(cosAngle).sub(centeredUV.y.mul(sinAngle)), centeredUV.x.mul(sinAngle).add(centeredUV.y.mul(cosAngle))).add(midpoint).sub(startPos), gradientDir).div(gradientLength.max(1e-6));
		const edgeMode = uniforms.edges.uniform;
		const stretchT = t.clamp(float(0), float(1));
		const inBoundsX = t.greaterThanEqual(float(0)).select(float(1), float(0));
		const inBoundsY = t.lessThanEqual(float(1)).select(float(1), float(0));
		const inBounds = inBoundsX.mul(inBoundsY);
		const mirrorT = mod(abs(t), float(2));
		const finalMirrorT = mirrorT.greaterThan(float(1)).select(float(2).sub(mirrorT), mirrorT);
		const wrapT = fract(t);
		const isMode1OrHigher = edgeMode.greaterThanEqual(float(.5));
		const isMode2OrHigher = edgeMode.greaterThanEqual(float(1.5));
		const finalT = edgeMode.greaterThanEqual(float(2.5)).select(wrapT, isMode2OrHigher.select(finalMirrorT, isMode1OrHigher.select(t, stretchT)));
		const mixedColor = mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, finalT.clamp(float(0), float(1)), uniforms.colorSpace.uniform);
		const finalAlpha = isMode1OrHigher.and(edgeMode.lessThan(float(1.5))).select(mixedColor.w.mul(inBounds), mixedColor.w);
		return vec4(mixedColor.x, mixedColor.y, mixedColor.z, finalAlpha);
	}
};
var LinearGradient_default = componentDefinition;
export { componentDefinition as n, LinearGradient_default as t };
