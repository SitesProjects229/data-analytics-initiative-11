import { Node } from 'three/webgpu';
import { CleanupCallback, ComponentDefinition, NodeMetadata, RenderCallback, ResizeCallback, UniformsMap } from './types';
import { PerformanceStats } from './performanceTracker';

/**
 * Information about a single node in the shader tree.
 */
interface NodeInfo {
    /**
     * The ID of the node.
     *
     */
    id: string;
    /**
     * The name of the component (e.g., "Blur", "RadialGradient")
     */
    componentName: string;
    /**
     * The shader node itself, as defined in fragmentNode()
     */
    fragmentNodeFunc: ComponentDefinition["fragmentNode"];
    /**
     * The ID of the parent node, or null if this is the root node.
     */
    parentId: string | null;
    /**
     * Whether this node requires render-to-texture for proper operation
     */
    requiresRTT: boolean;
    /**
     * Whether this node requires a child component to function properly
     * Effects with requiresChild=true will consume previous siblings and replace composition
     * Generators with requiresChild=false will blend into composition
     */
    requiresChild: boolean;
    /**
     * TSL uniform for opacity value (for performance)
     */
    opacityUniform: any;
    /**
     * The metadata for this node, covering data such as blend mode, opacity
     */
    metadata: NodeMetadata;
    /**
     * The uniform map for this node
     */
    uniforms: UniformsMap;
    /**
     * Callbacks to be executed when the node is removed
     * Used for cleaning up resources like event listeners
     */
    cleanupCallbacks: CleanupCallback[];
    /**
     * Callbacks to be executed before each render frame
     * Used for preparing data or updating uniforms before rendering
     */
    beforeRenderCallbacks: RenderCallback[];
    /**
     * Callbacks to be executed after each render frame
     * Used for post-render operations or preparing for the next frame
     */
    afterRenderCallbacks: RenderCallback[];
    /**
     * Callbacks to be executed when the canvas resizes
     * Used for resizing render targets in RTT effects
     */
    resizeCallbacks: ResizeCallback[];
    /**
     * Optional transform uniforms for UV transformation
     * Only created if transform metadata exists
     */
    transformUniforms?: {
        offsetX: any;
        offsetY: any;
        rotation: any;
        scale: any;
        anchorX: any;
        anchorY: any;
        edges: any;
        aspectRatio: any;
    };
    /**
     * Flag to track if transforms have ever been activated (non-default values used)
     * Once set to true, keeps RTT active even when values return to defaults
     * This prevents recompilation flash during animations
     * NOT persisted - renderer-only flag
     */
    transformRTTActive?: boolean;
}
/**
 * The registry of nodes in the shader tree.
 */
interface NodeRegistry {
    nodes: Map<string, NodeInfo>;
    rootId: string | null;
    idToNodeId: Map<string, string>;
}
/**
 * Options for initializing the renderer.
 */
interface InitializeOptions {
    canvas: HTMLCanvasElement;
    enablePerformanceTracking?: boolean;
}
/**
 * The core renderer for Shaders
 */
export declare function shaderRenderer(): {
    initialize: ({ canvas, enablePerformanceTracking: enableTracking }: InitializeOptions) => Promise<void>;
    cleanup: () => void;
    registerNode: (id: string, fragmentNodeFunc: ComponentDefinition["fragmentNode"] | null, parentId: string | null, metadata: NodeMetadata | null, uniforms?: UniformsMap, componentDefinition?: ComponentDefinition) => void;
    removeNode: (id: string) => void;
    updateUniformValue: (nodeId: string, uniformName: string, value: any) => void;
    updateNodeMetadata: (nodeId: string, metadata: Partial<NodeMetadata>) => void;
    showLicenseWarning: () => void;
    isInitialized: () => boolean;
    startAnimation: () => void;
    stopAnimation: () => void;
    renderAndWait: () => Promise<void>;
    getPerformanceStats: () => PerformanceStats;
    getNodeRegistry: () => {
        nodes: ReadonlyMap<string, NodeInfo>;
    };
    getRendererType: () => "webgpu" | "webgl" | null;
    __testing: {
        needsTransformation: (transform: import('./types').TransformConfig | undefined) => boolean;
        findChildNodes: (parentId: string) => NodeInfo[];
        applyMaskIfNeeded: (result: Node, nodeInfo: NodeInfo, nodeId: string, processedMasks: Set<string>, distortedUV?: Node) => Node;
        applyNodeTransformation: (result: Node, nodeInfo: NodeInfo) => Node;
        getNodeRegistry: () => NodeRegistry;
        getParentToChildren: () => Map<string | null, Set<string>>;
    };
};
export {};
//# sourceMappingURL=renderer.d.ts.map