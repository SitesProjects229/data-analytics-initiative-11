import { Fn, convertToTexture, float, screenUV, vec2, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "ChannelBlur",
	category: "Blurs",
	description: "Independent blur for red, green, and blue channels",
	requiresRTT: true,
	requiresChild: true,
	props: {
		redIntensity: {
			default: 0,
			description: "Blur intensity for red channel",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Red Intensity"
			}
		},
		greenIntensity: {
			default: 20,
			description: "Blur intensity for green channel",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Green Intensity"
			}
		},
		blueIntensity: {
			default: 40,
			description: "Blur intensity for blue channel",
			ui: {
				type: "range",
				min: 0,
				max: 100,
				step: 1,
				label: "Blue Intensity"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const weights = [
			.056,
			.135,
			.278,
			.487,
			.726,
			.923,
			1,
			.923,
			.726,
			.487,
			.278,
			.135,
			.056
		];
		const weightSum = 6.214;
		const redRadius = uniforms.redIntensity.uniform.mul(.1);
		const greenRadius = uniforms.greenIntensity.uniform.mul(.1);
		const blueRadius = uniforms.blueIntensity.uniform.mul(.1);
		const horizontalTexture = convertToTexture(Fn(() => {
			const uv$1 = screenUV;
			const pixelSize = vec2(1).div(viewportSize);
			const redTotal = float(0).toVar();
			const greenTotal = float(0).toVar();
			const blueTotal = float(0).toVar();
			for (let x = -6; x <= 6; x++) {
				const weight = float(weights[x + 6] / weightSum);
				const xOffset = float(x).mul(pixelSize.x);
				const redOffset = vec2(xOffset.mul(redRadius), float(0));
				const greenOffset = vec2(xOffset.mul(greenRadius), float(0));
				const blueOffset = vec2(xOffset.mul(blueRadius), float(0));
				const redSample = childTexture.sample(uv$1.add(redOffset)).r.mul(weight);
				const greenSample = childTexture.sample(uv$1.add(greenOffset)).g.mul(weight);
				const blueSample = childTexture.sample(uv$1.add(blueOffset)).b.mul(weight);
				redTotal.assign(redTotal.add(redSample));
				greenTotal.assign(greenTotal.add(greenSample));
				blueTotal.assign(blueTotal.add(blueSample));
			}
			return vec4(redTotal, greenTotal, blueTotal, float(1));
		})());
		onCleanup(() => {
			if (horizontalTexture?.renderTarget?.dispose) horizontalTexture.renderTarget.dispose();
		});
		return Fn(() => {
			const uv$1 = screenUV;
			const pixelSize = vec2(1).div(viewportSize);
			const redTotal = float(0).toVar();
			const greenTotal = float(0).toVar();
			const blueTotal = float(0).toVar();
			for (let y = -6; y <= 6; y++) {
				const weight = float(weights[y + 6] / weightSum);
				const yOffset = float(y).mul(pixelSize.y);
				const redOffset = vec2(float(0), yOffset.mul(redRadius));
				const greenOffset = vec2(float(0), yOffset.mul(greenRadius));
				const blueOffset = vec2(float(0), yOffset.mul(blueRadius));
				const redSample = horizontalTexture.sample(uv$1.add(redOffset)).r.mul(weight);
				const greenSample = horizontalTexture.sample(uv$1.add(greenOffset)).g.mul(weight);
				const blueSample = horizontalTexture.sample(uv$1.add(blueOffset)).b.mul(weight);
				redTotal.assign(redTotal.add(redSample));
				greenTotal.assign(greenTotal.add(greenSample));
				blueTotal.assign(blueTotal.add(blueSample));
			}
			const originalAlpha = childTexture.sample(uv$1).a;
			return vec4(redTotal, greenTotal, blueTotal, originalAlpha);
		})();
	}
};
var ChannelBlur_default = componentDefinition;
export { componentDefinition as n, ChannelBlur_default as t };
