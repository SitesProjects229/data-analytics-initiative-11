import { i as transformColorSpace, r as transformColor, t as colorSpaceOptions } from "./transformations-YbhRK-rd.js";
import { t as mixColors } from "./colorMixing-CZPFmiT4.js";
import { convertToTexture, dot, screenUV, smoothstep, vec3, vec4 } from "three/tsl";
const componentDefinition = {
	name: "Duotone",
	category: "Adjustments",
	description: "Map colors to two tones based on luminance",
	requiresRTT: true,
	requiresChild: true,
	props: {
		colorA: {
			default: "#ff0000",
			transform: transformColor,
			description: "First color (used for darker areas)",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#023af4",
			transform: transformColor,
			description: "Second color (used for brighter areas)",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		blend: {
			default: .5,
			description: "Blend point between the two colors",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Blend"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms, childNode, onCleanup }) => {
		if (!childNode) return vec4(0, 0, 0, 0);
		const childTexture = convertToTexture(childNode);
		onCleanup(() => {
			if (childTexture?.renderTarget?.dispose) childTexture.renderTarget.dispose();
		});
		const inputColor = childTexture.sample(screenUV);
		const luminance = dot(inputColor.rgb, vec3(.299, .587, .114));
		const adjustedLuminance = smoothstep(uniforms.blend.uniform.sub(.5), uniforms.blend.uniform.add(.5), luminance);
		return vec4(mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, adjustedLuminance, uniforms.colorSpace.uniform).rgb, inputColor.a);
	}
};
var Duotone_default = componentDefinition;
export { componentDefinition as n, Duotone_default as t };
