import { i as transformColorSpace, r as transformColor, t as colorSpaceOptions } from "./transformations-YbhRK-rd.js";
import { t as mixColors } from "./colorMixing-CZPFmiT4.js";
import { float, floor, fract, min, mod, screenUV, smoothstep, vec2, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "Checkerboard",
	category: "Base Layers",
	description: "Classic checkerboard pattern with two alternating colors",
	props: {
		colorA: {
			default: "#cccccc",
			transform: transformColor,
			description: "First color of the checkerboard pattern",
			ui: {
				type: "color",
				label: "Color A"
			}
		},
		colorB: {
			default: "#999999",
			transform: transformColor,
			description: "Second color of the checkerboard pattern",
			ui: {
				type: "color",
				label: "Color B"
			}
		},
		cells: {
			default: 8,
			description: "Number of cells along the shortest canvas edge (creates square cells)",
			ui: {
				type: "range",
				min: 1,
				max: 50,
				step: 1,
				label: "Cells"
			}
		},
		softness: {
			default: 0,
			description: "Smoothness of the transition between colors (0 = hard edges, 1 = very soft)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Softness"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms }) => {
		const uv$1 = screenUV;
		const aspect = viewportSize.x.div(viewportSize.y);
		const correctedUV = vec2(uv$1.x.mul(aspect), uv$1.y.oneMinus());
		const cells = uniforms.cells.uniform;
		const softness = uniforms.softness.uniform;
		const gridUV = correctedUV.mul(cells);
		const gridCoords = floor(gridUV);
		const checkerValue = mod(gridCoords.x.add(gridCoords.y), 2);
		let blendFactor = checkerValue;
		if (softness) {
			const cellUV = fract(gridUV);
			const distToEdge = min(min(cellUV.x, float(1).sub(cellUV.x)), min(cellUV.y, float(1).sub(cellUV.y)));
			const softRange = softness.mul(.5);
			const edgeBlend = smoothstep(float(0), softRange, distToEdge);
			blendFactor = checkerValue.mul(edgeBlend).add(float(.5).mul(float(1).sub(edgeBlend)));
		}
		return mixColors(uniforms.colorA.uniform, uniforms.colorB.uniform, blendFactor, uniforms.colorSpace.uniform);
	}
};
var Checkerboard_default = componentDefinition;
export { componentDefinition as n, Checkerboard_default as t };
