import { i as transformColorSpace, r as transformColor, t as colorSpaceOptions } from "./transformations-YbhRK-rd.js";
import { t as mixColors } from "./colorMixing-CZPFmiT4.js";
import { DataTexture, FloatType, LinearFilter, RGBAFormat } from "three";
import { float, screenUV, step, texture, vec2, vec4 } from "three/tsl";
const componentDefinition = {
	name: "CursorTrail",
	category: "Interactive",
	description: "Animated trail effect that tracks cursor movement",
	props: {
		colorA: {
			default: "#00aaff",
			transform: transformColor,
			description: "Color of fresh trails",
			ui: {
				type: "color",
				label: "Start Color"
			}
		},
		colorB: {
			default: "#ff00aa",
			transform: transformColor,
			description: "Color trails transition to as they fade",
			ui: {
				type: "color",
				label: "End Color"
			}
		},
		radius: {
			default: .5,
			description: "Base radius of trail circles",
			ui: {
				type: "range",
				min: .5,
				max: 2,
				step: .01,
				label: "Radius"
			}
		},
		length: {
			default: .5,
			description: "How long trail circles persist (in seconds)",
			ui: {
				type: "range",
				min: .1,
				max: 2,
				step: .1,
				label: "Trail Length"
			}
		},
		shrink: {
			default: 1,
			description: "How much circles shrink as they fade out (0 = no shrink, 1 = full shrink)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Shrink Amount"
			}
		},
		colorSpace: {
			default: "linear",
			transform: transformColorSpace,
			description: "Color space for color interpolation",
			ui: {
				type: "select",
				options: colorSpaceOptions,
				label: "Color Space"
			}
		}
	},
	fragmentNode: ({ uniforms, onBeforeRender, onCleanup }) => {
		const GRID_SIZE = 128;
		const trailData = new Float32Array(GRID_SIZE * GRID_SIZE * 4);
		const trailTexture = new DataTexture(trailData, GRID_SIZE, GRID_SIZE, RGBAFormat, FloatType);
		trailTexture.magFilter = LinearFilter;
		trailTexture.minFilter = LinearFilter;
		trailTexture.needsUpdate = true;
		const trailField = texture(trailTexture);
		let prevX = .5;
		let prevY = .5;
		let lastTime = Date.now();
		onBeforeRender(({ pointer }) => {
			const currentTime = Date.now();
			const dt = Math.min((currentTime - lastTime) / 1e3, .016);
			lastTime = currentTime;
			const radius = uniforms.radius.uniform.value * .1;
			const length$1 = uniforms.length.uniform.value;
			const shrink = uniforms.shrink.uniform.value;
			const dx = pointer.x - prevX;
			const dy = pointer.y - prevY;
			const speed = Math.sqrt(dx * dx + dy * dy);
			const fadeRate = 1 - dt / Math.max(.1, length$1);
			const ageRate = dt / Math.max(.1, length$1);
			for (let i = 0; i < GRID_SIZE * GRID_SIZE * 4; i += 4) {
				trailData[i] *= fadeRate;
				trailData[i + 1] = 1 - (1 - trailData[i]) * shrink;
				trailData[i + 2] = Math.min(1, trailData[i + 2] + ageRate);
			}
			if (speed > .001) {
				const influenceRadius = radius * 3;
				const minJ = Math.max(0, Math.floor((pointer.x - influenceRadius) * GRID_SIZE));
				const maxJ = Math.min(GRID_SIZE - 1, Math.ceil((pointer.x + influenceRadius) * GRID_SIZE));
				const minI = Math.max(0, Math.floor((pointer.y - influenceRadius) * GRID_SIZE));
				const maxI = Math.min(GRID_SIZE - 1, Math.ceil((pointer.y + influenceRadius) * GRID_SIZE));
				for (let i = minI; i <= maxI; i++) for (let j = minJ; j <= maxJ; j++) {
					const idx = (i * GRID_SIZE + j) * 4;
					const cellX = (j + .5) / GRID_SIZE;
					const cellY = (i + .5) / GRID_SIZE;
					const cellDx = cellX - pointer.x;
					const cellDy = cellY - pointer.y;
					const dist = Math.sqrt(cellDx * cellDx + cellDy * cellDy);
					if (dist < influenceRadius) {
						const addAmount = Math.exp(-dist * dist / (radius * radius)) * speed * 50 * dt;
						trailData[idx] = Math.min(1, trailData[idx] + addAmount);
						trailData[idx + 1] = 1;
						trailData[idx + 2] = 0;
					}
				}
			}
			trailTexture.needsUpdate = true;
			prevX = pointer.x;
			prevY = pointer.y;
		});
		onCleanup(() => {
			trailTexture.dispose();
		});
		const pixelSize = float(1 / GRID_SIZE);
		const centerSample = trailField.sample(screenUV);
		const sample1 = trailField.sample(screenUV.add(vec2(pixelSize, float(0))));
		const sample2 = trailField.sample(screenUV.add(vec2(float(0), pixelSize)));
		const sample3 = trailField.sample(screenUV.add(vec2(pixelSize.negate(), float(0))));
		const sample4 = trailField.sample(screenUV.add(vec2(float(0), pixelSize.negate())));
		const trailIntensity = centerSample.x.mul(float(.5)).add(sample1.x.mul(float(.125))).add(sample2.x.mul(float(.125))).add(sample3.x.mul(float(.125))).add(sample4.x.mul(float(.125)));
		const trailAge = centerSample.z.mul(float(.5)).add(sample1.z.mul(float(.125))).add(sample2.z.mul(float(.125))).add(sample3.z.mul(float(.125))).add(sample4.z.mul(float(.125)));
		const circleMask = step(float(.01), trailIntensity);
		const colorA = uniforms.colorA.uniform;
		const colorB = uniforms.colorB.uniform;
		const trailColor = mixColors(colorA, colorB, trailAge, uniforms.colorSpace.uniform);
		return vec4(trailColor.rgb, trailColor.a.mul(circleMask));
	}
};
var CursorTrail_default = componentDefinition;
export { componentDefinition as n, CursorTrail_default as t };
