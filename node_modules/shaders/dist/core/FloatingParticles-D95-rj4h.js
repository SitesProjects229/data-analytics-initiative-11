import { r as transformColor } from "./transformations-YbhRK-rd.js";
import { t as createAnimatedTime } from "./time-BZqyVJXt.js";
import { Fn, cos, dot, float, floor, fract, length, min, mix, screenUV, sin, smoothstep, time, vec2, vec3, vec4, viewportSize } from "three/tsl";
var hash1_2 = Fn(([p]) => {
	return fract(sin(dot(p, vec2(127.1, 311.7))).mul(43758.5453123));
});
var hash2_2 = Fn(([p]) => {
	return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))).mul(43758.5453));
});
var voronoiPointFromRoot = Fn(([root, deg]) => {
	const point = hash2_2(root).sub(.5);
	const s = sin(deg);
	const c = cos(deg);
	return vec2(c.mul(point.x).sub(s.mul(point.y)).mul(.66), s.mul(point.x).add(c.mul(point.y)).mul(.66)).add(root).add(.5);
});
var degFromRootUV = Fn(([uv$1, randomness]) => {
	return time.mul(randomness).mul(hash1_2(uv$1).sub(.5)).mul(2);
});
var getParticleDistance = Fn(([uv$1, cellUV, randomness]) => {
	const pointUV = voronoiPointFromRoot(cellUV, degFromRootUV(cellUV, randomness));
	return length(uv$1.sub(pointUV));
});
const componentDefinition = {
	name: "FloatingParticles",
	category: "Base Layers",
	description: "Animated floating particles with twinkle effects",
	requiresRTT: false,
	props: {
		randomness: {
			default: .25,
			description: "Randomness of particle animation",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Randomness"
			}
		},
		speed: {
			default: .25,
			description: "Speed of particle movement",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Speed"
			}
		},
		angle: {
			default: 90,
			description: "Movement angle in degrees (0=right, 90=down, 180=left, 270=up)",
			ui: {
				type: "range",
				min: 0,
				max: 360,
				step: 1,
				label: "Angle"
			}
		},
		particleSize: {
			default: 1,
			description: "Size of particles",
			ui: {
				type: "range",
				min: .1,
				max: 20,
				step: .1,
				label: "Particle Size"
			}
		},
		particleSoftness: {
			default: 0,
			description: "Edge softness of particles (0 = sharp, 1 = very soft)",
			ui: {
				type: "range",
				min: 0,
				max: 5,
				step: .01,
				label: "Particle Softness"
			}
		},
		twinkle: {
			default: .5,
			description: "Intensity of the twinkle effect (0 = off, 1 = full twinkle)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Twinkle"
			}
		},
		count: {
			default: 5,
			description: "Number of particle layers",
			ui: {
				type: "range",
				min: 1,
				max: 5,
				step: 1,
				label: "Count"
			}
		},
		particleColor: {
			default: "#ffffff",
			transform: transformColor,
			description: "Color of the particles",
			ui: {
				type: "color",
				label: "Particle Color"
			}
		},
		speedVariance: {
			default: .3,
			description: "Per-layer speed variance (0 = all layers same speed, 1 = high variance)",
			ui: {
				type: "range",
				min: 0,
				max: 1,
				step: .01,
				label: "Speed Variance"
			}
		},
		angleVariance: {
			default: 30,
			description: "Per-layer angle variance in degrees (0 = all layers same angle, 180 = full variance)",
			ui: {
				type: "range",
				min: 0,
				max: 180,
				step: 1,
				label: "Angle Variance"
			}
		},
		particleDensity: {
			default: 3,
			description: "Particle density (lower = more spread out, higher = more dense)",
			ui: {
				type: "range",
				min: .5,
				max: 3,
				step: .1,
				label: "Particle Density"
			}
		}
	},
	fragmentNode: (params) => {
		const { uniforms, childNode } = params;
		const baseUV = screenUV;
		const animTime = createAnimatedTime(params, uniforms.speed);
		const renderParticle = Fn(([uv$2]) => {
			const rootUV = floor(uv$2);
			const localPos = fract(uv$2);
			let minDist = getParticleDistance(uv$2, rootUV, uniforms.randomness.uniform);
			const softness = uniforms.particleSoftness.uniform;
			const scaledSize = uniforms.particleSize.uniform.mul(.01);
			const outerRadius = scaledSize.mul(.6).add(softness.mul(scaledSize.mul(2.4)));
			const needsNeighbors = outerRadius.greaterThan(.35);
			const nearLeft = localPos.x.lessThan(.4);
			const nearRight = localPos.x.greaterThan(.6);
			const nearTop = localPos.y.lessThan(.4);
			const nearBottom = localPos.y.greaterThan(.6);
			const checkLeft = needsNeighbors.and(nearLeft);
			const checkRight = needsNeighbors.and(nearRight);
			const checkTop = needsNeighbors.and(nearTop);
			const checkBottom = needsNeighbors.and(nearBottom);
			minDist = checkLeft.select(min(minDist, getParticleDistance(uv$2, rootUV.add(vec2(-1, 0)), uniforms.randomness.uniform)), minDist);
			minDist = checkRight.select(min(minDist, getParticleDistance(uv$2, rootUV.add(vec2(1, 0)), uniforms.randomness.uniform)), minDist);
			minDist = checkTop.select(min(minDist, getParticleDistance(uv$2, rootUV.add(vec2(0, -1)), uniforms.randomness.uniform)), minDist);
			minDist = checkBottom.select(min(minDist, getParticleDistance(uv$2, rootUV.add(vec2(0, 1)), uniforms.randomness.uniform)), minDist);
			const baseIntensity = smoothstep(outerRadius, scaledSize.mul(.6), minDist);
			const twinkleIntensity = uniforms.twinkle.uniform;
			const particlePhase = rootUV.x.mul(12.9898).add(rootUV.y.mul(78.233)).sin().mul(43758.5453).fract();
			const twinkleValue = sin(time.mul(2).add(particlePhase.mul(6.28318))).mul(.5).add(.5);
			const twinkleModifier = mix(float(1), twinkleValue, twinkleIntensity);
			return baseIntensity.mul(twinkleModifier).mul(uniforms.particleColor.uniform.rgb);
		});
		const layeredParticles = Fn(([uv$2]) => {
			const sizeMod = float(1.05);
			const alphaMod = float(.9);
			const layers = uniforms.count.uniform;
			const particles$1 = vec3(0).toVar();
			const size = float(1).toVar();
			const alpha = float(1).toVar();
			const offset = vec2(0).toVar();
			const angleRad = uniforms.angle.uniform.mul(3.14159).div(180);
			const baseMovementDir = vec2(cos(angleRad), sin(angleRad));
			const baseMovement = animTime.mul(baseMovementDir);
			const speedVar = uniforms.speedVariance.uniform;
			const angleVar = uniforms.angleVariance.uniform.mul(3.14159).div(180);
			for (let i = 0; i < 4; i++) {
				const layerActive = float(i).lessThan(layers).and(alpha.greaterThan(.02));
				const layerHash = hash2_2(vec2(alpha, float(i).mul(7.919)));
				const speedMod = float(1).add(layerHash.x.sub(.5).mul(speedVar));
				const angleDelta = layerHash.y.sub(.5).mul(angleVar).mul(2);
				const variedAngle = angleRad.add(angleDelta);
				const variedDir = vec2(cos(variedAngle), sin(variedAngle));
				const movement = baseMovement.mul(speedMod).add(variedDir.sub(baseMovementDir).mul(animTime));
				const layerParticles = renderParticle(uv$2.mul(size).add(movement).add(offset)).mul(alpha);
				particles$1.assign(particles$1.add(layerActive.select(layerParticles, vec3(0))));
				offset.assign(offset.add(layerHash.mul(10)));
				alpha.assign(alpha.mul(alphaMod));
				size.assign(size.mul(sizeMod));
			}
			return particles$1;
		});
		const uv$1 = baseUV.mul(2).sub(1);
		const aspectRatio = viewportSize.x.div(viewportSize.y);
		const particles = layeredParticles(vec2(uv$1.x.mul(aspectRatio), uv$1.y).mul(uniforms.particleDensity.uniform));
		const particleAlpha = length(particles);
		if (childNode) return vec4(mix(childNode.xyz, particles, particleAlpha.greaterThan(.01).select(particleAlpha, 0)), childNode.w);
		return vec4(particles, particleAlpha);
	}
};
var FloatingParticles_default = componentDefinition;
export { componentDefinition as n, FloatingParticles_default as t };
