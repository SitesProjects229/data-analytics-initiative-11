import { SRGBColorSpace, Texture, TextureLoader } from "three/webgpu";
import { float, max, min, or, screenUV, select, step, texture, uniform, vec2, vec4, viewportSize } from "three/tsl";
const componentDefinition = {
	name: "ImageTexture",
	category: "Base Layers",
	description: "Display an image with customizable object-fit modes",
	props: {
		url: {
			default: "https://shaders.com/sample.jpg",
			description: "Upload an image or provide a URL",
			ui: {
				type: "image-upload",
				label: "Image"
			}
		},
		objectFit: {
			default: "cover",
			description: "How the image should be sized within the viewport",
			transform: (value) => {
				return {
					"cover": 0,
					"contain": 1,
					"fill": 2,
					"scale-down": 3,
					"none": 4
				}[value] ?? 0;
			},
			ui: {
				type: "select",
				options: [
					{
						label: "Cover",
						value: "cover"
					},
					{
						label: "Contain",
						value: "contain"
					},
					{
						label: "Fill",
						value: "fill"
					},
					{
						label: "Scale Down",
						value: "scale-down"
					},
					{
						label: "None",
						value: "none"
					}
				],
				label: "Object Fit"
			}
		}
	},
	fragmentNode: ({ uniforms, onCleanup, onBeforeRender }) => {
		const baseUV = screenUV;
		const loader = new TextureLoader();
		let currentUrl = "";
		let isLoading = false;
		const placeholderTexture = new Texture();
		placeholderTexture.colorSpace = SRGBColorSpace;
		const textureNode = texture(placeholderTexture);
		const imageAspectUniform = uniform(1);
		const imageWidthUniform = uniform(0);
		const imageHeightUniform = uniform(0);
		const loadImage = (url) => {
			if (!url || url.trim() === "" || isLoading) return;
			isLoading = true;
			try {
				let resolvedUrl = url;
				try {
					resolvedUrl = new URL(url, window.location.href).href;
				} catch (e) {}
				loader.load(url, (loadedTexture) => {
					loadedTexture.colorSpace = SRGBColorSpace;
					const img = loadedTexture.image;
					const newWidth = img.width || 1;
					const newHeight = img.height || 1;
					const newAspect = newWidth / newHeight;
					loadedTexture.dispose();
					currentUrl = url;
					requestAnimationFrame(() => {
						const currentImage = placeholderTexture.image;
						if (currentImage && typeof currentImage === "object" && (currentImage.width !== newWidth || currentImage.height !== newHeight)) placeholderTexture.dispose();
						imageAspectUniform.value = newAspect;
						imageWidthUniform.value = newWidth;
						imageHeightUniform.value = newHeight;
						placeholderTexture.image = img;
						placeholderTexture.colorSpace = SRGBColorSpace;
						placeholderTexture.needsUpdate = true;
					});
					isLoading = false;
				}, void 0, (error) => {
					const isRelative = !url.startsWith("http://") && !url.startsWith("https://") && !url.startsWith("data:");
					console.error(`[ImageTexture] Failed to load image\n  Requested URL: ${url}\n  Resolved URL: ${resolvedUrl}\n  Path type: ${isRelative ? "relative" : "absolute"}\n  Error:`, error);
					isLoading = false;
				});
			} catch (error) {
				console.error(`[ImageTexture] Error initiating image load:`, error);
				isLoading = false;
			}
		};
		setTimeout(() => {
			const initialUrl = uniforms?.url?.uniform?.value ?? "";
			if (initialUrl && initialUrl.trim() !== "") loadImage(initialUrl);
		}, 0);
		onBeforeRender(() => {
			const newUrl = uniforms?.url?.uniform?.value ?? "";
			if (newUrl !== currentUrl && !isLoading) loadImage(newUrl);
		});
		onCleanup(() => {
			placeholderTexture.dispose();
		});
		const uv$1 = baseUV;
		const viewportAspect = viewportSize.x.div(viewportSize.y);
		const objectFitMode = uniforms.objectFit.uniform;
		const coverScale = max(viewportAspect.div(imageAspectUniform), float(1));
		const coverUVScale = vec2(imageAspectUniform.div(viewportAspect).mul(coverScale), coverScale);
		const containScale = min(viewportAspect.div(imageAspectUniform), float(1));
		const containUVScale = vec2(imageAspectUniform.div(viewportAspect).mul(containScale), containScale);
		const fillUVScale = vec2(1, 1);
		const scaleDownScale = min(min(viewportAspect.div(imageAspectUniform), float(1)), min(viewportSize.x.div(imageWidthUniform), viewportSize.y.div(imageHeightUniform)));
		const scaleDownUVScale = vec2(imageAspectUniform.div(viewportAspect).mul(scaleDownScale), scaleDownScale);
		const noneScale = min(viewportSize.x.div(imageWidthUniform), viewportSize.y.div(imageHeightUniform));
		const noneUVScale = vec2(imageAspectUniform.div(viewportAspect).mul(noneScale), noneScale);
		const isCover = step(objectFitMode, float(.5));
		const isContain = step(float(.5), objectFitMode).mul(step(objectFitMode, float(1.5)));
		const isFill = step(float(1.5), objectFitMode).mul(step(objectFitMode, float(2.5)));
		const isScaleDown = step(float(2.5), objectFitMode).mul(step(objectFitMode, float(3.5)));
		const isNone = step(float(3.5), objectFitMode);
		const uvScale = vec2(0).add(coverUVScale.mul(isCover)).add(containUVScale.mul(isContain)).add(fillUVScale.mul(isFill)).add(scaleDownUVScale.mul(isScaleDown)).add(noneUVScale.mul(isNone));
		const adjustedUV = uv$1.sub(vec2(.5)).div(uvScale).add(vec2(.5));
		const finalUV = vec2(adjustedUV.x, float(1).sub(adjustedUV.y));
		const sampledColor = textureNode.sample(finalUV);
		const isOutOfBounds = or(or(finalUV.x.lessThan(0), finalUV.x.greaterThan(1)), or(finalUV.y.lessThan(0), finalUV.y.greaterThan(1)));
		return vec4(sampledColor.rgb, select(isOutOfBounds, float(0), sampledColor.a));
	}
};
var ImageTexture_default = componentDefinition;
export { componentDefinition as n, ImageTexture_default as t };
