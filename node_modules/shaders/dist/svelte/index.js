import { n as generatePresetCode } from "./generatePresetCode-CtXcoyI0.js";
import "svelte/internal/disclose-version";
import * as $ from "svelte/internal/client";
import { getContext, onDestroy, onMount, setContext } from "svelte";
import { createUniformsMap, shaderRenderer } from "../core/index.js";
import { componentDefinition } from "../core/shaders/AngularBlur/index.js";
import { componentDefinition as componentDefinition$1 } from "../core/shaders/Ascii/index.js";
import { componentDefinition as componentDefinition$2 } from "../core/shaders/Beam/index.js";
import { componentDefinition as componentDefinition$3 } from "../core/shaders/Blob/index.js";
import { componentDefinition as componentDefinition$4 } from "../core/shaders/Blur/index.js";
import { componentDefinition as componentDefinition$5 } from "../core/shaders/BrightnessContrast/index.js";
import { componentDefinition as componentDefinition$6 } from "../core/shaders/Bulge/index.js";
import { componentDefinition as componentDefinition$7 } from "../core/shaders/CRTScreen/index.js";
import { componentDefinition as componentDefinition$8 } from "../core/shaders/ChannelBlur/index.js";
import { componentDefinition as componentDefinition$9 } from "../core/shaders/Checkerboard/index.js";
import { componentDefinition as componentDefinition$10 } from "../core/shaders/ChromaFlow/index.js";
import { componentDefinition as componentDefinition$11 } from "../core/shaders/ChromaticAberration/index.js";
import { componentDefinition as componentDefinition$12 } from "../core/shaders/Circle/index.js";
import { componentDefinition as componentDefinition$13 } from "../core/shaders/CursorTrail/index.js";
import { componentDefinition as componentDefinition$14 } from "../core/shaders/DiffuseBlur/index.js";
import { componentDefinition as componentDefinition$15 } from "../core/shaders/Dither/index.js";
import { componentDefinition as componentDefinition$16 } from "../core/shaders/DotGrid/index.js";
import { componentDefinition as componentDefinition$17 } from "../core/shaders/Duotone/index.js";
import { componentDefinition as componentDefinition$18 } from "../core/shaders/FilmGrain/index.js";
import { componentDefinition as componentDefinition$19 } from "../core/shaders/FloatingParticles/index.js";
import { componentDefinition as componentDefinition$20 } from "../core/shaders/GlassTiles/index.js";
import { componentDefinition as componentDefinition$21 } from "../core/shaders/Glow/index.js";
import { componentDefinition as componentDefinition$22 } from "../core/shaders/Godrays/index.js";
import { componentDefinition as componentDefinition$23 } from "../core/shaders/Grayscale/index.js";
import { componentDefinition as componentDefinition$24 } from "../core/shaders/Grid/index.js";
import { componentDefinition as componentDefinition$25 } from "../core/shaders/GridDistortion/index.js";
import { componentDefinition as componentDefinition$26 } from "../core/shaders/Group/index.js";
import { componentDefinition as componentDefinition$27 } from "../core/shaders/Halftone/index.js";
import { componentDefinition as componentDefinition$28 } from "../core/shaders/HueShift/index.js";
import { componentDefinition as componentDefinition$29 } from "../core/shaders/ImageTexture/index.js";
import { componentDefinition as componentDefinition$30 } from "../core/shaders/Invert/index.js";
import { componentDefinition as componentDefinition$31 } from "../core/shaders/LinearBlur/index.js";
import { componentDefinition as componentDefinition$32 } from "../core/shaders/LinearGradient/index.js";
import { componentDefinition as componentDefinition$33 } from "../core/shaders/Liquify/index.js";
import { componentDefinition as componentDefinition$34 } from "../core/shaders/Perspective/index.js";
import { componentDefinition as componentDefinition$35 } from "../core/shaders/Pixelate/index.js";
import { componentDefinition as componentDefinition$36 } from "../core/shaders/PolarCoordinates/index.js";
import { componentDefinition as componentDefinition$37 } from "../core/shaders/Posterize/index.js";
import { componentDefinition as componentDefinition$38 } from "../core/shaders/ProgressiveBlur/index.js";
import { componentDefinition as componentDefinition$39 } from "../core/shaders/RadialGradient/index.js";
import { componentDefinition as componentDefinition$40 } from "../core/shaders/RectangularCoordinates/index.js";
import { componentDefinition as componentDefinition$41 } from "../core/shaders/Ripples/index.js";
import { componentDefinition as componentDefinition$42 } from "../core/shaders/Saturation/index.js";
import { componentDefinition as componentDefinition$43 } from "../core/shaders/Sharpness/index.js";
import { componentDefinition as componentDefinition$44 } from "../core/shaders/Shatter/index.js";
import { componentDefinition as componentDefinition$45 } from "../core/shaders/SimplexNoise/index.js";
import { componentDefinition as componentDefinition$46 } from "../core/shaders/SineWave/index.js";
import { componentDefinition as componentDefinition$47 } from "../core/shaders/SolidColor/index.js";
import { componentDefinition as componentDefinition$48 } from "../core/shaders/Spherize/index.js";
import { componentDefinition as componentDefinition$49 } from "../core/shaders/Spiral/index.js";
import { componentDefinition as componentDefinition$50 } from "../core/shaders/Strands/index.js";
import { componentDefinition as componentDefinition$51 } from "../core/shaders/Stretch/index.js";
import { componentDefinition as componentDefinition$52 } from "../core/shaders/Stripes/index.js";
import { componentDefinition as componentDefinition$53 } from "../core/shaders/Swirl/index.js";
import { componentDefinition as componentDefinition$54 } from "../core/shaders/TiltShift/index.js";
import { componentDefinition as componentDefinition$55 } from "../core/shaders/Tint/index.js";
import { componentDefinition as componentDefinition$56 } from "../core/shaders/Tritone/index.js";
import { componentDefinition as componentDefinition$57 } from "../core/shaders/Twirl/index.js";
import { componentDefinition as componentDefinition$58 } from "../core/shaders/Vibrance/index.js";
import { componentDefinition as componentDefinition$59 } from "../core/shaders/WaveDistortion/index.js";
import { componentDefinition as componentDefinition$60 } from "../core/shaders/WebcamTexture/index.js";
import { componentDefinition as componentDefinition$61 } from "../core/shaders/ZoomBlur/index.js";
import { vec4 } from "three/tsl";
import { TelemetryCollector, isExternalUser, shouldCollectTelemetry } from "../core/telemetry/index.js";
function AngularBlur($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition && typeof componentDefinition.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition,
			fragmentNode: componentDefinition?.fragmentNode,
			type: typeof componentDefinition?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Ascii($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$1.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$1.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$1, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$1 && typeof componentDefinition$1.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$1.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$1,
			fragmentNode: componentDefinition$1?.fragmentNode,
			type: typeof componentDefinition$1?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Beam($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$2.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$2.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$2, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$2 && typeof componentDefinition$2.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$2.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$2,
			fragmentNode: componentDefinition$2?.fragmentNode,
			type: typeof componentDefinition$2?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Blob($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$3.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$3.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$3, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$3 && typeof componentDefinition$3.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$3.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$3,
			fragmentNode: componentDefinition$3?.fragmentNode,
			type: typeof componentDefinition$3?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Blur($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$4.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$4.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$4, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$4 && typeof componentDefinition$4.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$4.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$4,
			fragmentNode: componentDefinition$4?.fragmentNode,
			type: typeof componentDefinition$4?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function BrightnessContrast($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$5.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$5.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$5, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$5 && typeof componentDefinition$5.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$5.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$5,
			fragmentNode: componentDefinition$5?.fragmentNode,
			type: typeof componentDefinition$5?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Bulge($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$6.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$6.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$6, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$6 && typeof componentDefinition$6.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$6.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$6,
			fragmentNode: componentDefinition$6?.fragmentNode,
			type: typeof componentDefinition$6?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function CRTScreen($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$7.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$7.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$7, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$7 && typeof componentDefinition$7.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$7.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$7,
			fragmentNode: componentDefinition$7?.fragmentNode,
			type: typeof componentDefinition$7?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function ChannelBlur($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$8.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$8.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$8, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$8 && typeof componentDefinition$8.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$8.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$8,
			fragmentNode: componentDefinition$8?.fragmentNode,
			type: typeof componentDefinition$8?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Checkerboard($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$9.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$9.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$9, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$9 && typeof componentDefinition$9.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$9.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$9,
			fragmentNode: componentDefinition$9?.fragmentNode,
			type: typeof componentDefinition$9?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function ChromaFlow($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$10.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$10.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$10, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$10 && typeof componentDefinition$10.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$10.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$10,
			fragmentNode: componentDefinition$10?.fragmentNode,
			type: typeof componentDefinition$10?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function ChromaticAberration($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$11.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$11.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$11, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$11 && typeof componentDefinition$11.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$11.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$11,
			fragmentNode: componentDefinition$11?.fragmentNode,
			type: typeof componentDefinition$11?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Circle($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$12.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$12.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$12, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$12 && typeof componentDefinition$12.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$12.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$12,
			fragmentNode: componentDefinition$12?.fragmentNode,
			type: typeof componentDefinition$12?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function CursorTrail($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$13.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$13.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$13, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$13 && typeof componentDefinition$13.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$13.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$13,
			fragmentNode: componentDefinition$13?.fragmentNode,
			type: typeof componentDefinition$13?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function DiffuseBlur($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$14.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$14.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$14, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$14 && typeof componentDefinition$14.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$14.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$14,
			fragmentNode: componentDefinition$14?.fragmentNode,
			type: typeof componentDefinition$14?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Dither($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$15.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$15.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$15, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$15 && typeof componentDefinition$15.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$15.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$15,
			fragmentNode: componentDefinition$15?.fragmentNode,
			type: typeof componentDefinition$15?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function DotGrid($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$16.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$16.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$16, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$16 && typeof componentDefinition$16.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$16.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$16,
			fragmentNode: componentDefinition$16?.fragmentNode,
			type: typeof componentDefinition$16?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Duotone($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$17.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$17.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$17, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$17 && typeof componentDefinition$17.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$17.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$17,
			fragmentNode: componentDefinition$17?.fragmentNode,
			type: typeof componentDefinition$17?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function FilmGrain($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$18.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$18.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$18, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$18 && typeof componentDefinition$18.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$18.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$18,
			fragmentNode: componentDefinition$18?.fragmentNode,
			type: typeof componentDefinition$18?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function FloatingParticles($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$19.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$19.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$19, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$19 && typeof componentDefinition$19.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$19.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$19,
			fragmentNode: componentDefinition$19?.fragmentNode,
			type: typeof componentDefinition$19?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function GlassTiles($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$20.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$20.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$20, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$20 && typeof componentDefinition$20.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$20.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$20,
			fragmentNode: componentDefinition$20?.fragmentNode,
			type: typeof componentDefinition$20?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Glow($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$21.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$21.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$21, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$21 && typeof componentDefinition$21.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$21.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$21,
			fragmentNode: componentDefinition$21?.fragmentNode,
			type: typeof componentDefinition$21?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Godrays($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$22.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$22.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$22, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$22 && typeof componentDefinition$22.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$22.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$22,
			fragmentNode: componentDefinition$22?.fragmentNode,
			type: typeof componentDefinition$22?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Grayscale($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$23.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$23.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$23, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$23 && typeof componentDefinition$23.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$23.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$23,
			fragmentNode: componentDefinition$23?.fragmentNode,
			type: typeof componentDefinition$23?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Grid($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$24.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$24.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$24, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$24 && typeof componentDefinition$24.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$24.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$24,
			fragmentNode: componentDefinition$24?.fragmentNode,
			type: typeof componentDefinition$24?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function GridDistortion($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$25.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$25.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$25, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$25 && typeof componentDefinition$25.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$25.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$25,
			fragmentNode: componentDefinition$25?.fragmentNode,
			type: typeof componentDefinition$25?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Group($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$26.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$26.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$26, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$26 && typeof componentDefinition$26.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$26.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$26,
			fragmentNode: componentDefinition$26?.fragmentNode,
			type: typeof componentDefinition$26?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Halftone($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$27.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$27.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$27, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$27 && typeof componentDefinition$27.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$27.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$27,
			fragmentNode: componentDefinition$27?.fragmentNode,
			type: typeof componentDefinition$27?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function HueShift($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$28.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$28.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$28, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$28 && typeof componentDefinition$28.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$28.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$28,
			fragmentNode: componentDefinition$28?.fragmentNode,
			type: typeof componentDefinition$28?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function ImageTexture($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$29.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$29.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$29, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$29 && typeof componentDefinition$29.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$29.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$29,
			fragmentNode: componentDefinition$29?.fragmentNode,
			type: typeof componentDefinition$29?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Invert($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$30.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$30.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$30, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$30 && typeof componentDefinition$30.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$30.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$30,
			fragmentNode: componentDefinition$30?.fragmentNode,
			type: typeof componentDefinition$30?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function LinearBlur($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$31.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$31.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$31, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$31 && typeof componentDefinition$31.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$31.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$31,
			fragmentNode: componentDefinition$31?.fragmentNode,
			type: typeof componentDefinition$31?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function LinearGradient($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$32.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$32.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$32, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$32 && typeof componentDefinition$32.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$32.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$32,
			fragmentNode: componentDefinition$32?.fragmentNode,
			type: typeof componentDefinition$32?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Liquify($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$33.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$33.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$33, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$33 && typeof componentDefinition$33.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$33.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$33,
			fragmentNode: componentDefinition$33?.fragmentNode,
			type: typeof componentDefinition$33?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Perspective($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$34.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$34.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$34, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$34 && typeof componentDefinition$34.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$34.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$34,
			fragmentNode: componentDefinition$34?.fragmentNode,
			type: typeof componentDefinition$34?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Pixelate($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$35.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$35.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$35, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$35 && typeof componentDefinition$35.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$35.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$35,
			fragmentNode: componentDefinition$35?.fragmentNode,
			type: typeof componentDefinition$35?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function PolarCoordinates($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$36.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$36.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$36, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$36 && typeof componentDefinition$36.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$36.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$36,
			fragmentNode: componentDefinition$36?.fragmentNode,
			type: typeof componentDefinition$36?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Posterize($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$37.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$37.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$37, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$37 && typeof componentDefinition$37.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$37.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$37,
			fragmentNode: componentDefinition$37?.fragmentNode,
			type: typeof componentDefinition$37?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function ProgressiveBlur($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$38.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$38.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$38, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$38 && typeof componentDefinition$38.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$38.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$38,
			fragmentNode: componentDefinition$38?.fragmentNode,
			type: typeof componentDefinition$38?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function RadialGradient($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$39.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$39.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$39, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$39 && typeof componentDefinition$39.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$39.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$39,
			fragmentNode: componentDefinition$39?.fragmentNode,
			type: typeof componentDefinition$39?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function RectangularCoordinates($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$40.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$40.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$40, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$40 && typeof componentDefinition$40.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$40.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$40,
			fragmentNode: componentDefinition$40?.fragmentNode,
			type: typeof componentDefinition$40?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Ripples($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$41.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$41.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$41, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$41 && typeof componentDefinition$41.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$41.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$41,
			fragmentNode: componentDefinition$41?.fragmentNode,
			type: typeof componentDefinition$41?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Saturation($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$42.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$42.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$42, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$42 && typeof componentDefinition$42.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$42.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$42,
			fragmentNode: componentDefinition$42?.fragmentNode,
			type: typeof componentDefinition$42?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Sharpness($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$43.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$43.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$43, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$43 && typeof componentDefinition$43.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$43.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$43,
			fragmentNode: componentDefinition$43?.fragmentNode,
			type: typeof componentDefinition$43?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Shatter($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$44.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$44.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$44, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$44 && typeof componentDefinition$44.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$44.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$44,
			fragmentNode: componentDefinition$44?.fragmentNode,
			type: typeof componentDefinition$44?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function SimplexNoise($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$45.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$45.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$45, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$45 && typeof componentDefinition$45.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$45.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$45,
			fragmentNode: componentDefinition$45?.fragmentNode,
			type: typeof componentDefinition$45?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function SineWave($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$46.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$46.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$46, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$46 && typeof componentDefinition$46.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$46.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$46,
			fragmentNode: componentDefinition$46?.fragmentNode,
			type: typeof componentDefinition$46?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function SolidColor($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$47.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$47.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$47, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$47 && typeof componentDefinition$47.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$47.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$47,
			fragmentNode: componentDefinition$47?.fragmentNode,
			type: typeof componentDefinition$47?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Spherize($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$48.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$48.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$48, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$48 && typeof componentDefinition$48.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$48.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$48,
			fragmentNode: componentDefinition$48?.fragmentNode,
			type: typeof componentDefinition$48?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Spiral($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$49.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$49.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$49, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$49 && typeof componentDefinition$49.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$49.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$49,
			fragmentNode: componentDefinition$49?.fragmentNode,
			type: typeof componentDefinition$49?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Strands($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$50.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$50.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$50, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$50 && typeof componentDefinition$50.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$50.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$50,
			fragmentNode: componentDefinition$50?.fragmentNode,
			type: typeof componentDefinition$50?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Stretch($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$51.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$51.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$51, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$51 && typeof componentDefinition$51.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$51.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$51,
			fragmentNode: componentDefinition$51?.fragmentNode,
			type: typeof componentDefinition$51?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Stripes($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$52.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$52.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$52, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$52 && typeof componentDefinition$52.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$52.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$52,
			fragmentNode: componentDefinition$52?.fragmentNode,
			type: typeof componentDefinition$52?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Swirl($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$53.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$53.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$53, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$53 && typeof componentDefinition$53.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$53.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$53,
			fragmentNode: componentDefinition$53?.fragmentNode,
			type: typeof componentDefinition$53?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function TiltShift($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$54.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$54.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$54, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$54 && typeof componentDefinition$54.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$54.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$54,
			fragmentNode: componentDefinition$54?.fragmentNode,
			type: typeof componentDefinition$54?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Tint($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$55.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$55.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$55, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$55 && typeof componentDefinition$55.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$55.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$55,
			fragmentNode: componentDefinition$55?.fragmentNode,
			type: typeof componentDefinition$55?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Tritone($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$56.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$56.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$56, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$56 && typeof componentDefinition$56.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$56.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$56,
			fragmentNode: componentDefinition$56?.fragmentNode,
			type: typeof componentDefinition$56?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Twirl($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$57.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$57.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$57, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$57 && typeof componentDefinition$57.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$57.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$57,
			fragmentNode: componentDefinition$57?.fragmentNode,
			type: typeof componentDefinition$57?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function Vibrance($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$58.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$58.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$58, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$58 && typeof componentDefinition$58.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$58.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$58,
			fragmentNode: componentDefinition$58?.fragmentNode,
			type: typeof componentDefinition$58?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function WaveDistortion($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$59.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$59.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$59, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$59 && typeof componentDefinition$59.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$59.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$59,
			fragmentNode: componentDefinition$59?.fragmentNode,
			type: typeof componentDefinition$59?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function WebcamTexture($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$60.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$60.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$60, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$60 && typeof componentDefinition$60.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$60.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$60,
			fragmentNode: componentDefinition$60?.fragmentNode,
			type: typeof componentDefinition$60?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
function ZoomBlur($$anchor, $$props) {
	$.push($$props, true);
	const DEFAULT_TRANSFORM = {
		offsetX: 0,
		offsetY: 0,
		rotation: 0,
		scale: 1,
		anchorX: .5,
		anchorY: .5,
		edges: "transparent"
	};
	const componentDefaults = {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition$61.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	};
	const props = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy"
	]);
	const blendMode = $$props.blendMode ?? componentDefaults.blendMode;
	const opacity = $$props.opacity;
	const visible = $$props.visible ?? componentDefaults.visible;
	const id = $$props.id;
	const maskSource = $$props.maskSource;
	const maskType = $$props.maskType;
	const renderOrder = $$props.renderOrder ?? componentDefaults.renderOrder;
	const { children } = props;
	const effectiveTransform = $.derived(() => ({
		...DEFAULT_TRANSFORM,
		...$$props.transform
	}));
	const parentId = getContext("shaderParentId");
	if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const instanceId = id || `${componentDefinition$61.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	setContext("shaderParentId", instanceId);
	const shaderReadyProps = $.derived(() => {
		let baseProps = { ...componentDefaults };
		for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && key !== "children") {
			const propValue = props[key];
			const defaultValue = componentDefaults[key];
			if (propValue !== void 0 && propValue !== defaultValue) baseProps[key] = propValue;
		}
		return baseProps;
	});
	const uniforms = createUniformsMap(componentDefinition$61, $.get(shaderReadyProps), instanceId);
	const parentRegister = getContext("shaderNodeRegister");
	if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const parentUniformUpdate = getContext("shaderUniformUpdate");
	if (parentUniformUpdate === void 0) throw new Error("Shader components require shaderUniformUpdate from parent");
	const parentMetadataUpdate = getContext("shaderMetadataUpdate");
	if (parentMetadataUpdate === void 0) throw new Error("Shader components require shaderMetadataUpdate from parent");
	let isRegistered = $.state(false);
	Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
		$.user_effect(() => {
			if (!$.get(isRegistered)) return;
			if (uniform && uniform.value !== void 0) {
				const newValue = props[propName];
				if (newValue !== void 0) parentUniformUpdate(instanceId, propName, newValue);
			}
		});
	});
	$.user_effect(() => {
		if (!$.get(isRegistered)) return;
		parentMetadataUpdate(instanceId, {
			blendMode,
			opacity,
			visible: visible === false ? false : true,
			id,
			mask: maskSource ? {
				source: maskSource,
				type: maskType || "alpha"
			} : void 0,
			renderOrder,
			transform: $.get(effectiveTransform)
		});
	});
	onMount(() => {
		if (componentDefinition$61 && typeof componentDefinition$61.fragmentNode === "function") {
			parentRegister(instanceId, componentDefinition$61.fragmentNode, parentId, {
				blendMode,
				opacity,
				visible: visible !== false ? true : false,
				id,
				mask: maskSource ? {
					source: maskSource,
					type: maskType || "alpha"
				} : void 0,
				renderOrder,
				transform: $.get(effectiveTransform)
			}, uniforms);
			$.set(isRegistered, true);
		} else console.error("componentDefinition.fragmentNode is not a function:", {
			componentDefinition: componentDefinition$61,
			fragmentNode: componentDefinition$61?.fragmentNode,
			type: typeof componentDefinition$61?.fragmentNode
		});
	});
	onDestroy(() => {
		$.set(isRegistered, false);
		parentRegister(instanceId, null, null, null, null);
	});
	children?.($$anchor);
	$.pop();
}
var root = $.from_html(`<div><canvas data-renderer="shaders" style="width: 100%; height: 100%; display: block;"></canvas> <!></div>`);
function Shader($$anchor, $$props) {
	$.push($$props, true);
	const hideNotice = $.prop($$props, "hideNotice", 3, false), rest = $.rest_props($$props, [
		"$$slots",
		"$$events",
		"$$legacy",
		"hideNotice",
		"children"
	]);
	let containerRef;
	let canvasRef;
	const rootId = "shader-root-" + Math.random().toString(36).substring(7);
	let rendererInstance = shaderRenderer();
	let telemetryCollector = null;
	setContext("shaderParentId", rootId);
	setContext("shaderNodeRegister", (id, fragmentNodeFunc, parentId, metadata, uniforms = null) => {
		if (fragmentNodeFunc === null) rendererInstance.removeNode(id);
		else rendererInstance.registerNode(id, fragmentNodeFunc, parentId, metadata, uniforms);
	});
	setContext("shaderUniformUpdate", (nodeId, uniformName, value) => {
		rendererInstance.updateUniformValue(nodeId, uniformName, value);
	});
	setContext("shaderMetadataUpdate", (nodeId, metadata) => {
		rendererInstance.updateNodeMetadata(nodeId, metadata);
	});
	let wasVisible = false;
	let visibilityObserver = null;
	const initializeRenderer = async () => {
		if (!canvasRef) return;
		try {
			if (!rendererInstance.isInitialized()) await rendererInstance.initialize({ canvas: canvasRef });
			rendererInstance.registerNode(rootId, ({ childNode }) => childNode || vec4(0, 0, 0, 0), null, null, {});
			if (!hideNotice()) rendererInstance.showLicenseWarning();
			if (isExternalUser() && shouldCollectTelemetry()) {
				telemetryCollector = new TelemetryCollector(rendererInstance);
				telemetryCollector.start();
			}
		} catch (err) {
			console.error("[Shader] Initialization failed:", err);
			throw err;
		}
	};
	const setupVisibilityObserver = () => {
		if (!containerRef || visibilityObserver) return;
		visibilityObserver = new IntersectionObserver((entries) => {
			const entry = entries[0];
			if (!entry) return;
			const rect = containerRef?.getBoundingClientRect();
			const isCurrentlyVisible = entry.isIntersecting && rect && rect.width > 0 && rect.height > 0;
			if (isCurrentlyVisible && !wasVisible) {
				if (rendererInstance.isInitialized()) rendererInstance.startAnimation();
				else initializeRenderer().catch(console.error);
				wasVisible = true;
			} else if (!isCurrentlyVisible && wasVisible) {
				rendererInstance.stopAnimation();
				wasVisible = false;
			}
		}, { threshold: 0 });
		visibilityObserver.observe(containerRef);
	};
	onMount(async () => {
		if (!canvasRef || !containerRef) {
			console.error("Canvas or container ref is null in Shader onMount");
			return;
		}
		const rect = containerRef.getBoundingClientRect();
		if (rect.width > 0 && rect.height > 0) {
			await initializeRenderer();
			wasVisible = true;
		} else wasVisible = false;
		setupVisibilityObserver();
	});
	onDestroy(() => {
		if (telemetryCollector) {
			telemetryCollector.stop();
			telemetryCollector = null;
		}
		if (visibilityObserver) {
			visibilityObserver.disconnect();
			visibilityObserver = null;
		}
		if (rendererInstance && rendererInstance.isInitialized()) try {
			rendererInstance.cleanup();
		} catch (err) {
			console.warn("[Shader] Error during cleanup:", err);
		}
	});
	var div = root();
	$.attribute_effect(div, () => ({
		class: "shader",
		...rest
	}));
	var canvas = $.child(div);
	$.bind_this(canvas, ($$value) => canvasRef = $$value, () => canvasRef);
	var node = $.sibling(canvas, 2);
	$.snippet(node, () => $$props.children ?? $.noop);
	$.reset(div);
	$.bind_this(div, ($$value) => containerRef = $$value, () => containerRef);
	$.append($$anchor, div);
	$.pop();
}
export { AngularBlur, Ascii, Beam, Blob, Blur, BrightnessContrast, Bulge, CRTScreen, ChannelBlur, Checkerboard, ChromaFlow, ChromaticAberration, Circle, CursorTrail, DiffuseBlur, Dither, DotGrid, Duotone, FilmGrain, FloatingParticles, GlassTiles, Glow, Godrays, Grayscale, Grid, GridDistortion, Group, Halftone, HueShift, ImageTexture, Invert, LinearBlur, LinearGradient, Liquify, Perspective, Pixelate, PolarCoordinates, Posterize, ProgressiveBlur, RadialGradient, RectangularCoordinates, Ripples, Saturation, Shader, Sharpness, Shatter, SimplexNoise, SineWave, SolidColor, Spherize, Spiral, Strands, Stretch, Stripes, Swirl, TiltShift, Tint, Tritone, Twirl, Vibrance, WaveDistortion, WebcamTexture, ZoomBlur, generatePresetCode };
