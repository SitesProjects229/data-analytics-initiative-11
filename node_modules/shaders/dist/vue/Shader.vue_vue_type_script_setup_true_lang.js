import { createElementBlock, createElementVNode, defineComponent, mergeProps, onBeforeUnmount, onMounted, openBlock, provide, ref, renderSlot } from "vue";
import { shaderRenderer } from "../core/index.js";
import { vec4 } from "three/tsl";
import { TelemetryCollector, isExternalUser, shouldCollectTelemetry } from "../core/telemetry/index.js";
var Shader_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Shader",
	props: { hideNotice: {
		type: Boolean,
		default: false
	} },
	setup(__props, { expose: __expose }) {
		const props = __props;
		const containerRef = ref(null);
		const canvasRef = ref(null);
		const rootId = ref("ombre-root-" + Math.random().toString(36).substring(7));
		const rendererInstance = ref(shaderRenderer());
		const rendererResetSignal = ref(0);
		let telemetryCollector = null;
		provide("ombreParentId", rootId.value);
		provide("ombreRendererResetSignal", rendererResetSignal);
		provide("ombreNodeRegister", (id, fragmentNodeFunc, parentId, metadata, uniforms = null, componentDefinition = null) => {
			if (fragmentNodeFunc === null) rendererInstance.value.removeNode(id);
			else rendererInstance.value.registerNode(id, fragmentNodeFunc, parentId, metadata, uniforms, componentDefinition);
		});
		provide("ombreUniformUpdate", (nodeId, uniformName, value) => {
			rendererInstance.value.updateUniformValue(nodeId, uniformName, value);
		});
		provide("ombreMetadataUpdate", (nodeId, metadata) => {
			rendererInstance.value.updateNodeMetadata(nodeId, metadata);
		});
		const initializeRenderer = async () => {
			if (!canvasRef.value) return;
			if (!rendererInstance.value.isInitialized()) await rendererInstance.value.initialize({
				canvas: canvasRef.value,
				enablePerformanceTracking: true
			});
			rendererInstance.value.registerNode(rootId.value, ({ childNode }) => childNode || vec4(0, 0, 0, 0), null, null, {}, void 0);
			if (!props.hideNotice) rendererInstance.value.showLicenseWarning();
			if (isExternalUser() && shouldCollectTelemetry()) {
				telemetryCollector = new TelemetryCollector(rendererInstance.value);
				telemetryCollector.start();
			}
		};
		let wasVisible = false;
		let visibilityObserver = null;
		const setupVisibilityObserver = () => {
			if (!containerRef.value || visibilityObserver) return;
			visibilityObserver = new IntersectionObserver((entries) => {
				const entry = entries[0];
				if (!entry) return;
				const rect = containerRef.value?.getBoundingClientRect();
				const isCurrentlyVisible = entry.isIntersecting && rect && rect.width > 0 && rect.height > 0;
				if (isCurrentlyVisible && !wasVisible) {
					if (rendererInstance.value.isInitialized()) rendererInstance.value.startAnimation();
					else initializeRenderer().then(() => {
						rendererResetSignal.value++;
					}).catch(console.error);
					wasVisible = true;
				} else if (!isCurrentlyVisible && wasVisible) {
					rendererInstance.value.stopAnimation();
					wasVisible = false;
				}
			}, { threshold: 0 });
			visibilityObserver.observe(containerRef.value);
		};
		onMounted(async () => {
			if (canvasRef.value && containerRef.value) {
				const rect = containerRef.value.getBoundingClientRect();
				if (rect.width > 0 && rect.height > 0) {
					await initializeRenderer();
					rendererResetSignal.value++;
					wasVisible = true;
				} else wasVisible = false;
				setupVisibilityObserver();
			}
		});
		const captureScreenshot = async (maxWidth = 1200) => {
			if (!canvasRef.value) throw new Error("Canvas not available");
			try {
				await rendererInstance.value.renderAndWait();
			} catch (error) {
				console.warn("Failed to force render before screenshot:", error);
			}
			return new Promise((resolve, reject) => {
				const sourceCanvas = canvasRef.value;
				const sourceWidth = sourceCanvas.width;
				const sourceHeight = sourceCanvas.height;
				let targetWidth = sourceWidth;
				let targetHeight = sourceHeight;
				if (sourceWidth > maxWidth) {
					targetWidth = maxWidth;
					targetHeight = Math.round(sourceHeight / sourceWidth * maxWidth);
				}
				const dataUrl = sourceCanvas.toDataURL("image/png");
				const img = new Image();
				img.onload = () => {
					const tempCanvas = document.createElement("canvas");
					tempCanvas.width = targetWidth;
					tempCanvas.height = targetHeight;
					const ctx = tempCanvas.getContext("2d");
					if (!ctx) {
						reject(/* @__PURE__ */ new Error("Failed to get canvas context"));
						return;
					}
					ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
					tempCanvas.toBlob((blob) => {
						if (blob) resolve(blob);
						else reject(/* @__PURE__ */ new Error("Failed to capture screenshot"));
					}, "image/jpeg", .85);
				};
				img.onerror = () => {
					reject(/* @__PURE__ */ new Error("Failed to load canvas image"));
				};
				img.src = dataUrl;
			});
		};
		const getPerformanceStats = () => {
			return rendererInstance.value.getPerformanceStats();
		};
		__expose({
			captureScreenshot,
			getPerformanceStats
		});
		onBeforeUnmount(() => {
			if (telemetryCollector) {
				telemetryCollector.stop();
				telemetryCollector = null;
			}
			if (visibilityObserver) {
				visibilityObserver.disconnect();
				visibilityObserver = null;
			}
			rendererInstance.value.cleanup();
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", mergeProps({
				class: "shader",
				ref_key: "containerRef",
				ref: containerRef
			}, _ctx.$attrs), [createElementVNode("canvas", {
				"data-renderer": "shaders",
				ref_key: "canvasRef",
				ref: canvasRef,
				style: {
					"width": "100%",
					"height": "100%",
					"display": "block"
				}
			}, [renderSlot(_ctx.$slots, "default")], 512)], 16);
		};
	}
});
export { Shader_vue_vue_type_script_setup_true_lang_default as default };
