import { computed, defineComponent, effectScope, inject, mergeDefaults, onBeforeUnmount, provide, renderSlot, toValue, watch } from "vue";
import { createUniformsMap } from "../core/index.js";
import { componentDefinition } from "../core/shaders/Circle/index.js";
var Circle_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Circle",
	props: /* @__PURE__ */ mergeDefaults({
		blendMode: {},
		opacity: {},
		visible: { type: Boolean },
		id: {},
		maskSource: {},
		maskType: {},
		renderOrder: {},
		transform: {},
		color: {},
		radius: {},
		softness: {},
		center: {}
	}, {
		blendMode: "normal",
		renderOrder: 0,
		visible: true,
		...Object.entries(componentDefinition.props).reduce((acc, [key, config]) => {
			acc[key] = config.default;
			return acc;
		}, {})
	}),
	setup(__props) {
		const props = __props;
		const instanceId = props.id || `${componentDefinition.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
		provide("ombreParentId", instanceId);
		const DEFAULT_TRANSFORM = {
			offsetX: 0,
			offsetY: 0,
			rotation: 0,
			scale: 1,
			anchorX: .5,
			anchorY: .5,
			edges: "transparent"
		};
		const effectiveTransform = computed(() => ({
			...DEFAULT_TRANSFORM,
			...props.transform
		}));
		const uniforms = createUniformsMap(componentDefinition, computed(() => {
			let baseProps = { ...Object.entries(componentDefinition.props).reduce((acc, [key, config]) => {
				acc[key] = config.default;
				return acc;
			}, {}) };
			for (const key in props) if (key !== "blendMode" && key !== "opacity" && key !== "visible" && key !== "id" && key !== "maskSource" && key !== "maskType" && key !== "renderOrder" && key !== "transform" && props[key] !== Object.entries(componentDefinition.props).reduce((acc, [key$1, config]) => {
				acc[key$1] = config.default;
				return acc;
			}, {})[key]) baseProps[key] = toValue(props[key]);
			return baseProps;
		}).value, instanceId);
		const parentId = inject("ombreParentId");
		if (parentId === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
		const parentRegister = inject("ombreNodeRegister");
		if (parentRegister === void 0) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
		const parentUniformUpdate = inject("ombreUniformUpdate");
		if (parentUniformUpdate === void 0) throw new Error("Shader components require ombreUniformUpdate from parent");
		const parentMetadataUpdate = inject("ombreMetadataUpdate");
		if (parentMetadataUpdate === void 0) throw new Error("Shader components require ombreMetadataUpdate from parent");
		const rendererResetSignal = inject("ombreRendererResetSignal");
		const registerWithRenderer = () => {
			parentRegister(instanceId, componentDefinition.fragmentNode, parentId, {
				blendMode: props.blendMode,
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder,
				transform: effectiveTransform.value
			}, uniforms, componentDefinition);
		};
		const setupUniformWatchers = () => {
			const scope = effectScope();
			scope.run(() => {
				Object.entries(uniforms).forEach(([propName, { uniform, transform }]) => {
					watch(() => props[propName], (newValue) => {
						if (uniform && uniform.value !== void 0) parentUniformUpdate(instanceId, propName, newValue);
					}, { deep: true });
				});
				watch(() => [
					props.blendMode,
					props.opacity,
					props.visible,
					props.id,
					props.maskSource,
					props.maskType,
					props.renderOrder,
					props.transform
				], ([blendMode, opacity, visible]) => {
					parentMetadataUpdate(instanceId, {
						blendMode,
						opacity,
						visible: visible === false ? false : true,
						id: props.id,
						mask: props.maskSource ? {
							source: props.maskSource,
							type: props.maskType || "alpha"
						} : void 0,
						renderOrder: props.renderOrder,
						transform: effectiveTransform.value
					});
				}, { deep: true });
				if (rendererResetSignal) watch(() => rendererResetSignal.value, (newValue) => {
					if (newValue > 0) registerWithRenderer();
				}, { immediate: true });
			});
			onBeforeUnmount(() => {
				scope.stop();
			});
		};
		setupUniformWatchers();
		onBeforeUnmount(() => {
			parentRegister(instanceId, null, null, null, null, null);
		});
		return (_ctx, _cache) => {
			return renderSlot(_ctx.$slots, "default");
		};
	}
});
export { Circle_vue_vue_type_script_setup_true_lang_default as default };
