import { createContext, useEffect, useMemo, useRef } from "react";
import { shaderRenderer } from "../core/index.js";
import { vec4 } from "three/tsl";
import { TelemetryCollector, isExternalUser, shouldCollectTelemetry } from "../core/telemetry/index.js";
import { jsx, jsxs } from "react/jsx-runtime";
const OmbreContext = createContext(null);
const Shader = ({ children, hideNotice = false, style = {}, className = "",...rest }) => {
	const containerRef = useRef(null);
	const canvasRef = useRef(null);
	const rootId = useMemo(() => "ombre-root-" + Math.random().toString(36).substring(7), []);
	const rendererRef = useRef(null);
	if (rendererRef.current === null) rendererRef.current = shaderRenderer();
	const telemetryCollectorRef = useRef(null);
	const nodeRegister = useMemo(() => {
		return (id, fragmentNodeFunc, parentId, metadata, uniforms = null, componentDefinition = null) => {
			if (fragmentNodeFunc === null) {
				try {
					rendererRef.current.removeNode(id);
				} catch (err) {
					console.warn("Error removing node:", err);
				}
				return;
			}
			try {
				rendererRef.current.registerNode(id, fragmentNodeFunc, parentId, metadata, uniforms, componentDefinition);
			} catch (err) {
				console.error("Error registering node:", err, {
					id,
					parentId,
					metadata
				});
			}
		};
	}, []);
	const uniformUpdate = useMemo(() => {
		return (nodeId, uniformName, value) => {
			try {
				rendererRef.current.updateUniformValue(nodeId, uniformName, value);
			} catch (err) {
				console.warn("Error updating uniform:", err);
			}
		};
	}, []);
	const metadataUpdate = useMemo(() => {
		return (nodeId, metadata) => {
			try {
				rendererRef.current.updateNodeMetadata(nodeId, metadata);
			} catch (err) {
				console.warn("Error updating metadata:", err);
			}
		};
	}, []);
	const contextValue = useMemo(() => {
		return {
			ombreParentId: rootId,
			ombreNodeRegister: nodeRegister,
			ombreUniformUpdate: uniformUpdate,
			ombreMetadataUpdate: metadataUpdate
		};
	}, [
		rootId,
		nodeRegister,
		uniformUpdate,
		metadataUpdate
	]);
	const isInitializedRef = useRef(false);
	const isInitializingRef = useRef(false);
	const isCleanedUpRef = useRef(false);
	const wasVisibleRef = useRef(false);
	const visibilityObserverRef = useRef(null);
	const initializeRenderer = async () => {
		const canvas = canvasRef.current;
		if (!canvas || isInitializedRef.current || isInitializingRef.current) return;
		isInitializingRef.current = true;
		try {
			const renderer = rendererRef.current;
			if (!renderer.isInitialized()) await renderer.initialize({ canvas });
			renderer.registerNode(rootId, ({ childNode }) => childNode || vec4(0, 0, 0, 0), null, null, {});
			isInitializedRef.current = true;
			isInitializingRef.current = false;
			if (!hideNotice) renderer.showLicenseWarning();
			if (isExternalUser() && shouldCollectTelemetry()) {
				telemetryCollectorRef.current = new TelemetryCollector(renderer);
				telemetryCollectorRef.current.start();
			}
		} catch (err) {
			console.error("[Shader] Initialization failed:", err);
			isInitializingRef.current = false;
			throw err;
		}
	};
	const setupVisibilityObserver = () => {
		const container = containerRef.current;
		if (!container || visibilityObserverRef.current) return;
		visibilityObserverRef.current = new IntersectionObserver((entries) => {
			const entry = entries[0];
			if (!entry) return;
			const rect = container.getBoundingClientRect();
			const isCurrentlyVisible = entry.isIntersecting && rect && rect.width > 0 && rect.height > 0;
			if (isCurrentlyVisible && !wasVisibleRef.current) {
				if (rendererRef.current.isInitialized()) rendererRef.current.startAnimation();
				else initializeRenderer().catch(console.error);
				wasVisibleRef.current = true;
			} else if (!isCurrentlyVisible && wasVisibleRef.current) {
				rendererRef.current.stopAnimation();
				wasVisibleRef.current = false;
			}
		}, { threshold: 0 });
		visibilityObserverRef.current.observe(container);
	};
	useEffect(() => {
		isCleanedUpRef.current = false;
		const container = containerRef.current;
		if (!container) return;
		const rect = container.getBoundingClientRect();
		if (rect.width > 0 && rect.height > 0) {
			initializeRenderer().catch(console.error);
			wasVisibleRef.current = true;
		} else wasVisibleRef.current = false;
		setupVisibilityObserver();
		return () => {
			if (isCleanedUpRef.current) return;
			isCleanedUpRef.current = true;
			if (telemetryCollectorRef.current) {
				telemetryCollectorRef.current.stop();
				telemetryCollectorRef.current = null;
			}
			if (visibilityObserverRef.current) {
				visibilityObserverRef.current.disconnect();
				visibilityObserverRef.current = null;
			}
			if (rendererRef.current && isInitializedRef.current) try {
				rendererRef.current.cleanup();
			} catch (err) {
				console.warn("[Shader] Error during cleanup:", err);
			}
			isInitializedRef.current = false;
			isInitializingRef.current = false;
		};
	}, []);
	useEffect(() => {
		if (!hideNotice && rendererRef.current && isInitializedRef.current) try {
			rendererRef.current.showLicenseWarning();
		} catch (err) {}
	}, [hideNotice]);
	return /* @__PURE__ */ jsx(OmbreContext.Provider, {
		value: contextValue,
		children: /* @__PURE__ */ jsxs("div", {
			ref: containerRef,
			className: "shader" + (className ? " " + className : ""),
			style,
			...rest,
			children: [/* @__PURE__ */ jsx("canvas", {
				"data-renderer": "shaders",
				ref: canvasRef,
				style: {
					width: "100%",
					height: "100%",
					display: "block"
				}
			}), children]
		})
	});
};
var Shader_default = Shader;
export { OmbreContext, Shader_default as default };
