import { OmbreContext } from "./Shader.js";
import { useContext, useEffect, useMemo, useRef } from "react";
import { createUniformsMap } from "../core/index.js";
import { jsx } from "react/jsx-runtime";
import { componentDefinition } from "../core/shaders/ImageTexture/index.js";
function computeEffectiveProps(props, defaultProps$1) {
	let baseProps = { ...defaultProps$1 };
	for (const [key, value] of Object.entries(props)) if (key !== "children" && key !== "ref" && value !== void 0) baseProps[key] = value;
	return baseProps;
}
var DEFAULT_TRANSFORM = {
	offsetX: 0,
	offsetY: 0,
	rotation: 0,
	scale: 1,
	anchorX: .5,
	anchorY: .5,
	edges: "transparent"
};
var defaultProps = {
	blendMode: "normal",
	renderOrder: 0,
	visible: true
};
try {
	if (componentDefinition && componentDefinition.props) Object.entries(componentDefinition.props).forEach(([key, config]) => {
		const propConfig = config;
		if (propConfig && typeof propConfig === "object" && "default" in propConfig) defaultProps[key] = propConfig.default;
	});
} catch (e) {
	console.warn("Error extracting default props:", e);
}
const OmbreComponent = (props) => {
	const context = useContext(OmbreContext);
	if (!context) throw new Error("Shader components must be used inside an <Shader> component or another shader component");
	const { ombreParentId: parentId, ombreNodeRegister: parentRegister, ombreUniformUpdate: parentUniformUpdate, ombreMetadataUpdate: parentMetadataUpdate } = context;
	const instanceId = useMemo(() => {
		return props.id || `${componentDefinition.name.toLowerCase()}_${Math.random().toString(36).substring(7)}`;
	}, [props.id]);
	const effectiveProps = useMemo(() => {
		return computeEffectiveProps(props, defaultProps);
	}, [props]);
	const effectiveTransform = useMemo(() => ({
		...DEFAULT_TRANSFORM,
		...props.transform
	}), [props.transform]);
	const uniformsRef = useRef(null);
	if (uniformsRef.current === null) uniformsRef.current = createUniformsMap(componentDefinition, effectiveProps, instanceId);
	const childContextValue = useMemo(() => {
		return {
			...context,
			ombreParentId: instanceId
		};
	}, [context, instanceId]);
	useEffect(() => {
		if (!uniformsRef.current) return;
		try {
			const metadata = {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			};
			parentRegister(instanceId, componentDefinition.fragmentNode, parentId, metadata, uniformsRef.current, componentDefinition);
			return () => {
				parentRegister(instanceId, null, null, null, null);
			};
		} catch (error) {
			console.error("Error registering shader node:", error);
			return () => {};
		}
	}, [
		instanceId,
		parentId,
		parentRegister
	]);
	const prevPropsRef = useRef({});
	useEffect(() => {
		if (!uniformsRef.current) return;
		try {
			Object.entries(uniformsRef.current).forEach(([propName, uniformData]) => {
				if (!uniformData || typeof uniformData !== "object") return;
				const { uniform, transform } = uniformData;
				if (uniform?.value !== void 0 && propName in effectiveProps) {
					const newValue = effectiveProps[propName];
					if (newValue !== prevPropsRef.current[propName]) {
						parentUniformUpdate(instanceId, propName, newValue);
						prevPropsRef.current[propName] = newValue;
					}
				}
			});
		} catch (error) {
			console.error("Error updating uniforms:", error);
		}
	}, [
		effectiveProps,
		instanceId,
		parentUniformUpdate
	]);
	useEffect(() => {
		try {
			parentMetadataUpdate(instanceId, {
				blendMode: props.blendMode || "normal",
				opacity: props.opacity,
				visible: props.visible === false ? false : true,
				id: props.id,
				mask: props.maskSource ? {
					source: props.maskSource,
					type: props.maskType || "alpha"
				} : void 0,
				renderOrder: props.renderOrder || 0,
				transform: effectiveTransform
			});
		} catch (error) {
			console.error("Error updating metadata:", error);
		}
	}, [
		props.blendMode,
		props.opacity,
		props.visible,
		props.maskSource,
		props.maskType,
		props.renderOrder,
		props.id,
		effectiveTransform,
		instanceId,
		parentMetadataUpdate
	]);
	if (props.ref && typeof props.ref === "function") try {
		props.ref(null);
	} catch (e) {}
	return /* @__PURE__ */ jsx(OmbreContext.Provider, {
		value: childContextValue,
		children: props.children
	});
};
var ImageTexture_default = OmbreComponent;
export { ImageTexture_default as default };
